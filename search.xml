<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何进行搜索列表优化]]></title>
    <url>%2F2022%2F%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%90%9C%E7%B4%A2%E5%88%97%E8%A1%A8%E4%BC%98%E5%8C%96.html</url>
    <content type="text"><![CDATA[前言”搜索列表“就是有一个搜索框和一个显示搜索结果的列表的一种业务场景。在用户输入文字的时候能够在列表中展示搜索相关的信息。这个业务场景应该很多同学都做过，今天笔者就带着大家来逐步优化这种业务场景。本文建议在 PC 端上浏览，笔者已经为大家准备好了 demo，观众老爷们可以点开后续章节的的 demo 🔗进行调试。首先有几个要求： 即时响应用户输入 尽量快速显示用户搜索相关的列表 页面流程、性能尽可能高 需要减少不必要的请求 需要考虑请求异步时序问题 简单完成业务首先第一版先完成业务，我以 react 为列 12345678910111213141516171819202122232425262728293031import &#123;useState&#125; from 'react';function FirstDemo() &#123; // const [inputText, setInputText] = useState(''); const [list, setList] = useState([]); const onChange = (e) =&gt; &#123; console.log('onInput') fetch(`$&#123;api&#125;&amp;q=$&#123;e.target.value&#125;`) .then(async res =&gt; &#123; let result = await res.json(); setList(Array.isArray(result) ? result : []); &#125;) .catch(e =&gt; &#123; console.log(e) &#125;) &#125; return &lt;div className="box"&gt; &lt;div className="search-bar"&gt; 请输入你要搜索的仓库名： &lt;input onChange=&#123;onChange&#125; /&gt;&lt;/div&gt; &lt;ul className="list-box"&gt; &#123;list?.map((v, i) =&gt; &#123; return &lt;li&gt;&#123;v.name&#125;&lt;/li&gt; &#125;)&#125; &lt;/ul&gt; &lt;/div&gt;&#125; 好的，第一版demo1我们已经完成，我们来看看有哪些问题？ 防抖优化版本想一想这种场景，当用户快速输入时，在一个单词或一个词组没有输完其实可以不调 api 进行请求，有同学可能会想到 防抖、节流 来优化服务调用频次，当然个人认为在这里使用防抖更合适，防抖的间隔取多少合适呢？在不影响用户体验的情况下，一般 30-100 ms 我觉得都比较合理，好了，这种优化方式大家应该都用过，这里就不做代码演示了。 优化中、日、韩文本输入我们看下需求“要即时响应用户搜索”，需要为搜索框绑定哪些事件呢？原生的 onchange 、oninput 作为了备选项，他们执行的时机略有差异,大家可以在 MDN 上查看区别。对于使用 React 的用户，React 已经封装了原生事件，保证 onChange 事件能够在合适的时机触发。但你试着输入 CJK(中文、日文、韩文) 文本呢？会发生什么？我们在输入一些合成文本时会使得情况变得复杂起来，你切换到中文输入法时，试着输入”zhongguo”，你会发现还没有输入”中国”时已经就调了 8 次无效的 api，为什么说是无效的呢，我认为这些中间搜索结果其实用户并不关心，反而觉得这是 bug。 123456789101112131415161718192021222324const onCompositionStart = (e) =&gt; &#123; console.log('onCompositionStart'); &#125; const onCompositionUpdate = (e) =&gt; &#123; console.log('onCompositionUpdate'); &#125; const onCompositionEnd = (e) =&gt; &#123; console.log('onCompositionEnd'); &#125; return &lt;div className="box"&gt; &lt;div className="search-bar"&gt; &lt;input onChange=&#123;onChange&#125; onCompositionStart=&#123;onCompositionStart&#125; onCompositionUpdate=&#123;onCompositionUpdate&#125; onCompositionEnd=&#123;onCompositionEnd&#125; /&gt;&lt;/div&gt; &lt;ul className="list-box"&gt; &#123;list?.map((v, i) =&gt; &#123; return &lt;li&gt;&#123;v.text&#125;&lt;/li&gt; &#125;)&#125; &lt;/ul&gt; &lt;/div&gt; 我先在代码中添加 onCompositionStart、onCompositionUpdate、onCompositionEnd 事件，你可以在demo2中测试输入非 CJK 和 CJK 文本时控制台打印出的日志。 我们可以利用输入非 CJK 文本时只会执行 onInput 事件，输入 CJK 文本时会依次执行onCompositionStart、(onCompositionUpdate、onInput 持续输入会是一个重复的过程)、最后我们选择待选文本后执行 onCompositionEnd 事件。通过上面测试，对于用户输入 CJK 文本时我们事件应该在 onCompositionEnd 中执行呢？代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041function SearchDemo() &#123; const isCompositionRef = useRef(false); const [list, setList] = useState([]); const getData = (e) =&gt; &#123; fetch(`$&#123;api&#125;&amp;q=$&#123;e.target.value&#125;`) .then(res =&gt; &#123; console.log(res); // setList(res?.data || []); &#125;) .catch(e =&gt; &#123; console.log(e) &#125;) &#125; const onChange = (e) =&gt; &#123; // 输入为 CJK 不执行 getData if(isCompositionRef.current) return; getData(e) &#125; const onCompositionStart = (e) =&gt; &#123; isCompositionRef.current = true; &#125; const onCompositionEnd = (e) =&gt; &#123; isCompositionRef.current = false; getData(e) &#125; return &lt;div className="box"&gt; &lt;div className="search-bar"&gt; &lt;input onChange=&#123;onChange&#125; onCompositionStart=&#123;onCompositionStart&#125; onCompositionEnd=&#123;onCompositionEnd&#125; /&gt;&lt;/div&gt; &lt;ul className="list-box"&gt; &#123;list?.map((v, i) =&gt; &#123; return &lt;li&gt;&#123;v.text&#125;&lt;/li&gt; &#125;)&#125; &lt;/ul&gt; &lt;/div&gt;&#125; 现在我们的代码已经优化了这种场景，你可以试试看。demo3 这种优化方案我也在 element-ui 的 el-input 源码中看到过。当然 CompositionEvent 表示用户间接输入文本（如使用输入法）时发生的事件，还支持语音输入等，大家可以自己去探索下。 虚拟滚动列表优化数据量大的情形现在我们需要考虑 api 返回的数据特别大，list 10000 条以上，在启用 React fiber （React Concurrent Features） 特性之前，React 可能会长时间占用 js 线程，用户输入的数据无法及时在 input 中反馈，你可以使用新版 React 和 ReactDOM 来缓解这个问题，这种使用方式也比较简单，就不做代码演示。我们看下另一种方案，虚拟化列表滚动方案，本质上就是无论数据多少，我们只显示容器内或 viewport 内的条目即可，用户滚动时在动态变更容器内显示的数据。知乎-饿了么团队有篇文章介绍虚拟列表实现原理挺不错，推荐大家阅读再谈前端虚拟列表的实现。在这里我推荐一个组件 react-tiny-virtual-list，gzip 后大小只有 3kb，作者考虑了很多东西，如列表中项目高度一致、高度不一致情况、自定义容器不可见区域的 buffer（解决滑太快会看见页面空白的现象），作者做了很多demo，大家可以去试试，在这里就不做代码演示了。 优化异步请求时序问题由于 internet 是一个大型的网状结构，我们在频繁向后端发送请求的情况下，很有可能每次请求所选择的路径不相同（路由和寻址）以及一些其他原因，导致先发出的请求后接收到响应。如果浏览器发出了两个请求 1，2 ，浏览器却先收到请求 2 的响应并绘制到浏览器中，然后再接收到请求 1 的响应并绘制到浏览器中，这里如果 1 和 2 搜索的关键字不同就会导致 bug（搜索关键字和查询结果不一致）。 1234567891011121314151617181920212223242526272829303132333435363738function SearchDemo() &#123; // fetch 返回 promise，只保存最后一个 promise const lastPromise = useRef(); const [list, setList] = useState([]); const getData = (e) =&gt; &#123; const currentPromise = fetch(`$&#123;api&#125;&amp;q=$&#123;e.target.value&#125;`) lastPromise.current = currentPromise // 过滤掉不是最后一次发起的请求 currentPromise.then( res =&gt; &#123; if (currentPromise === lastPromise.current) &#123; setList(res?.data || []); &#125; &#125;, e =&gt; &#123; if (currentPromise === lastPromise.current) &#123; console.warn('fetch failure', e); &#125; &#125;, ); &#125; const onChange = (e) =&gt; &#123; getData(e) &#125; return &lt;div className="box"&gt; &lt;div className="search-bar"&gt; &lt;input onChange=&#123;onChange&#125; /&gt;&lt;/div&gt; &lt;ul className="list-box"&gt; &#123;list?.map((v, i) =&gt; &#123; return &lt;li&gt;&#123;v.text&#125;&lt;/li&gt; &#125;)&#125; &lt;/ul&gt; &lt;/div&gt;&#125; demo4这里技巧性比较强，利用 fetch 方法每次返回不同的 Promise 对象内存地址，并始终只记录最后一次的 Promise 对象内存地址，在接收到响应时判断并只处理最后一个请求的响应。思想最初来源于Handling API request race conditions in React 另一种方案优化异步请求时序问题Handling API request race conditions in React文章还提供了一个思路取消之前的所有请求，这里还有个好处，如果提前取消请求，浏览器就会省略解析 Response 这一过程，前面一种方式浏览器其实是解析了 Response ，只是我们没有用到而已demo5。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960function SearchDemo() &#123; const isCompositionRef = useRef(false); const [list, setList] = useState([]); const [text, setText] = useState([]); const onChange = (e) =&gt; &#123; // 输入为 CJK 不执行 getData if(isCompositionRef.current) return; setText(e?.target?.value); &#125; const onCompositionStart = (e) =&gt; &#123; isCompositionRef.current = true; &#125; const onCompositionEnd = (e) =&gt; &#123; isCompositionRef.current = false; setText(e?.target?.value); &#125; useEffect(() =&gt; &#123; setList([]); // Create the current request's abort controller const abortController = new AbortController(); // Issue the request fetch(`$&#123;api&#125;&amp;q=$&#123;e.target.value&#125;`, &#123; signal: abortController.signal, &#125;) .then(res =&gt; &#123; // IMPORTANT: we still need to filter the results here, // in case abortion happens during the delay. // In real apps, abortion could happen when you are parsing the json, // with code like "fetch().then(res =&gt; res.json())" // but also any other async then() you execute after the fetch if (abortController.signal.aborted) &#123; return; &#125; setList(res?.data || []); &#125;) .catch(e =&gt; &#123; console.log(e) &#125;) // Trigger the abortion in useEffect's cleanup function return () =&gt; &#123; abortController.abort(); &#125;; &#125;, [text]); return &lt;div className="box"&gt; &lt;div className="search-bar"&gt; &lt;input onChange=&#123;onChange&#125; onCompositionStart=&#123;onCompositionStart&#125; onCompositionEnd=&#123;onCompositionEnd&#125; /&gt;&lt;/div&gt; &lt;ul className="list-box"&gt; &#123;list?.map((v, i) =&gt; &#123; return &lt;li&gt;&#123;v.text&#125;&lt;/li&gt; &#125;)&#125; &lt;/ul&gt; &lt;/div&gt;&#125; 比如你快速输入”123”将在控制台看见如下效果： 结尾“搜索列表“只是一个小小的业务场景，如果你想去优化总是有些突破口。但笔者想说的，我们开发也需要考虑开发成本和收益，对于收益和开发成本不对等的情况下大家也没必要做这么多优化（又不是不能用），也比较反对“过早优化”。本文也是 2022 年的第一篇文章，祝大家能够在新的一年里“升职加薪、早日实现财务自由”。如果本文对你有帮助请你点击“关注”和“点赞”就是对我的支持，谢谢。欢迎转载 请注明出处 参考文档：再谈前端虚拟列表的实现Handling API request race conditions in Reactreact-tiny-virtual-list]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提升职场竞争力]]></title>
    <url>%2F2021%2F%E6%8F%90%E5%8D%87%E8%81%8C%E5%9C%BA%E7%AB%9E%E4%BA%89%E5%8A%9B.html</url>
    <content type="text"><![CDATA[最近在拉勾教育上学习了一个专栏《14 讲提升职场竞争力》，感觉对个人职业发展很有帮助，特总结于此。本专栏分为三个模块，以下是各个模块介绍。模块一，工作思维。 我会介绍职场中常见的 5 种工作思维，比如破解难题的拆解思维、提升工作经验价值的复盘思维、提高工作产出的优先级思维等。 学完这部分，你会从更高维度去思考问题，当别人还在依赖于直觉、经验做决策的时候，你已经从思维层面考虑到更多可能性和更完整全面的解决方案。 模块二，工作能力。 我会教你如何修炼语言表达能力、书面写作能力和职场学习能力。通过这些能力的修炼，你不仅能够把自己的工作结果最大化地展现出来，而且，依托强大的学习能力，你能及时更新自己知识体系和思维工具，不断迎接新的挑战。 其次，我会带你超越工作技能的维度，从行业知识和商业思维的角度，帮你建立一个完整的工作能力框架。这样你在职场中，就不会只是一个纯粹的执行者，你还有丰富的行业和商业能力储备，无论是做一个非常基础的工作，还是负责一条完整的业务线，你都有能力胜任。 模块三，人际合作。 这个部分我会介绍职场上真正有价值的人际关系该是什么样的，带你建立正确的经营职场人际关系的思维，学习职场人际关系建立与经营的方法技巧。 思维致胜流程意识所谓流程思维，简单地说，就是在解决问题的时候，你会不会想到从流程出发来考虑和解决问题。 使用流程应用流程的工作场景也有强场景和弱场景之分。强场景，就是那些客观上具有非常严密的流程，工作过程中不得不严格遵守的工作场景，例如转化漏斗分析。弱场景，就是那些虽然也有一定的流程，但是流程的逻辑并不是非常严密的工作场景，例如活动运营。所以无论是强场景，还是弱场景，都建议你严格依靠严密的流程来约束自己的工作，把流程思维应该当作一种自觉的、随时都要想到的“工具”。 优化流程优化流程一般指的是对既有的流程进行改造。流程优化就是对其中节点要素的增减，或者是对其中逻辑关系的局部优化。它们的目的都是让流程更顺、效率更高、成果更大。 如产品上线的流程原来的流程：产品开发——测试——运维部署——开发上线——产品（人员）验收。优化后的流程：产品开发——测试——产品（人员）验收——运维部署——开发上线。 制定流程你要负责一个项目或者一项业务，制定流程的能力是带领项目或者业务突围的必备条件。SOP，是 Standard Operating Procedure：标准作业程序，指将某一事件的标准操作步骤和要求以统一的格式描述出来，用于指导和规范日常的工作。 如何学会制定流程？确认关键节点关键节点是一个最有目的性或者有关键产出物的环节。 确认关键节点的过程，就是理清事情的头绪或者关键操作的过程。如，在电商购物过程中，浏览商品、点击购买、填写地址、提交订单、支付货款都是必要的操作步骤，但只有支付货款是关键节点，因为只要货款没有支付完成，这个购物行为就没有成功。 梳理逻辑关系确认了关键节点后，接下来就要找到节点事件或者操作要点之间的逻辑关系，用箭头表示出前后的顺序关系。如，电商 App 的用户行为流程大致如下：下载——打开App——浏览商品详情页——点击购买——填写地址——提交订单——支付货款。 细化完整流程以上两步虽然表明了不同节点之间的逻辑关系，但只是一个粗线条的流程，只适合某些岗位在某些场景下的工作。与外部门的协作也要放进整体流程去考虑，千万不要把流程中的决定性事项放在自己把控不住的范围。如，增加细节设计、增加边界设计、增加不同场景设计等（使我们的流程更加精细化、严密的流程）。 数据至上在做汇报时，需要用数据增强你的职场说服力。 什么是数据思维数据思维，简单来说就是在分析问题、做决策、汇报工作等关键工作场景中，依靠数据说话。 如何成为运用数据思维的高手成为一个善于运用数据的高手，我认为你至少要在四个方面展开数据思维的修炼： 锻炼数据的敏感性对外界、对自己多使用数据，培养对数据非常敏感，看任何问题，都会基于数据体现来考虑。 数据至上所谓数据至上，就是任何事情，能用数据，就不用文字。 你需要在问题分析的时候、在执行落地的时候、在呈现结果的时候保持数据至上的意识。 追求精确运用数据的时候要时刻保持精确性，因为精确能够体现你的专业性。尽量不要用概略性的表述。不同的场景下追求相应的精确度。在工作场合中，仅仅能使用数据是不够的，还需要精确使用数据，只有你的表述很精确，才是真正有说服力的。 善用对比。俗话说，没有对比就没有伤害，在数据应用方面，没有对比就不知道好坏。比如国家统计局公布GDP 的时候，不仅要公布本月的数值，更重要的是要公布和上个月的对比增减幅度，以及和去年同一个月份的对比情况； 复盘技巧复盘其实是一个围棋术语，也称 “复局”，指的是“对局”完毕后，回顾推演这一盘棋的记录，以检查下棋的过程中招法的优劣与得失关键。把复盘放到工作中来说，就是通过剖析工作全貌，把其中每个局部拿出来进行仔细分析，以萃取核心工作经验与价值。 工作总结≠工作复盘总结是对结果好坏的分析，而复盘是对产生结果原因的深度分析。如果复盘中缺乏对于原因的深度剖析，就起不到复盘应该有的作用。 复盘各方的收益对公司而言，复盘为公司积累了处理相关领域的宝贵经验，一次投入多重收益；对团队而言，复盘帮助团队成员共享了完整的经验方法，大家都能从中受益；对自己而言，复盘总结的经验知识，你可以复用在以后的类似工作中，省时省力更省心。 工作深度复盘的三步骤梳理事情的完整过程和信息在进行一项工作复盘的时候，首先要对事件的过程和信息进行完整的梳理。因为在做一件工作的时候，基于协作等因素，信息分散在不同的人和角落中。把这些信息进行系统的汇总，你对整件事情才会有完整的认知，复盘才会更全面。否则，信息的缺失，让你的复盘工作可能根本没法往下进行。对一项工作的完整过程及信息进行梳理，需要把时间线和事件线结合起来。时间线，就是工作进行的重要时间点构成的脉络。这有助于你从时间维度来梳理重要的事件，避免遗漏。事件线，就是重要事件，按照时间顺序进行的脉络，也是复盘架信息。 深度剖析重要节点和事件复盘第二步就需要剖析重要的节点事件，从中寻找这些重要事件进展过程中存在的问题。这里可以从事和人两个层面入手。事的层面，事的层面主要从两个方面来进行剖析：工作内容和工作方法，剖析工作内容要区分积极的事情和消极的事情，寻找做得好的方面和原因，以及不好的方面和原因。人的层面，任何工作都离不开人，其中不可避免地存在着各种各样与人相关的问题，对于人的剖析，可以从四个维度上来展开。第一，剖析人的情绪、决策行为，以及情绪对决策行为的影响。第二，剖析环境因素对于人的影响。第三，不仅剖析自己，还要剖析他人。第四，对利益相关方的影响进行剖析。 总结重要的经验教训在第二步的复盘中，你一定会分析出大量有价值的经验信息，但它们过于庞杂且相对孤立，这样的经验你即使总结出来，可能在下次遇到问题的时候也很难复用。第一，寻找经验之间的联系，进行归类总结。第二，对经验进行重要性排序，记住关键经验。 复盘注意的两个注意要点第一，不断发问。 为了达到深度复盘的目的，你需要不断地发问，在不断追问中找到问题的核心，提炼出有价值的经验教训。第二，坦诚面对。 复盘的时候，坦诚面对是一个很大的挑战，尤其是对于失败事情的复盘，很多人缺乏自我剖析的勇气，觉得事情都已经失败了，再去揭伤疤太痛苦了。所以，有的人就会避重就轻、敷衍了事。 拆解方法拆解思维，指的是把一个问题拆分成颗粒度更细的维度，从更细小的组成部分考虑和分析问题，从而找到解决方案的一种思维。举个很简单的例子，假如一款 App，被要求在年底达到 1000 万的用户量，可以从时间维度上拆出具体的目标（按月）。 用拆解思维解决难题困境方案规划类问题的破解之道方案规划类问题往往需要通过 PPT 呈现解决方案，所以也可以叫 PPT 类问题。大到公司的战略规划、年度业务规划，小到个人的工作汇报、产品规划、用户调研方案等都属于此类问题。方案规划类问题通常都比较宏大，宏大的问题往往需要非常具体、细化的拆解之后，才有可落地的完整解决方案。比如，公司的年度规划，必须落地到一个个具体的业务目标上。方案规划类问题的解决，可以借助于结构重构法、自由发散法两种方法。结构重构法，就是通过使用业内已经成熟的思维方法，重新搭建一个全新的框架来解决问题。自由发散法，指的是在发散思考的时候，没有成熟框架依托，只能靠你头脑中储备的知识来思考可能的维度，在此基础上再进行归类分组，搭建成一个可能的框架来解决问题的方法。 数据计算类问题的破解之道数据计算类问题，指的是以严格的数据考核的工作问题，比如销售目标的拆解、投资回报率的计算、用户量的增长等诸如此类的问题。 数据计算类问题的破解之道步骤第一步：找到基本公式。如以“全年增长 5000 万收入目标达成”是一个计算销售收入的问题，一般的计算公式是销售额=销售数量销售单价，但这个问题中求解的是会员收入问题，所以，公式需要进行相应的改造。第二步：改造解题公式。根据业务收入实际的来源，改造为这个公式：会员收入增长= 新增会员数 会员价格。第三步：拆解解题方案。在上面的公式中，会员价格是一个固定的数值，因此，求解会员收入增长的问题，就转换成了如何增长新增会员数的问题。因为新会员是要靠大量的新用户转化而来的，所以问题会进一步转化为获取多少新用户。 流程梳理类问题及其破解之道流程梳理类问题，指的是问题解决环节之间具有前后密切承继关系的问题。最重要的是，当你通过拆解流程的细分环节分析出了问题点，之后就可以对相应环节进行细致的排查，就此找到解决问题的办法。 优先思维对工作区分优先级， 区分工作的优先级（先做什么后做什么） 四象限法则详细拆解四象限法则，破解不会用优先级思维的困境提到优先级思维，就绕不开四象限法则，这是优先级思维最好的落地工具。它根据事情紧迫性和重要性两个维度，构成了一个四象限的矩阵，把事情分为重要紧急、重要不紧急、不重要紧急、不重要不紧急，然后优先选择第一象限重要的事情去做。12345 重要 *不紧急----*----紧急 * 不重要 四象限法则判断事情优先级先判断事情的紧迫性和重要性紧迫性主要是从时间维度上来评估，一件事情到底紧迫与否，就看离最终的时间节点的远近，如果截止日期迫在眉睫，那么就非常紧迫，反之紧迫性就没有那么高。任务的重要性可以按业务类工作与商业收益评估、协作类工作与影响力评估、事务类工作与职业成长价值评估一般：业务类工作的重要性 &gt; 协作类工作的重要性 &gt; 事务类工作的重要性。 能力重识（六大核心职场力）语言表达（教你清晰表达，高效沟通）破解“不愿说”不敢说、不屑说 摆脱“说不好”在职场中，有一类人自信十足，他们并不怵说话，但你听他们的话总是感觉云里雾里、一团乱麻、没有重点，怎么也理不清。 最佳表达（金字塔原理 16 字箴言）结论先行、以上统下、归类分组、逻辑递进。 开头一句话抛出观点或者概括核心内容最好用一句话提纲挈领，抓住听讲者的注意力。 中间用一二三明确分层当你抛出观点或者总括内容之后，马上就要进入细节的内容。如果你是发表观点，那么马上就要说明你的理由。如果是分析问题，那么就展开现象、原因和解决办法。在说的时候，你应该注意两点。 明确分层：把你所讲述的细节内容要点分清一二三，因为人类的耳朵天然不擅长处理结构化的信息，耳朵在接受信息的时候，听到的往往是线性的信息。 说话节奏：在需要停顿的时候进行停顿，该强调的一定要突出语调，对于信息的不同层次，结合第一、第二这样明显的分界标志词说出来，让他们听到你的结构，减轻听讲者的负担。结尾重复总结核心内容为了防止参会的人听完后面的信息忘了前面的观点，所以在讲完时要总结，再强调下你的观点。否则，参会的人可能会进行选择性理解，这样就会导致沟通偏差。走出“说不破”跟前面“说不出”正好相反的人，便是“话匣子”。他们的话不缺乏逻辑层次，在一些简单的问题上，也能发表一些让人耳目一新的观点。走出“说不破”的解决办法 没有从问题出发，一定要时刻以问题为原点，跳出信息的海洋，用最精简的信息来回答问题。 没有研究透问题，还有些同学在发表观点的时候，倒是不会出现“失焦”的情况。但是，可能对问题没有研究透，聊到的都是一些皮毛的东西，也会出现说不到点子上的困境。书面表达职场中的书面表达能力我们以职场中最为常见的 3 种书面表达能力——公文、PPT 和业务文案写作能力，来展开这个话题。公文写作能力公文写作能力，又叫作格式化文本的写作能力。例如邮件的写作、简历写作、会议纪要、会议邀请通知、投标书等都属于此类。这些文案的写作通常都有特定的格式和话语体系，强调逻辑性，不强调艺术性，写作时中规中矩。对于这类书面表达，一定要精炼简洁、主题明确、逻辑清晰、客观中立。千万不要似是而非、缺乏逻辑，更不要洋洋洒洒、漫无目的、记流水账。PPT 写作能力PPT 是职场中使用非常广泛的一种工具，在工作汇报、会议演讲中都会用到。构图精致、画面优美、动画适宜的 PPT 很容易吸引别人的注意力，且同样会影响他人对你个人的认知。 从整体上，所有的 PPT 页面应该是围绕着一件事情或者一个观点展开的，每一页都是对核心观点的阐释。这点听起来简单，但现实中却存在很多反例，缺陷与不足之处各异。 从局部来说，每一页 PPT 也都需要有一个核心观点，并有相应的论证。 具体到每一页 PPT ，标题都应该是对本页内容的核心概括，是总论点之下的一个分论点，而其中的内容无论是文字、图片，还是数字图表，其实都是支撑论点的论据。业务文案写作能力业务文案的写作并不是每个职场人都会遇到的工作，但是，很多业务类岗位的职场人都需要具备这种能力。以运营人员为例，需要写的活动文案和短信文案以及 Push 文案都会有较大的差异，必须深入理解这些文案的写作特点和差异，才能产出符合业务特性的文案。如何修炼自己的书面表达能力掌握第一要诀——写对于任何人来说，要进行书面表达能力地修炼，其实没有什么捷径可走，窍门就是写。如，开始接受一个工作项目的时候，写工作规划，结束一项工作的时候，写复盘总结。 修炼逻辑能力职场上的写作核心目的是信息沟通、说服别人，所以逻辑性是职场写作最重要的要求。比如，你要通过邮件说服别人支持你的工作，或者说服上级接受你的方案，不能只讲道理，没有证据。也不能观点和理由混杂在一起，这样是不行的。 通过模仿快速掌握基本的写作方法当职场中遇到需要写作的场合，而又不知道如何写的时候，最快速的解决办法就是模仿他人的写作方法来先完成任务。之后，再考虑长期训练相应能力的问题。 职场学习职场学习和学校的学习有很大的不同，其中最关键的一个就是：学校学习的是知识，职场学习的是能力。 职场上学习步骤执行能力当一个人处于基础执行层时，最核心的就是把工作任务搞定的能力。这时候，你承担得更多的是一些具体的落地工作，虽然这些事情中也需要你思考一些细枝末节问题的合理性，但是，主要还是领导规划你来执行。领导交给你的那些事情，做的时候你都能搞定，但是，为什么领导要让你这么做，背后的原因是什么，有些你都是不甚明白。 研究能力所谓的研究能力，就是面对问题，分析清楚问题的本质，找到问题出现的深层原因，基于原因寻找可靠的解决办法。为了达到这个目的，你要去研究业务知识，你得了解你们公司业务整体运转的逻辑是什么。因为你所面对的问题肯定不是无缘无故产生的，更不是孤立存在的，一定是业务链条上其他的环节触发了什么因素，导致了现在你所要面对和解决的问题。你要把这些因素挖出来，找到解决的办法。 综合能力你要承担起一个管理者的角色，你要突破的是综合能力。因为你要管理几个人来完成工作任务，你不仅要学会规划的能力（规划事情的能力和人员安排的能力），而且要学习管理人的能力。此外，因为你不仅要和上级领导相处，你还要和下级、同级的其他管理者相处，你处在了夹心层，要处理各种各样的关系，你要学习人际管理的方法。你要突破综合能力的瓶颈，就需要学习规划能力、管理能力、人际关系能力。这每一项都有很多要学习的东西，而且，不再像执行能力和研究能力那样，仅仅是处理的信息，你要处理与人相关的问题，复杂性进一步提高。 你该如何修炼执行能力和研究能力？从执行能力到研究能力的学习，其实是从硬技能到软技能的学习。所谓硬技能，就像产品经理的需求文档撰写能力、画原型图的能力，这些侧重于解决具体问题的能力。而软技能，就像这门课程中工作思维的学习。 如何练就硬核的执行能力第一种区分：通用性能力和专业性能力所谓通用性能力，就是那些在解决任何具体问题的时候都可能用到的能力，它们的普适性比较强，比如第二模块中讲到的语言、书面表达能力，行业视野和商业思维，都是通用性的工作能力。所谓专业性能力，就是针对特定问题才能够用的，解决问题具有相对适用性范围的能力，比如对于产品经理来说，交互设计就是专业性能力。 第二种区分：操作性能力和指导性能力所谓操作性能力，就是那种具有明确的操作方法，你按照具体的操作方法反复练习就可以掌握的能力。比如 Excel 技能、活动运营的操作流程、需求文档撰写能力等。所谓指导性能力，就是那种没有什么操作流程，只是一个知识、原则、理论、框架，你在解决问题的时候，可以借助于它们，来指导你产出一些方法、激活一些思路。以此来解决相应的问题。 工作技能很多同学进入一个岗位，日复一日干着重复的工作，节奏堪比钟表一样，一眼就可以望到头。这种无望却无奈的困境，以前存在于很多传统企业中，现在已经遍及互联网大厂。在互联网企业中，职业升迁有两条典型的路径：一条是专业线，也就是通常大家说的大厂的 P 序列；一条是管理线，也就是所谓的 M 序列。 如何摆脱“螺丝钉”困局？寻找高增长的行业和企业快速发展的企业，规模会不断扩大，人员规模也就需要同等扩大，这时候就会让你有机会扩大自己的工作技能(内部转岗)。 建立“π 型能力”结构关于职场人的能力，以往其实有一种说法，叫作“T 型能力”，就是一横一竖，一横指的是你要在职业能力的横向方面向广博修炼，一竖指的是你要在专业能力的纵向方面向精深修炼。“T型能力”是过去人们常常津津乐道的一个指导原则。“π 型能力”是我借用北大刘澜教授提出的一个概念。它指的是，在横向的一横上，你要广撒网，扩展自己的能力的宽度；从纵向的两竖上，你至少要在两个职业方向上，精深的修炼自己的工作技能。 行业视野概括来说，与你所在企业相关的行业有关的一切知识和信息，都属于这个范畴。 行业视野三个层次 最高层：主要是对企业生存所依存的政治、经济、法律、技术、社会环境的认知，这是行业的宏观层认知。 中间层：主要是对企业生存所依赖的上游、中游和下游环境的认知，这是行业的中观层认知。 最底层：主要是对企业自身生存的价值创造的完整链条的认知，这是行业的微观层认知。宏观层认知及其修炼你要有行业视野，首先你要有宏观层的认知，这意味着你要有意识去了解大的政策、经济、环境、技术和社会环境，也就是你要进行企业环境的 PESTEL 分析。PESTEL：政治因素（Political）、经济因素（Economic）、社会文化因素（Sociocultural）、技术因素（Technological）、环境因素（Environmental）和法律因素（Legal）。中观层认知及其修炼中观层的认知，主要是了解行业内的协作和制约关系，要对此形成认识，可以进行行业的产业链分析。如，你去三亚旅游，你订了一间酒店，那么，这个服务通常都是由行业产业链不同的环节提供的：上游的酒店企业提供了酒店房间，中游的在线旅游网站（比如携程、去哪儿）提供了订票服务，下游还有各种广告服务公司，为去哪儿携程提供了广告曝光吸引你。这些企业就是基于这样密切的合作，完成了对你的服务。产业链具体如何梳理呢？第一步，明确角色。根据普适性的商业逻辑，产业链一般又可以具化为上游供应商、中间渠道商、下游服务商、终端消费者 4 类主要的角色。第二步，梳理关系。这一步比较简单，就是把上面的 4 类角色按照上下游关系列出来。不过，并不是所有的关系都是 4 种角色依次往后的，有些会直接跳过某个角色层，比如直销就是上游供应商直接到下游的服务商或者终端消费者。第三步，填充角色。这一步就是找到你所在行业每个角色层的具体企业，供应商有哪些企业、渠道商有哪些企业、服务商有哪些企业。最重要的是，要把自己所在的企业也要放进去，看看你们是跟谁在竞争，跟谁是潜在合作关系，受到谁的制约，又制约了谁。以此来判断企业潜在的可能业务机会。微观层认知及其修炼产销服具体化这种方法的核心逻辑就是，根据生产、销售、服务这三个关键环节，看企业对于在各个环节中设置了哪些具体的活动，它们形成的前后协作关系，就构成了企业核心价值链。组织架构逆推企业的组织架构都是严格按照价值创造活动而来，所以，逆向去看组织架构就可以非常清楚地看到企业的价值创造活动。弄清它们之间的协作关系，就弄清了企业的价值链。业务关系链梳理所谓业务关系链梳理法，就是以你的岗位为基点，梳理和你协作的上下游同事关系，以及他们的上下游关系，梳理后整个完整的业务流程就是价值链。商业思维所谓商业思维，简单地说，就是思考企业为达到利润目标，所需要关注的最核心的经营环节是如何运转的。该如何掌握基本的商业思维？职场人身处在企业中，多少都会有一些商业方面的知识，但是，要对此有深入的了解，你至少要系统地了解六个方面的内容。用户需求在互联网企业中，需求是一个高频的词汇。你可能经常听到产品经理说我这有个 XX 需求……但是，他们说的需求其实仅仅是一个产品功能点。而我这里的需求指的是企业生存发展的根本立足点——用户需要什么。区分，真需求还是伪需求？大众需求还是小众需求？显性需求和隐性需求？市场概况市场概况主要包括行业的现状、竞争的情况、市场规模大小。有用户需求只能说明这个市场存在理论上的可能，但是，市场概况则能够直观地说明这个市场的现实可能性。市场规模大小、市场竞争的激烈程度、市场集中度解决方案解决方案，简单来说就是通过什么方式或者产品解决用户的需求，解决方案通常包括你要解决用户的哪一部分具体需求，具体通过什么产品形式来解决。商业模式商业模式，主要指的企业通过什么盈利。日常最常见的商业模式，就是提供商品获取附加值。比如三只松鼠的干果，或者提供服务收服务费，比如理发。资源需求一个企业在做任何一个产品项目的时候，都需要相应的资源需求配置，具体说就是要配置多少人，要花多少钱。风险情况风险，就是任何可能给企业造成冲击的不确定因素，或者给企业造成经营困难的事情。企业遇到的风险，很可能就是你遇到的风险，这是具有高度相关性的。比如很多新闻资讯类 App 因为内容不合规问题被下架，不仅对企业是风险，对于具体的相关人也是风险。人际历练关系建立人际关系方面你至少要处理好“一主两辅”三种关系 和直接领导的相互关系——主要的人际关系； 和本部门同事的协作关系——第一种辅助的人际关系； 和非本部门同事的合作关系——第二种辅助的人际关系。和上级领导建立积极的“互信和支持”关系职场中，和领导建立强互信关系，获得领导的信任和支持，你才能拿到重要的机会、产出成果、做出业绩、升职加薪。互信关系所谓互信就是你要让领导信任你，你也要信任领导。领导信任你的前提是你要对他忠诚，这样他才真正放心你，给你委以重任。如果一个曾经背叛过其他领导先例的人，给到任何一个新领导，他都很难对这个人产生信任。相互支持关系所谓相互支持关系，也是一种双向的关系，首先你要支持领导，支持他的业务规划，支持他的分工安排，支持他的日常工作安排。如果你能完成领导派给你的工作任务，那就是对领导的支持。如果你能够出色地完成工作任务，成为部门内业绩最好的那个人，那就是对领导工作的极大支持。和部门同事建立良性的“竞争中的协作”关系部门同事的关系相对比较特殊、敏感，既有竞争也有协作，是一种竞争中的协作关系。这里的重点是竞争，其次才是协作，它们是有先后顺序的。所以，你在和同事相处的时候，要处理好这对矛盾的关系。职场中的竞争关系在同一个部门中存在着广泛的竞争：关于资源的竞争、关于工作任务的竞争、关于领导关注度的竞争，还有如果领导有一天高升，可能还会面临空缺职位升迁的竞争。所谓良性的竞争关系，就是你要正大光明的竞争，要以理服人，以能服人，以成果服人。良性竞争也有负面清单，就是你不要做那些损人利己或者损人不利己的事情，不要在同事背后下黑手、捅刀子、说坏话。所谓玩火必自焚，领导也不傻，如果你为了自己的私利做这些事情，损害的是领导的大局和公司的大局，一定不会有好结果。但是，不让你这样做，并不是说你就不要注意这些，俗话说，害人之心不可有，防人之心不可无。职场中的协作关系在协作方面，你和同事应该建立的是一种什么样的关系呢？我认为是一种平等互助的协作关系。要建立这种关系，你就要学会不要侵犯领地、不要越俎代庖、不要给别人当老师。所谓不要侵犯领地，就是在工作中不要试图去抢做别人的事情，除非这是领导明确直接划拨的。所谓不要越俎代庖，就是工作中当遇到一些工作协作的交叉地带，一定要认清自己的角色定位，不要代别人去做他应该做的决策，即使有的时候你可能是好心，但是也会极大概率出现不良后果，不仅是因为这样会激起别人对你的不满和防备，而且，万一出现不良后果，你很可能正好成了背锅侠。所谓不要给别人当老师，俗话说就是不要在别人面前装大，在职场给别人做老师是一件禁忌。和支持部门同事建立“长期互利”的合作关系职场中，要做出工作成果，除了同部门同事之间的协作配合之外，还要处理好和其他支撑部门同事的关系，要和他们建立“长期互利”的合作关系。所谓长期互利关系，指的是你要尽可能和其他部门同事建立相对稳定、给彼此都带来职场成长或收获的关系。稳定的合作关系，之所以要建立长期稳定的关系，主要是因为同事之间的互信，只有在长期持续的互动中才能更加可靠。互利的合作关系之所以要建立互利的关系，是因为大家都有各自的绩效目标和升职加薪的年终目标，如果别人帮你的工作总是没有成果，那么，你觉得他还会有信心再支持你吗？尤其是他长达半年一年支持你的工作，最终无所成果，绩效很差，那么他很可能就不会再和你合作了。关系经营如何主动和领导建立深入的“互信和支持”关系要做主动的关系管理主动和领导沟通，通过重要事件与领导进行深度沟通互动，以此让领导了解你的积极态度，验证你的工作能力，感受你的忠诚与信任。要以专业性让领导信服在互联网的职场中，要和领导建立互信的关系，最重要的就是靠实力，所谓实力既包括工作思维和能力，也包括工作成绩。而后者其实也是取决于前者的。工作思维和能力与人际关系，其实是密切相关的，工作思维和能力所带来的良好的工作业绩，是对领导的最大的支持，也是取得领导信任的关键。关键时刻顶得上去如何在关键时刻顶得上去，你至少可以有两个思路：勇于攻坚克难、勇于承担责任。勇于攻坚克难，指的是在工作中，不仅在遇到比较难的挑战的时候，要基于自己实力的判断，勇于挑起重担，去迎接难题、解决难题。勇于承担责任，更加考验的是你在做事情之后的处理态度。职场中有很多人，有了成果邀功比谁都跑得快，事情失败了之后，就默不作声了，没有承担责任的勇气。不要给领导创造“惊喜”领导处于高位，天然会有不安全感，你一定要照顾他这种需求。在日常的工作中，多注意自己的言行可能给领导造成误解和困惑。你重点要关注两个点。第一，信息同步要及时。 在工作中，你一定要尽可能做到和领导之间“低延时”信息同步，比如在工作进度和工作成果方面，你一直要让领导知道事情的进展，让他认为对你的工作是可控的。尤其是一些重要的工作，更要及时同步信息，遇到问题及时和领导请示。一定要避免领导成为最后一个知情人。如果发生这样的事情，你们的信任关系就会出现严重的裂痕。第二，越级沟通要慎重。 职场中越级沟通是一大禁忌，也是信任的腐蚀剂。首先，一定不要主动越级汇报，如果遇到被动的越级汇报，一定要第一时间让领导知道这件事情，并且随时同步过程中的信息，对于你的汇报内容，一定要优先让领导知道，然后再进行下一步的动作。该怎样和同事建立良好的合作或协作关系建立广泛的同盟之所以要建立广泛的同盟，从大的方面来说还是要服务于自己职业发展的各种目标，尽可能减少工作的阻力，尽可能增加你开展工作的顺利性，给自己营造一个做事的良好外部环境。保持开放的心态所谓保持开放心态，就是你在面对和处理同事关系的时候，要自信不封闭，学会将心比心，求同存异。将心比心，就是要有同理心，会换位思考，遇到问题时，想一想如果自己处于别人位置会怎么思考、怎么做。如果你自己不愿意做的事情，不要强求他人，如果你自己即使非常努力做不好的事情，也不要苛求别人去做好。求同存异，指的是你在处理同事关系的时候，可以认同共识，基于共识去合作，但是，如果遇到和别人价值观不同的方面，如果不对决策产生重要影响，可以持保留意见。你要的是完成工作拿到成果，而不是谁对谁错。我在工作中，常常遇到一些人因为细枝末节的问题和别人争得面红耳赤，而没有把注意力放在真正解决问题上。以职业性打动对方和同事建立良好的合作或者协作关系的核心基础是你的职业性，就是上一讲课程中讲到的要以理服人、以能服人、以成果服人。以理服人，指的是你在和同事进行工作讨论、交流的时候，要通过严密的逻辑、有说服力的证据来论证自己所做事情的可行性。如果你自己都没有思考清、逻辑混乱的时候，最好不要正式和别人讨论实施问题。以能服人，就是你要通过自己的能力来证明自己的思考是缜密，方案是靠谱的。这需要你锻炼自己的工作思维和工作能力，比如，你做调研，就要展示给别人一个专业的调研报告；你做数据分析，就要给别人一个全面透彻的分析报告；所谓以成果服人，就是你要拿出一些出色的业绩来证明自己，因为有的时候，你说自己能力 OK 并不管用，但是，你过往成功的工作成果则可以。之所以你要以成果服人，是因为每个人都希望自己做的事情有成果，这样才有升职加薪的基础。 PS:以职业性打动对方也有一个负面清单，就是千万不要以领导压人。有些人遇到事情推动不下去，就拿领导说事，企图逼迫别人就范，这实际上在证明自己的无能，只能让别人对你心生厌恶。当然，有的时候遇到一些油盐不进，就是喜欢讲道理的人，可以适当、委婉的借助于领导的权威加速事情的推进，但是，注意掌握分寸。 以工作成果回馈对方以成果回馈对方，指的是你和别人的合作，应该建立在有成果的工作产出基础之上。这就对你提出了较高的要求，意味着你在做任何事情的时候，都尽可能以有所产出为出发点来考虑问题，因为如果别人支持你的事情要总是没有成果，他们也受不了，因为他的领导也会拷问他的工作成果，他的工作绩效，部分的取决于你的工作成果。如果你们的成果确实比较显著，你应该花时间写一份项目工作成果总结报告，对支持此项工作的同事表达感谢，其中你一定要提到他们的名字，并且最好把成果和具体人关联起来，这样才能表达出你的诚意，然后以邮件的形式发送给所有参与项目的人，并且抄送他们的领导。 沟通说服要做到的这一点，我认为至少要解决三个问题： 让对方了解你的意图； 让对方同意你的观点和方案； 让对方支持你的行动。 下面我就从沟通前、沟通中、沟通后三个环节，跟你聊一聊如何更好地和别人沟通，获得他们实际的支持行动。 沟通前：有目的地设计沟通策略一定要在沟通之前做充分的准备，不要赤手空拳去沟通，否则结果惨不忍睹。在沟通前，需要首先弄清自己的目的，你找别人只是同步信息，还是要达成什么共识做决策 。 基于同步信息的沟通如果你只是同步信息，那么你要传递什么信息，一定要清楚、明确，不能模糊和模棱两可。 选择沟通方式 如果是不重要的信息，你通过书面还是面对面都可以，怎么方便怎么来。 如果是重要简短的信息，那么，你可以通过微信或者口头表述的方式沟通即可。 如果是重要复杂的信息，你就需要采取相对正式的书面方式，比如邮件来和对方沟通，如果书面沟通无法完全表达清楚，那么就补充面对面会议沟通。 你沟通的信息，别人是否成功接受了，你一定要确认。 基于达成共识的沟通如果你是要达成共识，那么，你要做的准备工作就更多了，你要根据问题的性质、沟通的对象、行动计划等因素，综合考虑该怎么尽快地达成自己的目的。首先，如果是一个重要、难办的问题，你就考虑清楚它的难点是什么，针对这个难点别人可能关心的是什么，会提出什么问题，预设一些可能的问题，并提前准备好回答的逻辑和答案，以做到有备无患。其次，达成共识是一件比较难的事情，你要注意沟通的对象，不同的对象对于同一个问题他们的关注点可能也会不同，你也要提前考虑到这种差异可能给你带来的挑战。最后，通常某件事情达成共识之后，都会有相应的落地动作，所以，在你沟通前想好期望的时间、节奏安排。这样人家对你的行动计划才有明确的概念。在行动计划中，还有很重要的一点，就是你要提前想好自己的备选方案，如果你的第一方案没有通过，那么马上抛出备选方案来沟通。尽可能在一次沟通中就达成共识，毕竟如果多次沟通就需要别人更多的时间。总之，在沟通开始前，你的准备越是充分，你在沟通的过程中才能更加专业地解答别人的问题。你对待事情是认真严肃的，你的这种专业精神会影响到他，他也会认真对待你的事情，真心帮你把事情做好。如果你是和领导沟通，那要侧重准备与 Why 相关的问题，和同事沟通就侧重准备与 How 相关的问题。 沟通中：妥善管理沟通对象和环境职场中的沟通，会有各种各样的情景，很多时候都是有业绩压力和利益争执的情景。这时候人的行为、语言、情绪、行为都会偏离日常状态。如果你是沟通的发起人，一定要注意对沟通情景的设计和管理。这主要从两个方面来展开：一个是人的方面，一个是环境的方面。 沟通环境方面的设计管理如果你预计是这个沟通可能会有激烈的交锋，或者各种不太和谐的情况发生，那么，你就可以在沟通的环境因素方案有所考虑，比如你可以定一个大一点的会议室，或者比较敞亮的会议室。可以在开场的时候，准备一些暖场的笑话之类的。尽可能创造一个相对弱化紧张氛围的环境。如果你是一对一的沟通，要谈论一些艰难的话题，可以考虑不要在正式的场合，可以约沟通对象到户外散步，或者去喝咖啡、吃个饭，在喝咖啡吃饭的时候去做些重要的铺垫。不要小看这些微观环境的因素，它们对于沟通会有潜移默化的影响。 沟通对象方面的设计管理当然，对于环境的设计其实能做的事情不多，主要还是对人的方面的管理。其中又包括对于他人的管理和对自己的管理。对于他人的管理，你能做的虽然不多，但你可以决定沟通的时间点。假如你的沟通对象心情不好，你就不要在这种时候去找他沟通非常重要的事情，因为如果他有情绪，可能就会把这种情绪延续到和你的问题沟通中，很可能你的沟通事情本身没有问题，但是，因为情绪因素，反而你就不幸躺枪了。仔细倾听。 在沟通中，仔细倾听很重要。你可能认为这是一句正确的废话。其实不是。你可以回想一下，在那些正式的场合中，你是如何听别人讲话的？你是在真的倾听吗？放下自我。 当别人质疑自己观点的时候，很多人会本能地产生防备的心理。他们往往认为别人是在故意为难自己，或者是挑战自己的尊严。更好的策略是应该放下自我、认真听取别人的观点，从中寻求可能有价值的意见，即使提出不同观点的那个人可能说得完全没有道理，你也能够从中判断出这个人的水平，从而在以后的工作中决定该怎么和这个人相处，甚至由个性推到共性，学会判断这一类人，学习和这一类人相处。延迟回应 。 当别人对你的观点或者方案提出质疑的时候，本来你没有想好问题的最优答案，但是，还是想急于回应别人的问题，因为你觉得既然是在现场沟通，你就必须现场给出答复，其实，这是一种思维定式。你完全可以延迟回应，先告诉对方自己还没有想好，等回去想好了再给出回复。沟通把控。 在沟通中，你一定要注意不要被带了节奏，带到沟里去了。否则，你不仅浪费了时间，还没有产生沟通的结果。所以，当某个沟通对象滔滔不绝地谈论偏离主要问候的观点时，你一定要及时引导到讨论的主线上。 沟通后：总结复盘获取多重价值当你结束一次和领导的讨论，或者和同事的一次脑暴之后，你应该立即着手记录你们讨论中彼此主要的观点，存在的核心问题，等待解决的问题。否则，这些信息内容会随着时间消逝，在你的大脑中逐渐变模糊，这样就影响了后面问题的解决。同时，你也要复盘沟通本身，提高自己沟通的能力，尽可能让一次沟通产生工作成果价值和工作能力价值等多重价值。]]></content>
      <categories>
        <category>个人发展</category>
      </categories>
      <tags>
        <tag>个人发展</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 中稀疏数组的一些知识]]></title>
    <url>%2F2021%2Fjs-%E4%B8%AD%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86.html</url>
    <content type="text"><![CDATA[什么是稀疏数组？在说稀疏数组之前，你需要知道很多语言将数组的分为稀疏数组与密集数组（区别是数组的各个子元素是否有孔，我们称为”hole”）。也就是说稀疏数组中的元素之间可以有空隙，在那些仅有少部分项被使用的数组中，hole 可以大大减少内存空间的浪费。 V8中数组的实现快数组（FAST ELEMENTS）快数组是一种线性的存储方式。新创建的空数组，默认的存储方式是Fast Elements方式，快数组长度是可变的，可以根据元素的增加和删除来动态调整存储空间大小，内部是通过扩容和收缩机制实现，那来看下源码中是怎么扩容和收缩的。 Fast Holey Elements模式前面说了新创建的数组，默认是Fast Elements方式。在Fast Elements 模式中有一个扩展，是 Fast Holey Elements 模式。Fast Holey Elements 模式适合于数组中的空洞情况，即只有某些索引存有数据，而其他的索引都没有赋值的情况。在 Fast Holey Elements 模式下，当容量小于1024时，没有赋值的数组索引将会存储一个特殊的值，这样在访问这些位置时就可以得到 undefined。但是 Fast Holey Elements 同样会动态分配连续的存储空间，分配空间的大小由最大的索引值决定。12345678// 如下产生Fast Holey Elements的两种方式let a = new Array(10);console.log(a);// (10) [empty × 10]let b = [1, , , , 4];console.log(b)// (5) [1, empty × 3, 4] 慢数组（Dictionary Elements）慢数组是一种字典的内存形式。不用开辟大块连续的存储空间，节省了内存，但是由于需要维护这样一个 HashTable，其效率会比快数组低。在 Fast Elements 模式下，capacity 用于指示当前内存占用量大小，通常根据数组当前最大索引的值确定。在数组索引过大，超过 capacity 到一定程度( 由V8中 kMaxGap 常量决定，其值为 1024) ，数组将直接转化为 Dictionary Elements 模式。更多关于V8的知识请移步 justjavac 的专栏 常见数组方法如何来处理稀疏数组？这里我对数组的 map、find、findIndex、filter、forEach、reduce方法做实验。 map 方法12345678var array = [1,,,2]var mapArray = array.map((item, index) =&gt; &#123; console.log(index) return item + 1;&#125;)// 方法执行是打印 0，3 似乎跳过了数组中 hole 元素console.log(mapArray)// (4) [2, empty × 2, 3] 根据规范中定义的算法，如果被 map 调用的数组是稀疏数组，新数组将也是离散的保持相同的索引为空。 find 方法12345678var array = [1,,,2]var findArray = array.find((item, index) =&gt; &#123; console.log(index) return item &gt;= 2;&#125;)// 方法执行是打印 0，1，2，3 没有跳过 hole 元素console.log(findArray)// 2 findIndex 方法12345678var array = [1,,,2]var findIndexArray = array.findIndex((item, index) =&gt; &#123; console.log(index) return item &gt;= 2;&#125;)// 方法执行是打印 0，1，2，3 没有跳过 hole 元素console.log(findIndexArray)// 3 filter 方法12345678var array = [1,,,2]var filterArray = array.filter((item, index) =&gt; &#123; console.log(index) return item &gt;= 2;&#125;)// 方法执行是打印 0，3 似乎跳过了数组中 hole 元素console.log(filterArray)// [2] forEach 方法12345var array = [1,,,2]array.forEach((item, index) =&gt; &#123; console.log(index)&#125;)// 方法执行是打印 0，3 似乎跳过了数组中 hole 元素 reduce 方法12345678var array = [1,,,2]var count = array.reduce((acc, item, index) =&gt; &#123; console.log(index) return acc + item;&#125;, 0)// 方法执行是打印 0，3 似乎跳过了数组中 hole 元素console.log(count)// 3 总结本文只是想通过测试让大家更了解常见数组方法如何来处理稀疏数组，常见的数组方法如 map、forEach、filter、reduce 都会跳过数组中的 hole 元素。前端还有很多细节可挖掘，我们继续前行吧。]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[来几道Promise的题，看看你会几道?]]></title>
    <url>%2F2020%2F%E6%9D%A5%E5%87%A0%E9%81%93Promise%E7%9A%84%E9%A2%98%EF%BC%8C%E7%9C%8B%E7%9C%8B%E4%BD%A0%E4%BC%9A%E5%87%A0%E9%81%93.html</url>
    <content type="text"><![CDATA[前言本文将带你完成以下任务，相信你会更好掌握 Promise。 JS实现一个带并发限制的异步调度器Scheduler，保证同时运行的任务最多有两个 实现Promise.all 实现Promise.any 实现Promise.race Promise.allSettled 多个返回promise的函数串行执行 Promise 超时设计，利用Promise.race来实现 第一题JS实现一个带并发限制的异步调度器Scheduler，保证同时运行的任务最多有两个。完整题目1234567891011121314151617181920212223242526272829303132333435363738// JS实现一个带并发限制的异步调度器Scheduler，// 保证同时运行的任务最多有两个。// 完善代码中Scheduler类，// 使得以下程序能正确输出class Scheduler &#123; constructor() &#123; this.count = 2 this.queue = [] this.run = [] &#125; add(task) &#123; // ... &#125;&#125;const timeout = (time) =&gt; new Promise(resolve =&gt; &#123; setTimeout(resolve, time)&#125;)const scheduler = new Scheduler()const addTask = (time, order) =&gt; &#123; scheduler.add(() =&gt; timeout(time)).then(() =&gt; console.log(order))&#125;addTask(1000, &apos;1&apos;)addTask(500, &apos;2&apos;)addTask(300, &apos;3&apos;)addTask(400, &apos;4&apos;)// output: 2 3 1 4// 一开始，1、2两个任务进入队列// 500ms时，2完成，输出2，任务3进队// 800ms时，3完成，输出3，任务4进队// 1000ms时，1完成，输出1// 1200ms时，4完成，输出4 答案12345678910111213141516171819202122232425262728293031323334class Scheduler &#123; constructor() &#123; this.awatiArr = []; this.count = 0; &#125; async add(promiseCreator) &#123; if (this.count &gt;= 2) &#123; await new Promise((resolve) =&gt; &#123; this.awatiArr.push(resolve); &#125;); &#125; this.count++; const res = await promiseCreator(); this.count--; if (this.awatiArr.length) &#123; // 前面promise的resolve this.awatiArr.shift()(); &#125; return res; &#125;&#125;const scheduler = new Scheduler();const timeout = (time) =&gt; &#123; return new Promise(r =&gt; setTimeout(r, time))&#125;const addTask = (time, order) =&gt; &#123; scheduler.add(() =&gt; timeout(time)) .then(() =&gt; console.log(order))&#125;// test// addTask(1000, 1)// addTask(500, 2)// addTask(300, 3)// addTask(400, 4) 解释 当前执行并发大于等于2时，生成一个暂停的Promise，把resolve添到一个数组中，下面的代码被暂停执行 当前执行并发小于2, 立即执行异步操作并在该异步操作执行完毕后从数组中弹出最先push的resolve改变Promise的状态 由于Promise被resolve了，最初被暂停的代码可以继续执行 关键点为 Promise 没有被 resolve 或 reject 时后面代码会被暂停，Promise 的 resolve 或 reject 可以在Promise构造函数外执行解释非常好的文章 第二题实现Promise.all()// 结束条件：有一个 Promise rejected 或 所有 Promise resolved。 接收一个 Promise 实例的数组或具有 Iterator 接口的对象 如果元素不是 Promise 对象，则使用 Promise.resolve 转成 Promise 对象 如果全部成功，状态变为 resolved，返回值将组成一个数组传给回调 只要有一个失败，状态就变为 rejected，返回值将直接传递给回调all() 的返回值也是新的 Promise 对象 注意⚠️，不管是Promise.all、any、race还是allSettled，参数都是一个🉑️迭代对象及部署了[Symbol.iterator]方法（如array\string\map\set\有length属性的对象）123456789101112131415161718192021222324function promiseAll(iterable) &#123; let array = Array.from(iterable); let resolveNum = 0; let promiseNum = array.length; let lists = new Array(promiseNum); return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; promiseNum; i++) &#123; Promise.resolve(array[i]).then(res =&gt; &#123; lists[i] = res; resolveNum++; if (resolveNum === promiseNum) &#123; return resolve(lists) &#125; &#125;).catch(reason =&gt; &#123; return reject(reason); &#125;); &#125; &#125;);&#125;// promiseAll([1, Promise.reject(12)]).then(res =&gt; &#123;// console.log(res)// &#125;).catch(reason =&gt; &#123;// console.log(reason)// &#125;); 第三题实现Promise.any() 结束条件：有一个 Promise resolved 或 所有 Promise rejected 就返回一个AggregateError类型的实例。 如果可迭代对象中没有一个 promise 成功（即所有的 promises 都拒绝），就返回一个失败的 promise 和AggregateError类型的实例，它是 Error 的一个子类，用于把单一的错误集合在一起。这里你有学习到了一个新的错误类型 AggregateError 快去看看吧 1234567891011121314151617181920212223242526272829function promiseAny(iterable) &#123; let array = Array.from(iterable); let promiseNum = array.length; let rejectNum = 0; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; promiseNum; i++) &#123; Promise.resolve(array[i]).then(res =&gt; &#123; return resolve(res); &#125;).catch(error =&gt; &#123; rejectNum++; if (rejectNum === promiseNum) &#123; return reject(new AggregateError(&quot;&quot;, &quot;All promises were rejected&quot;)) &#125; &#125;); &#125; &#125;);&#125;// var p1 = new Promise(function (resolve, reject) &#123;// setTimeout(reject, 500, &quot;one&quot;);// &#125;);// var p2 = new Promise(function (resolve, reject) &#123;// setTimeout(reject, 600, &quot;two&quot;);// &#125;);// promiseAny([p1, p2]).then(res =&gt; &#123;// console.log(res)// &#125;).catch(error =&gt; &#123;// console.log(error)// &#125;); 第四题实现Promise.race()结束条件：一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。123456789101112131415161718192021222324function promiseRace(iterable) &#123; let array = Array.from(iterable); let promiseNum = array.length; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; promiseNum; i++) &#123; Promise.resolve(array[i]).then(res =&gt; &#123; return resolve(res); &#125;).catch(error =&gt; &#123; return reject(error); &#125;); &#125; &#125;);&#125;// var p1 = new Promise(function (resolve, reject) &#123;// setTimeout(resolve, 500, &quot;one&quot;);// &#125;);// var p2 = new Promise(function (resolve, reject) &#123;// setTimeout(reject, 600, &quot;two&quot;);// &#125;);// promiseRace([p1, p2]).then(res =&gt; &#123;// console.log(res)// &#125;).catch(error =&gt; &#123;// console.log(error)// &#125;); 第五题Promise.allSettled() 结束条件：所有给定的promise都已经fulfilled或rejected后的promise。 对于 promise 为 resolved 时对象为 {status: ‘fulfilled’, value: promise的值} 对于 promise 为 rejected 时对象为 {status: ‘rejected’, reason: rejected的原因} 目前是用在我们SSR项目中，一次性会在服务端发起多个请求，总不能一个请求挂掉都把成功的请求都丢弃吧，你可是试试这个方法。123456789101112131415161718192021222324252627282930313233function promiseAllSettled(iterable) &#123; let array = Array.from(iterable); let promiseNum = array.length; let num = 0; let list = new Array(promiseNum); return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; promiseNum; i++) &#123; let obj = &#123; status: &apos;&apos; &#125;; Promise.resolve(array[i]).then(res =&gt; &#123; obj.status = &apos;fulfilled&apos;; obj.value = res; &#125;).catch(error =&gt; &#123; obj.status = &apos;rejected&apos;; obj.reason = error; &#125;).finally(() =&gt; &#123; num++; list[i] = obj; if (promiseNum === num) &#123; return resolve(list); &#125; &#125;); &#125; &#125;);&#125;// const promise1 = Promise.reject(3);// const promise2 = new Promise((resolve, reject) =&gt; setTimeout(resolve, 100, &apos;foo&apos;));// promiseAllSettled([promise1, promise2]).then(res =&gt; &#123;// console.log(res)// &#125;).catch(error =&gt; &#123;// console.log(error)// &#125;); 第六题多个返回promise的函数串行执行123456789101112131415161718192021222324252627282930// 实现一function promiseSerial(array) &#123; if (array.length === 0) throw &apos;参数数组至少有一项&apos; array.reduce((preP, nextP) =&gt; &#123; return preP.then(() =&gt; nextP()); &#125;, Promise.resolve());&#125;// 实现二async function promiseSerial1(array) &#123; if (array.length === 0) throw &apos;参数数组至少有一项&apos; for (let promise of array) &#123; await promise(); &#125;&#125;const createPromise = (time, id) =&gt; () =&gt; new Promise(solve =&gt; setTimeout(() =&gt; &#123; console.log(Date.now() / 1000); console.log(&quot;promise&quot;, id); solve(); &#125;, time) );// test// promiseSerial1([// createPromise(1000, 1),// createPromise(1000, 2),// createPromise(1000, 3)// ]) 第七题Promise 超时设计，利用Promise.race来实现1234567891011121314151617181920212223242526function resolveAfter(ms, value = undefined) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&apos;timeout&apos;); resolve(value || Promise.reject(new Error(&apos;Operation timed out&apos;))); &#125;, ms); &#125;);&#125;function PromiseTimeout(ms, promise) &#123; return Promise.race([ promise, resolveAfter(ms) ]);&#125;// test// var p1 = new Promise((resolve, reject) =&gt; &#123;// setTimeout(() =&gt; &#123;// console.log(&apos;p1&apos;);// resolve(&apos;p1-resolved&apos;)// &#125;, 1000);// &#125;)// PromiseTimeout(100, p1).then(res =&gt; &#123;// console.log(res)// &#125;).catch(error =&gt; &#123;// console.log(error)// &#125;); 最后行文匆忙（主要是要哄👶睡觉了），本文主要是个人对 Promise 的一些理解，如有错误还望斧正。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道CSS面试题]]></title>
    <url>%2F2020%2F%E4%B8%80%E9%81%93css%E9%9D%A2%E8%AF%95%E9%A2%98.html</url>
    <content type="text"><![CDATA[前言在看一篇 木易杨大佬，三年前端寒冬入大厂，收获蚂蚁、字节 offer 面经分享的文章，其中一道字节跳动的CSS题目吸引了我（哈哈，因为我对这个知识点比较含糊，答不上来），下面我们大家就一起来看看这道题吧。 题目求最终 left、right 的宽度（container 的 width &lt; left 的 width + right 的 width 的情况）123456789101112131415161718192021222324&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .container &#123; width: 600px; height: 300px; display: flex; &#125; .left &#123; flex: 1 2 500px; background: red; &#125; .right &#123; flex: 2 1 400px; background: blue; &#125;&lt;/style&gt; 先补充下理论知识首先我们还是看一下，flex属性的定义吧!12The flex CSS property sets how a flex item will grow or shrink to fit the space available in its flex container.It is a shorthand for flex-grow, flex-shrink, and flex-basis. flex属性其实是flex-grow（主轴空间多余时放大比例）、flex-shrink（主轴空间不足时缩小比例）、flex-basis（分配多余空间之前占据的主轴空间）这三个属性的简写。flex虽说时前面提到的三个属性的简写，但在一些情况下是可以省略的。 flex单值语法: 值必须为以下其中之一:一个无单位数(number): 它会被当作 flex-grow 的值。一个有效的宽度(width)值: 它会被当作 flex-basis 的值。关键字none，auto或initial.双值语法: 第一个值必须为一个无单位数，并且它会被当作 flex-grow 的值。第二个值必须为以下之一：一个无单位数：它会被当作 flex-shrink 的值。一个有效的宽度值: 它会被当作 flex-basis 的值。三值语法:第一个值必须为一个无单位数，并且它会被当作 flex-grow 的值。第二个值必须为一个无单位数，并且它会被当作 flex-shrink 的值。第三个值必须为一个有效的宽度值， 并且它会被当作 flex-basis 的值。 上面提到的有效的宽度值，其实就是 number + unit，如 3px、 5rem等。 解题首先，left 的 flow-basis 为 500px，right 的 flow-basis 为 400px，两者之后大于 container 容器的宽度 600px，这时肯定会触发 left 和 right 的压缩来适应容器的宽度，但如何分配压缩比的呢？left 的 width + right 的 width = container 的 width，这个公式肯定成立。但为题是 left 的 width 和 right 的 width 如何表示呢？用数学的用法来解答，假设缩放基数为 x。12500*(1-2/x) + 400*(1-1/x) = 600求解，x = 14/3 现在答案出来了，left 的 width 约为 285.72px，right 的 width 约为 314.28px。 这里顺便验证下 container 的 width = left 的 width + right 的 width123456789101112131415161718192021222324&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .container &#123; width: 900px; height: 300px; display: flex; &#125; .left &#123; flex: 1 2 500px; background: red; &#125; .right &#123; flex: 2 1 400px; background: blue; &#125;&lt;/style&gt; 结果符合预期，当container 的 width = left 的 width + right 的 width，直接按各个 flex item 的 flow-basis 展示就好。 这里顺便验证下 container 的 width &gt; left 的 width + right 的 width123456789101112131415161718192021222324&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .container &#123; width: 1000px; height: 300px; display: flex; &#125; .left &#123; flex: 1 2 500px; background: red; &#125; .right &#123; flex: 2 1 400px; background: blue; &#125;&lt;/style&gt; 这种情况也比较简单，可以这样理解，left 和 right 按 flow-basis 分配，还剩下 100px，则将起分为 left 的 flex-grow + right 的 flex-grow 份，然后 left 占 自己的 flex-grow 份。123// left 的 widthleft的width = 500 + (1/3)*100 = 533.33pxright的width = 400 + (2/3)*100 = 466.67px 参考文档三年前端寒冬入大厂，收获蚂蚁、字节 offer 面经分享CSS flex 属性]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试-手撕代码篇]]></title>
    <url>%2F2019%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81%E7%AF%87.html</url>
    <content type="text"><![CDATA[前言在前端面试有一个非常重要的环节，也是面试者最担心的一个环节。对“手撕代码”的考察需要面试者平时总结和积累（临时抱佛脚是不好使的），在这里笔者就自己如何攻破“手撕代码”环节总结了一些经验，希望能帮助你挑战高薪，迎娶白富美😄😄😄。 使用IDE时尽量避免直接使用提示API，亲自输入（孰能生巧，当然感觉没问题的API就不用浪费时间了） 遇到不熟悉的API，一定要查文档研究清楚（参数个数和具体意义以及返回值） 如在模拟某个原生API时，先写出原生API并分析出形参和返回值 感觉功能完成时，需要在考虑一下边界条件（参数非比填情况、undefined、null） 平常有空时多刷刷一二线大厂的面试题（扩充自己的知识广度） 多关照一些前端动态（比如说curry、compose你没听过，这就有点尴尬） 常见的“手撕代码”，都是高频题哦curry（柯里化）1234567function curry(fn: any) &#123; return function judgeCurry(...args: any) &#123; return fn.length &gt; args.length ? (...args1: any) =&gt; judgeCurry(...args,...args1): fn(...args); &#125;&#125; compose（函数组合）12345678910function compose(...args: any[]) &#123; return (subArgs: any) =&gt; &#123; // for(let i = args.length - 1; i &gt;= 0; i--) &#123; // res = args[i](res); // &#125; return args.reverse().reduce((acc, func,index) =&gt; &#123; return func(acc); &#125;, subArgs); &#125;&#125; pipe（函数管道）12345678910export function pipe(...args: any[]) &#123; return (subArgs: any) =&gt; &#123; // for(let i = args.length - 1; i &gt;= 0; i--) &#123; // res = args[i](res); // &#125; return args.reduce((acc, func,index) =&gt; &#123; return func(acc); &#125;, subArgs); &#125;&#125; throttle（函数节流）1234567891011121314151617function throttle(fn: any, wait: number)&#123; let last: any; return function() &#123; let now: any = Date.now(); // 初次执行 if (!last) &#123; fn.apply(this, arguments); last = now; return; &#125; // 以后触发，需要判断是否到延迟 if(now - last &gt;= wait) &#123; fn.apply(this, arguments); last = now; &#125; &#125;&#125; debounce（函数防抖）12345678910111213141516171819function debounce(func: any, delay: number) &#123; // 初次触发定时器为null，后面产生一份定时器并记下定时器id let timer: any = null; // 闭包使定时器id逃逸 return function() &#123; let args = arguments; // 如果已有定时器id，则需要清除，重新开始延迟执行 if (timer) &#123; clearTimeout(timer); timer = null; &#125; timer = setTimeout( () =&gt; &#123; func.apply(this, args); // 销毁定时器id，以便下次节流函数触发 timer = null; &#125;, delay); &#125; &#125; formatMoney（千分位）1234567891011121314151617181920212223242526272829function fmoney(num: number)&#123; /* 正则实现 */ // 参考：https://www.cnblogs.com/lvmylife/p/8287247.html let [integer, decimal] = String(num).split(&apos;.&apos;); let regExp = /\d&#123;1,3&#125;(?=(\d&#123;3&#125;)+$)/g; integer = integer.replace(regExp, &apos;$&amp;,&apos;); return `$&#123;integer&#125;$&#123;decimal === undefined ? &apos;&apos;: &apos;.&apos;+decimal&#125;`; // 正则解释 // 正则表达式 \d&#123;1,3&#125;(?=(\d&#123;3&#125;)+$) 表示前面有1~3个数字，后面的至少由一组3个数字结尾 // 先行肯定断言(?=)会作为匹配校验，但不会出现在匹配结果字符串里面 // ?=表示正向引用，可以作为匹配的条件，但匹配到的内容不获取，并且作为下一次查询的开始 // $&amp; 表示与正则表达式相匹配的内容，具体的可查看 w3school的replace()方法 /* Number.prototype.toLocaleString()实现 */ // Number.prototype.toLocaleString() // return num.toLocaleString(&apos;en&apos;); /* Intl.NumberFormat().format(number)实现 */ // Intl.NumberFormat().format(number) // return Intl.NumberFormat(&apos;en&apos;).format(num); // reduce 方案 // let arr = String(num).split(&apos;.&apos;); // let char = arr[0].split(&apos;&apos;).reverse(); // let IntStr = char.reduce((acc, value, index) =&gt; &#123; // return `$&#123;index % 3 === 0 ? String(value)+&apos;,&apos; : String(value)&#125;$&#123;acc&#125;`; // &#125;, &apos;&apos;).slice(0, -1); // return `$&#123;IntStr&#125;$&#123;arr[1]? &apos;.&apos;+arr[1] : &apos;&apos; &#125;`;&#125; deepClone（深拷贝）说明：通过new WeakMap()来避免循环引用（拷贝引用类型时并保存其地址，后面遇到引用类型先检查是否已经保存了）通过Reflect.ownKeys(obj)遍历出obj自身的所有可枚举和不可枚举的属性以及symbol属性拷贝对应属性的属性描述符12345678910111213141516171819202122232425262728293031323334353637383940414243444546function checkType(obj: any): string &#123; const type = Object.prototype.toString.call(obj); return type.slice(8, -1);&#125;// 深拷贝（hash = new WeakMap()考虑循环引用的问题）export function deepClone(obj: any, hash = new WeakMap()) : any&#123; if(checkType(obj) === &apos;RegExp&apos;) &#123; // regExp.source 正则对象的源模式文本; // regExp.flags 正则表达式对象的标志字符串; // regExp.lastIndex 下次匹配开始的字符串索引位置 let temp = new RegExp(obj.source, obj.flags); temp.lastIndex = obj.lastIndex; return temp; &#125; if(checkType(obj) === &apos;Date&apos;) &#123; return new Date(obj); &#125; // 非复杂类型(null、undefined、string、number、symbol、boolean、function) if(obj === null || typeof obj !== &apos;object&apos;) &#123; return obj; &#125; // 还可以扩展其他类型。。。 // 与后面hash.set()防止循环引用 if(hash.has(obj)) &#123; return hash.get(obj); &#125; let newObj = new obj.constructor(); hash.set(obj, newObj); // Object.keys(obj)类型于 for in 和 obj.hasOwnProperty // 是否应该拷贝自身属性（可枚举的和不可枚举的以及symbol） Reflect.ownKeys(obj).forEach(function(key) &#123; if(typeof obj[key] === &apos;object&apos; &amp;&amp; obj[key] !== null) &#123; newObj[key] = deepClone(obj[key], hash); &#125;else&#123; // 直接赋值 // newObj[key] = obj[key]; // 是否应该保留属性描述符 Object.defineProperty(newObj, key, Object.getOwnPropertyDescriptor(obj, key)); &#125; &#125;); return newObj;&#125; 模拟instanceof1234567891011121314function instance_of(L: Object, R: any)&#123; let protoChain = Object.getPrototypeOf(L); const Lprototype = R.prototype; // 最坏情况递归查到Object.prototype === null while(protoChain) &#123; // 两个对象指向同一个内存地址，则为同一个对象 if(protoChain === Lprototype) &#123; return true; &#125; protoChain = Object.getPrototypeOf(protoChain); &#125; // 找到终点还没找到，那就没有了呗 return false;&#125; 实现call方法123456789101112131415Function.prototype.myCall = function myCall() &#123; let [thisArg, ...args] = Array.from(arguments); if (!thisArg) &#123; //context 为 null 或者是 undefined thisArg = typeof window === &apos;undefined&apos; ? global : window; &#125; // this 的指向的是当前函数 func (func.call) // 为thisArg对象添加func方法，func方法又指向myCall，所以在func中this指向thisArg thisArg.func = this; // 执行函数 let result = thisArg.func(...args); // thisArg 上并没有 func 属性，因此需要移除 delete thisArg.func; return result;&#125; 实现apply方法123456789101112131415Function.prototype.myApply = function myApply() &#123; // 第一个参数为this对象，第二个参数为数组（与myCall唯一的区别就在第二个参数是数组） let [thisArg, args] = Array.from(arguments); if (!thisArg) &#123; //context 为 null 或者是 undefined thisArg = typeof window === &apos;undefined&apos; ? global : window; &#125; // this 的指向的是当前函数 func (func.call) thisArg.func = this; // 执行函数 let result = thisArg.func(...args); // thisArg 上并没有 func 属性，因此需要移除 delete thisArg.func; return result;&#125; 实现bind方法12345678910111213141516171819Function.prototype.myBind = function myBind() &#123; let [thisArg, ...args] = [...arguments]; if (!thisArg) &#123; //context 为 null 或者是 undefined thisArg = typeof window === &apos;undefined&apos; ? global : window; &#125; let that = this; return function() &#123; // 防止第二次调用 func 是，该func已经被delete了，需要重新赋值 if(!thisArg.func) &#123; thisArg.func = that; &#125; let result = thisArg.func(...args); // thisArg原本没有func方法 delete thisArg.func; return result; &#125;&#125; 模拟Promise.all（多个Promise并行执行）目前还存在参数适配的问题1234567891011121314151617181920212223242526272829var p1 = function()&#123; return new Promise((resolve, reject) =&gt; &#123;setTimeout(function()&#123;resolve(&apos;12&apos;)&#125;, 1000)&#125;)&#125;;var p2 = function()&#123; return new Promise((resolve, reject) =&gt; &#123;setTimeout(function()&#123;resolve(2)&#125;, 2000)&#125;)&#125;;var p3 = function()&#123; return new Promise((resolve, reject) =&gt; &#123;setTimeout(function()&#123;resolve(3)&#125;, 1000)&#125;)&#125;;function promiseAll(tasks) &#123; let ary = new Array(tasks.length).fill(1).map(item =&gt; &#123;return &#123;val: undefined, success: false&#125;&#125;); return new Promise((resolve, reject) =&gt; &#123; for(let i = 0; i &lt; tasks.length; i++) &#123; tasks[i]().then(res =&gt; &#123; ary[i].val = res; ary[i].success = true; if(ary.every(item =&gt; item.success === true))&#123; resolve(ary.map(item =&gt; item.val)) &#125; &#125;).catch(err =&gt; &#123; reject(err); &#125;); &#125; &#125;);&#125;// testpromiseAll([p1, p2, p3]).then(res =&gt; console.log(res)).catch(err =&gt; &#123; console.log(err);&#125;); 多个Promise串行执行(两种方式)12345678910111213141516171819202122function parallelPromises1(tasks)&#123; var result = []; return tasks.reduce((accumulator,item,index)=&gt;&#123; return accumulator.then(res=&gt;&#123; item = typeof item === &apos;function&apos; ? item() : item; return item.then(res=&gt;&#123; // debugger result[index] = res return index == tasks.length - 1 ? result : item &#125;) &#125;) &#125;,Promise.resolve())&#125;async function parallelPromises2(tasks) &#123; let ary = []; for (let task of tasks) &#123; let temp = await task(); ary.push(temp); &#125; return ary;&#125; 写在后面上面代码完全是笔者手敲，难免有错误，还望斧正。这种题目还有很多（实现简易版的EventEmitter、简易版模版引擎等），笔者会持续更新。如果对你有帮助，俺希望送上你的github小星星，在此感谢。本文同步发布于个人博客掘金知乎专栏]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux备忘录]]></title>
    <url>%2F2019%2Flinux%E5%A4%87%E5%BF%98%E5%BD%95.html</url>
    <content type="text"><![CDATA[常用操作public key也就是你本地的 id_rsa.pub 文件，将文件内容添加到远程下列目录中/root/.ssh/authorized_keys yumyum提供了查找、安装、删除某一个、一组甚至全部软件包的命令。yum [options] [command] [package …]options：可选，选项包括-h（帮助），-y（当安装过程提示选择全部为”yes”），-q（不显示安装的过程）等等。command：要进行的操作。package操作的对象。1.列出所有可更新的软件清单命令：yum check-update2.更新所有软件命令：yum update3.仅安装指定的软件命令：yum install 4.仅更新指定的软件命令：yum update 5.列出所有可安裝的软件清单命令：yum list6.删除软件包命令：yum remove 7.查找软件包 命令：yum search 8.清除缓存命令:yum clean packages: 清除缓存目录下的软件包yum clean headers: 清除缓存目录下的 headersyum clean oldheaders: 清除缓存目录下旧的 headersyum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers lsoflist open files是一个列出当前系统打开文件的工具 处理端口占用lsof -i tcp:port // 返回pidkill pid // 杀死进程 文件ls显示目录ls 目录名称ls 无参数时，显示当前目录下的文件ls / 显示根目录下的文件 显示一个文件的属性以及文件所属的用户和组ls -l前0～9位分别代表0代表文件类型，d为目录，-为文件，l为链接文档等1～3代表属主权限user（rwx分别代表read、write、execute，没有该权限则-表示）4～6代表属组权限group7～9代表其他用户权限others 查看全部文件ls -a 仅列出目录本身，而不是列出目录内的文件数据(常用)ls -d cdChange Directory切换目录cd 相对路径或绝对路径 pwdPrint Working Directory显示目前所在的目录 pwd [-P]-P ：显示出确实的路径，而非使用连结 (link) 路径。 mkdirmake directory创建新目录 mkdir [-mp] 目录名称-m ：配置文件的权限mkdir -m 711 test2-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！mkdir -p test1/test2 rmdir删除空的目录-p ：连同上一级『空的』目录也一起删除 cp [-adfilprsu] 来源档 目标档拷贝文件和目录 rmrm [-fir] 文件或目录-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；-i ：互动模式，在删除前会询问使用者是否动作-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！ mv移动文件与目录，或修改名称mv [-fiu] source destination-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！-u ：若目标文件已经存在，且 source 比较新，才会升级 (update) chgrpchgrp [-R] 属组名 文件名更改文件属组，-R代表递归操作目录中的所有文件和目录 chownchown [–R] 属主名 文件名chown [-R] 属主名：属组名 文件名更改文件属主，也可以同时更改文件属组 chmod更改文件9个属性Linux文件属性有两种设置方法，一种是数字，一种是符号。chmod [-R] xyz 文件或目录 // xyz分别代表权限值，x为user，y为grounp，z为others，r(4)w(2)x(1)chmod u=rwx,g=rx,o=r 文件或目录chmod Linux 文件内容查看cat由第一行开始显示文件内容cat [-AbEnTv] tac文件内容从最后一行开始显示，tac与cat命令刚好相反。tac 文件路径 nl查看文件显示行号nl [-bnw] 文件路径 more一页一页翻动查看文件more 文件路径 less一页一页翻动查看文件（可以往前翻）less 文件路径less运行时可以进行下列操作/字串 ：向下搜寻『字串』的功能；?字串 ：向上搜寻『字串』的功能；n ：重复前一个搜寻 (与 / 或 ? 有关！) head取出文件前面几行head [-n number] 文件显示前number行 tail取出文件后面几行tail [-n number] 文件-n ：后面接数字，代表显示几行的意思-f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测看服务端日志用的比较多： tail -nf 100 文件 用户和用户组管理useradd添加新的用户账号useradd 选项 用户名-c comment 指定一段注释性描述。-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。-g 用户组 指定用户所属的用户组。-G 用户组，用户组 指定用户所属的附加组。-s Shell文件 指定用户的登录Shell。-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。如：useradd -d /usr/sam -m sam userdel删除帐号，将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。userdel 选项 用户名-r 它的作用是把用户的主目录一起删除。 usermod修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。usermod 选项 用户名 passwd指定和修改用户口令passwd 选项 用户名-l 锁定口令，即禁用账号。-u 口令解锁。-d 使账号无口令。-f 强迫用户下次登录时修改口令。 groupadd增加一个新的用户组groupadd 选项 用户组如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。-g GID 指定新用户组的组标识号（GID）。-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。 groupdel删除一个已有的用户组groupdel 用户组 groupmod修改用户组的属性roupmod 选项 用户组-g GID 为用户组指定新的组标识号。-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。-n 新用户组 将用户组的名字改为新名字。 newgrp如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。newgrp groupName 其他/etc/passwd文件是用户管理工作涉及的最重要的一个文件。/etc/group文件记录的是用户所属的用户组。/etc/shadow主目录：一般是用户登录后的目录，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。添加批量用户 磁盘管理df检查文件系统的磁盘空间占用情况。df [-ahikHTm] 目录或文件名-a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；-k ：以 KBytes 的容量显示各文件系统；-m ：以 MBytes 的容量显示各文件系统；-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；-H ：以 M=1000K 取代 M=1024K 的进位方式；-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；-i ：不用硬盘容量，而以 inode 的数量来显示 du对文件和目录磁盘使用的空间的查看。du [-ahskm] 文件或目录名称-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。-h ：以人们较易读的容量格式 (G/M) 显示；-s ：列出总量而已，而不列出每个各别的目录占用容量；-S ：不包括子目录下的总计，与 -s 有点差别。-k ：以 KBytes 列出容量显示；-m ：以 MBytes 列出容量显示； fdiskLinux 的磁盘分区表操作工具fdisk [-l] 装置名称-l ：输出后面接的装置所有的分区内容。若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来。 mkfs磁盘分割完毕后自然就是要进行文件系统的格式化，格式化的命令非常的简单，使用 mkfs（make filesystem） 命令。mkfs [-t 文件系统格式] 装置文件名 fsckfile system check用来检查和维护不一致的文件系统fsck [-t 文件系统] [-ACay] 装置名称 mount磁盘挂载与卸除mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点 参考文档linux启动流程runoob/linux]]></content>
      <categories>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS开发者大会5th]]></title>
    <url>%2F2019%2FCSS%E5%BC%80%E5%8F%91%E8%80%85%E5%A4%A7%E4%BC%9A5th.html</url>
    <content type="text"><![CDATA[周末看了CSS2019开发者大会的视频，受益匪浅。本文记录大部分视频内容以及自己的理解，如有理解不当的地方，还望指出。 为什么块格式自动 margin 不垂直居中元素？如果 margin-left 和 margin-right 都设置为 auto，则他们两个值相等，所以水平能够居中。如果 margin-top 和 margin-bottom 都设置为 auto，则他们实际等于0，所以就不能垂直居中。CSS5th分享原文 移动端设置 viewport 的两种写法meta 标签1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; CSS(暂不可用)12345@viewport &#123; width: extend-to-zoom 100%; height: auto; zoon: 1.0;&#125; 滚动捕捉（实验性）scroll-snap-type // 定义在滚动容器中的一个snap点如何被执行。scroll-snap-alignscroll-margin // 定义滚动捕捉区域的开始，该区域用于将此框捕捉到snapport。scroll-padding 自定义属性（非CSS变量）声明属性(–开头)12345678// 任何元素都可以使用:root &#123; --gutter: 1em;&#125;// 局部可使用#side div &#123; --gutter: 1em;&#125; 使用($开头)123.container &#123; padding: $gutter;&#125; CSS Houdini（Js in CSS）CSS Houdini 是各大厂商的工程师所组成的工作小组，志在建立一系列的 API，让开发者能够介入浏览器的 CSS engine 操作，帶给开发者更多的解决方案。 以内容为主的尺寸计算方式外部尺寸： 根据元素的上下文确定大小，而不考虑其内容。如：width: 400px;内部尺寸： 根据元素的内容确定大小，而不考虑其上下文。如：widht: min-content;w3c#intrinsic-sizes利用@supports，本地CSS功能检测123456789.selector &#123; /* Styles that are supported in old browsers */&#125;@supports (property:value) &#123; .selector &#123; /* Styles for browsers that support the specified property */ &#125;&#125; 混合模式和滤镜mix-blend-mode // 描述了元素的内容应该与元素的直系父元素的内容和元素的背景如何混合。background-blend-mode // 定义该元素的背景图片和背景色如何混合。isolation // 定义该元素是否必须创建一个新的stacking context。filter // 将滤镜效果应用于元素。isolation 属性的主要作用是当和background-blend-mode属性一起使用时，可以只混合一个指定元素栈的背景：它允许使一组元素从它们后面的背景中独立出来，只混合这组元素的背景。 镂空矩形镂空outline: 999px solid rgba(0, 0, 0, .5);椭圆镂空box-shadow: 0 0 0 9999px rgba(0, 0, 0, .5);不规则镂空mask-composite mask允许使用者通过部分或者完全隐藏一个元素的可见区域。这种效果可以通过遮罩或者裁切特定区域的图片。具体有下列属性mask-imagemask-modemask-repeatmask-positionmask-clipmask-originmask-sizemask-typemask-compositeCSS遮罩CSS3 mask/masks详细介绍 transition &amp;&amp; animation要创建一个 transition,浏览器需要看到样式的变化 使用 requestAnimationFrame 来让浏览器看到样式变化 1234567891011121314button.onclick = () =&gt; &#123; // Make the panel const panel = document.createElement(&apos;div&apos;); ... // Stretch it in panel.style.transform = &apos;scale(0)&apos;; panel.style.transition = &apos;transform .5s&apos;; requestAnimationFrame(() =&gt; &#123; requestAnimationFrame(() =&gt; &#123; panel.style.transform = &apos;scale(1)&apos;; &#125;); &#125;);&#125;; 使用 getComputedStyle(elem).property 来让浏览器看到样式变化 1234567891011button.onclick = () =&gt; &#123; // Make the panel const panel = document.createElement(&apos;div&apos;); ... // Stretch it in panel.style.transform = &apos;scale(0)&apos;; getComputedStyle(panel).transform; panel.style.transition = &apos;transform .5s&apos;; panel.style.transform = &apos;scale(1)&apos;;&#125;; 虽然 getComputedStyle(elem) 不会更新样式，但是 getComputedStyle(elem).property 会更新样式。使用 getComputedStyle 的代价很高transitionendtransitionend 事件会在 CSS transition 结束后触发。但下列情况不会出发当 transition 完成前移除 transition 时，比如移除css的transition-property 属性，事件将不会被触发。当 transition 完成前设置 display 为”none”，事件同样不会被触发。当 transition 完成前元素被移除不会触发。为了防止以上 transition 被取消setTimeout 将其添加到异步任务队列中。transitioncancel 事件。还有 transitionrun 事件（需确保一开始是有 transition 的）。 animationanimation-timing-function只在关键帧之间 适用WEB ANIMATIONS1234567891011ele.animate( &#123; transform: [&apos;scale(1)&apos;, &apos;scale(2)&apos;], opacity: [1, 0], &#125;, &#123; duration: 3000, iterations: Infinity, easing: &apos;cubic-bezier(0.7, 0.0, 1.0, 1.0)&apos;, &#125;); 特性检查（html.animate）123if (&apos;animate&apos; in elem) &#123; // ... Animate away...&#125; polyfill (web-animations-js)Animating like you just don’t care with Element.animate尽量只对 transform 和 opacity 使用动画。根据用户的偏好，禁用复杂动画，媒体查询 prefers-reduced-motion 可偏向于用户。移动端一般动画和过渡时间把握在300ms，根据屏幕大小适当调整。 其他属性text-fill-color设置字体的填充颜色，如果未设置此属性，则字体颜色为 color 属性的值。text-fill-color 与 color 的区别text-fill-color 只设置字体的颜色，color 设置所有的前景色。相当于 text-fill-color 为 color 的子集。background-clip置元素的背景（背景图片或颜色）是否延伸的范围（border-box/padding-box/content-box/text等）。box-decoration-break指定一个元素的片段时、多行、多列或页面断应该呈现形式（ 默认slice，clone独立呈现）。clip-path该属性可以创建一个只有元素的部分区域可以显示的剪切区域（circle、ellipse、polygon等）。object-fit指定可替换元素的内容应该如何适应到其使用的高度和宽度确定的框。可替换元素有哪些？iframe、video、embed、img等writing-mode设置文本行如何被布置（水平或垂直），以及其中块前进方向。shape-outsideshape-outside的CSS 属性定义了一个可以是非矩形的形状，相邻的内联内容应围绕该形状进行排列。CSS Regions &amp;&amp; CSS Exclusions]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell笔记]]></title>
    <url>%2F2018%2Fshell%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[最近公司需要做gitlab分支重置、部署、构建的可视化工具，涉及到Shell脚本相关的知识，先来补充一波。 运行Shell脚本&amp;Shell 注释作为可执行程序12chmod +x ./demo.sh #使脚本具有执行权限./demo.sh #执行脚本 作为解释器参数1/bin/sh ./demo.sh 单行注释以 # 开头的行就是注释，会被解释器忽略。 多行注释12345:&lt;&lt;EOF注释内容...注释内容...注释内容...EOF PS：EOF 也可以使用其他符号(‘ !)。 Shell 变量声明变量123name=fanerge name=&apos;fanerge&apos;name=&quot;fanerge&quot; 使用变量12$name$&#123;name&#125; 只读变量12name=fanergereadonly name #表明该变量只读 删除变量1unset nmae 获取字符串长度12name=&quot;fanerge&quot;$&#123;#string&#125; # 7 提取子字符串123name=&quot;fanerge&quot;$&#123;name:1&#125; # anerge$&#123;name:1:4&#125; # aner PS：分别代表开始位置和结束位置，没有结束位置则到字符串末尾 查找子字符串12name=&quot;fanerge&quot;`expr index &quot;$&#123;name&#125;&quot; e` # 4 // 从1开始计数 Shell 数组声明数组1name=(1 2 3) 读取数组123$&#123;name[2]&#125; # 3 // 读取指定下标项目$&#123;name[*]&#125; # 1 2 3 // 读取数组所有项目$&#123;name[@]&#125; # 1 2 3 // 读取数组所有项目 获取数组的长度123$&#123;#name[*]&#125; # 4$&#123;#name[@]&#125; # 4$&#123;#name[n]&#125; # n为下标，返回数组第n个项目的长度 Shell 传递参数123sh test.sh f a necho $0 # test.shecho $1 # f PS：其他特殊符号。参数处理 说明$# 传递到脚本的参数个数$ 以一个单字符串显示所有向脚本传递的参数。如”$“用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。$$ 脚本运行的当前进程ID号$! 后台运行的最后一个进程的ID号$@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。$- 显示Shell使用的当前选项，与set命令功能相同。$? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 Shell 基本运算符原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。 算术运算符1val=`expr 2 + 3` # 5 PS：表达式和运算符之间要有空格，加（+）、减（-）、乘（*）、除（/）、取余（%）、赋值（=）、条件表达式的等于（==）和不等于（!=） 关系运算符关系运算符只支持数字，不支持字符串，除非字符串的值是数字。运算符 说明-eq 检测两个数是否相等，相等返回 true。-ne 检测两个数是否不相等，不相等返回 true。-gt 检测左边的数是否大于右边的，如果是，则返回 true。-lt 检测左边的数是否小于右边的，如果是，则返回 true。-ge 检测左边的数是否大于等于右边的，如果是，则返回 true。-le 检测左边的数是否小于等于右边的，如果是，则返回 true。 布尔运算符运算符 说明! 非运算，表达式为 true 则返回 false，否则返回 true。-o 或运算，有一个表达式为 true 则返回 true。-a 与运算，两个表达式都为 true 才返回 true。 逻辑运算符运算符 说明&amp;&amp; 逻辑的 AND|| 逻辑的 OR 字符串运算符运算符 说明= 检测两个字符串是否相等，相等返回 true。!= 检测两个字符串是否相等，不相等返回 true。-z 检测字符串长度是否为0，为0返回 true。-n 检测字符串长度是否为0，不为0返回 true。str 检测字符串是否为空，不为空返回 true。 文件测试运算符文件测试运算符用于检测 Unix 文件的各种属性。操作符 说明-b file 检测文件是否是块设备文件，如果是，则返回 true。-c file 检测文件是否是字符设备文件，如果是，则返回 true。-d file 检测文件是否是目录，如果是，则返回 true。-f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。-g file 检测文件是否设置了 SGID 位，如果是，则返回 true。-k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。-p file 检测文件是否是有名管道，如果是，则返回 true。-u file 检测文件是否设置了 SUID 位，如果是，则返回 true。-r file 检测文件是否可读，如果是，则返回 true。-w file 检测文件是否可写，如果是，则返回 true。-x file 检测文件是否可执行，如果是，则返回 true。-s file 检测文件是否为空（文件大小是否大于0），不为空返回 true。-e file 检测文件（包括目录）是否存在，如果是，则返回 true。 Shell echo命令123456echo I am fanergeecho &apos;I am fanerge&apos; # 原样输出echo &quot;I am fanerge&quot;echo &quot;\&quot;I am fanerge\&quot;&quot; # 带有转义字符echo -e &quot;OK! \n&quot; # -e 开启转义 \n为换行 \c为不换行echo `date` # 显示命令执行结果 Shell printf 命令printf format-string [arguments…]参数说明： format-string: 为格式控制字符串 arguments: 为参数列表。 format-string部分参数%d,用来输出十进制整数。%f,用来输出实数（包括单，双精度），以小数形式输出，默认情况下保留小数点6位。%c,用来输出一个字符。%s,用来输出一个字符串。%-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。%-4.2f 指格式化为小数，其中.2指保留2位小数。 printf的转义序列序列 说明\a 警告字符，通常为ASCII的BEL字符\b 后退\c 抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略\f 换页（formfeed）\n 换行\r 回车（Carriage return）\t 水平制表符\v 垂直制表符\ 一个字面上的反斜杠字符\ddd 表示1到3位数八进制值的字符。仅在格式字符串中有效\0ddd 表示1到3位的八进制值字符 Shell test 命令Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。数值测试、字符串测试、文件测试类似12345678num1=100num2=100if test $[num1] -eq $[num2]then echo &apos;两个数相等！&apos;else echo &apos;两个数不相等！&apos;fi Shell 流程控制if else123456789if condition1then command1elif condition2 then command2else commandNfi for 循环1234567for var in item1 item2 ... itemNdo command1 command2 ... commandNdone while 语句1234while conditiondo commanddone PS：let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。123456echo &apos;按下 &lt;CTRL-D&gt; 退出&apos;echo -n &apos;输入你最喜欢的网站URL: &apos;while read urldo echo &quot;是的！$&#123;url&#125; 是一个好网站&quot;done PS：while循环可用于读取键盘信息。 无限循环1234567891011while :do commanddone---------while truedo commanddone---------for (( ; ; )) until 循环1234until conditiondo commanddone PS：until 循环执行一系列命令直至条件为 true 时停止，这恰好与 while 相反。 case1234567891011121314151617181920case 值 in模式1) command1 command2 ... commandN ;;模式2） command1 command2 ... commandN ;;*) command1 command2 ... commandN ;;esac PS：case以esac结尾。 跳出循环在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，Shell使用两个命令来实现该功能：break和continue。break命令break命令允许跳出所有循环（终止执行后面的所有循环）。continuecontinue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。 Shell 函数12345678910[ function ] funname [()]&#123; action; [return int;]&#125;------- PS：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255)。$1、$2、${10}分别代表第一个、第二个、第十个参数。函数返回值在调用该函数后通过 $? 来获得。参数处理 说明$# 传递到脚本的参数个数$ 以一个单字符串显示所有向脚本传递的参数$$ 脚本运行的当前进程ID号$! 后台运行的最后一个进程的ID号$@ 与$相同，但是使用时加引号，并在引号中返回每个参数。$- 显示Shell使用的当前选项，与set命令功能相同。$? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 Shell 输入/输出重定向命令 说明command &gt; file 将输出重定向到 file。PS：注意任何file1内的已经存在的内容将被新内容替代。command &lt; file 将输入重定向到 file。command &gt;&gt; file 将输出以追加的方式重定向到 file。PS：追加。n &gt; file 将文件描述符为 n 的文件重定向到 file。n &gt;&gt; file 将文件描述符为 n 的文件以追加的方式重定向到 file。n &gt;&amp; m 将输出文件 m 和 n 合并。n &lt;&amp; m 将输入文件 m 和 n 合并。&lt;&lt; tag 将开始标记 tag 和结束标记 tag 之间的内容作为输入。 Shell 文件包含1. filename # 注意点号(.)和文件名中间有一空格]]></content>
      <categories>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mobx使用初探api]]></title>
    <url>%2F2018%2FMobx%E4%BD%BF%E7%94%A8%E5%88%9D%E6%8E%A2api.html</url>
    <content type="text"><![CDATA[Mobx数据流简单总结下Mobx常用api的使用 可观察数据Array、Object、Map、Observable // 将一个数据变成可观察数据（数组不是真正的数组）extendObservable() // 将动态添加的数据变为可观察（对象） String、Number、Boolean如果是方法的还需要observable.box来修饰调用get和set方法可以访问和修改原始类型值 对可观察数据做出的反应computed可以根据多个可观察数据产生一个新的可观察数据 autorun自动追踪可观察数据，当在可观察数据发生变化时执行（会初始化执行一次） when当第一个参数为true，执行第二个参数方法 reaction它接收两个函数参数，第一个(数据函数)是用来追踪并返回数据作为第二个函数(效果 函数)的输入 修改可观察数据actionaction.bound // 多一个功能绑定thisrunInAction将多次可观察数据的改变合并到一次触发（优化性能） mobx-reactimport {PropTypes as mobxPropTypes} from ‘mobs-react’;给UI组件使用 @observer // 把react组件的render方法包装成autorun 工具函数import {intercept, observe} from ‘mobx’;observe 和 intercept 可以用来监测单个 observable(它们不追踪嵌套的 observable) 的变化。intercept 可以在变化作用于 observable 之前监测和修改变化。 observe 允许你在 observable 变化之后拦截改变。 toJS递归地将一个(observable)对象转换为 javascript 结构。支持 observable 数组、对象、映射和原始类型。 spyspy(listener). 注册一个全局间谍监听器，用来监听所有 MobX 中的事件。 tracetrace 是一个小工具，它能帮助你查找为什么计算值、 reactions 或组件会重新计算。 mobx提升性能法则细粒度拆分视图组件使用专用组件处理列表尽可能晚地解构可观察数据]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Mobx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一些前端技巧]]></title>
    <url>%2F2018%2F%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E5%89%8D%E7%AB%AF%E6%8A%80%E5%B7%A7.html</url>
    <content type="text"><![CDATA[CSS技巧纯 CSS 实现多行文字截断 JS技巧弹幕开发h5与webview如何互通 打包工具webpack4webpack、webpack-cli、babel-core、babel-loader、babel-preset-env \ 常见依赖babel-plugin-transform-class-properties // class支持属性babel-plugin-transform-decorators-legacy // 支持decorators语法babel-preset-react // jsx依赖 其它查看某个网站全国访问速度情况]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页长度相关API]]></title>
    <url>%2F2018%2F%E7%BD%91%E9%A1%B5%E9%95%BF%E5%BA%A6%E7%9B%B8%E5%85%B3API.html</url>
    <content type="text"><![CDATA[元素的宽高clientWidth、clientHeight：是指元素内容+内边距大小，不包括边框、外边距、滚动条部分。offsetWidth、offsetHeight：是指元素内容+内边距大小+边框大小，不包括外边距和滚动条部分。scrollWidth、scrollHeight：是指元素内容+内边距+对应方向的溢出部分。 元素的位置clientLeft、clientTop：是指元素的内边距的外边缘和边框的外边缘的距离（其实边框的宽度）。offsetLeft、offsetTop：元素的边框的外边缘距离与已定位的父容器（offsetparent）的左边距离（不包括元素的边框和父容器的边框）。scrollTop、scrollLeft：获取或设置一个元素垂直或水平滚动的像素数。pageXOffset、pageYOffset：返回文档在窗口左上角水平和垂直方向滚动的像素。 鼠标位置event.clientX、event.clientY // 鼠标相对于视口左上角X,Y坐标（不包括工具栏和滚动条）event.pageX、event.pageY // 鼠标相对于文档左上角X,Y坐标event.offsetX、event.offsetY // 鼠标相对于事件源元素（srcElement）的X,Y坐标（只有ie支持）event.screenX、event.screenY // 鼠标相对于用户显示器屏幕左上角的X,Y坐标。 其他度量视口大小document.documentElement.clientWidthdocument.documentElement.clientHeight 页面实际大小document.documentElement.scrollWidthdocument.documentElement.scrollHeight 屏幕大小window.screen.widthwindow.screen.height 屏幕可用宽度（去除状态栏）window.screen.availWidthwindow.screen.availHeight 窗口的内高度、内宽度（文档显示区域+滚动条）window.innerWidthwindow.innerHeight 窗口的外高度、外宽度window.outerWidthwindow.outerHeiht 返回元素的大小及其相对于视口的位置ele.getBoundingClientRect() 返回一个指向客户端中每一个盒子的边界矩形的矩形集合ele.getClientRects() 返回一个应用活动样式表并解析这些值可能包含的任何基本计算后报告元素的所有CSS属性的值window.getComputedStyle(element, [pseudoElt])]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用语法汇总]]></title>
    <url>%2F2018%2Fgit%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%B1%87%E6%80%BB.html</url>
    <content type="text"><![CDATA[本文不会介绍git的工作原理，需要你对git有一定的了解。本文几乎罗列出了所有常用的git命令，可作为日常开发的查询手册。 git clonegit clone [remoteUrl] // clone远程库到当前目录（项目名为远程项目名，会自动设置origin为remoteUrl的引用）git clone [remoteUrl] [本地项目名] // clone项目并会重命名为[本地项目名]PS：自动设置本地 master 分支跟踪clone的远程仓库的 master 分支 git fetch用于从另一个存储库下载对象和引用git fetch // 取回远程主机所有分支的更新git fetch [remoteUrl] // 取回远程主机[remoteUrl]的更新到本地仓库（不自动合并到工作区）git fetch [upstream] // 取回远程主机的引用[upstream]的更新到本地仓库git fetch [remoteUrl] [branchName] // 取回远程主机[remoteUrl]的分支[branchName]的更新git fetch [remoteUrl|upstream] [远程分支名]:[本地分支名] // 将[远程分支]fetch到本地并命名为[本地分支名] git checkout用于切换分支或恢复工作区文件git checkout - // 切到最近的一次分支git checkout [branchName] // 切换到[branchName]分支git checkout -b [branchName] // 创建并切换到[branchName]分支git checkout -b [localBranch] [remoteUrl]/[remoteBranch] // 创建并切换到[localBranch]并追踪[remoteUrl]/[remoteBranch]git checkout -m [branchName] // 如果你在错误分支中开发，但又不允许直接切换分支（因为本地有修改），git会帮我们将错误分支到代码合并到branchNanegit checkout -- [fileName] // 撤销工作区的指定文件的操作（没有通过git add添加到暂存区）git checkout . // 撤销工作区的所有文件的操作git checkout head -- [fileName] // 撤销文件到上次commit的时候（head指向上次commit）git checkout -b [localBranchName] [upstream]/[remoteBranchName] // 以远程[remoteBranchName]为模板新建[localBranchName]并切换到该分支并追踪到[upstream]/[remoteBranchName]【2018-12-19】 git pull用于从另一个存储库或本地分支获取并集成（git fetch + git merge FETCH_HEAD）git pull [远程主机名] [远程分支名]:[本地分支名]git pull origin next:master // 取回origin主机的next分支，与本地的master分支合并git pull origin next // 若想取回origin主机的next分支并与当前分支合并，可省略当前分支名一旦当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名git pull origin如果当前分支只有一个追踪分支，连远程主机名都可以省略git pull清理远程已删除本地还存在的分支（2020-04-20）git pull -p git add将文件内容添加到索引/暂存区git add [path] // [path]可以是文件也可以是目录git add . // 将所有修改添加到暂存区git add -u [path] // 把[path]中所有跟踪文件中被修改过或已删除文件的信息添加到暂存区（省略表示 . ,即当前目录）git add -A [path] // 所有跟踪文件中被修改过或已删除文件和所有未跟踪的文件信息添加到暂存区（省略表示 . ,即当前目录）git add -i [path] // 查看已跟踪的文件是否有更改、是否有添加到暂存区 git status用于显示工作目录和暂存区的状态git status -uno // 只列出所有已经被git管理的且被修改但没提交的文件git status -s // --short 格式化输出git status git commit将暂存区当前内容与描述更改的用户和日志消息一起存储在新的提交中git commit -a // 会对以已追踪的文件自动执行git add并commit（只会对已追踪的文件有效果）git commit -m ‘注释’ // 带注释的提交git commit --amend -m ‘注释’// 尝试重写提交（修改上次commit，如果提交内容没有更改，将使用本次提交注释覆盖上次提交注释） git push用于将本地分支的更新git push [远程主机名] [本地分支名]:[远程分支名] // 将[本地分支名]推送到[远程主机名]的[远程分支名]（远程分支名不存在时则新建）git push [远程主机名] :[远程分支名] // 省略本地分支，表示删除[远程主机名]的[远程分支名]git push [远程主机名] -d [远程分支名] // 与上等价（--delete）git push [upstream] [branchName] // 推送[branchName]分支到远端git push -a [远程主机名] // 将本地的所有分支都推送到远程主机（--all）git push [远程主机名] HEAD // 将当前分支推送到远程的同名分支git push [远程主机名] --tags // 推送所有标签git push [远程主机名] [tagName] // 推送单个标签git push [远程主机名] :[tagName] // 删除远程标签git push [远程主机名] tag [tagName] // 将本地标签[tagName]推送到远端[remoteUrl] git branch查看（当前分支前会有星号）、创建、删除分支git branch // 查看本地分支git branch -r // 查看远端分支git branch -a // 本地+远程分支列表（--all）git branch [branchName] // 新建[branchName]分支git branch -v // 查看分支的最近commit及注释git branch -vv // 查看本地git branch -D [branchName] // 删除[branchName]分支（需要切换到要删除分支以外的分支）git branch -m [oldBranchName] [newBranchName] // 重命名分支git branch --set-upstream-to [remoteUrl]/[branchName] // 为当前分支建立追踪关系，追踪为[remoteUrl]/[branchName]git branch --unset-upstream // 撤销本地分支与远程分支的追踪关系 git merge用于将两个或两个以上的开发历史加入一起git merge [branchName] // 合并branchName分支到当前分支的顶部git merge -s ours [branchName] // 合并branchName分支到当前分支,并使用ours合并策略（该参数将强迫冲突发生时，自动使用当前分支的版本）git merge -s theies [branchName] // 同上，但该参数将强迫冲突发生时，自动使用被合并分支的版本 git rebase如在 dev 分支上执行：git rebase master作用：该命令会把你的”dev”分支里的每个提交(commit)取消掉，并且把它们临时保存为补丁(patch)(这些补丁放到”.git/rebase”目录中),然后把最新的“master”代码合并到“dev”分支，最后把之前临时保存的这些补丁应用到”dev”分支上。git describe // 显示离当前提交最近的标签 需求（开发分支 dev 远程分支 remoteDev）git checkout devGit rebase remoteDev// 如果有冲突，解决冲突—循环git add .git rebase --continuegit rebase --abort // 在过程中可以终止rebase，恢复到rebase开始前的状态。git rebase 与 git merge 合并多次commitMessage（由于自己的分支）12345// 例如将最近的5次commitMessage合并到倒数第6次（倒数第6次commitId为sha1）git rebase -i sha1// 后面进行交互式处理一般把需要保留的前面留p（pick），需要合并到前面的改为s（squash），注意一定要保证第一个为p后面还会确认commitMessage git log用于显示提交日志信息git log -1 // 查看最近一条commit记录git log -n // 最近n次提交git log --oneline // 单行显示日志git log --pretty=oneline // 查看以前提交记录git log --no-merges // 显示整个提交历史记录，但跳过合并git log [dirName]/[fileName] // 查看当前分支dirName目录下fileName文件的提交日志git log --since=”2 weeks ago” -- [fileName] // 显示最近两周fileName文件的提交日志git log --name-status [branchName1]..[branchName2] // 显示branchName2分支尚未在branchName1分支中的提交git log --follow [fileName] // 显示fileName文件的更改信息，包括更名之前的提交git log --branches // 显示所有分支的提交git log --branches --not --remotes=origin // 显示所有分支的提交（但不包括本地追踪远程分支origin）git log [remoteUrl]/[branchName] // 查看远端某分支的日志git log [commitId] // 查看对应commitId的提交git log --author=[userName] // 查看属于userName提交的记录git log -p // 查看提交历史并显示每次提交的内容差异git log -p -2 // 最近两条git log --stat // 每次提交的简略的统计git log --pretty=[args] // 参数为 oneline：一行显示，还有short，full ，fuller git shortlog用于汇总git日志输出（commit次数+提交注释）git shortlog -s // 汇总每位开发者commit次数git shortlog -n // commit次数排名 git diff工作目录(Working tree)和暂存区域快照(index)之间的差异git diff [fileName] // 比较当前文件和暂存区文件差异git diff [commitId1] [commitId2] // 比较两次提交之间的差异git diff [branch1] [branch2] // 比较两个分支之间的差异git diff --staged // 比较暂存区和版本库差异git diff --cached // 比较暂存区和版本库差异（git add后尚未git commit）git diff --stat // 仅仅比较统计信息git diff HEAD // 自上次提交以来工作树中的更改git diff [branchName] // 查看工作目录和某分支的差异git diff HEAD^ HEAD // 比较上次提交和上上次提交git diff // 查看未暂存的修改git diff --cached // --staged 查看已暂存的修改 git rm &amp;&amp; git mv用于从工作区和索引中删除文件（git rm 删除文件可以被git记录下来，rm只是物理删除）git rm --cached [fileName] // 只是从暂存区中删除文件索引git rm [fileName] // 工作区和暂存区同时删除文件PS：其他参数-f为--force -r为递归处理该目录下的所有文件用于移动或重命名文件git mv [fileName] [dirName] // 将文件[fileName]移动到目录[dirName]中去git mv [oldFileName] [newFileName] // 重命名 git reset作用是修改HEAD的位置，即将HEAD指向的位置改变为之前存在的某个版本（这个版本之后的commit都将消失）【2018-12-18更新】git reset HEAD [fileName] // 撤销已经git add到暂存区的指定文件的操作（原理是重新取最后一次commit的内容）git reset HEAD // 撤销已经git add到暂存区的操作git reset HEAD~1 // 重置到上次commitgit reset [commitId] // 重置到commitIdgit reset --soft [commitId] // HEAD回退到commitId，暂存区和工作区不变git reset --mixed [commitId] // HEAD回退到commitId，暂存区改变，工作区不变（默认方式）git reset --hard [commitId] // HEAD回退到commitId，暂存区和工作区都将改变（非常危险）git reset soft,hard,mixed之区别深解 git revert作用通过反做创建一个新的版本，这个版本的内容与我们要回退到的目标版本一样，但是HEAD指针是指向这个新生成的版本，而不是目标版本。适用场景： 如果我们想恢复之前的某一版本（该版本不是merge类型），但是又想保留该目标版本后面的版本，记录下这整个版本变动流程，就可以用这种方法。Git恢复之前版本的两种方法reset、revert（图文详解）【2018-12-18更新】 git remotegit remote rename [shortOldName] [shortNewName]// 修改一个远程仓库的简写名（引用）git remote rm [shortname] // 移除一个源git remote show [remoteName] // 查看某一个远程仓库的更多信息git remote // 查看远程仓库（origin代表你本地clone的远程地址）git remote -v // 查看远程仓库（带fetch、push地址）git remote add [shortName] [url] // 添加远程仓库（shortname为以后的引用名）git remote set-url [shortOldName] [url] // 修改源[shortOldName]的地址git remote // 管理一组跟踪的存储库git remote // 查询当前库的远程库git remote -v // （--verbose）查看库的远程fetch和push地址（前提是有对应权限）git remote add [shortName] [remoteUrl] // 添加远程仓库[shortName]为其简短引用 git stash适用于在处理需要较长时间的任务task1时又有紧急任务task2需要处理，可以通过git stash来保存本次的修改并将工作目录恢复到HEAD提交，等完成紧急任务task2后又继续之前的任务task1git stash // 将当前任务存储起来（保存本地修改，并恢复工作目录以匹配HEAD提交）git stash list // 查看已存储的任务列表git stash apply stash@{2} // 应用已存储的任务列表的第2+1条git stash drop stash@{2} // 从已存储的任务列表移除第2+1条git stash pop // 取出已保存的最近任务（git stash apply + git stash drop）PS：适用于在处理需要较长时间的任务时，有紧急任务需要处理在其他分支处理 git tag用于创建，列出，删除或验证使用GPG签名的标签对象git tag // 列出所有标签git tag -a [tagName] -m [options] HEAD // 为当前HEAD创建标签git tag -a [tagName] -m [options] [commitID] // 为某个commitID创建标签git tag -l // 查看所有标签git tag -d [tagName] // 删除某个标签git tag -l ‘关键字’ // 列出满足关键字的标签git tag -v [tagName] // 查询tagName是否已经使用git tag [tagName] // 创建轻量级标签（轻量级标签实际上就是一个保存着对应提交对象的校验和信息的文件，其实就是不带-a，-s 或 -m）git tag -a [tagName] -m [说明] // 创建一个带说明的标签名为tagName的标签git tag -a [tagName] [commitId] // 为某个commitId创建tagNamePS：实质tag保存在.git/refs/tags中 git submodule用于初始化或更新或检查子模块场景：基于公司的项目会越来越多，常常需要提取一个公共的类库提供给多个项目使用，下面介绍下基本使用步骤克隆含有子模块的项目git clone [remoteUrl] // clone 主项目git submodule init // 初始化本地配置文件git submodule update // clone相关的子模块或者git clone --recursive [remoteUrl] // 先clone主项目，再递归clone子模块为项目添加子项目git submodule add [remoteUrl] // 添加子模块，[remoteUrl]为子模块远程地址删除某个子项目git rm --cached [subModuleName]rm -rf [subModuleName]rm .gitmodulesvim .git/configgit commit -a -m ‘remove [subModuleName] submodule’git submodule命令 git show用于显示各种类型的对象git show [tagName] // 查看相应标签的版本信息git show [tagName]^{tree} // 显示标签[tagName]指向的树git show -s --format=%s [tagName]^{commit} // 显示标签[tagName]指向的提交主题git show next~10:Documentation/README //git show [commitId] // 查看某次提交的内容 patchgit format-patch // 创建最新提交的修补程序git format-patch [commitId] // 为指定[commitId]创建补丁git apply [补丁标记id] // 使用补丁修改本地文件而不创建提交git am [补丁标记id] // 使用补丁修改本地文件并创建提交 git config用于获取并设置存储库或全局选项git config --list // 查看所有的git配置git config [key] // 查看特定项配置 重置分支git branch -D [branchName] // 删除本地分支git push [远程主机名] -d [远程分支名] // 删除远程分支git fetch [远程主机名] master:[本地分支名] // 以远程的master作为本地的[本地分支名]git push [远程主机名] [本地分支名] // 将本地分支推送到远端git branch --set-upstream-to [远程主机名]/[远程分支名]git checkout -b [localBranchName] [upstream]/[remoteBranchName] .gitignore文件常用操作git update-index –assume-unchanged -path 可以忽略文件git update-index –no-assume-unchanged –path 可以取消忽略文件 查端口所用PID，并kill【2019-02-01更新】maclsof -i:port号 // 查端口所用PIDkill PID // 杀掉进程 windownetstat -aon | findstr port号 // 查端口所用PIDtasklist | findstr PID // 根据PID查进程taskkill /pid PID -t -f // 杀掉进程 其他git init // 创建一个空的Git仓库或重新初始化一个现有仓库git reflog // 查看所有分支的所有操作记录（包括commit和reset的操作）git cherry-pick [commitHash] // 把某个分支的commit作为一个新的commit引入到你当前分支上git help // 查看帮助列表git help [key] // 查看特定[key]相关帮助git mergetool // 用于运行合并冲突解决工具来解决合并冲突git blame [file] // 用来定位每一行代码的最后一次修改者ifconfig // 查看ip地址等信息ipconfig // 查看ip地址（window） Git 异常处理清单更新于[2020-06-08]1234567891011121314151617181920// 本地工作区文件恢复git checkout &lt;filename/dirname&gt;// 远程分支删除后，删除本地分支及关联git branch --set-upstream-to=origin/master mastergit push origin --delete feature/testgit branch --unset-upstream &lt;branchname&gt;// 修改分支名git branch -m &lt;oldbranch&gt; &lt;newbranch&gt;// 撤回提交git reset --soft [&lt;commit-id&gt;/HEAD~n&gt;] // 只撤销commitgit reset --mixed [&lt;commit-id&gt;/HEAD~n&gt;] // 撤销stage Index + commitgit reset --hard [&lt;commit-id&gt;/HEAD~n&gt;] // 撤销work Space + stage Index + commit // 撤销本地分支合并git revert &lt;commit-id&gt;// 时光机git reflog// 恢复误删的本地分支git checkout -b &lt;branch-name&gt; &lt;commit-id&gt;// 查看哪个分支有自己提交的 commit &lt;commit-id&gt;git branch --contains &lt;commit-id&gt; 一份值得收藏的 Git 异常处理清单 参考文档：配置tab快捷键补全Git撤销&amp;回滚操作Git Cheat Sheetgit-tips]]></content>
      <categories>
        <category>代码管理</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页劫持]]></title>
    <url>%2F2018%2F%E7%BD%91%E9%A1%B5%E5%8A%AB%E6%8C%81.html</url>
    <content type="text"><![CDATA[最近和朋友谈到网页劫持，之前对这个话题还不是很了解。但在我们访问网页是，突然就能被传送到不知所谓的页面，铺满各种“屠龙宝刀点击就送”、“充值XX元就可获得流量大礼包”之类的内容。就算不是页面跳转，网页也有可能被插入额外的广告，无论是去哪个网站都会有一个烦不胜烦的小窗无法消除。 劫持分类我们生活中常见的劫持有，DNS劫持（运营商作怪）、路由劫持、代理服务器劫持（这个好理解只提一下）、HTTP劫持、软件劫持。随后我将介绍这些劫持和如何预防这些劫持。 DNS劫持描述当用户输入URL直到网页显示，这个过程发生了以下事情，信息首先会通过浏览器发送，然后经路由中转，接着DNS将域名解析成IP，找到服务器后服务器会发送内容给用户，接着再由路由转发数据，最后浏览器将内容呈现给用户（视实际情况，这个过程中还可能存在更多关卡，比如说防火墙、代理服务器等）。由此可见，无论浏览器、路由、DNS、服务器等任一环节中出了叛徒，用户请求的网页就可能惨遭删改。 产生的缘由在用户输入URL后到专门的DNS服务器进行查询IP，后面的通信很多都依赖于这个IP地址，如果这个IP地址是错误的呢？为什么说DNS劫持又是运营商劫持呢？运营商目前竞争比较激烈，为了进一步推广业务，或者进行额外的创收，一些管理不严的二线运营商或者运营商的分部，就会在DNS解析上动歪脑筋了。 解决方案选择可靠的DNS服务器，例如奇虎360、诺顿、Comodo、百度、阿里、Google等企业，都有提供DNS解析服务，你也可以选择Open DNS这样的老牌免费DNS服务。还可以向运营商投诉，如果运营上不处理，可以直接向工信部投诉。 HTTP劫持描述DNS劫持一般会替换调整个网页（返回的IP地址不对哒嘛），与DNS劫持不同的是网页劫持往往只是在页面上添加一个小窗，但这小窗并不属于网页本身的广告，有时候无论你访问什么网页，这小窗都不会消失，甚是烦人。 产生的缘由HTTP劫持的原理就是在服务器和用户之间的信息传输之中添油加醋，这是由于信息没有被加密而造成的。用户请求了网站服务器，服务器返还网页给用户，在传输过程中就给了他人加料的机会。 解决方案将网页升级为HTTPS的连接是最有效的方法，使用HTTPS之后，在传输数据过程中，数据是加密的，在传输过程中就很难被篡改了。HTTPS不仅可以防止HTTP劫持，也能够较好地防止DNS劫持，这是由于HTTPS的安全是由SSL来保证的，需要正确的证书，连接才会成立。如果DNS把域名解析到了不对应的IP，是无法通过证书认证的，连接会被终止。 路由劫持在我们的发送request和接受response，都会经过路由，路由器其实也会进行网页劫持。例如小米路由器，就曾经做过劫持网页的事情。虽然性质不严重，没有张贴引人注目的广告，只是把404之类的页面替换成自家网页，但这总归是不对的。这个解决办法，只能购买靠谱和权威厂家的路由了。 软件劫持有的同学可能使用过一些软件来全局的清除广告，但是，这是通过全局流量管控来实现的，电脑所有的网络流量都会经由去广告软件之手，因此软件要进行网页劫持，也是轻而易举的事情。例如，著名的去广告软件AD safe，就干过劫持网页的事情。由此可见，使用三方去广告软件也不是很靠谱，还请读者自我分辨。]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[品算法图解]]></title>
    <url>%2F2018%2F%E5%93%81%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E6%9C%89%E6%84%9F.html</url>
    <content type="text"><![CDATA[常用的数据结构数组、链表、散列表、栈、队列、图、树 数组数组，在内存上必须给出连续的空间（一但内存空间不足时，需要将整个数组移位到另一块内存足够大的地方）。内存空间占用的少，因为链表还要保存下一个节点的内存地址。访问性：访问性好，数组内的数据可随机访问，因为其内存地址时连续的。操作性：操作性差，在数组中插入、删除元素，都会导致其后的元素整体移动（插入时向后移动、删除时向前移动）。扩展性：扩展性差，因为一个数组建立后所占用的空间大小就是固定的（大多数语言时这样的）。大O表示：读取 O(1)，插入 O(n)，删除 O(n) 链表链表，内存地址上可以是不连续的,每个链表的节点包括当前节点的值和下一个节点的内存地址(单向链表的一个,双向链表的话会有两个)。访问性：访问性差，链表不具备随机访问性，其每次访问都是从头开始访问。操作性：操作性好，只需要操作对应节点之前的内存地址为变更后的节点地址。扩展性：扩展性好，因为其内存不连续，只要还有剩余内存即可。大O表示：读取 O(n)，插入 O(1)，删除 O(1) 散列表散列表使用数组来存储数据，通过一个散列函数将其映射到数组不同位置。 避免hash冲突较低的填装因子（填装因子=散列表包含的元素数/位置总数）。良好的散列函数。使用数组链表处理冲突。大O表示：平均情况读取、插入、删除都为O(1)，最糟糕情况读取、插入、删除都为O(n) 图非加权图—广度优先搜索用于查找其最短路径。加权图（权重为正）—狄克斯特拉算法用于查找其最短路径。加权图（权重有负）—贝尔曼-福德算法用于查找其最短路径。 参考文档数组与链表的优缺点]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS的内存管理（垃圾回收）]]></title>
    <url>%2F2018%2FJS%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%89.html</url>
    <content type="text"><![CDATA[内存在JS这门语言中，变量分为两种类型：基本类型（Undefined、Null、Boolean、Number 和String）和引用类型（Object、Array、Function等）。对应存储内存又分为栈内存（Stack）和堆内存（Heap）。 栈内存作用：存储基本类型的变量和存储引用类型的变量内存地址。特点：这些基本类型在内存中分别占有固定大小的空间，他们的值保存在栈空间，我们通过按值来访问的。 堆内存作用：实际存储引用类型的变量的值（通过和栈内存中保存的内存地址关联起来）。特点：这种值的大小不固定（比如说一个Array的length是可以动态改变的，因此不知道其需要的内存大小），因此不能把它们保存到栈内存中。 内存泄漏定义当已经不需要某块内存时这块内存不能被垃圾回收机制及时处理（间歇的不定期的寻找到不再使用的变量），并释放掉它们所指向的内存。 常见的产生内存泄漏场景 在声明变量没有带var、let、const等，它将直接挂载到全局上（即在浏览器中的window对象上），window对象上的属性及方法不会被回收。 盲目使用闭包（在闭包中存在对外部变量的引用，所以不会回收外部变量） 移除DOM节点是，没有清除对应的事件处理函数 没有及时清理定时器（没有清理setTimeout、setInterval等，就不能回收定时器的依赖） 垃圾回收机制标记清除（常见）这是javascript中最常用的垃圾回收方式。当变量进入执行环境时，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境所引用变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量不需要访问这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。如何给对象添加标记？反转特殊位或者添加对象列表 【2018-11-22看见优秀的文章，比较好的说明了JS内存机制】标记清除算法将“不再使用的对象”定义为“无法达到的对象”。简单来说，就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。JavaScript 内存机制 引用计数（早起IE机制）另一种不太常见的垃圾回收策略是引用计数。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占的内存。PS：该方式不能处理循环引用。 排查内存泄漏通过控制面板 Performance 选中 Memory 查看 JS Heap（正常情况会有升有降）通过查看 Main 了解主线程在各个时间段执行了那些函数来进行排查（所以避免在开发中写过多的匿名函数，不然你将看到很多anonymous function）通过控制面板 Memory 选中 Heap snapshot 可以进行具体分析（快照有一个相互比较的功能，可能比较两个快照的差异）]]></content>
      <categories>
        <category>性能</category>
      </categories>
      <tags>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端话题]]></title>
    <url>%2F2018%2F%E5%89%8D%E7%AB%AF%E8%AF%9D%E9%A2%98.html</url>
    <content type="text"><![CDATA[记录一些比较有意思的话题。 new操作符的工作原理我们都知道 new 运算符是用来实例化一个类，从而在内存中分配一个实例对象。1234567let Person = function(name, age)&#123; this.name = name; this.age = age;&#125;Person.prototype.getAge = function()&#123; return this.age;&#125; PS：这里我先说明一下直接执行 Person 会返回 undefined，new Person(…) 会返回一个对象（即我们的this对象）。 调用构造函数实际上会经历以下4个步骤(1) 创建一个新对象(2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象即类的实例）(3) 执行构造函数中的代码（即为这个新对象添加属性）(4) 返回新对象如果不明白，请看前辈整理的文章 JavaScript内部属性[[Scope]]与作用域链的理解[[Scope]]属性每一个 function 声明时都会有一个内部属性 [[Scope]]，例如声明 foo 函数会创建一个 foo.[[Scope]] 属性12345678910111213141516var a = 1;function foo()&#123; ...&#125;// 当我们的 foo 函数创建时，它的作用域链中插入了一个全局对象GO（Global Object），包含全局所有定义的变量// 伪代码foo.[[Scope]] = &#123; GO: &#123; this: window , window: ... , document: ... , ...... a: undefined, // 预编译阶段还不知道a值是多少 foo: function()&#123;...&#125;, &#125;&#125; 执行环境在函数执行时，会创建一个叫做执行环境/执行上下文（execution context，下文均用EC表示）的内部对象（独一无二）。 执行环境有以下特点函数每次执行时的执行环境独一无二多次调用同一函数就多次创建执行环境并且函数执行完毕后，执行环境就会被销毁12345678910111213141516171819202122// foo函数执行前，创建了执行期上下文（EC）// 首先取得foo内部[[Scope]]属性保存的作用域链（复制）到 EC 的底部// 然后foo函数执行前预编译产生了一个活动对象AO（Active Object），这个对象被推入EC作用域链的最前端// 伪代码：foo函数预编译产生AO活动对象，挂载到foo中EC作用域链的最前端foo.EC = &#123; AO: &#123; this: window, arguments: [100,200], x: 100, y: 200, b: undefined, bar: function()&#123;...&#125; &#125;, GO: &#123; this: window , window: ... , document: ... , a: 1, foo: function()&#123;...&#125;, ...... &#125;&#125; 案列分析这里我们来看一个稍微复杂一点的场景12345678910var a = 1;function foo(x, y)&#123; var b = 2; function bar()&#123; var c = 3; // console.log(a); &#125; bar();&#125;foo(100, 200); foo函数在预编译阶段创建了bar函数，于是bar函数创建了属性[[Scope]]，包含bar被创建的作用域中对象的集合，也就是复制了foo.EC所以我们可以得到1234567891011121314151617181920// 伪代码：bar函数创建产生[[Scope]]对象// bar.[[Scope]] = foo.ECbar.[[Scope]] = &#123; AO: &#123; this: window, arguments: [100,200], x: 100, y: 200, b: undefined, bar: function()&#123;...&#125; &#125;, GO: &#123; this: window , window: ... , document: ... , a: 1, foo: function()&#123;...&#125;, ...... &#125;&#125; PS：由于bar函数是在foo函数执行时创建的，所以bar[[Scope]]=foo.ECbar函数执行，过程同foo函数执行相近，整理出 bar.EC1234567891011121314151617181920212223bar.EC = &#123; AO: &#123; // bar 产生的 AO this: window, arguments: [], c: undefined, &#125;, AO: &#123; // foo 产生的 EC this: window, arguments: [100,200], x: 100, y: 200, b: 2, bar: function()&#123;...&#125; &#125;, GO: &#123; // foo 的 [[Scope]] this: window , window: ... , document: ... , a: 1, foo: function()&#123;...&#125;, ...... &#125;&#125; 作用域链js引擎就是通过作用域链的规则来进行变量查找（准确的说应该是执行上下文的作用域链）查找过程就拿上面的代码来说，比如说我在bar函数执行console.log(a);那么bar函数执行时，js引擎想要打印a，于是就去作用域链上查找第一层AO没有（bar运行时产生的）第二层AO没有（foo运行时产生的）第三层GO找到了变量a （foo定义是a为undefined，预编译时a被赋值为1）于是返回了变量a的值如果在bar函数中在创建一个der函数，der的EC又会是怎么样呢？读者自行脑补吧（大体思路类似）[[Scope]]与作用域链 defer和async四种组合关系&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。 &lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;有 async，加载和渲染后续文档元素的过程将和 script.js 的加载并行进行，且并立即执行。 &lt;script defer src=&quot;script.js&quot;&gt;&lt;/script&gt;有 defer，加载和渲染后续文档元素的过程将和 script.js 的加载并行进行，但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。 &lt;script defer async src=&quot;script.js&quot;&gt;&lt;/script&gt;同时存在时，async生效。 defer和async 共同点defer 和 async 在内联脚本无作用。在下载时和与HTML解析异步的，执行时阻塞HTML解析（包括没有defer 和 async属性的场景）。 defer和async的区别async异步下载后立即执行（可能不按下载顺序执行，适用于无任何依赖的脚本）。defer异步下载后等文档完成解析后，触发 DOMContentLoaded 事件前执行（安下载顺序执行，适用于有依赖关系的脚本）。PS：CSS并行下载，JS串行下载，相对于HTML解析来说。defer和async的区别 PWA具体功能可以添加至主屏幕实现离线缓存功能实现了消息推送 相关技术App ManifestService WorkerPush &amp;&amp; Notification（push: server 将更新的信息传递给 SW notification: SW 将更新的信息推送给用户）讲讲PWA jsEvent Loop机制在JavaScript中，任务被分为Task（又称为MacroTask,宏任务）和MicroTask（微任务）两种。 MicroTaskprocess.nextTick（node独有）, Promises, Object.observe(废弃), MutationObserver MacroTaskscript(同步代码), setTimeout, setInterval, setImmediate（node独有）, I/O, UI rendering 执行顺序script(同步代码) -&gt; MicroTask -&gt; MacroTask在执行上面代码时有产生了一些 MicroTask 和 MacroTask 会挂起，在一下次Event Loop再触发，以此类推。可以看看我之前的博客 通用 curry 实现1234567891011121314151617181920212223242526//柯里函数实质：传递给函数一部分参数来调用它，让它返回一个函数来处理剩余参数function curry(fx) &#123; //要进行柯里化的函数的形参数量 let arity = fx.length; return function f1() &#123; //第一次传入的参数数量 let args = Array.from(arguments); //若传入的参数数量大于等于形参数量 if (args.length &gt;= arity) &#123; return fx.apply(null,args) &#125;else&#123; let f2 = function() &#123; //如果只传入了一部分参数 let args2 = Array.from(arguments) //判断是否所有参数都传完了，如果没有，不断concat新传的参数，然后执行f1函数 return f1.apply(null, args.concat(args2)) &#125; return f2 &#125; &#125;&#125; let add = (num1, num2, num3)=&gt; num1 + num2 + num3;console.log(curry(add)(1)(2)(3)) // 6 curry实现 通用的 compose 的实现12345678910111213141516let compose = function(...args) &#123; var len = args.length, count = len - 1, result; return function f1(...args1) &#123; result = args[count].apply(this, args1); if (count &lt;= 0) &#123; count = len - 1; return result; &#125; else &#123; count--; return f1.call(null, result); &#125; &#125;&#125; 关于javascript函数式编程中compose的实现 参考文档：详解Javascript中new()到底做了些什么？]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-基础知识]]></title>
    <url>%2F2018%2Fvue-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html</url>
    <content type="text"><![CDATA[vue双向绑定原理单向与双向Model&gt;View（单向）Model&lt;&gt;View（单向） 双向的原理通过数据劫持和发布者-订阅者模式的方式来实现。 数据劫持主要通过 Object.defineProperty(obj, prop, descriptor) 的set和get方法执行对应的改变视图的方法。 new Proxy(target, handler) 来实现数据劫持。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS常用设计模式总结]]></title>
    <url>%2F2017%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[写在前面设计模式，是一套经过前人总结、业务验证并适合于特定业务开发的代码组织方式，可能会有一些同学会认为设计模式没有用，我这里需要指出设计模式并不是万能的只适合于特定业务场景的开发（对我们的业务开发起到一定的指导作用，所有设计模式的目的都是让开发者编写可维护、易扩展的代码），其实你日常开发中或多或少都使用过设计模式，只是你不知道名字而已（如，绑定事件和触发事件这就是一个简单的发布-订阅模式）。本文所有设计模式都是使用 JavaScript 语言书写，这些案例都是较为基础的，目的是帮助前端同学更好的理解设计模式。为了你更好的理解设计模式，你需要了解设计模式的六大原则：单一职责原则、开放封闭原则、里氏替换原则、依赖倒置原则、接口隔离原则、迪米特法则，可以看这篇设计模式六大原则。本文将同步发布于Blog、掘金、segmentfault、知乎等处，如果本文对你有帮助，记得为我得到我的个人技术博客项目给个star哦。 设计模式设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。 SOLID原则设计模式一般需要满足下列原则【2019-01-09更新】SOLID 是几个单词首字母组合而来，分别表示 单一功能原则、开闭原则、里氏替换原则、接口隔离原则以及依赖反转原则。单一功能原则：如果一个类干的事情太多太杂，会导致后期很难维护。我们应该厘清职责，各司其职减少相互之间依赖。开闭原则：“开”指的就是类、模块、函数都应该具有可扩展性，“闭”指的是它们不应该被修改。也就是说你可以新增功能但不能去修改源码。里氏替换原则：名字很唬人，其实道理很简单，就是子类不要去重写父类的方法。接口隔离原则：JavaScript 几乎没有接口的概念，所以这条原则很少被使用。官方定义是“客户端不应该依赖它不需要的接口”，也就是接口最小化，把接口解耦。依赖反转原则：高层次模块不能依赖低层次模块，它们依赖于抽象接口，抽象接口不能依赖具体实现，具体实现依赖抽象接口。总结下来就两个字，解耦。 工厂模式（Factory）定义：简单工厂模式是由一个方法来决定到底要创建哪个类的实例, 而这些实例通常都拥有相同的接口（属性和方法）。举例：计算器（加、减、乘、除）、自行车售卖（山地、公路）、饮料机（咖啡、牛奶、水）、RPG中职业（战士、法师、射手）需要详细了解该模式，请访问该链接 单例模式（Singleton）定义：单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。举例：：模态框、登录控件、注销控件需要详细了解该模式，请访问该链接 策略模式（Strategy）定义：策略模式包括两个部分，算法的使用部分（不变的）和算法的实现部分（可变的）。举例：表单效验（是否为空、长度、手机号、邮箱等等）、计算年终奖（工资、效绩）需要详细了解该模式，请访问该链接 代理模式（Proxy）定义：为一个对象提供一个代用品或占位符，以便控制对它的访问。代理对象和本体对象实现了同样的接口，并且会把任何方法调用传递给本体对象；举例： 图片预加载、图片懒加载、合并HTTP请求（代理收集一定时间内的所有HTTP请求，然后一次性发给服务器）、惰性加载（通过代理处理和收集一些基本操作，然后仅在真正需要本体的时候才加载本体）、缓存代理（缓存请求结果、计算结果）需要详细了解该模式，请访问该链接 中介者模式（Mediator）定义：中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者模式使网状的多对多关系变成了相对简单的一对多关系。举例：手机购买页面（颜色、数量、内存、价格）、MVC模式（控制层便是位于表现层与模型层之间的中介者）需要详细了解该模式，请访问该链接 装饰者模式（Decorator）定义：装饰者(decorator)模式能够在不改变对象自身的基础上，在程序运行期间给对象动态的添加职责。装饰者用于通过重载方法的形式添加新功能，该模式可以在被装饰者前面或者后面加上自己的行为以达到特定的目的。与继承相比，装饰者是一种更轻便灵活的做法。举例：雷霆战机（吃道具的例子）需要详细了解该模式，请访问该链接 发布订阅模式（Observer）定义：对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。举例：模块通信、事件绑定与触发、售楼中心需要详细了解该模式，请访问该链接 适配器模式（Adapter）定义：适配器模式（Adapter）是将一个类（对象）的接口（方法或属性）转化成客户希望的另外一个接口（方法或属性），适配器模式使得原本由于接口不兼容而不能一起工作的那些类（对象）可以一些工作。速成包装器（wrapper）。举例：常用于接口适配、兼容多个库（如Prototype库的$函数和YUI的get方法）需要详细了解该模式，请访问该链接 迭代器模式（Iterator）定义：迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。举例：jquery的$.each()、需要详细了解该模式，请访问该链接 桥接模式（Bridge）定义：桥接模式（Bridge）将抽象部分与它的实现部分分离，使它们都可以独立地变化。举例：用桥接模式联结多个类、事件监控需要详细了解该模式，请访问该链接 外观模式（Facade）定义：外观模式（Facade）为子系统中的一组接口提供了一个一致的界面，此模块定义了一个高层接口，这个接口使得这一子系统更加容易使用。举例：兼容浏览器事件绑定、兼容浏览器阻止冒泡、默认事件需要详细了解该模式，请访问该链接 访问者模式（Visitor）定义：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。举例：需要详细了解该模式，请访问该链接 模版方法模式定义：模版方法模式由二部分组成，第一部分是抽象父类，第二部分是具体实现的子类，一般的情况下是抽象父类封装了子类的算法框架，包括实现一些公共方法及封装子类中所有方法的执行顺序，子类可以继承这个父类，并且可以在子类中重写父类的方法，从而实现自己的业务逻辑。举例：泡饮品（茶 和 coffee）、公司面试（百度面试 和 阿里面试）需要详细了解该模式，请访问该链接 组合模式（Composite）定义：组合模式（Composite）将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象（子对象）和组合对象的使用具有一致性。举例：文件扫描（目录为组合对象和文件为子对象）、dom节点操作需要详细了解该模式，请访问该链接 备忘录模式（Memento）定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态。举例：分页控件、撤销组件需要详细了解该模式，请访问该链接 职责链模式（Chain of Responsibility）定义：职责链模式（Chain of responsibility）是使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。举例：挤公交车递钱（只有售票员可以收钱）、交押金预定手机需要详细了解该模式，请访问该链接 状态模式（State）定义：状态模式（State）定义一个对象，这个对象可以通过管理其状态从而使得应用程序作出相应的变化。状态模式是一个非常常用的设计模式，它主要有两个角色组成（环境类、状态类）。举例：文件下载（开始、暂停、完成、失败等）、红绿灯需要详细了解该模式，请访问该链接 享元模式（Flyweight）定义：享元模式是一种用于性能优化的模式，如果系统中因为创建了大量类似的对象而导致内存不足或占用过高这种模式就非常有用了（具体做法缓存对象从而达到重复利用）。举例：内衣厂展示许多商品展示、地图应用（对象池）需要详细了解该模式，请访问该链接]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web实验性知识]]></title>
    <url>%2F2018%2FWeb%E5%AE%9E%E9%AA%8C%E6%80%A7%E7%9F%A5%E8%AF%86.html</url>
    <content type="text"><![CDATA[伪类:placeholder-shown定义CSS 伪类在 input 或 textarea 元素显示 placeholder text 时生效。PS：可以配合 :not() 伪类等配合，优化表单。 伪:focus-within定义CSS 伪类，表示一个元素获得焦点或该元素的后代元素获得焦点。换句话说，元素自身或者它的某个后代匹配:focus伪类。神奇的选择器 :focus-within display:contents定义元素本身不产生任何边界框，而元素的子元素与伪元素仍然生成边界框，元素文字照常显示。为了同时照顾边界框与布局，处理这个元素时，要想象这个元素不在元素树型结构里，而只有内容留下。这包括元素在原文档中的子元素与伪元素，比如::before和::after这两个伪元素，如平常一样，前者仍然在元素子元素之前生成，后者在之后生成。MDN-placeholder-shown五个最新的CSS特性以及如何使用它们 contain定义contain 属性允许开发者声明当前元素和它的内容尽可能的独立于 DOM 树的其他部分。这使得浏览器在重新计算布局、样式、绘图或它们的组合的时候，只会影响到有限的 DOM 区域，而不是整个页面。MDN-contain]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>html,css,js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何形成一个完整的HTML对象]]></title>
    <url>%2F2018%2F%E5%A6%82%E4%BD%95%E5%BD%A2%E6%88%90%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84HTML%E5%AF%B9%E8%B1%A1.html</url>
    <content type="text"><![CDATA[写在前面，本文将同步发布于Blog、掘金、segmentfault、知乎等处，如果本文对你有帮助，记得为我得到我的个人技术博客项目给个star哦。 为何写这篇文章？你可能做Web开发已经有一段时间，你是否有想过下列问题呢？为什么div元素甚至是所有的html元素都可以使用addEventListener来添加事件呢？为什么每个DOM节点都有parentNode、firstChild、nodeType等属性呢？为什么每个DOM元素都有className、classList、innerHTML等属性呢？为什么有些DOM元素有accessKey、contentEditable、isContentEditable等属性呢？为什么每个DOM元素都有onclick、ondblclick、ondrag等属性？本文就是来解答这些简单而又不“简单”的问题。 Object你可以在浏览器中选择一个节点，然后在控制台中输入12$0.hasOwnProperty // ƒ hasOwnProperty() &#123; [native code] &#125; PS：$0表示当前选择的DOM元素。为什么我的一个元素会有对象的方法，追究其原因在设计HTML时，通过从各个接口继承不同的属性和方法。例如span元素继承关系：span -&gt; HTMLSpanElement -&gt; HTMLElement -&gt; Element -&gt; Node -&gt; EventTarget-&gt; Object[2018-08-16] EventTarget定义EventTarget 是一个由可以接收事件的对象实现的接口，并且可以为它们创建侦听器。 作用Element，document 和 window 是最常见的事件目标，但是其他对象也可以是事件目标，比如XMLHttpRequest，AudioNode，AudioContext 等等。许多事件目标（包括元素，文档和 window）还支持通过 onXXX（如onclick） 属性和属性设置事件处理程序。 该接口的方法EventTarget.addEventListener()在EventTarget上注册特定事件类型的事件处理程序。 EventTarget.removeEventListener()EventTarget中删除事件侦听器。 EventTarget.dispatchEvent()将事件分派到此EventTarget。 我们自己实现EventTarget123456789101112131415161718192021222324252627282930313233343536var EventTarget = function() &#123; this.listeners = &#123;&#125;;&#125;;EventTarget.prototype.listeners = null;EventTarget.prototype.addEventListener = function(type, callback) &#123; if (!(type in this.listeners)) &#123; this.listeners[type] = []; &#125; this.listeners[type].push(callback);&#125;;EventTarget.prototype.removeEventListener = function(type, callback) &#123; if (!(type in this.listeners)) &#123; return; &#125; var stack = this.listeners[type]; for (var i = 0, l = stack.length; i &lt; l; i++) &#123; if (stack[i] === callback)&#123; stack.splice(i, 1); return; &#125; &#125;&#125;;EventTarget.prototype.dispatchEvent = function(event) &#123; if (!(event.type in this.listeners)) &#123; return true; &#125; var stack = this.listeners[event.type].slice(); for (var i = 0, l = stack.length; i &lt; l; i++) &#123; stack[i].call(this, event); &#125; return !event.defaultPrevented;&#125;; Node定义Node是一个接口，许多DOM类型从这个接口继承，并允许类似地处理（或测试）这些各种类型。Node是一个接口，许多DOM类型从这个接口继承，并允许类似地处理（或测试）这些各种类型。 有那些接口重Node继承其方法和属性？Document, Element, CharacterData (which Text, Comment, and CDATASection inherit), ProcessingInstruction, DocumentFragment, DocumentType, Notation, Entity, EntityReferencePS：在方法和属性不相关的特定情况下，这些接口可能返回null。它们可能会抛出异常 - 例如，当将子节点添加到不允许子节点存在的节点时。 接口相关的属性和方法属性Node.baseURI返回一个表示base URL的DOMString。不同语言中的base URL的概念都不一样。 在HTML中，base URL表示协议和域名，以及一直到最后一个’/‘之前的文件目录。 Node.childNodes返回一个包含了该节点所有子节点的实时的NodeList。NodeList 是“实时的”意思是，如果该节点的子节点发生了变化，NodeList对象就会自动更新。 Node.firstChild返回该节点的第一个子节点，如果该节点没有子节点则返回null。 Node.lastChild返回该节点的最后一个子节点，如果该节点没有子节点则返回null。此处省略若干Node接口属性，更多属性查看这里。 方法——————–重点分割线——————-重点：从其父类EventTarget继承了addEventListener、removeEventListener、dispatchEvent等方法。 Node.appendChild()将一个节点添加到指定父节点的子节点列表末尾。 Node.contains()返回的是一个布尔值，来表示传入的节点是否为该节点的后代节点。 Node.cloneNode()返回调用该方法的节点的一个副本。此处省略若干Node接口方法，更多方法查看这里。 Element说明Element是非常通用的基类，所有 Document对象下的对象都继承它。这个接口描述了所有相同种类的元素所普遍具有的方法和属性。 这些继承自Element并且增加了一些额外功能的接口描述了具体的行为。PS：HTMLElement 接口是所有HTML元素的基础接口， 而 SVGElement 接口是所有SVG元素的基本接口。在web以外的语言，像 XUL 可以通过 XULElement 的API，也能实现它。 属性所有属性继承至它的祖先接口 Node, 和它所扩展的接口 EventTarget, 并且从以下部分继承了属性ParentNode, ChildNode, NonDocumentTypeChildNode, 和Animatable. Element.assignedSlot返回元素对应的 HTMLSlotElement 接口 Element.attributes返回一个与该元素相关的所有属性集合NamedNodeMap Element.classList返回该元素包含的class属性是一个DOMTokenList. Element.className它是一个 DOMString 表示这个元素的class.此处省略若干Element接口属性，更多方法查看这里。 方法——————–重点分割线——————-从它的父类（Node）和它父类的父类（EventTarget）继承方法，并实现parentNode、ChildNode、NonDocumentTypeChildNode、Animatable。此处省略若干Element接口方法，更多方法查看这里。 Element.closest()方法用来获取匹配特定选择器且离当前元素最近的祖先元素（也可以是当前元素本身）。如果匹配不到，则返回 null。 Element.getAttribute()返回元素上一个指定的属性值。如果指定的属性不存在，则返回 null 或 “” （空字符串）。 Element.getElementsByClassName()参数中给出类的列表，返回一个动态的 HTMLCollection ，这里面包含了所有持有这些类的后代元素。此处省略若干Element接口方法，更多方法查看这里。 HTMLElement作用HTMLElement 接口表示所有的 HTML 元素。一些HTML元素直接实现了HTMLElement接口，其它的间接实现HTMLElement接口。 属性——————–重点分割线——————-继承自父接口Element和 GlobalEventHandlers的属性。HTMLElement.accessKey DOMString 获取/设置元素访问的快捷键HTMLElement.accessKeyLabel DOMString 返回一个包含元素访问的快捷键的字符串（只读）HTMLElement.contentEditable DOMString 获取/设置元素的可编辑状态HTMLElement.isContentEditable Boolean 表明元素的内容是否可编辑（只读）此处省略若干HTMLElement接口属性，更多方法查看这里。 Event handlersHTMLElement.onTouchStartHTMLElement.onTouchEndHTMLElement.onTouchMoveHTMLElement.onTouchEnterHTMLElement.onTouchLeaveHTMLElement.onTouchCancel 方法HTMLElement.blur() void 元素失去焦点HTMLElement.click() void 触发元素的点击事件HTMLElement.focus() void 元素获得焦点HTMLElement.forceSpellCheck() void GlobalEventHandlers定义GlobalEventHandlers接口描述了事件处理程序像HTMLElement常见的几个接口,文件,窗口,或WorkerGlobalScope Web Workers。这些接口可以实现更多的事件处理程序。 属性GlobalEventHandlers.onabort中断事件。 GlobalEventHandlers.onblur失去焦点事件。 GlobalEventHandlers.onfocus获取焦点事件。此处省略若干GlobalEventHandlers接口属性，更多方法查看这里。 元素接口该接口用于创建对应的元素。如：HTMLDivElement 接口提供了一些特殊属性（它也继承了通常的 HTMLElement 接口）来操作div元素。HTMLFormElement接口可以创建或者修改对象;它继承了HTMLElement接口的方法和属性。HTMLAnchorElement 接口表示超链接元素，并提供一些特别的属性和方法（除了那些继承自普通 HTMLElement对象接口的之外）以用于操作这些元素的布局和显示。…… 回答前面问题通过上面的知识，我们了解到：HTMLDivElement（其他元素接口） 继承 HTMLElement 和 GlobalEventHandlers 接口。HTMLElement 继承 Element 接口。Element 继承 Node 接口。Node 继承 EventTarget 接口。为什么div元素甚至是所有的html元素都可以使用addEventListener来添加事件呢？回答：从 EventTarget 接口中继承而来。为什么每个DOM节点都有parentNode、firstChild、nodeType等属性呢？回答：从 Node 接口中继承而来。为什么每个DOM元素都有className、classList、innerHTML等属性呢？回答：从 Element 接口中继承而来。为什么有些DOM元素有accessKey、contentEditable、isContentEditable等属性呢？回答：从 HTMLElement 接口中继承而来。为什么每个DOM元素都有onclick、ondblclick、ondrag等属性？回答：从 GlobalEventHandlers 接口中继承而来。——————–重点分割线——————- 只有通过上面的继承关系，我们得到的 DOM 元素才是一个完整的 HTML 对象，我们才能为它设置/获取属性、绑定事件、添加样式类等操作。参考文档： EventTargetNodeElementHTMLElementGlobalEventHandlers]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己踩过的坑]]></title>
    <url>%2F2018%2F%E8%87%AA%E5%B7%B1%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91.html</url>
    <content type="text"><![CDATA[touchstart 和 click 的坑产生原因：1234var tap = &apos;ontouchstart&apos; in window ? &apos;touchstart&apos; : &apos;click&apos;;wrap.addEvenListener(tap, function()&#123; signUp();&#125;); 通过上面代码简单为用户设置事件类型，但我们忽略了‘联想触控笔记本’，由于该笔记本支持‘touchstart’事件，但当用户使用鼠标时却不能触发‘touchstart’事件，造成不能触发对应的事件处理函数。 有些 PC 设备屏幕为触摸屏，同时支持touchstart和click事件； 用户触发touchstart事件，默认必然会导致触发click事件，但是触发click事件，不一定会导致touchstart事件被触发； 此类设备外接鼠标时，通过上面的绑定方式，会绑定touchstart事件，但是鼠标操作只能触发click，导致touchstart不触发； 解决方案均使用click事件（移动端存在300ms延迟）通过UA判断设备是否为移动端，再确认事件类型1234function isMobile() &#123; return navigator.userAgent.match(/(blackberry|configuration\/cldc|hp |hp-|htc |htc_|htc-|iemobile|kindle|midp|mmp|motorola|mobile|nokia|opera mini|opera |Googlebot-Mobile|YahooSeeker\/M1A1-R2D2|android|iphone|ipod|mobi|palm|palmos|pocket|portalmmm|ppc;|smartphone|sonyericsson|sqh|spv|symbian|treo|up.browser|up.link|vodafone|windows ce|xda |xda_)/i) ? true : false;&#125; var tap = isMobile() ? &apos;touchstart&apos; : &apos;click&apos;; 全部使用click，通过FastClick解决300毫秒的延迟问题不再绑定的时候进行判断，而是对touchstart 和 click 同时绑定，但是在 touchstart 触发的时候暂停取消后续 click 的响应。具体实现： 在touchstart事件响应中调用preventDefault()方法，阻止后续click事件的触发（也会阻止多个事件绑定叠加和多人合作项目，导致以来 click 事件出现bug） 在touchstart事件中设置一些标记，或者取消click事件的绑定，使得click事件触发时不会触发我们绑定的逻辑，在一段时间（例如300-500ms）后再恢复 直接对事件处理函数进行节流（throttle），保证在一段时间内（300ms - 500ms），事件处理函数只触发一次 instanceofobject instanceof constructorinstanceof 运算符是用来在运行时指出对象是否是特定类的一个实例。instanceof 运算符用来测试一个对象的原型链中是否存在一个构造函数的 prototype 属性。 URL 构造函数 和 URLSearchParams 构造函数URLURL() 构造函数返回一个新创建的URL对象，表示由参数定义的URL。 实例属性URL 实例的属性与Location对象的属性基本一致，返回当前 URL 的信息。URL.href、URL.protocol等 静态方法URL.createObjectURL()URL.createObjectURL方法用来为上传/下载的文件、流媒体文件生成一个 URL 字符串。这个字符串代表了File对象或Blob对象的 URL。URL.revokeObjectURL()URL.revokeObjectURL方法用来释放URL.createObjectURL方法生成的 URL 实例。它的参数就是URL.createObjectURL方法返回的 URL 字符串。 URLSearchParamsURLSearchParams对象是浏览器的原生对象，用来构造、解析和处理 URL 的查询字符串（即 URL 问号后面的部分）。 方法URLSearchParams.append() 插入一个指定的键/值对作为新的搜索参数。URLSearchParams.delete() 从搜索参数列表里删除指定的搜索参数及其对应的值。URLSearchParams.entries() 返回一个iterator可以遍历所有键/值对的对象。URLSearchParams.get() 获取指定搜索参数的第一个值。URLSearchParams.getAll() 获取指定搜索参数的所有值，返回是一个数组。URLSearchParamsURL 对象，URLSearchParams 对象]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-基础知识整理]]></title>
    <url>%2F2018%2FReact-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86.html</url>
    <content type="text"><![CDATA[setState 一定是异步的吗？setState 只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是“同步”的。你真的理解setState吗？ FiberFiber 本质上是一个虚拟的堆栈帧，新的调度器会按照优先级自由调度这些帧，从而将之前的同步渲染改成了异步渲染，在不影响体验的情况下去分段计算更新。对于如何区别优先级，React 有自己的一套逻辑。对于动画这种实时性很高的东西，也就是 16 ms 必须渲染一次保证不卡顿的情况下，React 会每 16 ms（以内） 暂停一下更新，返回来继续渲染动画。对于异步渲染，现在渲染有两个阶段：reconciliation 和 commit 。前者过程是可以打断的，后者不能暂停，会一直更新界面直到完成。 Reconciliation 阶段componentWillMountcomponentWillReceiveProps（使用 getDerivedStateFromProps 代替）shouldComponentUpdatecomponentWillUpdate Commit 阶段componentDidMountcomponentDidUpdatecomponentWillUnmountreact 生命周期函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class ExampleComponent extends React.Component &#123; // 用于初始化 state constructor() &#123;&#125; // 用于替换 `componentWillReceiveProps` ，该函数会在初始化和 `update` 时被调用 // 因为该函数是静态函数，所以取不到 `this` // 如果需要对比 `prevProps` 需要单独在 `state` 中维护 static getDerivedStateFromProps(nextProps, prevState) &#123;&#125; // 判断是否需要更新组件，多用于组件性能优化 shouldComponentUpdate(nextProps, nextState) &#123;&#125; // 组件挂载后调用 // 可以在该函数中进行请求或者订阅 componentDidMount() &#123;&#125; // 用于获得最新的 DOM 数据 getSnapshotBeforeUpdate() &#123;&#125; // 组件即将销毁 // 可以在此处移除订阅，定时器等等 componentWillUnmount() &#123;&#125; // 组件销毁后调用 componentDidUnMount() &#123;&#125; // 组件更新后调用 componentDidUpdate() &#123;&#125; // 渲染组件函数 render() &#123;&#125; // 以下函数不建议使用 componentWillMount() &#123;&#125; componentWillUpdate(nextProps, nextState) &#123;&#125; componentWillReceiveProps(nextProps) &#123;&#125;&#125;``` ## 首次渲染触发的生命周期constructor()UNSAFE_componentWillMount()render()componentDidMount()## 非初次渲染触发的生命周期UNSAFE_componentWillReceiveProps(nextProps) shouldComponentUpdate(nextProps, nextState)UNSAFE_componentWillUpdate()render()componentDidUpdate()## 其他什么周期函数componentWillUnmount()static getDerivedStateFromProps(nextProps, prevState) // 代替 componentWillReceiveProps 在初始化和 update 时触发，由于时静态方法无 thisgetSnapshotBeforeUpdate(prevProps, prevState) // 此生命周期的返回值将作为第三个参数传递给componentDidUpdate。 （这个生命周期不是经常需要的，但可以用于在恢复期间手动保存滚动位置的情况。）与componentDidUpdate一起，这个新的生命周期将覆盖旧版componentWillUpdate的所有用例。# React16.0中的portal作用：将子节点插入到父节点之外的dom（render到一个组件里面去，实际改变的是网页上另一处的DOM结构。）。使用场景：Modal、Dialog、Message等全局提示组件比如写一个Dialog通用组件 import React from ‘react’;import {createPortal} from ‘react-dom’; class Dialog extends React.Component { constructor() { super(…arguments); const doc = window.document; this.node = doc.createElement(&apos;div&apos;); doc.body.appendChild(this.node); } render() { return createPortal( {this.props.children} , //塞进传送门的JSX this.node //传送门的另一端DOM node ); } componentWillUnmount() { window.document.body.removeChild(this.node); }}```React-DOM Portal React16新特性Error Boundary（错误边界）之前，一旦某个组件发生错误，整个组件树将会从根节点被unmount下来。Error Boundary可以看作是一种特殊的React组件，新增了componentDidCatch这个生命周期函数，它可以捕获自身及子树上的错误并对错误做优雅处理，包括上报错误日志、展示出错提示，而不是卸载整个组件树。（注：它并不能捕获runtime所有的错误，比如组件回调事件里的错误，可以把它想象成传统的try-catch语句）PS：最佳实践封装通用错误组件，用起包裹可能出错的组件，来捕获子组件可能发生的错误。 render方法新增返回类型render方法支持直接返回string，number，boolean，null，portal，以及fragments(带有key属性的数组)，这可以在一定程度上减少页面的DOM层级。 支持自定义DOM属性现在React可以将属性直接传递给DOM，不过有些写法任然无效。 setState传入null时不会再触发更新比如在一个选择城市的函数中，当点击某个城市时，newValue的值可能发生改变，也可能是点击了原来的城市，值没有变化，返回null则可以直接避免触发更新，不会引起重复渲染，不需要在shouldComponentUpdate函数里面去判断。十分钟快速了解React16新特性 React编码优化 使用 key 属性为列表项组件做身份标记 shouldComponentUpdate 决定组件是否render PureComponent 来定义组件 Stateless components 函数式组件 慎用bind，它会返回一个新的函数]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web性能优化]]></title>
    <url>%2F2018%2FWeb%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html</url>
    <content type="text"><![CDATA[页面渲染的4个关键指示First Paint（FP）仅有一个需要挂载的根节点。 First Contentful Paint（FCP）包含页面的基本框架，但没有数据内容。 First Meaningful（FMP）包含页面所有元素及数据。 Time to Interactive（TTI）允许交互时间。 预加载技术DNS prefetchDNS prefetching通过指定具体的URL来告知客户端未来会用到相关的资源，这样浏览器可以尽早的解析DNS。&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//example.com&quot;&gt; Preconnect和DNS prefetch类似，preconnect不光会解析DNS，还会建立TCP握手连接和TLS协议（如果需要）。&lt;link rel=&quot;preconnect&quot; href=&quot;http://css-tricks.com&quot;&gt; Prefetch当能确定网页在未来一定会使用到某个资源时，开发者可以让浏览器提前请求并且缓存好以供后续使用，prefetch支持预拉取图片、脚本或者任何可以被浏览器缓存的资源。&lt;link rel=&quot;prefetch&quot; href=&quot;image.png&quot;&gt;PS：可以解决字体文件必须等DOM和CSSOM创建好后才能下载的性能瓶颈。 Subresource可以用来指定资源是最高优先级的。&lt;link rel=&quot;subresource&quot; href=&quot;styles.css&quot;&gt;PS：rel=prefetch指定了下载后续页面用到资源的低优先级，而rel=subresource则是指定当前页面资源的提前加载。 Prerenderprerender是一个重量级的选项，它可以让浏览器提前加载指定页面的所有资源。一些适用场景用户搜索后的结果页面、登录成功后的页面、多页文章（预先加载下一页的资源）&lt;link rel=&quot;prerender&quot; href=&quot;/thenextpage.html&quot; /&gt;PS：该属性会下载所有的资源、创建DOM、渲染页面、执行JS这篇文章可以防止页面还没有展示给用户就出发JS的执行等等。 Preload允许始终预加载某些资源，不像prefetch有可能被浏览器忽略，浏览器必须请求preload标记的资源。&lt;link rel=&quot;preload&quot; href=&quot;image.png&quot;&gt;AlloyTeam-一箩筐的预加载技术 微任务（jobs）和宏任务（task）微任务包括：process.nextTick，原生Promise(有些实现的promise将then方法放到了宏任务中)，Object.observe(已废弃)，MutationObserver宏任务包括：script，setTimeout，setInterval，setImmediate，I/O ，UI rendering，MessageChannel 如何生成新图层（避免重排影响其他图层）通过以下几个常用属性可以生成新图层3D 变换：translate3d、translateZwill-changevideo、iframe 标签通过动画实现的 opacity 动画转换position: fixed React 16 加载性能优化React 16 加载性能优化指南 CSS性能优化技巧内联首屏关键CSS（Critical CSS）即为只将渲染首屏内容所需的关键CSS内联到HTML中。github-首屏的关键样式提取 异步加载CSS（四种方式）第一种方式是使用JavaScript动态创建样式表link元素，并插入到DOM中。第二种方式是将link元素的media属性设置为用户浏览器不匹配的媒体类型甚至不存在的类型都可以，对浏览器来说，如果样式表不适用于当前媒体类型，其优先级会被放低，会在不阻塞页面渲染的情况下再进行下载。` 第三种方式是通过rel属性将link元素标记为alternate可选样式表，也能实现浏览器异步加载。 第四中方式是rel=”preload”5这一Web标准指出了如何异步加载资源，包括CSS类资源。 `PS：第四中为标准方案，as 属性是必须的。 去除无用CSSgithub-去除无用CSS 有选择地使用选择器CSS选择器的匹配是从右向左进行的。 如何启用GPU硬件加速什么情况形成新的层 layer？（作用为重绘时只影响该层，不影响层外的元素。） 3D 或者 CSS的transform属性 video 和 canvas 元素 CSS的filter属性 覆盖在其它元素之上的元素，比如通过z-index提升层级 哪些属性直接在GPU处理？transformopacityfiltertransform: translateZ(0); // 可以强制GPU渲染 使用硬件加速需要注意的地方？MemoryGPU处理过多的内容会导致内存问题。这在移动端和移动端浏览器会导致崩溃。因此，通常不会对所有的元素使用硬件加速。 Font rendering在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。 浏览器的优化通常配合will-change属性使用1234.example &#123; transform: rotate(1turn); will-change: transform;&#125; PS：这个功能允许你告诉浏览器这个属性会发生变化，因此浏览器会在开始之前对其进行优化。在 CSS 动画中使用硬件加速]]></content>
      <categories>
        <category>性能</category>
      </categories>
      <tags>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊伪元素（::after和::before）、pointer-events属性、touch-action属性]]></title>
    <url>%2F2018%2F%E8%81%8A%E8%81%8A%E4%BC%AA%E5%85%83%E7%B4%A0%EF%BC%88-after%E5%92%8C-before%EF%BC%89%E5%92%8Cpointer-events%E5%B1%9E%E6%80%A7%E5%92%8Ctouch-action%E5%B1%9E%E6%80%A7.html</url>
    <content type="text"><![CDATA[伪元素（以::after举例）属性基础介绍定义：::after用来创建一个伪元素，做为已选中元素的最后一个子元素。通常会配合content属性来为该元素添加装饰内容。这个虚拟元素默认是行内元素。使用：CSS2.0为element:after{content: &#39;&#39;;...}；CSS3.0为element::after{content: &#39;&#39;;...}这些并不是我今天想讨论的，我们应该来看看伪元素的一些其他性质。 补充知识本文的重点：我们都知道我们不能为伪元素添加事件（目前是这样，不知道以后W3C会不会考虑），但是伪元素是可以触发元素本体上的事件。我认为伪元素的出现使我们在某种程度上可以精简DOM结构（伪元素可以达到补充、完善UI的目的），但是由于会触发元素本体上的事件，可能有些地方使用需要考虑一下了（在DOM简化的微小性能优化和是否适用于该场景中权衡一下）。PS：元素本体：为了文章的好理解，我自己起的名字，意思为某个元素除了虚拟元素（::after等）以外的部分。比如为了为了实现下图UI，用元素的 after伪类 实现登录和注册分割中的‘点.’，但这个 after伪类保留了 span标签 登录事件感觉有点不符合UI语义。 CSS之pointer-events属性我这里只讨论 pointer-events 的auto、none、inherit、initial、unset（不讨论SVG相关的属性值）。 属性基础介绍定义：指定在什么情况下 (如果有) 某个特定的图形元素可以成为鼠标事件的 target，也就是说通过设置该属性可以控制该元素是否为事件的target。对上面提到的属性值做下简单的介绍：auto： 与 pointer-events 属性未指定时的表现效果相同none： 元素永远不会成为鼠标事件的 target（不一定意味着元素上的事件侦听器永远不会触发，后面在做介绍）。inherit： 该关键字使得元素获取其父元素的计算值(computed value )，由于该属性为非继承属性 inherit 在这里指定的行为通常没有多大意义，一般使用使用 initial 或 unset 作为替代。initial： 相关标准都设置了每个元素的的初始值，pointer-events 属性的初始值为 auto 。unset： 关键字 unset 是 关键字 initial 和 inherit的组合（如果有继承父级样式，则将该属性重新设置为继承的值，如果没有继承父级样式，则将该属性重新设置为初始值）。 补充知识还记得我们刚刚讲到 pointer-events 的属性值为 none 时提到“不一定意味着元素上的事件侦听器永远不会触发，后面在做介绍”，这里开始做说明。 使用pointer-events来阻止元素成为鼠标事件目标不一定意味着元素上的事件侦听器永远不会触发。如果元素后代明确指定了pointer-events属性并允许其成为鼠标事件的目标，那么指向该元素的任何事件在事件传播过程中都将通过父元素，并以适当的方式触发其上的事件侦听器。当然，位于父元素但不在后代元素上的鼠标活动都不会被父元素和后代元素捕获（鼠标活动将会穿过父元素而指向位于其下面的元素）。 该属性提高页面滚动时候的绘制性能是不准确的为什么这么说呢？已经有前辈写过相应的文章，以及详细的测试数据pointer-events:none提高页面滚动时候的绘制性能？ 只能失效鼠标事件，并不能让键盘事件失效pointer-events 只能失效鼠标事件，并不能让键盘事件失效，所以用该属性对按钮的禁用需要小心大家可以看看张鑫旭前辈的文章。 CSS之touch-action属性属性基础介绍定义：用于指定某个给定的区域是否允许用户操作，以及如何响应用户操作（比如浏览器自带的划动、缩放等）。属性值介绍：auto： 当触控事件发生在元素上时，由浏览器来决定进行哪些操作，比如对viewport进行平滑、缩放等。none： 当触控事件发生在元素上时，不进行任何操作。pan-x： 启用单指水平平移手势。可以与 pan-y 、pan-up、pan-down、pinch-zoom 组合使用。pan-y： 启用单指垂直平移手势。可以与 pan-x 、pan-left 、pan-right、pinch-zoom 组合使用。manipulation： 浏览器只允许进行滚动和持续缩放操作。任何其它被auto值支持的行为不被支持。启用平移和缩小缩放手势，但禁用其他非标准手势，例如双击以进行缩放。 禁用双击可缩放功能可减少浏览器在用户点击屏幕时延迟生成点击事件的需要。pinch-zoom： 启用多手指平移和缩放页面。 这可以与任何平移值组合。 补充知识移动端300ms延迟，就可以使用 touch-action: manipulation;因为 manipulation 会禁用双击事件（浏览器就不需要等待300ms之后来判断了）。处理移动端点击延迟代码123html &#123; touch-action: manipulation;&#125; 实践应用 在地图或游戏开发中，最常见的用法是禁用元素（及其不可滚动的后代）上的所有手势，以使用自己提供的拖放和缩放行为。 123#map &#123; touch-action: none;&#125; 水平图像轮播开发中，只想通过水平滑动但不想干扰网页的垂直滚动或缩放，可用以下代码。 12345.image-carousel &#123; width: 100%; height: 150px; touch-action: pan-y pinch-zoom;&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP知识（前端相关）]]></title>
    <url>%2F2018%2Fhttp%E5%BD%92%E7%BA%B3.html</url>
    <content type="text"><![CDATA[安全（Safe）说一个HTTP方法是安全的，是说这是个不会修改服务器的数据的方法。也就是说，这是一个对服务器只读操作的方法。这些方法是安全的：GET，HEAD和OPTIONS。所有安全的方法都是idempotent（幂等），有些不安全的方法如PUT和DELETE则不是。PS：网络爬虫也是依赖于安全的HTTP方法，安全方法: GET, HEAD, OPTIONS；非安全方法: PUT, DELETE, POST。MDN-Safe 幂等（Idempotent）一个HTTP方法是幂等的，指的是同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态（不是返回的状态码而是数据）也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。在正确实现的条件下，GET，HEAD，PUT和DELETE 等方法都是幂等的，而 POST 方法不是。所有的 safe 方法也都是幂等的。 HTTP方法比较GETGET方法请求一个指定资源的表示形式，使用GET的请求应该只被用于获取数据。 HEADHEAD方法请求一个与GET请求的响应相同的响应，但没有响应体（也就是说只存在响应头无响应体）。PS：该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源。 POSTPOST方法用于将实体提交到指定的资源，通常导致状态或服务器上的副作用的更改。 PUT请求方法 PUT 用于新增资源或者使用请求中的有效负载替换目标资源的表现形式。PS：PUT 与 POST 方法的区别在于，PUT方法是幂等的。 DELETEDELETE 请求方法用于删除指定的资源。 CONNECTCONNECT 方法可以开启一个客户端与所请求资源之间的双向沟通的通道。它可以用来创建隧道（tunnel）。 OPTIONSOPTIONS 方法 用于获取目的资源所支持的通信选项。在 CORS 作为预检请求。 TRACETRACE 方法 实行了向目标资源的沿路径的消息环回(loop-back)测试 ，提供了一种实用的debug机制。 PATCH请求方法 PATCH 用于对资源进行部分修改。PS：在HTTP协议中， PUT 方法已经被用来表示对资源进行整体覆盖， 而 POST 方法则没有对标准的补丁格式的提供支持。不同于 PUT 方法，而与 POST 方法类似，PATCH 方法是非幂等的，这就意味着连续多个的相同请求会产生不同的效果。 浏览器缓存强缓存Cache-Control（请求头和响应头）通用消息头被用于在http 请求和响应中通过指定指令来实现缓存机制。max-age：指定设置缓存最大的有效时间（单位为s）。s-maxage：覆盖max-age 或者 Expires 头，但是仅适用于共享缓存(比如各个代理CDN)，并且私有缓存中它被忽略。public：表明响应可以被接收的客户端、代理服务器等缓存。private：表明响应只能被客户端缓存，不能作为共享缓存（即代理服务器不能缓存它）。no-cache：在释放缓存副本之前，强制高速缓存将请求提交给原始服务器进行验证。no-store：缓存不应存储有关客户端请求或服务器响应的任何内容。 Expires（响应头）响应头包含日期/时间， 即在此时候之后，响应过期。PS：如果在Cache-Control响应头设置了 “max-age” 或者 “s-max-age” 指令，那么 Expires 头会被忽略。 协商缓存Last-modified（响应头）它包含源头服务器认定的资源做出修改的日期及时间。工作原理：浏览器首次请求资源是响应头中包含 Last-modified 字段，当再次请求时将上次 Last-modified 的值赋值给 If-Modified-Since 请求头，服务器根据对应资源的修改时间于 If-Modified-Since 的值进行比较，从而断定该资源是否被修改再响应304或200。 ETag（响应头）工作原理：和 Last-modified（If-Modified-Since）工作原理基本一致，只不过服务器判断资源是否被更改的条件不是文件修改时间而是为资源生产的hash值是否发生变化。PS：可以弥补 max-age 和 Last-modified 只能精确到秒的缺陷。alloyteam-浅谈Web缓存]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[懂这些，你将能构建更安全的Web应用]]></title>
    <url>%2F2018%2Fweb%E5%AE%89%E5%85%A8.html</url>
    <content type="text"><![CDATA[浏览器安全同源策略（Same Origin Policy）同源策略限制了一个源（origin）中加载的文档或脚本与其他源（origin）中的资源交互的方式。这是一种用来隔离潜在恶意文档的关键安全机制。源的定义：如果两个页面的协议、域名、端口（如果有指定）和都相同，则两个页面具有相同的源。 浏览器沙箱Sandbox 和 多线程架构浏览器为我们提供了一个独立的沙箱环境，尽量来保障浏览器的安全，也有部分浏览器采用一个 tab 页面一个线程，这样多线程架构增强了浏览器的安全（即使某个线程崩溃了，也不至于浏览器崩溃）。 恶意网址拦截（大多基于黑名单）常见的黑名单获取：PhishTank恶意网址黑名单、Google 的SafeBrowsing API、EVSSL证书 更安全的浏览器进化IE8 的 XSS Filter功能Firefox 的 CSP（Content Security Policy） XSS（跨站脚本攻击Cross Site Script）定义XSS攻击全称跨站脚本攻击，是为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS，XSS是一种在web应用中的计算机安全漏洞，它允许恶意 Web 用户将代码植入到提供给其它用户使用的页面中。XSS分为三种类型：1.反射型XSS 2.存储型XSS 3.DOM Based XSS（通过修改页面的DOM节点形成的XSS） 危害Cookie劫持（一般Cookie作为登录凭证，通过HttpOnly可以防止）、构造GET与POST请求、XSS钓鱼、识别用户浏览器、CSS HIstory Hack（访问过的连接会使用:visited的样式）、获取用户的真实IP地址（前提如用户安装了Java环境JRE等）、XSS Worm 解决方案CSP(Content Security Policy)、对特殊字符转义，不要相信任何来自用户的输入（包括请求体、queryString甚至是请求Headers） 响应头 HttpOnly 有效保护 Cookie XSS Filter输入检查 排除、转义特殊字符 输出检查 安全的编码函数 HtmlEncode （将特殊字符转换为实体字符） 只需一种编码吗 浏览器解析 htmlparser 优先于 JavaScript Parser 对于处理富文本开发： 我们应该让事件被严格禁止，不包含iframe、script、base、form等危险标签。 使用白名单，避免使用黑名单。 OWASP 开源的 XSS Filter 项目（Antisamy–Java 和 .NET）（HTML Purifier–PHP） XSS漏洞的原理 CSRF（跨站点脚本Cross-site request forgery）原理是指在黑客已经将代码植入受害用户的浏览器访问的页面的前提下，以“受害用户”的身份向服务端发起一个伪造的http请求，从而实现服务器 CRUD 来执行读写操作。 解决方案验证码，我们应该使用验证码作为防御 CSRF 的辅助手段，而不应该作为最主要的解决方案（毕竟不可能所有操作都加上验证码，多次验证码不利于用户体验）。Referer Check ，常见应用为防止图片盗链，直白的讲就是后端需要检查请求头中的 Referer 字段，是否为我们期望的”源”。Anti CSRF Token，需要保证使用足够安全的随机数生产算法或真随机数生成器，只有用户和服务器共同持有，才能保证安全。PS：Referer 首部包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。CSRF漏洞的原理 clickjacking（点击劫持）原理点击劫持其实是一种视觉上的欺骗手段，攻击者将一个透明的、不可见的iframe覆盖在一个网页上，通过调整iframe页面位置，诱使用户在页面上进行操作，在不知情的情况下用户的点击恰好是点击在iframe页面的一些功能按钮上，其实还也可使用 img 来代替 iframe，这就是后面要说的 XSIO。HTML5的Drag 和 Drop API会发生数据窃取，分别在 Drag 隐藏一个 iframe ，在 Drop 中 隐藏一个 textarea ，在 drop 事件时就可以获取来自 drag 的数据，从而形成数据劫持，event.dataTransfer.getData() 防御frame busting：禁止iframe的嵌套JS防止潜入X-Frame-Options：防止或限制网页内嵌（http头部X-FRAME-OPTIONS）CSP的frame-ancestors：指定了一个可以包含frame，iframe，object，embed，or applet等元素的有效来源。PS：http头部X-FRAME-OPTIONS为非标准的（但所有浏览器都支持），你可以使用CSP的frame-ancestors（标准属性）。同样还有触屏劫持（TapJacking）实现原理基本类似。ClickJacking漏洞的原理 window.name 的妙用window.name 属性可设置或返回存放窗口的名称的一个字符串。因为 window 对象是浏览器的窗体，并非 document 对象，因此许多时候 window 对象不受同源策略的限制。可以利用该属性实现跨域、跨页面传递数据可以使用postMessage来进行跨源通信。 XSIO原理：没有限制图片的position属性为absolute，导致可以控制一张图片出现在网页的任意位置。百度的XSIO iframe 的 sandbox 属性可以防止以下操作： 访问父页面的DOM（从技术角度来说，这是因为相对于父页面iframe已经成为不同的源了） 执行脚本 通过脚本嵌入自己的表单或操作表单 对cookie、本地存储Storage、本地数据库IndexDB的读写 PS：sandbox 属性有 allow-same-origin（允许同源访问）、allow-top-navigation（允许访问顶层窗口）、allow-forms（允许提交表单）、allow-script（允许执行脚本） a标签 和 area标签的安全问题当a链接有target=”_blank”属性时，必须添加rel=”noreferrer noopener”，不然新产生的页面可以通过window.opener来获取到父窗口的window对象。&lt;a href=&quot;www.baidu.com&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot; &gt; CSP (内容安全策略)内容安全策略 (CSP, Content Security Policy) 是一个附加的安全层，用于帮助检测和缓解某些类型的攻击，包括跨站脚本 (XSS) 和数据注入等攻击。 这些攻击可用于实现从数据窃取到网站破坏或作为恶意软件分发版本等用途。其实CSP的本质是以白名单的机制对网站加载或执行的资源起作用。 适用方式 可以通过配置你的网络服务器返回 Content-Security-Policy HTTP头部 ( 有时你会看到一些关于X-Content-Security-Policy头部，它是旧版本)。 在html页面中meta元素中使用，如下1&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &apos;self&apos;; img-src https://*; child-src &apos;none&apos;;&quot;&gt; 隐私与:visited选择器为什么说:visited选择器暴露了用户隐私？曾经，CSS选择器 :visited 被网站用来查看用户的浏览记录。通过使用 getComputedStyle() 或其他方法扫描用户的浏览记录来获取用户访问了哪些网站。这很容易实现，不仅能够判断用户是否曾经访问过这个页面，还能猜测出大量的用户身份信息。不过现代浏览器已经做了相应的修复和只能给已访问链接设置少量的样式（color、background-color、border-color、outline-color、fill 和 stroke 等） 跨域资源共享（CORS）CORS属于HTTP访问控制特性，以下内容大多针对于XMLHttpRequest，有些并不适用于 Fetch 。当一个资源从与该资源本身所在的服务器不同的域或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。比如，站点 http://domain-a.com 的某 HTML 页面通过 img 的 src 请求 http://domain-b.com/image.jpg。网络上的许多页面都会加载来自不同域的CSS样式表，图像和脚本等资源。出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求或者返回结果被浏览器拦截了。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非使用CORS头文件。PS：跨域并非不一定是浏览器限制了发起跨站请求，也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。最好的例子是 CSRF 跨站攻击原理，请求是发送到了后端服务器无论是否跨域！注意：有些浏览器不允许从 HTTPS 的域跨域访问 HTTP，比如 Chrome 和 Firefox，这些浏览器在请求还未发出的时候就会拦截请求，这是一个特例。）跨域资源共享（ CORS ）机制允许 Web 应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。浏览器支持在 API 容器中（例如 XMLHttpRequest 或 Fetch ）使用 CORS，以降低跨域 HTTP 请求所带来的风险。 X-Frame-Options 响应头X-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面可否在 frame（已废弃）, iframe 或者 object 中展现的标记。网站可以使用此功能，来确保自己网站的内容没有被嵌到别人的网站中去，也从而避免了点击劫持 (clickjacking) 的攻击。 使用 X-Frame-OptionsX-Frame-Options 有三个值:DENY–表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。SAMEORIGIN–表示该页面可以在相同域名页面的 frame 中展示。ALLOW-FROM uri–表示该页面可以在指定来源的 frame 中展示。PS：如果设置为 DENY，不光在别人的网站 frame 嵌入时会无法加载，在同域名页面中同样会无法加载。另一方面，如果设置为 SAMEORIGIN，那么页面就可以在同域名页面的 frame 中嵌套。 前端反爬虫该课题是在腾讯的IMWeb前端博客上看到的，整理于此，非常感谢。反击爬虫，前端工程师的脑洞可以有多大？ FONT-FACE拼凑式猫眼电影-页面使用了font-face定义了字符集，并通过unicode去映射展示。 BACKGROUND拼凑式美团-与font的策略类似，美团里用到的是background拼凑。数字其实是图片，根据不同的background偏移，显示出不同的字符。 字符穿插式微信公众号文章-某些微信公众号的文章里，穿插了各种迷之字符，并且通过样式把这些字符隐藏掉。 伪元素隐藏式汽车之家-把关键的厂商信息，做到了伪元素的content里（如汽车厂家）。 元素定位覆盖式去哪网-对于一个4位数字的机票价格，先用四个i标签渲染，再用两个b标签去绝对定位偏移量，覆盖故意展示错误的i标签，最后在视觉上形成正确的价格。 IFRAME异步加载式网易云音乐-页面一打开，html源码里几乎只有一个iframe，并且它的src是空白的：about:blank。接着js开始运行，把整个页面的框架异步塞到了iframe里面。 字符分割式全网代理IP-他们会先把IP的数字与符号分割成dom节点，再在中间插入迷惑人的数字，如果爬虫不知道这个策略，还会以为自己成功拿到了数值；不过如果爬虫注意到，就很好解决了。 字符集替换式去哪儿移动侧-html里明明写的3211，视觉上展示的却是1233。原来他们重新定义了字符集，3与1的顺序刚好调换得来的结果PS：常用的后端反爬有 User-Agent + Referer检测、账号及Cookie验证、验证码、IP限制频次。 子资源完整性（SRI,Subresource Integrity）子资源完整性(Subresource Integrity)是允许浏览器检查其获得的资源（例如从 CDN 获得的）是否被篡改的一项安全特性。它通过验证获取文件的哈希值是否和你提供的哈希值一样来判断资源是否被篡改。子资源完整性 (SRI) 是一种安全功能，允许浏览器验证所获取的文件 (比如，从一个 CDN 内容分发网络) 是无意外操作而交付的。它的工作原理是允许你提供一个获取文件必须匹配的加密哈希。 SRI 如何工作使用 内容分发网络 (CDN) 在多个站点之间共享脚本和样式表等文件可以提高站点性能并节省带宽。然而，使用CDN也存在风险，如果攻击者获得对 CDN 的控制权，则可以将任意恶意内容注入到 CDN 上的文件中 （或完全替换掉文件)，因此可能潜在地攻击所有从该 CDN 获取文件的站点。子资源完整性通过确保 Web 应用程序获得的文件未经第三方注入或其他任何形式的修改来降低这种攻击的风险。 如何使用 SRI将使用 base64 编码过后的文件哈希值写入你所引用的 script 或 link 标签的 integrigy 属性值中即可启用子资源完整性功能。PS：integrity 值分成两个部分，第一部分指定哈希值的生成算法（目前支持 sha256、sha384 及 sha512），第二部分是经过 base64 编码的实际哈希值，两者之间通过一个短横（-）分割。integrity 值可以包含多个由空格分隔的哈希值，只要文件匹配其中任意一个哈希值，就可以通过校验并加载该资源。 内容安全策略（CSP）和子资源完整性（SRI）共同使用你可以根据内容安全策略来配置你的服务器使得指定类型的文件遵守 SRI。这是通过在 CSP 头部添加 require-sri-for 指令实现的：1234// 这条指令规定了所有 JavaScript 都要有 integrity 属性，且通过验证才能被加载。Content-Security-Policy: require-sri-for script;// 你也可以指定所有样式表也要通过 SRI 验证：Content-Security-Policy: require-sri-for style; 你也可以对两者都加上验证。 生成 SRI 哈希的工具openssl 在命令行你可以用 openssl 在命令行中执行如下命令来生成 SRI 哈希值：cat FILENAME.js | openssl dgst -sha384 -binary | openssl enc -base64 -A在线生成 SRI 哈希值的工具下面以知乎的一个js文件为例1234// 原js文件地址https://unpkg.zhimg.com/za-js-sdk@2.8.3/dist/zap.js// 生成的脚本标签&lt;script src=&quot;https://unpkg.zhimg.com/za-js-sdk@2.8.3/dist/zap.js&quot; integrity=&quot;sha384-B4YDh2AljLezOmNwiezobW8FJbJQfyZxm1SksT7THfKULK6SVxN+dRNSvLxEmXtA&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; shasum 在命令行shasum -b -a 384 FILENAME.js | xxd -r -p | base64MDN-SRI 用户密码是泄漏的原因？ HTTPS 协议旨在保护用户数据在网络上不被窃听（机密性） 和不被篡改（完整性）。处理用户数据的网站应该使用 HTTPS 协议保护他们的用户不受黑客的侵害。如果网站使用 HTTP 协议而不是 HTTPS 协议，窃取用户信息（比如他们的登录凭证）将会轻而易举。这曾经被 Firesheep 很好地演示过。这里罗列出密码所牵涉到的安全问题： 在HTTP之上运行登录表单. 即使表单的action对象是HTTPS链接,用户的登录表单信息也会受到威胁,因为攻击者能够通过用户修改用户接收到的页面(例如,攻击者插入键盘记录脚本来盗取用户输入的密码.他们还能改变表单目的页从而将敏感信息传递到受他们控制的服务器). 在表单的action链接中使用HTTP链接.在这种情况下,用户输入的任何信息都将以明文方式通过网络传递.这样,从密码离开用户的电脑到密码到达服务器过程中,用户的密码将清楚地展现在任何嗅探用户网络的人眼前. 在网页iframe中递交登录表单(或是嵌入在HTTP frame中的HTTPS frame).即使最上层页面是HTTPS,但在HTTP iframe中包含密码域和在HTTP页面中包含密码域是没有区别的.攻击者同样能够修改这个页面以及偷取用户信息. 有时网页需要用户名及密码,但实际上却没有存储这些敏感的信息.例如,一个新闻页面可能存储一个用户想要再次阅读的文章,却没有存储任何关于这位用户的其他信息.这个新闻站点的网页开发者可能没有动力去对于提高他的网站的安全性以及保护他们用户的信息.不幸的是,密码重用也是一个大问题.用户可能在不同的站点使用相同的密码(新闻网页,社交网络,电子邮箱及其银行).因此即使通过用户名及密码登陆你的网页对你来说不是很大的问题,对于重复使用相同用户名及密码来登陆他们银行账户的用户来说却是一个极大的威胁.网络攻击者正变得越来越聪明.他们在一个网站同时盗取用户名及密码然后在另一个可能能给他们带来金钱的网站上使用这些密码. 弱签名算法在签署数字证书时，哈希算法的完整性是决定证书安全性的关键因素。哈希算法的弱点可能导致攻击者在某些情况下能够获得伪造的证书。由于技术的升级和已知的新型攻击，此类攻击的可行性已经大为提升。因此，不推荐使用旧算法，对于旧算法的支持最终也会停止。 MD5对基于MD5的签名的支持已在2012年初停止。 SHA-1基于SHA-1的签名非常普遍；截至2015年5月，大约45%的数字证书皆使用此算法。但是，SHA-1已经过时因而不再推荐使用。SHA-1的证书将从2017开始不再被主流浏览器厂商视为安全的。 SHA-2（推荐使用）SHA-2是一个哈希算法家族，其中包括SHA-256和SHA-512。截至2015年，SHA-2家族被认为足够安全强大。许多证书颁发机构颁发新的证书使用SHA-256。 SQL注入原理通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 解决方案使用预编译语句、使用存储过程、检查数据类型、使用安全函数（编码特殊字符）、最小权限原则（是否可操作数据库）PS：防御SQL注入的最佳方式，就是使用预编译语句，绑定变量。 MIMT(中间人攻击Man-in-the-middle-attacks)原理Client &lt;–&gt; Proxy Server(Middle Man这里可能存在攻击) &lt;–&gt; Web Server真实的服务器Client 发出的请求 和 Web Server返回的数据都经过Proxy Server 转发，这个Proxy Server 就起到了一个Middle Man的作用，如果这个“中间人” 够黑，那么整个代理过程的数据都可以由这个“中间人”控制，“中间人”可以进行截取敏感数据、代码注射、Proxp worm操作。 解决方案启用虚拟专用网(VPN)、https(传输报文加密)web中间人攻击的威胁 DDOS（分布式拒绝服务Distributed Denial of Service）定义最基本的DDOS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。 解决方案限制请求频率、高防服务器、黑名单、DDoS 清洗、CDN（隐藏真实IP及分流） 类别SYN flood（网络层DDOS）什么是SYN Flood攻击?对抗措施：SYN Cookie 为每一个IP地址分配一个Cookie，并统计每个IP地址的访问频率。如果短时间内收到大量的来自同一个IP地址的数据包，则认为是受到攻击，之后来自这个IP地址的包将被丢失。 Challenge Collapasar（应用层DDOS）原理：对一些消耗资源较大的应用页面不断发起正常的请求（查询数据库、读写硬盘文件等），以达到消耗服务端资源的目的。对抗措施：在应用中针对每个”客户端”做一个请求频率的限制，可以通过IP地址与Cookie定位一个客户端。若IP地址改变（代理服务器）或Cookie清空，应该使用应用代码要做好性能优化（常用数据转移到内存中），在网络架构上做好优化（利用负载均衡、CDN、镜像站点等分流，减轻主站的压力）。知乎-什么是 DDoS 攻击？ 文件上传漏洞产生的问题 上传文件是Web脚本语言 上传文件是木马、病毒文件，诱骗用户或者管理员下载执行 上传文件是钓鱼图片或包含了脚本的图片，在某些浏览器会被作为脚本执行 解决方案文件上传的目录设置为不可执行判断文件类型（使用白名单而不是黑名单）使用随机数改写文件名和文件路径单独设置文件服务器的域名 案列绕过文件上传检查功能UI原本允许上传JPG图片，那么可以构造文件名（需要修改POST包）为xxx.php[\0].JPG，其中[\0]为十六进制的0x00字符，.JPG绕过了应用的上传文件类型判断，但对于服务器来说，此文件因为0x00字符截断的关系，最终会变成xxx.php。对应的解决方案，可以检查附件头信息（同样也可以使用脚本语言来伪造一个合法头信息，这时应该提供不让脚本执行的容器，Web Server将其当做静态文件来解析，从而避免）。 Apache文件解析问题在Apache1.x、Apache2.x中，对文件名的解析就存在以下特性。Apache对于文件的解析是从后往前解析的，知道遇到一个Apache认识的文件类型为止。Apache的mime.types文件配置了Apache能认识那些文件。 认证与会话管理认证和授权？认证的目的是为了认出用户是谁，而授权的目的是为了决定用户能够做什么。 常见的认证方式密码认证多因素认证（手机号+身份证+护照等等）Session 与认证（对SessionID加密后保存在Cookie中，Cookie随HTTP请求发送，且受浏览器同源策略的保护） 常见攻击Session Fixation 攻击：登录前和登录后，重写 Session ID。 单点登录（SSO）SSO英文全称Single Sign On，单点登录。SSO是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。它包括可以将这次主要的登录映射到其他应用中用于同一个用户的登录的机制。它是目前比较流行的企业业务整合的解决方案之一。OpenID：OpenID 是一个以用户为中心的数字身份识别框架，它具有开放、分散性。OpenID 的创建基于这样一个概念：我们可以通过 URI （又叫 URL 或网站地址）来认证一个网站的唯一身份，同理，我们也可以通过这种方式来作为用户的身份认证。 访问控制垂直权限管理主要为基于角色的访问控制（Role-Based Access Control）RBAC一个用户有多个角色，一个角色有一个权限集合，最小粒度为每个权限（权限码）。有以下几个分类 基于URL的访问控制如不同角色能访问不同的页面1234&lt;sec:http&gt; &lt;sec:intercept-url pattern=&quot;/admin&quot; access=&quot;ROLE_ADMIN&quot;/&gt; &lt;sec:intercept-url pattern=&quot;/user/*&quot; access=&quot;ROLE_USER&quot;/&gt;&lt;/sec:http&gt; 基于method的访问控制如限定角色调用方法12@PreAuthorize(&quot;hasRole(&apos;ROLE_USER&apos;)&quot;)public void create(Contact contact) 基于表达式的访问控制如角色和IP地址验证hasRole(&#39;admin&#39;) and hasIpAddress(&#39;192.168.1.0/24&#39;) 水平权限管理什么叫水平权限？用户A只能访问用户A的数据，不能通过构造URL等手段访问到用户B的数据。 OAuth（Open Authorization）OAUTH协议是一个在不提供用户名和密码的情况下，授权第三方应用访问 Web 资源的安全协议。OAuth1.0中分为3个角色（Consumer：消费方 Client、Service Provider：服务提供方 Server、User：用户 Resource Owner）如我们在人人网，想要导入用户MSN里的好友这里人人网为消费方；MSN为服务提供方、用户为资源拥有者 cookie防篡改（实现思路） 服务端提供一个签名生成算法secret 根据方法生成签名secret(wall)=34Yult8i 将生成的签名放入对应的Cookie项username=wall|34Yult8i。其中，内容和签名用|隔开。 服务端根据接收到的内容和签名，校验内容是否被篡改（签名和服务器之前生成的不一致则表示cookie被篡改了）。 Cookie防篡改机制 参考文档：浏览器的同源策略CSP 策略指令X-Frame-OptionsPUBLIC SUFFIX LISTCORSX-Frame-OptionsSRI Hash GeneratorHTTPSLet’s Encrypt，免费好用的 HTTPS 证书]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS技巧]]></title>
    <url>%2F2018%2FCSS%E6%8A%80%E5%B7%A7.html</url>
    <content type="text"><![CDATA[本文总结日常CSS技巧，大多收集于网络、《CSS揭秘》 半透明边框思路：默认 background 是从 border-box 裁切，我们可以通过 background-clip 属性来改变 background 裁切区域如 padding-box，在使用 rgba 或者 hsla 来指定边框颜色即可。12345.border &#123; border: 10px solid hsla(0,0%,100%,.5); background: white; background-clip: padding-box;&#125; 半透明边框PS：根据 stack context 层级关系 background 在 border 下层。 多重边框box-shadow 方案思路：首先要知道 box-shadow 的参数：vl hl blurl spreadl color inset，并且支持多重阴影。demoPS：box-shadow 不影响布局（不占用空间）、不受 box-sizing 的控制、不适用于增加热点区域。 outline 方案只适用于两层边框。PS：当 border 为圆角时，outline 不会贴合元素的圆角，需要使用 box-shadow 来填补。 灵活的背景定位background-position 的扩展语法方案background-position: right 20px bottom 10px;PS：背景定位于 right 的 20px处，bottom 的 10px处。bg-position background-origin 方案background-origin 属性指定 background-position 属性应该是相对位置。background-origin calc() 方案background-position: calc(100% - 20px) calc(100% - 10px);PS：需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)。background-position-calc 边框内圆角我们知道box-shadow是会紧贴border-radius圆角边的，但是，描边outline并不会与圆角边border-radius贴合，我们可以将两者组合，通过box-shadow去填补描边outline所产生的间隙来达到我们想要的效果。12345.box &#123; border-radius: 8px; outline: 6px solid #b4a078; box-shadow: 0 0 0 5px #b4a078; // 用于填充 outline 不能紧靠 border-radius&#125; 边框内圆角 条纹背景横向条纹（默认横向渐变）如形成三条间隔条纹背景。background: linear-gradient(#fb3 33.3%,#58a 0, #58a 66.6%, yellowgreen 0);PS：#58a 0 的作用为直接填充 &gt; 33.3% 的部分。horizontal-stripes 垂直条纹12background: linear-gradient(to right, /* 或 90deg */#fb3 50%, #58a 0);background-size: 30px 100%; vertical-stripes 斜向条纹12background: linear-gradient(45deg, #fb3 25%, #58a 0, #58a 50%, #fb3 0, #fb3 75%, #58a 0);background-size: 42.426406871px 42.426406871px; diagonal-stripesdiagonal-stripes-60deg 灵活的同色系条纹12background: #58a;background-image: repeating-linear-gradient(30deg, hsla(0,0%,100%,.1), hsla(0,0%,100%,.1) 15px, transparent 0, transparent 30px); subtle-stripes 复杂的背景图案网格波点角向渐变css3patterns图案库 连续的图像边框设置多层背景，再通过 background-clip 来裁剪各层背景。图像边框信封背景蚂蚁行军边框footnote 自适应的椭圆前提为 width === height圆形：border-radius: 100px;椭圆：border-radius: 100px / 75px;适应性椭圆：border-radius: 50%;PS：50%; === 50% / 50%;分别为该元素的宽的50%和高的50%。适应性椭圆适应性的半椭圆：border-radius: 100% 0 0 100% / 50%;PS：上面的写法，分别为四个角设置。适应性的半椭圆四分之一椭圆：border-radius: 100% 0 0 0;PS：其中一个角的水平和垂直半径值都需要是100%，而其他三个角都不能设为圆角。quarter-ellipse 平行四边形需求为让容器元素为平行四边形，但文本不可倾斜。 嵌套元素方案抵消策略PS：对容器进行 skew() 变形，对内容再应用一次反向的 skew() 变形，从而抵消容器的变形效果 伪元素方案parallelograms-pseudoPS：把所有样式（背景、边框等）应用到伪元素上，然后再对伪元素进行变形。 菱形图片基于变形的方案diamond-imagesPS：运用 rotate(-45deg) 再使用 scale(1.42) 填满菱形区域。 裁切路径方案clip-path: polygon(50% 0, 100% 50%, 50% 100%, 0 50%);diamond-clip 切角效果线性渐变线性渐变 弧形切角径向渐变 内联 SVG 与 border-image 方案相关 SVG 支持，以背景形式引入 SVG。bevel-corners 裁切路径方案主要使用 clip-path 属性。bevel-corners-clipped 梯形标签页需求为让容器元素为梯形，但文本不可倾斜。1transform: perspective(.5em) rotateX(5deg); trapezoid-tabsPS：把所有样式（背景、边框等）应用到伪元素上，然后再对伪元素进行变形。 简单的饼图基于 transform 的解决方案pie-animatedpie-static SVG 解决方案pie-svg box-shadowbox-shadow: hl vl blur spread color;PS：hl为水平位置，vl为垂直位置，blur为模糊距离（模糊面积越大，阴影就越大越淡），spread为阴影大小（取正值时，阴影扩大；取负值时，阴影收缩）。 单侧投影box-shadow: 0 5px 4px -4px black;shadow-one-sidePS：第四个参数会根据你指定的值去扩大或（当指定负值时）缩小投影的尺寸。 对边投影12box-shadow: 5px 0 5px -5px black, -5px 0 5px -5px black; shadow-opposite-sidesPS：利用 box-shadow 可以设置多重阴影。 不规则投影filter 之 drop-shadow()drop-shadow滤镜与box-shadow区别应用demodemo1PS：drop-shadow 没有 inset，不能叠加，有颜色就会有阴影（不特定于盒模型）。 染色效果基于滤镜的方案color-tint-filter滤镜文档 基于混合模式的方案background-blend-mode 属性定义了背景层的混合模式（图片与颜色）。color-tint 毛玻璃效果frosted-glassPS：伪类来实现效果，原本元素放文本，就不会导致文本模糊。 折角效果45°折角的解决方案123456background: #58a; /* 回退样式 */background: linear-gradient(to left bottom, transparent 50%, rgba(0,0,0,.4) 0) no-repeat 100% 0 / 2em 2em, linear-gradient(-135deg, transparent 1.5em, #58a 0); folded-corner 其他角度的解决方案folded-corner-realisticfolded-corner-mixin 连字符断行CSS 属性 hyphens 告知浏览器在换行时如何使用连字符连接单词。可以完全阻止使用连字符，也可以控制浏览器什么时候使用，或者让浏览器决定什么时候使用。hyphenation 插入换行line-breaksPS：有一个 Unicode 字符是专门代表换行符的： 0x000A ① 。在 CSS 中，这个字符可以写作 “\000A” ，或简化为 “\A” ，类似于 br 标签。 文本行的斑马条纹1234567padding: .5em;line-height: 1.5;background: beige;background-size: auto 3em;background-origin: content-box;background-image: linear-gradient(rgba(0,0,0,.2) 50%,transparent 0); zebra-lines 调整 tab 的宽度tab-size 属性规定制表符（tab）字符的空格长度，只对 textarea 和 pre 有效。tab-size 连字font-variant-ligatures1font-variant-ligatures: common-ligatures no-discretionary-ligatures no-historical-ligatures; 未来的文本下划线text-decoration-color 用于自定义下划线或其他装饰效果的颜色。text-decoration-style 用于定义装饰效果的风格（比如实线、虚线、波浪线等）。text-decoration-skip 用于指定是否避让空格、字母降部或其他对象。text-underline-position 用于微调下划线的具体摆放位置。underlines 现实中的文字效果凸版印刷效果空心字效果文字外发光效果文字凸起效果 环形文字SVG实现 选用合适的鼠标光标提示禁用状态123:disabled, [disabled], [aria-disabled=&quot;true&quot;] &#123; cursor: not-allowed;&#125; disabled 隐藏鼠标光标适用于播放 video 等情形。12cursor: url(&apos;transparent.gif&apos;); // 兼容低版本cursor: none; 扩大可点击区域Fitts 法则 或 菲茨定律 或 费茨法则人机交互的一个法则Fitts 法则认为，人类移动到某个目标区域所需的最短时间是由目标距离与目标宽度之比所构成的对数函数。 border 增加用户交互区域123border: 10px solid transparent;box-shadow: 0 0 0 1px rgba(0,0,0,.3) inset;background-clip: padding-box; hit-area-border 伪类增加用户交互区域123456789button &#123; position: relative;&#125;button::before &#123; content: &apos;&apos;; position: absolute; top: -10px; right: -10px; bottom: -10px; left: -10px;&#125; hit-area 自定义复选框checkboxestoggle-buttons 通过阴影来弱化背景伪元素方案123456789body.dimmed::before &#123; position: fixed; top: 0; right: 0; bottom: 0; left: 0; z-index: 1; background: rgba(0,0,0,.8);&#125; box-shadow 方案1box-shadow: 0 0 0 50vmax rgba(0,0,0,.8); box-shadow;) backdrop 方案backdropPS：dialog 元素（ 元素可以由它的 showModal() 方法显示出来），那么根据浏览器的默认样式，它会自带一个遮罩层（ ::backdrop 伪元素）。 通过模糊来弱化背景123main.de-emphasized &#123; filter: blur(3px) contrast(.8) brightness(.8);&#125; 滤镜效果 滚动提示上下滚动 交互式的图片对比控件image-slider 自适应内部元素width 新添了一些属性，如min-content。123456figure &#123; max-width: 300px; max-width: min-content; margin: auto;&#125;figure &gt; img &#123; max-width: inherit; &#125; intrinsic-sizing 精确控制表格列宽1234table &#123; table-layout: fixed; width: 100%;&#125; table-column-widths 根据兄弟元素的数量来设置样式相当于li:only-childli:first-child:nth-last-child(1) 当列表正好包含四项时，命中所有列表项li:first-child:nth-last-child(4),li:first-child:nth-last-child(4) ~ li 当列表至少包含四项时，命中所有列表项li:first-child:nth-last-child(n+4),li:first-child:nth-last-child(n+4) ~ li 当列表最多包含四项时，命中所有列表项li:first-child:nth-last-child(-n+4),li:first-child:nth-last-child(-n+4) ~ li 当列表包含2～6项时，命中所有列表项li:first-child:nth-last-child(n+2):nth-last-child(-n+6),li:first-child:nth-last-child(n+2):nth-last-child(-n+6) ~ listyling-sibling-count 满幅的背景，定宽的内容fluid-fixed 垂直居中基于绝对定位的解决方案123456main &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; 基于视口单位的解决方案123456main &#123; width: 18em; padding: 1em 1.5em; margin: 50vh auto 0; // 这里不能使用50%，详细请了解包含快知识 transform: translateY(-50%);&#125; 基于 Flexbox 的解决方案123456.container &#123; display: flex;&#125;main &#123; margin: auto; // 水平和垂直都可以居中&#125; 基于 Flexbox 的解决方案（匿名容器）PS：匿名容器即为没有被标签包裹的文本节点12345.container &#123; display: flex; align-items: center; justify-content: center;&#125; 紧贴底部的页脚下列 header、main、footer 为 body 的子元素。 固定高度的解决方案12345main &#123; min-height: calc(100vh - footerHeight); /* 避免内边距或边框搞乱高度的计算： */ box-sizing: border-box;&#125; flex的解决方案123456789body &#123; display: flex; flex-flow: column; min-height: 100vh;&#125;main &#123; // 自动伸展并占满所有的可用空间 flex: 1; &#125; 缓动效果（动画和过渡）回弹动画弹性过渡PS：对颜色过渡时小心，RGB 三个通道的值是独立进行插值运算的，在过渡过程中会产生其他颜色。一般通过 transition-property 设置指定过渡属性来避免。 逐帧动画运动曲线适用性：贝塞尔曲线适用于平滑运动， steps(步进数, [start || end])适用于逐帧动画PS：参数一为步进数（把动画分为多少步，然后在逐步运行），参数二用于指定动画在每个循环周期的什么位置发生帧的切换动作。逐帧动画 闪烁效果animation-direction 属性定义是否循环交替反向播放动画。reverse 动画反向播放。alternate 动画在奇数次（1、3、5…）正向播放，在偶数次（2、4、6…）反向播放。alternate-reverse 动画在奇数次（1、3、5…）反向播放，在偶数次（2、4、6…）正向播放。闪烁效果 打字动画打字动画 状态平滑的动画animation–play-state 属性指定动画是否正在运行或已暂停。paused 指定暂停动画running 指定正在运行的动画指定暂停动画 ::first-letter定义：::first-letter会选中某 block-level element（块级元素）第一行的第一个字母，并且文字所处的行之前没有其他内容（如图片和内联的表格） 。 ::first-letter 伪元素生效的前提，常见的标点符号、各类括号和引号在::first-letter 伪元素眼中全部都是“辅助类”字符，不会作为第一个字符计算。 与::before使用（::before 若有字符，会参与计算及 伪类的 content 的字符会被::first-letter生效）。 ::first-letter 伪元素可以生效的 CSS 属性有：字体属性、背景属性、color、padding、border、margin等。 PS：“辅助类”包括·@#%&amp;()（）[]【】{}:：”“”;；’‘’》《,，.。？?!！…、/\。iScroll, smooth scrolling for the web CJK（中文/日文/韩文）两端对齐text-align: justify;text-justify: inter-ideograph; 用户交互反馈（通用的按钮及连接交互反馈）通用的连接和按钮交互反馈，原理为：background-color 总是在最底下的位置，所以这里的 background-image 一定是覆盖在按钮等元素背景色之上的，不会影响按钮原来的背景色。123a[href]:active, button:active &#123; background-image: linear-gradient(to top, rgba(0,0,0,.05), rgba(0,0,0,.05));&#125; 元素的显示与隐藏script 标签如果希望元素不可见，同时不占据空间，辅助设备无法访问，同时不渲染，不进行资源加载。123&lt;script type=&quot;text/html&quot;&gt; &lt;img src=&quot;1.jpg&quot;&gt;&lt;/script&gt; PS：script标签隐藏内容获取使用 script.innerHTML display:none 隐藏如果希望元素不可见，同时不占据空间，辅助设备无法访问，但资源有加载，DOM 可访问。123.dn &#123; display: none;&#125; visibility: hidden 隐藏如果希望元素不可见，同时不占据空间，辅助设备无法访问，但显隐的时候可以有 transition 淡入淡出效果。1234.hidden &#123; position: absolute; visibility: hidden;&#125; 如果希望元素不可见，不能点击，辅助设备无法访问，但占据空间保留。123.hidden &#123; visibility: hidden;&#125; clip 剪裁隐藏如果希望元素不可见，不能点击，不占据空间，但键盘可访问。12345678.clip &#123; position: absolute; clip: rect(0 0 0 0);&#125;.out &#123; position: relative; left: -999em;&#125; relative 隐藏如果希望元素不可见，不能点击，但占据空间，且键盘可访问。1234.lower &#123; position: relative; z-index: -1;&#125; 透明度隐藏如果希望元素不可见，但可以点击，而且不占据空间，则可以使用透明度。12345.opacity &#123; position: absolute; opacity: 0; filter: Alpha(opacity=0);&#125; 如果单纯希望元素看不见，但位置保留，依然可以点可以选，则直接让透明度为 0。1234.opacity &#123; opacity: 0; filter: Alpha(opacity=0);&#125; PS：img元素，设置 display:none 在所有浏览器下依旧都会请求图片资源（浪费了宽带）。 流向的改direction（改变水平流向）unicode-bidi（文字流向）writing-mode（改变 CSS 世界纵横规则）writing-mode: lr-tb | tb-rl | tb-lr (IE8+);writing-mode: horizontal-tb | vertical-rl | vertical-lr; 1px边框（移动端）box-shadow/border + transform12345678910111213.border &#123; width: 100%; position: relative;&#125;.border::after &#123; content:&apos;&apos;; position: absolute; bottom: 0;left: 0; width: 100%; box-shadow: 0 0 0 1px red; transform-origin: 0 bottom; transform: scaleY(.5);&#125; PS：还可以结合 @media (min-resolution: xdppx)做进一步处理。 backgroundbackground-origin: padding-box; 默认background-position: top 20px left 20px; 参照点为默认padding-boxbackground-size: x y;圆锥渐变background: conic-gradient(red, yellow, lime, aqua, blue, fuchsia, red);background缩写语法background:bg-color bg-image position/bg-size bg-repeat bg-origin bg-clip bg-attachment initial|inherit; border-radius 可以通过’/‘设置水平水平和垂直半径，如border-radius: 100px / 75px; 它不仅可以接受长度值，还可以接受百分比值（这个百分比值会基于元素的尺寸进行解析，即宽度用于水平半径的解析，而高度用于垂直半径的解析。）。 white-space指定元素内的空白怎样处理。normal 默认。空白会被浏览器忽略。pre 空白会被浏览器保留。其行为方式类似 HTML 中的 标签。nowrap 文本不会换行，文本会在在同一行上继续，直到遇到 标签为止。pre-wrap 保留空白符序列，但是正常地进行换行。pre-line 合并空白符序列，但是保留换行符。inherit 规定应该从父元素继承 white-space 属性的值。 otherline-height 的百分比时相对于 font-size 计算的。vertical-align 的百分比时相对于 line-height 计算的。ex 一个 ex 是一个字体的 x-height。 (x-height 通常是字体尺寸的一半。)ch 数字 0 的宽度，使用场景（需要配合等宽字体）：全数字输入框：手机号等。font-weight 运行原理：字体不同粗细需要字体文件是否存在该粗细的字体。font-style 同样有效的前提为字体文件中存在该类型的字体，italic 和 oblique。font-family: system-ui; // 让网页的字体跟系统走，，网站字体能时时刻刻与时俱进。text-transform 属性控制文本的大小写，支持capitalize、uppercase、lowercase。适用场景：身份证输入，最后以为X，帮助用户转为大写；验证码输入，帮助用户转为大写。::backdrop CSS 伪元素 是在任何处于全屏模式的元素下的即刻渲染的盒子（并且在所有其他在堆中的层级更低的元素之上）。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS笔记]]></title>
    <url>%2F2018%2FCSS%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[本文主要目的唤起你的记忆，如果你很熟悉该属性就当做复习，如果不熟悉，你就应该好好去查查文档了，毕竟本文只是点到即止的。 CSS方法attr()用来获取选择到的元素的某一HTML属性值，并用于其样式。 calc()可以通过计算来决定一个CSS属性的值了。PS：运算符前后都需要保留一个空格，例如：width: calc(100% - 10px); countercounter-reset属性创建或重置一个或多个计数器。counter-increment属性递增一个或多个计数器值。counter(name)方法用于获取计数器的值。PS：counter-reset属性通常是和counter-increment属性，content属性一起使用。 cubic-bezier()它主要作用于动画和过渡的运动曲线函数 animation-timing-function 和 transition-timing-function 。cubic-bezier转换网站 gradientlinear-gradient线性渐变background-image: linear-gradient(to right, red, orange, yellow, green, blue, indigo, violet);repeating-linear-gradient – 重复线性渐变background: repeating-linear-gradient(to top left, lightpink, lightpink 5px, white 5px, white 10px); radial-gradient径向渐变background: radial-gradient(red, yellow, rgb(30, 144, 255));repeating-radial-gradient – 重复径向渐变background: repeating-radial-gradient(powderblue, powderblue 8px, white 8px, white 16px); image-set()可以根据用户设备的分辨率匹配合适的图像。background-image: image-set( &quot;test.png&quot; 1x, &quot;test-2x.png&quot; 2x, &quot;test-print.png&quot; 600dpi ); img 的 srcset属性以逗号分隔的一个或多个字符串列表表明一系列用户代理使用的可能的图像。&lt;img src=&quot;mm-width-128px.jpg&quot; srcset=&quot;mm-width-128px.jpg 1x, mm-width-256px.jpg 2x&quot;&gt;PS：img的srcset属性方便的解决了页面图片适应不同屏幕密度的情况。 matrix()matrix() 指定了一个由指定的 6 个值组成的 2D 变换矩阵。这种矩阵的常量值是隐含的，而不是由参数传递的；其他的参数是以列优先的顺序描述的。matrix3d() 参数为 9 个值，对应 3D 变换。PS：所有的 transform 参数值都可以用矩阵来表示。 var()var()函数可以代替元素中任何属性中的值的任何部分。语法：var( &lt;custom-property-name&gt; [, &lt;declaration-value&gt; ]? )ps：带有前缀–的属性名，比如–example–name，表示的是带有值的自定义属性，其可以通过 var 函数在全文档范围内复用的。 通用属性backface-visibility指定当元素背面朝向观察者时是否可见。元素的背面总是透明的，当其朝向观察者时，显示正面的镜像。 cross-fade作用：CSS3背景图片透明叠加属性。方法：background-image: -webkit-cross-fade(url(1.jpg), url(2.jpg), 50%);PS：透明度是作用在第二张图片上的。Cross-fade caret-color用来定义插入光标（caret）的颜色，这里说的插入光标，就是那个在网页的可编辑器区域内，用来指示用户的输入具体会插入到哪里的那个一闪一闪的形似竖杠 | 的东西。 clip-path可以创建一个只有元素的部分区域可以显示的剪切区域（也就是说可以让一个元素显示出不同的形式，如圆形、椭圆、多边形等等）。CSS3 clip-path 用法详解 shape-outside属性指定使用下面列表的值来定义浮动元素的浮动区域。这个浮动区域决定了行内内容（浮动元素）所包裹的形状。其中还包括basic-shape有inset()、 circle()、ellipse()、polygon() resolutiondpi每英寸包含点的数量（dots per inch）普通屏幕通常包含96dpi，一般将2倍于此的屏幕称之为高分屏，即大于等于192dpi的屏幕，比如Mac视网膜屏就达到了192dpi（即2dppx）。 dpcm每厘米包含点的数量（dots per centimeter） dppx每像素包含点的数量（dots per pixel）基本的换算单位12341dppx = 96dpi1dpi ≈ 0.39dpcm1dpcm ≈ 2.54dpi1in = 2.54cm = 25.4 mm = 101.6q = 72pt = 6pc = 96px empty-cells渲染表格 table 中没有可见内容的单元格的边框和背景，取值为show 和 hide。 widthwidth属性又多了几个关键字成员，fill-available, max-content, min-content, 以及fit-content，兼容性还有很大问题，暂不深究。 max-content固有的首选宽度. min-content这个关键字将解析为这个容器内部最大的不可断行元素的宽度（即最宽的单词、图片或具有固定宽度的盒元素）。 available包含块的宽度减去水平 margin, border 和 padding. fit-content以下两种情况下的较大值:固有的最小宽度 或 固有首选宽度（max-content）和可用宽度（available）的较小值 border-box之前的 length 或 percentage 应用到元素的边框盒子. content-box之前的 length 或 percentage 应用到元素的内容盒子. hanging-punctuation指定了标点符号应该放在文本句子的开头还是结尾。悬挂标点符号可能被放在线框外。 hyphens告知浏览器在换行时如何使用连字符连接单词。可以完全阻止使用连字符，也可以控制浏览器什么时候使用，或者让浏览器决定什么时候使用。 image-rendering决定浏览器对缩放图像采取的缩放算法.它适用于元素本身和有其他属性的图像.它对非缩放图像没有影响。 image-orientation用来修正某些图片的预设方向。PS：该属性不是用来对图片进行任意角度旋转的, 它是用来修正那些带有不正确的预设方向的图片的. 因此该属性值会被四舍五入到 90 度的整数倍. 通用关键字inherit – 关键字使得元素获取其父元素的计算值(computed value )，当然肯定只针对可继承属性。initial – 是将属性的初始值( initial value)赋给元素，至于那些为不同属性的初始值，请参见W3C。unset – CSS 关键字 unset 是 关键字 initial 和 inherit的组合（换句话说这个unset关键字会优先用inherit的样式，其次会应该用initial的样式）。all – CSS all简写属性重设除了unicode-bidi 和 direction 之外的所有属性至它们的初始值或继承值。 inline-size定义元素的块的水平或垂直大小，这取决于它的写入模式。它对应于 width 或 height，取决于 writing-mode 属性。 isolation定义该元素是否必须创建一个新的stacking context。PS：该属性的主要作用是当和background-blend-mode属性一起使用时，可以只混合一个指定元素栈的背景：它允许使一组元素从它们后面的背景中独立出来，只混合这组元素的背景。 支持欠佳的属性，暂不深究margin-block-start 和 margin-block-end定义元素的逻辑块结束余量，该元素根据元素的writing-mode、方向性和文本方向映射到物理量度。margin-inline-start 和 margin-inline-endmin-block-size 和 min-inline-sizeoffset-block-start 和 offset-block-endoffset-inline-start 和 offset-inline-endpadding-block-start 和 padding-block-endpadding-inline-end 和 padding-inline-start mask允许使用者通过部分或者完全隐藏一个元素的可见区域。这种效果可以通过遮罩或者裁切特定区域的图片。遮罩mask是一个复合属性，包括mask-image、mask-mode、mask-repeat、mask-position、mask-clip、mask-origin、mask-size、mask-composite这8个属性 mask-image默认值为none，值为透明图片，或透明渐变 mask-repeat默认值为repeat，可选值与background-repeat相同 mask-position默认值为0 0，可选值与background-position相同 mask-clip默认值为border-box，可选值与background-clip相同 mask-origin默认值为border-box，可选值与background-origin相同 mask-size默认值为auto，可选值与background-size相同 mask-mode默认值为match-source，可选值为alpha、luminance、match-source，或者它们的组合 mask-composite默认值为add，可选值为add、subtract、intersect、exclude mix-blend-mode描述了元素的内容应该与元素的直系父元素的内容和元素的背景如何混合。 作用于替换元素，如imgobject-fit指定替换元素的内容应该如何适应到其使用的高度和宽度确定的框。 object-position指定元素的替换内容在其盒子内的对齐方式。 overflow-wrap是用来说明当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行。PS：word-wrap 属性原本属于微软的一个私有属性，在 CSS3 现在的文本规范草案中已经被重名为 overflow-wrap 。 pointer-events指定在什么情况下 (如果有) 某个特定的图形元素可以成为鼠标事件的 target。 quotes设置嵌套引用的引号类型。PS：当4个参数时，前两个值规定第一级引用嵌套，后两个值规定下一级引号嵌套。前两个值规定第一级引用嵌套，后两个值规定下一级引号嵌套。 @supportsCSS 规则关联了一组嵌套的CSS语句,这些语句被放置在一个CSS区块中,该区块以大括号分割, 还有一个由多个CSS声明检测组成的条件,它是一个键值组合, 由逻辑与,逻辑或,逻辑非组合而成. 这样的条件语句称为支持条件.语法：123@supports &lt;supports_condition&gt; &#123; /* specific rules */&#125; PS：在 supports_condition 中还支持 not、or、and 逻辑。 tab-size用于自定义制表符 (U+0009) 的宽度。 table-layout用于布局表格单元格，行和列的算法。 text-align-last描述的是一段文本中最后一行在被强制换行之前的对齐规则。 text-combine-upright文本结合 writing-mode（为vertical-rl 或 vertical-lr） 指定多个字符的组合到单个字符的空间中。 text-emphasis主要效果为文本强调。text-emphasis-colortext-emphasis-positiontext-emphasis-style text-orientation设置文本的方向。 text-renderingCSS 属性定义浏览器渲染引擎如何渲染字体。浏览器会在速度、清晰度、几何精度之间进行权衡。 text-transformCSS属性指定如何将元素的文本大小写。 text-underline-position当 text-decoration属性的值设置为 underline 之后，可以用 text-underline-position 属性为其设置下划线的位置。 touch-action用于指定某个给定的区域是否允许用户操作，以及如何响应用户操作（比如浏览器自带的划动、缩放等）。 transform-boxdefines the layout box, to which the transform and transform-origin properties relate to. transform-style确定元素的子元素是否位于3D空间中，还是在该元素所在的平面内被扁平化。 unicode-bidiCSS 的 unicode-bidi 属性和 direction 属性一起决定了如何处理文档中的双向文本（bidirectional text）。 unicode-range属性值可以是单个字符编码、字符编码区间、通配符区间、多个值等，如小写字母：[0x61,0x7a]（或十进制[97, 122]）CSS unicode-range 特定字符使用 font-face 自定义字体。 vertical-alignCSS 的属性 vertical-align 用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。baseline元素基线与父元素的基线对齐。对于一些 可替换元素，比如 textarea ， HTML标准没有说明它的基线，这意味着对其使用这个关键字，各浏览器表现可能不一样。sub元素基线与父元素的下标基线对齐。super元素基线与父元素的上标基线对齐。text-top元素顶端与父元素字体的顶端对齐。text-bottom元素底端与父元素字体的底端对齐。middle元素中垂线与父元素的基线加上小写x一半的高度值对齐。length元素基线超过父元素的基线指定高度。可以取负值。percentage同 length , 百分比相对于 line-height 。以下两个值是相对于整行来说的：top 元素及其后代的顶端与整行的顶端对齐。bottom元素及其后代的底端与整行的底端对齐。 will-changeCSS 属性 will-change 为web开发者提供了一种告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作。PS：这种优化可以将一部分复杂的计算工作提前准备好，使页面的反应更为快速灵敏。 writing-mode定义了文本水平或垂直排布以及在块级元素中文本的行进方向。 增加热区的范围 border 可以增加热区（与用户交互的区域），outline 和 box-shadow 是不能办到的。 伪元素同样可以代表其宿主元素来响应鼠标交互。 通常的做法1border: 10px solid transparent; filter(滤镜效果)CSS滤镜（filter）属提供的图形特效，像模糊，锐化或元素变色。过滤器通常被用于调整图片，背景和边界的渲染。filter 可以开启浏览器的硬件加速GPU，优化性能。 blur()给图像设置高斯模糊。filter: blur(number); brightness()给图片应用一种线性乘法，使其看起来更亮或更暗。如果值是0%，图像会全黑。值是100%，则图像无变化。其他的值对应线性乘数效果。值超过100%也是可以的，图像会比原来更亮。如果没有设定值，默认是1。 drop-shadow()给图像设置一个阴影效果。阴影是合成在图像下面，可以有模糊度的，可以以特定颜色画出的遮罩图的偏移版本。 contrast()调整图像的对比度。值是0%的话，图像会全黑。值是100%，图像不变。值可以超过100%，意味着会运用更低的对比。若没有设置值，默认是1。 grayscale()将图像转换为灰度图像。值定义转换的比例。值为100%则完全转为灰度图像，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0。 hue-rotate()给图像应用色相旋转。“angle”一值设定图像会被调整的色环角度值。 invert()反转输入图像。值定义转换的比例。100%的价值是完全反转。值为0%则图像无变化。值在0%和100%之间，则是效果的线性乘子。 若值未设置，值默认是0。 opacity()转化图像的透明程度。 saturate()转换图像饱和度。值定义转换的比例。值为0%则是完全不饱和，值为100%则图像无变化。 sepia()将图像转换为深褐色。值定义转换的比例。值为100%则完全是深褐色的，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0。PS：你可以组合任意数量的函数来控制渲染。下面的例子可以增强图像的对比度和亮度。filter: contrast(175%) brightness(3%) 背景backgroundbackground 是CSS简写属性，用来集中设置各种背景属性。background 可以用来设置一个或多个属性:background-color, background-image, background-position, background-repeat,background-size, background-attachment。 background-attachment如果指定了 background-image ，那么 background-attachment 决定背景是在视口中固定的还是随包含它的区块滚动的。 background-blend-mode定义该元素的背景图片，以及背景色如何混合。 background-clip置元素的背景（背景图片或颜色）是否延伸到边框下面。PS：简写形式background:bg-color bg-image bg-position/bg-size bg-repeat bg-origin bg-clip bg-attachment initial|inherit; 伪类:active:active CSS伪类匹配被用户激活的元素。PS：当多伪类同时使用时，需要注意顺序，否则就会发生被覆盖，如链接:link — :visited — :hover — :active。 :target代表一个唯一的页面元素(目标元素)，其ID与当前URL片段匹配. :default表示一组相关元素中的默认表单元素。该选择器可以在 &lt;button&gt;, &lt;input type=&quot;checkbox&quot;&gt;, &lt;input type=&quot;radio&quot;&gt;, 以及 &lt;option&gt; 上使用。 :dir伪类匹配特定文字书写方向的元素。在HTML中, 文字方向由dir属性决定。 :enabled表示任何启用的（enabled）元素。如果一个元素能够被激活（如选择、点击或接受文本输入）或获取焦点，则该元素是启用的。 :disabled表示任何被禁用的元素。如果一个元素不能被激活（如选择、点击或接受文本输入）或获取焦点，则该元素处于被禁用状态。 :read-only表示元素不可被用户编辑的状态（如锁定的文本输入框）。 :read-write代表一个元素（例如可输入文本的 input元素）可以被用户编辑。PS：这个选择器不仅仅选择 input 元素，它也会选择所有可以被用户编辑的元素，例如设置了 contenteditable 属性的 p 元素。 :empty代表没有子元素的元素。子元素只可以是元素节点或文本（包括空格），无论一个元素是否为 (empty 或 not), 注释或处理指令都不会产生影响。 :not()是以一个简单的以选择器X为参数的功能性标记函数。它匹配不符合参数选择器X描述的元素。PS：:not伪类不像其它伪类，它不会增加选择器的优先级。 :focus表示获得焦点的元素（如表单输入）。当用户点击或触摸元素或通过键盘的 “tab” 键选择它时会被触发。 :fullscreen应用于当前处于全屏显示模式的元素。 它不仅仅选择顶级元素，还包括所有已显示的栈内元素。 :in-range代表一个 input 元素，其当前值处于属性min 和max 限定的范围之内. :out-of-range代表一个 input 元素，其当前值不在属性min 和max 限定的范围之内. :indeterminate表示状态不确定的表单元素. :invalid表示任意内容未通过验证的 input 或其他 form 元素 . :valid表示任意内容通过验证的 input 或其他 form 元素 . :required表示 任意 input 元素表示任意拥有required属性的 input 或 textarea 元素使用它. 它允许表单在提交之前容易的展示必填字段并且渲染其外观. :lang()基于元素语言来匹配页面元素。 :optional表示任意没有required属性的 input，select 或 textarea 元素使用它。 :only-child代表了属于某个父元素的唯一一个子元素.PS：等价的方法还有:first-child:last-child或者:nth-child(1):nth-last-child(1) :root这个 CSS 伪类匹配文档树的根元素。对于 HTML 来说，:root 表示 html 元素，除了优先级更高之外，与 html 选择器相同。 :scope它将会匹配作为选择符匹配元素的参考点(css的作用域或作用点)。在HTML中，可以使用 style 的scoped属性来重新定义新的参考点。如果HTML中没有使用这个属性，那么默认的参考点(css的作用域或作用点)是 html。 scroll-behavior当由于导航或者CSSOM滚动api产生滚动时，CSS属性 scroll-behavior 为一个滚动框指定滚动行为，其他任何的滚动，例如那些由于用户行为而产生的滚动，不受这个属性的影响。在根元素中指定这个属性时，它反而适用于视窗。PS：可以配合 a 链接来实现平滑滚动到对应锚点位置。可以在Chrome浏览器中测试下 scroll-snap-typeCSS属性定义在滚动容器中的一个snap点如何被严格的执行。PS：此属性不能用来指定任何精确的动画或者物理运动效果来执行snap点，而是交给用户代理来处理。 shape-outsideCSS 属性定义了一个行内内容应该包裹的形状。默认表现是行内元素包裹该形状的margin box。 shape-image-thresholdCSS property defines the alpha channel threshold used to extract the shape using an image as the value for shape-outside. shape-marginCSS property specifies a margin for a CSS shape created using shape-outside. @page@page 规则用于在打印文档时修改某些CSS属性。你不能用@page规则来修改所有的CSS属性，而是只能修改margin,orphans,widow 和 page breaks of the document。对其他属性的修改是无效的。 size指定页面盒模型所在的容器的大小和方向。一般情况下，因为一个页面盒模型被渲染到一面纸张上，所以这个属性也指示了目标纸张的大小。 marks向文档添加剪切标记和/或注册标记。 bleed指定一个超出页面盒模型的区域，在这个区域的页面内容将被裁剪。 :first需要和 @page 配套使用，打印文档的时候，第一页的样式。 :left需要和 @page 配套使用, 对打印文档的左侧页设置CSS样式. :right需要和 @page 配套使用, 对打印文档的右侧页设置CSS样式. :blank与 :empty 关系类似，浏览器支持不佳。 两个实验性:recto 和 :verso page-break-afterCSS 属性调整当前元素之后的分页符 page-break-beforeCSS属性调整当前元素之前的分页符。 page-break-insideCSS 属性调整当前元素内的分页符。 伪元素::after::after用来创建一个伪元素，做为已选中元素的最后一个子元素。通常会配合content属性来为该元素添加装饰内容。PS：这个虚拟元素默认是行内元素。 ::fitst-letter会选中某 block-level element（块级元素）第一行的第一个字母，并且文字所处的行之前没有其他内容（如图片和内联的表格） 。PS：你可能还不知道，::before 伪元素 和 content 属性结合起来有可能会在元素前面注入一些文本。如此，::first-letter 将会匹配到content文本的首字母。首行只在 block-container box内部才有意义, 因此 ::first-letter 伪元素 只在display属性值为block, inline-block, table-cell, list-item 或者 table-caption的元素上才起作用. 其他情况下, ::first-letter 毫无意义. ::backdrop是在任何处于全屏模式的元素下的即刻渲染的盒子（并且在所有其他在堆中的层级更低的元素之上）。 ::placeholder可以选择一个表单元素的占位文本，它允许开发者和设计师自定义占位文本的样式。 ::selection应用于文档中被用户高亮的部分（比如使用鼠标或其他选择设备选中的部分）。 ::slotted()CSS pseudo-element represents any element that has been placed into a slot inside an HTML template (see Using templates and slots for more information). css3 布局Flex 布局place-contentStudy-Notes grid 布局Grid通过设置 display: grid; 可以定义一个 CSS 网格。然后使用 grid-template-rows 和 grid-template-columns 属性来定义网格的 columns 和 rows。PS：grid-template-rows 和 grid-template-columns 有较多种参数。minmax(min, max)可以设置最小值和最大值，当某个值为 auto 时不限制。repeat( [ | auto-fill | auto-fit ] , )重复的多个 track，第一个参数指定了 repeat 的次数。auto-fit倾向于使用最少列数占满当前行空间，浏览器先是和 auto-fill 一样，暗中创建一些列来填充多出来的行空间，然后坍缩（collapse）这些列以便腾出空间让其余列扩张。auto-fill倾向于容纳更多的列，所以如果在满足宽度限制的前提下还有空间能容纳新列，那么它会暗中创建一些列来填充当前行。 Grid Areas网格区域是网格中由一个或者多个网格单元格组成的一个矩形区域。当你使用基于网格线位置放置一个项目或者使用命名的网格区域定义区域时，网格区域被创建。通常用 grid-area 属性命名它们（为子网格命名），然后用 grid-template-areas 把它们放在网格上。Grid Areas Grid Lines使用Grid布局在显式网格中定义轨道的同时会创建网格线。网格线可以用它们的编号来寻址，线编号遵循文档的写入模式，因此在从右到左的语言中，列线1行将位于网格的右侧。PS：主要给下列属性使用grid-column-start、grid-column-end、grid-row-start、grid-row-end。Grid Lines Gutters网格间距是网格轨道之间的间距，可以通过 grid-column-gap 或者 grid-row-gap 在Grid布局中创建。 动画和过渡和转换animationanimation属性是如下属性的一个简写属性形式: animation-name, animation-duration, animation-timing-function, animation-delay, animation-iteration-count, animation-direction 和 animation-fill-mode. animation-name指定应用的一系列动画，每个名称代表一个由@keyframes定义的动画序列。 animation-delayCSS属性定义动画于何时开始，即从动画应用在元素上到动画开始的这段时间的长度。 animation-directionCSS 属性指示动画是否反向播放，它通常在简写属性animation中设定。 animation-fill-mode用来指定在动画执行之前和之后如何给动画的目标应用样式。 animation-iteration-count定义动画在结束前运行的次数 可以是1次 无限循环。 animation-play-state定义一个动画是否运行或者暂停。可以通过查询它来确定动画是否正在运行。另外，它的值可以被设置为暂停和恢复的动画的重放。 animation-timing-function定义CSS动画在每一动画周期中执行的节奏。 perspective 或 perspective()指定了观察者与z=0平面的距离，使具有三维位置变换的元素产生透视效果。z&gt;0的三维元素比正常大，而z&lt;0时则比正常小，大小程度由该属性的值决定。 perspective-origin指定了观察者的位置，在属性perspective中被用作消失点。 百分比属性参照对象参照包含块宽高 参照包含块的width（margin、padding、width、left、right、font-size、text-index） 参照包含块的height（height、top、bottom） 参照自身盒子宽高 盒子模型中的border-radius 背景中的background-size 在transform变换中，translate()、transform-origin、scale()你知道我们平时在CSS中写的%都是相对于谁吗？ 长度单位相对长度单位em相对长度单位，这个单位表示元素的font-size的计算值。如果用在font-size 属性本身，它会继承父元素的font-size。 ex这个单位表示元素font的 x-height 。在含有“x”字母的字体中，它是该字体的小写字母的高度；对于很多字体， 1ex ≈ 0.5em。 ch这一单位代表元素所用字体 font中“0”这一字形的宽度（“0”，Unicode字符U+0030），或更准确地说是“0”这一字形的预测尺寸（advance measure）。 rem这个单位代表根元素的 font-size 大小（html 元素的font-size）。 lh等于元素行高line-height的计算值。 rlh等于根元素行高line-height的计算值。 视口比例的长度vh视口高度的 1/100。 vw视口宽度的 1/100。 vi等于初始包含块的大小的1%，在根元素的内联轴的方向上。 vb等于初始包含块的大小的1%，在根元素的块轴的方向上。 vmin视口高度和宽度之间的最小值的 1/100。 vmax视口高度和宽度之间的最大值的 1/100。 绝对长度单位px对于屏幕显示，通常是一个设备像素（点）的显示。 mm毫米。 cm厘米（10毫米）。 in英寸（2.54厘米）。 pt磅（1/72 英寸）。 pc12 点活字 (1 pc 等于 12 点)。 color颜色关键字black（黑） 、silver（银）、gray[*]（灰）、white（白）等等。 其他关键字transparent 关键字，是 rgba(0,0,0,0) 的简写。currentColor 关键字，取当前 color 的值。 颜色表达式十六进制符号 #RRGGBBrgb(r, g, b)rgba(r, g, b, a)hsl(h, s, l) // 分别代表：色相、饱和度、亮度hsla(h, s, l, a) angle用于表示角的大小，单位为度（degrees）、 百分度（gradians）、弧度（radians）或圈数（turns）。在 gradient 和 transform 的某些方法等场景中有所应用。 deg度。一个完整的圆是 360deg。例：0deg，90deg，14.23deg。 grad百分度。一个完整的圆是 400grad。例：0grad，100grad，38.8grad。 rad弧度。一个完整的圆是 2π 弧度，约等于 6.2832rad。1rad 是 180/π 度。例：0rad，1.0708rad，6.2832rad。 turn圈数。一个完整的圆是 1turn。例：0turn，0.25turn，1.2turn。 cusor（各属性使用的场景）not-allowed提示禁用状态，如按钮禁用、禁止拖动123:disabled, [disabled], [aria-disabled=&quot;true&quot;] &#123; cursor: not-allowed;&#125; none隐藏鼠标光标，如播放视频等1234video &#123; cursor: url(transparent.gif); // 兼容 cursor: none;&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一些有趣的repo]]></title>
    <url>%2F2018%2F%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84repo.html</url>
    <content type="text"><![CDATA[大量开源项目hellogithub 轮子awesome-javascript前端常用插件、工具类库汇总Web开发前端模版美化代码-prettierWeb技术的终端交互式地图剪贴板html的head标签CSS-Hover.css视差滚动库轻量级富文本编辑器markDown生成流程图marked键盘事件库-hotkeys实现数字增长动画-countUp.jsWeb水印搭建标准的js库jslib-basedraggable表格发布订阅模式-EventEmitter同构fetch不蒜子文件上传uppy 微信小程序开发框架vue风格mpvuevue风格wepyreact风格taro React相关react-hoverautobind-decoratorreact-helmetreact-loadablereact-content-loaderreact-lazyloadreact-slickawesome-reactreact-component-listReact-Clipboardreact-dnd-html5-backendreact-dndreact-highlight-words 图标Font-Awesome Git（Commit规范）commitizencommitlinthusky 页面生产图片html2canvasdom-to-imagerasterizeHTML.js 动画Animate.css演示文稿-reveal.js演示文稿-impress.jsanimate-textpdf.js轮播器-swiper 图表库EChartsBizChartsAntVChart 游戏phaser 数学库mathjsbig.jsTheoremJS数学公式库-KaTeX best-resume-ever用Vue和LESS简单、快速建立许多漂亮的简历，并创建你最好的简历。best-resume-ever css知识You-need-to-know-css Web性能测试工具hiper Web页面加载进度条nprogressnanobar UI库阅文-lulu（jQuery） 常用的网址码点查询大全 CSS实现各种形状CSS实现各种形状 屏幕录制屏幕录制-LICEcapmac-屏幕录制giphy capture 代码gitignoregitignore 时间处理momentdate-fnsdayjs 抓取工具Wireshark、Fiddler、Charles、Postman 数据库Navicat for mysql]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>优秀项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome调试]]></title>
    <url>%2F2018%2FChrome%E8%B0%83%E8%AF%95.html</url>
    <content type="text"><![CDATA[记录Chrome DevTools比较少用但又很重要的技巧。 检查动画使用Chrome DevTools Animations(动画)检查器检查和修改动画。功能：通过打开Animation Inspector(动画检查器)捕获动画。它会自动检测动画并将它们分组。通过减慢动画，重播动画，或查看源代码，来检查动画。通过更改动画的时间，延迟，持续时间或关键帧偏移来修改动画。 设置DOM断点设置DOM断点可以用来调试复杂的JavaScript应用程序。例如，如果你的JavaScript改变了DOM元素的样式，设置一个DOM断点当元素的属性被修改时触发。在以下DOM更改都会触发断点：子树的变化，属性改变，节点删除。设置DOM断点Elements –&gt; Break on –&gt; Subtree Modifications/Attributes Modifications/Node Removal查看DOM断点（包含断点类型）Elements –&gt; DOM Breakpoints 查看元素事件监听器在Event Listeners(事件侦听器)窗格中查看与DOM节点相关联的JavaScript事件。查看事件Elements –&gt; Event Listeners当取消勾选Framework listeners(框架侦听器)复选框时，事件侦听器代码可能会解析框架或库代码中的某处。 模拟传感器Main menu –&gt; More Tools –&gt; Sensors模拟地理位置坐标以测试地理位置覆盖。模拟设备方向来测试加速计数据。 在XHR上中断有两种方法可以触发XHR上的断点：当任何XHR到达XHR生命周期的某个阶段时（readystatechange，load等），或者当XHR的URL与某个字符串匹配时。 调试杂项命名函数可以提高调用堆栈的可读性，不限于回掉函数。 把第三方代码放入Blackbox(黑箱)例如第三方库：jQuery、React等1.打开 DevTools Settings(设置)。2.在左侧的导航菜单中，单击Blackboxing(黑箱)。3.点击Add pattern…(添加模式)按钮。4.在Pattern(模式)文本框输入您希望从调用堆栈中排除的文件名模式。DevTools 会排除该模式匹配的任何脚本。5.在文本字段右侧的下拉菜单中，选择Blackbox(黑箱)以执行脚本文件但是排除来自调用堆栈的调用，或选择6.Disabled(禁用)来阻止文件执行。7.点击 Add(添加) 保存。下次运行页面并触发断点时，DevTools 将在Call Stack(调用堆栈)中隐藏任何来自放入黑盒脚本函数的调用。把第三方代码放入Blackbox管理线程执行使用Sources(源文件)面板上的Threads(线程)窗格暂停，step into(步入)，并检查其他线程，例如service worker 或 web worker 线程。 启动 JavaScript CPU 状态分析启动一个JavaScript CPU 状态分析，可以添加一个可选标签名。要停止分析，请调用console.profileEnd()。每个分析结果都将添加到Profiles(分析)面板。console.profile([label])console.profileEnd();在调用该方法的地方打印堆栈跟踪。console.trace(object) 监听事件monitorEvents()方法指示DevTools记录指定目标事件的信息。monitorEvents(document.body, “click”);要停止监听事件，请调用unmonitorEvents()方法,传递一个停止监视对象的参数。unmonitorEvents(document.body);查看在对象上注册事件监听器getEventListeners() API返回在指定对象上注册事件的监听器。返回值是一个对象，其中包含每个已注册事件类型的数组（例如，click 或 keydown）。 每个数组的成员都是对象，描述每中类型的已注册监听器。 # Chrome 滚动截屏Chrome 截全屏（PC） 打开控制台 Alt + Command+ I (Mac) 或 Ctrl + Shift + I (Windows) 功能搜索 Command + Shift + P(Mac) 或 Ctrl + Shift + P (Windows) 输入“Screen” 并选择 Capture full size screenshot 功能即可 Chrome 截全屏（移动端）只需在 toggle device toolbar 选择移动端进行上面2的操作即可 部分截屏只需在选择对应的DOM基础上进行上面2的操作即可如何利用 Chrome 浏览器实现滚动截屏 Chrome 模拟移动端降低CPU及网速Performance -&gt; setting -&gt; CPU/Network 参考文档：参考]]></content>
      <categories>
        <category>调试</category>
      </categories>
      <tags>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web知识]]></title>
    <url>%2F2018%2FWeb%E6%9C%AF%E8%AF%AD.html</url>
    <content type="text"><![CDATA[本文所有知识点，点到即止，详细内容请看各部分的连接。 点击穿透（多见于移动端模态框等浮层）产生：上层元素触发touch事件-&gt;上层元素消失（300ms之内）-&gt;底层元素click事件触发PS：touch事件之后会有300ms延迟在执行click事件是因为，在这300ms中若再次tap行为则认定为double tap事件，否则就触发click事件。方案：只用touch事件、只用click事件（不推荐）、fastclick类库等点击穿透原理及解决 CSP（内容安全策略Content-Security-Policy）定义：内容安全策略 (Content Security Policy) 是一个附加的安全层，用于帮助检测和缓解某些类型的攻击，包括跨站脚本 (XSS) 和数据注入等攻击。CSP 策略指令 CORS定义：CORS (跨域资源共享)是一个系统, 包括传输的 HTTP headers, 其确定是否阻止或完成从该资源所在的域外的另一个域的网页上的受限资源的请求。PS：同源安全策略( same-origin security policy)默认禁止“跨域”请求. CORS 给予Web服务器跨域访问控制, 启用安全的跨域数据传输。CORS BFC（块格式化上下文Block Formatting Context）定义：块格式化上下文（Block Formatting Context）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。如何触发BFC：• html 根元素；• float 的值不为 none；• overflow 的值为 auto、scroll 或 hidden；• display 的值为 table-cell、table-caption 和 inline-block 中的任何一个；• position 的值不为 relative 和 static。 块格式化上下文 CRLFCRLF实际上是两个字符：CR是Carriage Return（ASCII 13，\r），LF是Line Feed（ASCII 10，\n）。\r\n这两个字符是用于表示换行的，其十六进制编码分别为 0x0d、0x0a。 containing block（包含块）定义：在 CSS2.1 中，很多框的定位和尺寸的计算，都取决于一个矩形的边界，这个矩形，被称作是包含块( containing block )。PS：主要作用是以百分比（相关于包含块）计算自身的width、height、top、left、padding、margin等css Layout 属性。我所了解的CSS包含块 FOUC（无样式内容闪烁Flash Of Unstyled Content）定义：指的是加载网页时出现的短暂的CSS样式失效。方案：head头部放css、避免使用importFOUC Hack定义：由于不同的浏览器对CSS的支持程度不同，同样CSS的样式代码在不同浏览器当中的表现可能出现不一致。为了让所有浏览器样式统一，有时需要为某种浏览器设置不同于其他浏览器的“专属样式”。方案：属性前缀法、选择器前缀法、条件注释法（） Domain Name（域名）域名（英语：Domain Name），简称域名、网域，是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。顶级域名又称为跟域名（TLD）共1058+（.com、.net、.cn等等）13个根域名服务器（不代表只有13台服务器，事实上517+台服务器） DNS（网域名称系统Domain Name System）网域名称系统（DNS，Domain Name System，有时也简称为域名）是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP地址数串。 a链接问题a链接使用绑定 mousedown 事件且 event.preventDefault() 会导致 :active 伪类失效（Firefox）。PS：Firefox 认为 mousedown 事件在 :active 之前发生。 min-width、max-width、width、!important优先级如果min-width、max-width、width、!important同时存在时，优先级顺序：min-width &gt;&gt; max-width &gt;&gt; !important &gt;&gt; width 巧用css 兄弟选择器（如导航分割线）123456789&lt;a href=&quot;&quot;&gt;登录&lt;/a&gt;&lt;a href=&quot;&quot;&gt;注册&lt;/a&gt;// 这样排除第一个元素a + a:before &#123; content: &quot;&quot;; font-size: 0; padding: 10px 3px 1px; margin-left: 6px; border-left: 1px solid gray;&#125; img 在firefox和其他浏览器的差异12345img &#123; // width 和 height 无效，需要设置display: inline-block; width: xx; height: xx;&#125; 关于百分比设置下列属性left（right）、width、padding、margin、background-position、text-index设置值为百分比时，其计算基准为包含块的width值top（bottom）、height设置值为百分比时，其计算基准为包含块height值 滚动容器底部留白滚动容器底部留白使用 margin-bottom，使用 padding-bottom 存在兼容性问题。 margin 合并（只存在垂直方向） 相邻兄弟元素 margin 合并。 父级和第一个、父级和最后一个子元素。（虽然是在子元素上设置的 margin-top，但实际上就等同于在父元素上设置了 margin-top） 空块级元素的 margin 合并。 PS：合并规则，正正取大值，正负值相加，负负最小值。 margin: auto;的理解margin: auto; 表示对剩余空白进行分配。下面元素 .son 的 margin-left 为 300 - 200 -80 = 20px12345678.father &#123; width: 300px;&#125;.son &#123; width: 200px; margin-right: 80px; margin-left: auto; // 20px&#125; 使用 margin 来进行 right 对齐12345678.father &#123; width: 300px;&#125;.son &#123; width: 200px; margin-left: auto; // 此时 auto 值为100px // flot: right; 等价&#125; PS：块级元素的左中右对齐使用 margin ，内联元素使用 text-align 控制左中右对戏。水平和垂直居中12345678910.father &#123; width: 300px; height:150px; position: relative;&#125;.son &#123; position: absolute; // 很关键 top: 0; right: 0; bottom: 0; left: 0; width: 200px; height: 100px; margin: auto; // 很关键&#125; border 的一些秘密border-width 不支持百分比值（outline、box-shadow、text-shadow同样）border-style:double 至少 3px 才有效果。border-style:dashed 不同浏览器不一致（虚线颜色区的宽高比以及颜色区和透明区的宽度比例），如chrome上为方形ie为圆形。thin（1px）、medium（默认值3px）、thick（4px）。 border 技巧等腰三角形123456div &#123; width: 0; border-width: 10px 20px; border-style: solid; border-color: #f30 transparent transparent;&#125; 直角三角形123456div &#123; width: 0; border-width: 10px 20px; border-style: solid; border-color: #f30 #f30 transparent transparent;&#125; 边框 3D 效果12345div &#123; width: 10px; height: 10px; border: 10px solid; border-color: #f30 #00f #396 #0f0;&#125; 等高布局 css 度量单位 ex相对长度单位。相对于字符“x”的高度。通常为字体高度的一半。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。作用：基于ex单位的天然垂直居中对齐效果 行距行距 = line-height - font-size line-height:1.5、line-height:150%和 line-height:1.5em 表现一样，为什么重置css时只能用第一种呢？因为继承细节有所差别，如果使用数值作为 line-height 的属性值，那么所有的子元素继承的都是这个值（如1.5）；但是，如果使用百分比值或者长度值作为属性值，那么所有的子元素继承的是最终的计算值（16px*150%=24px，此时继承的就是24px这个值，不是150%）。 vertical-align作用：只能应用于内联元素以及 display 值为 table-cell 的元素。定义：该属性定义行内元素的基线相对于该元素所在行的基线的垂直对齐。线类，如 baseline（默认值）、top、middle、bottom；文本类，如 text-top、text-bottom；上标下标类，如 sub、super；数值百分比类，如 20px、2em、20%等PS：其实middle为基线往上 1/2 x-height 处（ x-height 为 x 的高度） 消除图片下间隙 display:block; vertical-align:top; // top，text-top，bottom，text-bottom 均可 font-size:0; // 父级设置 overflow:hidden; float:left; CSS图片下面产生间隙的6种解决方案 float规范约定了浮动元素和内联元素在一行显示。浮动元素会生成一个块级框，而不论它本身是何种元素。 clip属性fixed 固定定位的剪裁最佳可访问性隐藏（clip: rect(0,0,0,0)） stacking context（层叠上下文）层叠上下文，英文称作 stacking context，是 HTML 中的一个三维的概念。 层叠水平（stacking level)（逐渐升高） 层叠上下文（background/border） – 充当背景色 负的z-index block块状水平盒子 – 布局 float浮动盒子 inline水平盒子（inline/inline-block/inline-table） – 内容 z-index:anto 或 看成 z-index:0 正的z-index 一般情况都会满足满足上面的规则，详情可以看下面demo： See the Pen stackingContext by 余真帆 (@fanerge) on CodePen. 如何触发一个元素形成堆叠上下文？ 根元素 (HTML), z-index 值不为 “auto”的 绝对/相对定位， 一个 z-index 值不为 “auto”的 flex 项目 (flex item)，即：父元素 display: flex|inline-flex， opacity 属性值小于 1 的元素（参考 the specification for opacity）， transform 属性值不为 “none”的元素， mix-blend-mode 属性值不为 “normal”的元素， filter值不为“none”的元素， perspective值不为“none”的元素， isolation 属性被设置为 “isolate”的元素， position: fixed 在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值 -webkit-overflow-scrolling 属性被设置 “touch”的元素 PS：使用了上述属性就会形成一个stacking context（堆叠上下文）。此时，要对两者进行层叠排列，就需要 z-index ，z-index 越高的层叠层级越高。做了一个上述情况的demo： See the Pen stackingContext2 by 余真帆 (@fanerge) on CodePen. 层叠顺序与堆栈上下文知多少 requestIdleCallbackwindow.requestIdleCallback()会在浏览器空闲时期依次调用函数， 这就可以让开发者在主事件循环中执行后台或低优先级的任务，而且不会对像动画和用户交互这样延迟触发而且关键的事件产生影响。函数一般会按先进先调用的顺序执行，除非函数在浏览器调用它之前就到了它的超时时间。你应该知道的requestIdleCallback 敏捷开发的原则编辑快速迭代相对那种半年一次的大版本发布来说，小版本的需求、开发和测试更加简单快速。一些公司，一年发布仅2~3个版本，发布流程缓慢，它们仍采用瀑布开发模式，更严重的是对敏捷开发模式存在误解。 让测试人员和开发者参与需求讨论需求讨论以研讨组的形式展开最有效率。研讨组，需要包括测试人员和开发者，这样可以更加轻松定义可测试的需求，将需求分组并确定优先级。 同时，该种方式也可以充分利用团队成员间的互补特性。如此确定的需求往往比开需求讨论大会的形式效率更高，大家更活跃，参与感更强。 编写可测试的需求文档开始就要用“用户故事”（User Story）的方法来编写需求文档。这种方法，可以让我们将注意力放在需求上，而不是解决方法和实施技术上。过早的提及技术实施方案，会降低对需求的注意力。 多沟通，尽量减少文档任何项目中，沟通都是一个常见的问题。好的沟通，是敏捷开发的先决条件。在圈子里面混得越久，越会强调良好高效的沟通的重要性。团队要确保日常的交流，面对面沟通比邮件强得多。 做好产品原型建议使用草图和模型来阐明用户界面。并不是所有人都可以理解一份复杂的文档，但人人都会看图。 及早考虑测试及早地考虑测试在敏捷开发中很重要。传统的软件开发，测试用例很晚才开始写，这导致过晚发现需求中存在的问题，使得改进成本过高。较早地开始编写测试用例，当需求完成时，可以接受的测试用例也基本一块完成了。]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dom接口]]></title>
    <url>%2F2018%2Fdom%E6%8E%A5%E5%8F%A3.html</url>
    <content type="text"><![CDATA[CustomEvent创建一个自定义事件。1234567// 添加一个适当的事件监听器obj.addEventListener(&quot;cat&quot;, function(e) &#123; process(e.detail) &#125;)// 创建一个自定义事件var event = new CustomEvent(&quot;cat&quot;, &#123;&quot;detail&quot;:&#123;&quot;hazcheeseburger&quot;:true&#125;&#125;)// 分发事件obj.dispatchEvent(event) DocumentFragmentDocumentFragment 接口表示一个没有父级文件的最小文档对象。DocumentFragment不是真实DOM树的一部分，它的变化不会引起DOM树的重新渲染的操作(reflow) ，且不会导致性能等问题。 创建一个DocumentFragment123456789101112131415let ul = document.querySelector(`[data-uid=&quot;ul&quot;]`);let frag = document.createDocumentFragment();const list = [ &apos;IE&apos;, &apos;Chrome&apos;];list.forEach(item =&gt; &#123; let li = document.creteElement(&apos;li&apos;); li.textContent = item; frag.appendChild(li);&#125;);// 只进行一次dom操作，触发一次reflowul.appendChild(frag);``` ## 其他方法（实例方法） documentFragment.find()返回 DocumentFragment 树里第一个匹配的元素 Element 。documentFragment.findAll()返回 DocumentFragment 树里所有匹配的元素 NodeList。documentFragment.querySelector()documentFragment.querySelectorAll()documentFragment.getElementById()12345678910# MutationObserver给开发者们提供了一种能在某个范围内的DOM树发生变化时作出适当反应的能力.该API设计用来替换掉在DOM3事件规范中引入的Mutation事件.## 实例方法observe()给当前观察者对象注册需要观察的目标节点,在目标节点(还可以同时观察其后代节点)发生DOM变化时收到通知.disconnect()让该观察者对象停止观察指定目标的DOM变化.即使再次调用其observe()方法,该观察者对象包含的回调函数都不会再被调用.takeRecords()清空观察者对象的记录队列,并返回里面的内容.## 示例 let target = document.querySelector(‘#some-id’); // 创建观察者对象let observer = new MutationObserver(function(mutations) { mutations.forEach(function(mutation) { console.log(mutation.type); });}); // 配置观察选项:let config = { attributes: true, childList: true, characterData: true } // 传入目标节点和观察选项observer.observe(target, config); // 随后,你还可以停止观察observer.disconnect();```]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git工具书]]></title>
    <url>%2F2018%2Fgit%E5%B7%A5%E5%85%B7%E4%B9%A6.html</url>
    <content type="text"><![CDATA[工作原理图片来源Git 常用操作总结PS：Workspace：工作区Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库 基本操作git托管项目（新建 or clone一个git项目）mkdir gitdemo // 在当前目录创建gitdemo目录cd gitdemopwd // 显示当前目录git init // 将当前目录设置为git管理的仓库git init [projectName] // 新建一个目录，将其初始化为Git代码库orgit clone [ssh/https] 工作区&gt;&gt;暂存区（add为添加文件rm为移除文件）git add [fileName] // 单个或多个文件git add *.js // 通配符git add -u // 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)git add . // 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件git add -A // 提交所有变化（是git add .和git add -u的结合，git add -all的简写 git rm [file1] [file2] // 删除工作区文件，并且将这次删除放入暂存区git rm --cached [fileName] // 停止追踪指定文件，但该文件会保留在工作区git mv [fileNameOld] [fileNameNew] // 改名文件，并且将这个改名放入暂存区 暂存区&gt;&gt;本地仓库git commit -m ‘说明信息’ // 提交git commit -am ‘说明’ // git add . 和 git commit的简写（一次完成两个动作）常用commit type feat: 新功能 fix: 修复问题 docs: 修改文档 style: 修改代码格式，不影响代码逻辑 refactor: 重构代码，理论上不影响现有功能 perf: 提升性能 test: 增加修改测试用例 chore: 修改工具相关（包括但不限于文档、代码生成等） 本地仓库&gt;&gt;远程仓库git push ssh://git@dev.fanerge.com/gitdemo.git master // 把本地仓库提交到远程仓库的master分支中git push -u origin master // 当前分支提交到远程 master 分支git push // 如果当前分支与远程分支存在追踪关系 远程仓库&gt;&gt;本地仓库git fetch [远程主机名] [分支名] // 远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地git fetch origin mastergit clone [ssh/https]// 从远程主机克隆一个版本库更详细的资料 远程仓库&gt;&gt;工作区git pull [远程主机名] [远程分支名]:[本地分支名] // 远程主机某个分支的更新，再与本地的指定分支合并git pull // 当前分支只有一个追踪分支时可省略部分参数 分支操作查看分支git branch // 查看本地所有分支（*表示当前分支）git branch -v // 查看本地所有分支及最近一次提交信息git branch -vv // 查看本地所有分支及最近一次提交信息和远程追踪分支git branch -r // 查看远程所有分支git branch -a // 查看本地/远程所有分支 切换分支git checkout [branchName] // 切换分支git checkout - // 切换到上一个分支 新建分支git branch [branchName] // 新建一个分支（但仍然留在当前分支）git checkout -b [branchName] // 新建一个分支（并切换到该分支）git branch [branchName] [commitId] // 新建一个分支（并指向指定的commitId）git branch --track [branchName] [remoteBranchName] //新建一个分支（并指定与远程分支的追踪关系）如：新建 test 分支，并指向远程的 orign/dev 分支git branch --track test origin/dev 新建远程分支（新建本地分支，推送的远程作为远程分支）git branch [branchName]git push origin [branchName]:[remoteBranchName]还需要为新建本地分支和远程分支建立追踪关系如：本地的 test 分支作为远程的 dev 分支git push origin test:dev 建立追踪关系（当前分支和远程分支）作用：用来描述当前和远程分支的位置关系，在使用git pull 和 git push 的时候可以省略远程参数git branch --track [branchName] [remoteBranchName] //新建一个分支（并指定与远程分支的追踪关系）git branch –-set-upstream-to=origin/[branchName]如：当前分支和远程 dev 分支建立追踪关系git branch –-set-upstream-to=origin/dev 合并分支（branchName合并到当前分支）git merge [branchName]git rebase [branchName]PS：git merge dev（当前分支为master）会在 master 分支产生一个新的commit。git rebase dev（当前分支为master）会将master上的提交推至顶端。 删除分支（本地）git branch -d [branchName] // 删除分支（本地）git push origin --delete [branchName] // 删除分支（远程）git branch -dr [remoteBranchName] // 删除分支（远程） 标签管理tag作用类似于里程碑，可以快速找到里程碑的代码。 查看所有taggit tag 新建tag在当前commitgit tag [tagName] 新建一个tag在指定commitgit tag [tagName] [commitId] 删除本地taggit tag -d [tagName] 删除远程taggit push origin :refs/tags/[tagName] 查看tag信息git show [tagName] 向远程提交指定taggit push [remoteBranchName] [tagName] 新建一个分支，指向某个taggit checkout -b [branchName] [tagName] 查看信息显示有变更的文件git status 显示当前分支的版本历史git log 显示当前分支的版本历史（包括commit发生变更的文件）git log –stat 显示当前分支的版本历史（通过关键词）git log -S [keyword] 显示某个commit之后的所有变动，每个commit占据一行git log [tagName] HEAD –pretty=format:%s 显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件git log [tagName] HEAD –grep feature 显示某个文件的版本历史，包括文件改名git log –follow [fileName]git whatchanged [fileName] 显示指定文件相关的每一次diffgit log -p [fileName] 显示过去5次提交git log -5 –pretty –oneline 显示所有提交过的用户，按提交次数排序git shortlog -sn 显示指定文件是什么人在什么时间修改过git blame [file] 显示暂存区和工作区的差异git biff 显示暂存区和上一个commit的差异git diff –cached [fileName] 显示工作区与当前分支最新commit之间的差异git diff HEAD 显示两次提交之间的差异git diff [first-branch]…[second-branch] 显示今天你写了多少行代码git diff –shortstat “@{0 day ago}” 显示某次提交的元数据和内容变化git show [commitId] 显示某次提交发生变化的文件git show –name-only [commitId] 显示某次提交时，某个文件的内容git show [commitId]:[fileName] 显示当前分支的最近几次提交git reflog 远程同步下载远程仓库的所有变动git fetch [ssh/https] 显示所有远程仓库（包括fetch和push地址）git remote -v 显示某一远程仓库的信息git remote show [remoteRepositoryName] 增加一个新的远程仓库，并命名git remote add [shortname] [url] 取回远程仓库的变化，并与本地分支合并（merge）git pull [remote] [remoteBranchName]PS：remote 一般为 origin ，当建立追踪关系，可以git pull 省略两个参数 上传本地指定分支到远程仓库git push [remote] [branchName] 强行推送当前分支到远程仓库，即使有冲突git push [remote] –force 推送所有分支到远程仓库git push [remote] –all 撤销/恢复撤销工作区修改（指定文件）git chekout – [fileName] 撤销工作区（所有文件）git checkout – . 暂存区–&gt;工作区（指定文件）git reset HEAD [fileName] // 撤销暂存区的修改git checkout [fileName] // 撤销工作区的修改 重置暂存区到上次提交commit（工作区不变）git reset [fileName] 重置暂存区、工作区到上次提交commitgit reset –hardgit reset HEAD^ –hard // 回到上一次commitgit reset HEAD^^ –hard // 回到上一次的上一次commit 重置暂存区、当前分支指定commitId（工作区不变）git reset [commitId] 重置暂存区、工作区、当前分支为指定commitIdgit reset –hard [commitId] 重置当前HEAD为指定commitId（暂存区、工作区不表）git reset –keep [commitId] 新建一个commitId，用来撤销指定commitId（后者的所有变化都将被前者抵消，并且应用到当前分支）git revert [commitId] 暂时将未提交的变化存于stash，后续再从stash中取出git stash list // 查看 stash 列表git stash // 保存当前暂未提交的修改git stash apply // 从stash中恢复，但不清除该stashgit stash drop // 清除该stashgit stash pop // 从stash中恢复并清除该stashPS：一般用于停下手中活，处理更加紧急的任务，处理完任务后在回过头继续。git stash pop = git stash apply + git stash drop 开发分支合并到master分支更新与2018-07-17git rebase的作用用于增删改当前 commits ，并将其合并到对应分支。适用于：dev分支有开发，master分支其他人有合并，合并时需要以最新的master分支作为基础合并。假如在dev分支开发完毕需要合并时： git checkout dev // 确保在你所在的开发分支如dev git rebase master 如果有冲突，解决冲突 git rebase --continue git checkout master // 回到master分支，进行合并 git merge dev git：rebase（变基）的使用和理解 如何将fork别人的库与原项目同步呢更新于2018-09-12 在fork库中添加上游代码库的 remote 源git remote add {upstream} git@github.com:xxx/xxx.git 将本地的修改提交commit 在每次PR前，做如下操作即可与上游{upstream}同步git remote update upstreamgit rebase upstream/{branch name} 如：git rebase upstream/dev Push 代码git push origin dev vimVim共有3种模式编辑模式(命令模式)-默认模式输入模式末行模式 各种模式的切换编辑–&gt;输入 i: 在当前光标所在字符的前面，转为输入模式； a: 在当前光标所在字符的后面，转为输入模式； o: 在当前光标所在行的下方，新建一行，并转为输入模式； I：在当前光标所在行的行首，转换为输入模式 A：在当前光标所在行的行尾，转换为输入模式 O：在当前光标所在行的上方，新建一行，并转为输入模式； 输入–&gt;编辑ESC 编辑–&gt;末行: 末行–&gt;编辑ESC, ESC 关闭文件1、末行模式关闭文件:q 退出:wq 保存并退出:q! 不保存并退出:w 保存:w! 强行保存:wq –&gt; :x2、编辑模式下退出ZZ: 保存并退出 参考文档：git 官网常用 Git 命令清单Git教程]]></content>
      <categories>
        <category>代码管理</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js算法集合]]></title>
    <url>%2F2018%2Fjs%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88.html</url>
    <content type="text"><![CDATA[判断文本是否为回文定义：如果将一个文本翻转过来，能和原文本完全相等，那么就可以称之为“回文”。 方法一（字符串、数组内置方法）123456789101112131415/** 判断文字是否为回文* @param &#123;string|number&#125; val 需要判断的文字* @return &#123;boolean&#125; bool 是否为回文 */function isPalindrome1(val)&#123; // 允许输入字符串和数字和布尔值 if (typeof val !== &apos;string&apos;) val = val.toString(); let newVal = val.split(&apos;&apos;).reverse().join(&apos;&apos;); return val === newVal;&#125;isPalindrome1(121) // trueisPalindrome1(&apos;yuzuy&apos;) // true // PS：方法简单，但效率不高，会产生一个新的变量 方法二（循环）1234567891011121314151617181920/** 判断文字是否为回文* @param &#123;string|number&#125; val 需要判断的文字* @return &#123;boolean&#125; bool 是否为回文 */function isPalindrome2(val)&#123; val = val + &apos;&apos;; // 非字符串转化为字符串 // 这里为什么 i &lt;= j 呢？如果中间只有一个字符，是不需要比较的，它肯定等于它本身！！！ for(let i = 0, j = val.length - 1; i &lt; j; i++, j--)&#123; if(val.charAt(i) !== val.charAt(j))&#123; return false; &#125; &#125; return true;&#125;isPalindrome2(121) // trueisPalindrome2(&apos;yuzuy&apos;) // true PS：网上还有其他解法，大多为以上两种的变形。 反转字符串方法一（字符串、数组内置方法））借用反转字符串的方法12345678910/** 反转字符串* @param &#123;string&#125; val 需要反转的字符串* @return &#123;string&#125; str 反转后的字符串*/function reverseVal1(val)&#123; if (typeof val !== &apos;string&apos;) return; return val.split(&apos;&apos;).reverse().join(&apos;&apos;);&#125; 方法二（循环）循环系列1234567891011121314151617181920212223242526272829303132333435/** 反转字符串* @param &#123;string&#125; val 需要反转的字符串* @return &#123;string&#125; str 反转后的字符串*/function reverseVal2(val)&#123; if (typeof val !== &apos;string&apos;) return; let str = &apos;&apos;, i = 0, len = val.length; while(i &lt; len)&#123; str += val.charAt(len - 1 - i); i++; &#125; return str;&#125;/** 反转字符串* @param &#123;string&#125; val 需要反转的字符串* @return &#123;string&#125; str 反转后的字符串*/function reverseVal3(val)&#123; if (typeof val !== &apos;string&apos;) return; let str = &apos;&apos;, len = val.length; for(let i = len - 1; i &gt;= 0; i--)&#123; str += val.charAt(i) &#125; return str;&#125; 测试：reverseVal(‘abc’) // ‘cba’ 阶乘方法一（递归）123456789101112/** 阶乘* @param &#123;number&#125; n 需要求的阶乘* @return &#123;number&#125; 阶乘值*/function factorialize1(n)&#123; if(typeof n !== &apos;number&apos;) throw new Error(&apos;参数必须为整整&apos;) if(n === 1) return 1; // 建议不要使用 arguments.callee，目前已经废弃了。 return n * factorialize1(n - 1);&#125; PS：上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。 方法二（ES6尾调用优化）（递归优化版）123456789101112/** 阶乘* @param &#123;number&#125; n 需要求的阶乘* @return &#123;number&#125; 阶乘值*/function factorialize2(n, total = 1)&#123; if(typeof n !== &apos;number&apos; || typeof total !== &apos;number&apos;) throw new Error(&apos;参数必须为整整&apos;) if(n === 1) return total; return factorialize2(n - 1, n * total) // f(3) =&gt; f(2, 3 * 2) =&gt; f(1, 6) =&gt; 6&#125; PS：ES6尾调用优化但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。 方法三（循环）1234567891011121314151617/** 阶乘* @param &#123;number&#125; n 需要求的阶乘* @return &#123;number&#125; 阶乘值*/function factorialize3(n)&#123; if(typeof n !== &apos;number&apos;) throw new Error(&apos;参数必须为整整&apos;) if(n === 1) return 1; let total = 1; while(n&gt;1)&#123; total = n * total; n--; &#125; return total;&#125; 测试：factorialize1(3) // 6 随机生成长度为n字符串方法一123456789101112131415161718/** 生成指定长度的随机字符串* @param &#123;number&#125; n 生成字符串个数* @return &#123;string&#125; str 反转后的字符串*/function randomString1(n)&#123; let str = &apos;abcdefghijklmnopqrstuvwxyz0123456789&apos;; let tem = &apos;&apos;, i = 0; // Math.random 函数产生值的范围[0,1) while(i&lt;n)&#123; tem += str.charAt(Math.floor(Math.random() * str.length)) i++; &#125; return tem;&#125; PS：Math.round(Math.random() (str.length - 1))Math.ceil(Math.random() (str.length - 1))Math.floor(Math.random() * str.length)这三种方式等价，都能生成[0, str.length-1]随机数 方法二（进制转化）12345678/** 生成指定长度的随机字符串* @param &#123;number&#125; n 生成字符串个数* @return &#123;string&#125; 反转后的字符串*/function randomString2(n)&#123; return Math.random().toString(36).substr(2).slice(0, n)&#125; PS：该方法原理为随机产生的数转换为指定进制字符串toString(n)，n为[2,36]，n&lt;=10时只产生0-9也就是10进制数字该方法有个缺点，产生字符串的长度有一定的限制。 方法三（随机码点）1234567891011121314151617181920/** 生成指定长度的随机字符串* @param &#123;number&#125; n 生成字符串个数* @return &#123;string&#125; str 反转后的字符串*/function randomString3(n)&#123; let str = &apos;&apos;; function randomChar()&#123; let l = Math.floor(Math.random() * 62); if(l &lt; 10) return l; // 数字部分 0-9 if(l &lt; 36) return String.fromCharCode(l + 55); // 大写字母 return String.fromCharCode(l + 61); // 小写字母 &#125; while(str.length &lt; n) str += randomChar(); return str;&#125; PS：可以参考对于的ASCII码表。测试：randomString1(3) // ‘1sd’ 数组去重方法一（ES6的Set数据结构）12345678/** 数组去重* @param &#123;array&#125; ary 需要去重的数组* @return &#123;array&#125; 去重后的数组*/function unique1(ary)&#123; return [...new Set(ary)];&#125; 方法二（对象的key唯一性）123456789101112131415161718/** 数组去重* @param &#123;array&#125; ary 需要去重的数组* @return &#123;array&#125; 去重后的数组*/function unique2(ary)&#123; let obj = &#123;&#125;, i = 0, len = ary.length; while(i &lt; len)&#123; if(!obj[ary[i]])&#123; obj[ary[i]] = true; // 如果不存在 &#125; i++; &#125; return Object.keys(obj);&#125; PS：该方法存在一定问题，数组的元素全部被转化为字符串，因为ES6之前对象的key只能是字符串。会把数字1和字符串’1’，会被视为同一个值。 方法三（临时数组判断插入）123456789101112131415161718/** 数组去重* @param &#123;array&#125; ary 需要去重的数组* @return &#123;array&#125; 去重后的数组*/function unique3(ary)&#123; let tem = [], i = 0, len = ary.length; while(i &lt; len)&#123; // tem.indexOf() === -1 同理 !tem.includes(ary[i]) ? tem.push(ary[i]) : &apos;&apos;; i++; &#125; return tem;&#125; 方法四（判断首次出现的位置）如果当前数组的第i项在当前数组中第一次出现的位置不是i，那么表示第i项是重复的，忽略掉。否则存入结果数组。12345678910111213141516/** 数组去重* @param &#123;array&#125; ary 需要去重的数组* @return &#123;array&#125; 去重后的数组*/function unique4(ary)&#123; let tem = [ary[0]], len = ary.length; for(let i = 1; i &lt; len; i++ )&#123; // 核心，首次的索引出现是否为当前的索引 if(ary.indexOf(ary[i]) === i) tem.push(ary[i]); &#125; return tem;&#125; 方法五（排序后逐个比较插入）给传入数组排序，排序后相同值相邻，然后遍历时新数组只加入不与前一值重复的值。123456789101112131415/** 数组去重* @param &#123;array&#125; array 需要去重的数组* @return &#123;array&#125; 去重后的数组*/function unique5(array)&#123; let ary = array.slice(); ary.sort(); let tem = [ary[0]]; for(let i = 0, len = ary.length; i &lt; len; i++)&#123; ary[i] !== tem[tem.length - 1] ? tem.push(ary[i]) : &apos;&apos;; &#125; return tem;&#125; PS：返回的数组顺序发生了改变。 方法六获取没有重复的最右一值放入新数组（检测到有重复值时终止当前循环同时进入顶层循环的下一轮判断）。12345678910111213141516/** 数组去重* @param &#123;array&#125; ary 需要去重的数组* @return &#123;array&#125; 去重后的数组*/function unique6(ary)&#123; let tem = []; for(let i = 0, len = ary.length; i &lt; len; i++)&#123; for(let j = i + 1; j &lt; len; j++)&#123; if(ary[i] === ary[j]) j = ++i; &#125; tem.push(ary[i]) &#125; return tem;&#125; 测试：unique1([1, 2, 3, 2]) // [1, 2, 3] 出现次数最多的字符方法一（对象key的唯一性进行累加）123456789101112131415161718192021222324function maxNum1(str)&#123; if(typeof(str) !== &apos;string&apos;) str = str.toString(); let obj = &#123;&#125;, maxChar = []; // 使用数组保存出现最多次的某些字符 str.split(&apos;&apos;).forEach( (val) =&gt; &#123; if(!obj[val])&#123; let demo = obj[val] = 1; &#125;else&#123; obj[val]++; &#125; &#125;) let maxCount = Math.max.apply(null, Object.values(obj)) // forEach方法总是返回 undefined 且 没有办法中止或者跳出 forEach 循环。 Object.entries(obj).forEach( item =&gt; &#123; if(item[1] == maxCount)&#123; maxChar.push(item[0]) &#125; &#125;) return maxChar;&#125; 测试：maxNum1(‘11223333’) // ‘3’ 数组扁平化实现方法：Array.prototype.flatten(depth)，参数depth表示需要扁平化的层数，返回一个新的数组。 方法一（递归遍历数组拼接）123456789101112131415161718function flatten1(ary)&#123; let tem = [], i = 0, len = ary.length; while(i &lt; len)&#123; if(Array.isArray(ary[i]))&#123; // 递归进行上面步骤 // [].concat(...ary)，它的参数可以为数组或值，作用为将数组或值连接成新数组。 tem = tem.concat(flatten1(ary[i])) &#125;else&#123; tem.push(ary[i]); &#125; i++; &#125; return tem;&#125; PS：可以处理多层数组。 方法二（reduce结合concat）1234567function flatten2(ary)&#123; return ary.reduce((pre, cur) =&gt; &#123; return pre.concat(Array.isArray(cur) ? flatten2(cur) : cur) &#125;, []) &#125; PS：可以处理多层数组。 方法三（转化为字符串）12345function flatten2(ary)&#123; return ary.toString().split(&apos;,&apos;)&#125; PS：返回的数组项将为字符串。 方法四（解构数组）12345678910111213function flatten4(ary)&#123; let tem = [] ary.forEach(item =&gt; &#123; if(Array.isArray(item))&#123; tem = tem.concat(...item); &#125;else&#123; tem = tem.concat(item); &#125; &#125;) return tem;&#125; PS：只能处理2维数组。测试：getMaxProfit1([1, 2, 3, [4, 5, 6]]) // [1, 2, 3, 4, 5, 6] 数组中最大差值方法一123function getMaxProfit1(ary)&#123; return Math.max.apply(null, ary) - Math.min.apply(null, ary);&#125; 测试：getMaxProfit1([1, 2, 3, 4]) // 3 斐波那契数列这里我们只实现通项公式 方法一1234567function fib1(n)&#123; if(n === 1 || n === 2)&#123; return 1; &#125; return fib1(n - 1) + fib1(n - 2);&#125; PS：时间复杂度为O(2^n)，空间复杂度为O(n) 方法二12345678910111213function fib2(n)&#123; let tem = [1, 1]; if(n === 1 || n === 2)&#123; return 1; &#125; // 数组索引从0开始，数列索引从1开始 for(let i = 2; i &lt; n; i++)&#123; tem[i] = tem[i-1] + tem[i-2]; &#125; return tem[n-1];&#125; PS：时间复杂度为O(n)，空间复杂度为O(n) 方法三123456789101112function fib2(n)&#123; let prev = 1, next = 1, res; for(let i = 2; i &lt; n; i++)&#123; res = prev + next; prev = next; next = res; &#125; return res;&#125; PS：时间复杂度为O(n)，空间复杂度为O(1)测试：fib2(3) // 2 判断是否为质数（prime number）素数质数：只能被1和自己整除且大于1的数。合数：数大于1且因数多余2个（大于1的数质数的补集）。 方法一（循环）123456789101112function isPrimeNumber1(n)&#123; if(n &lt; 2) return false; if(n === 2) return true; // 最小的质数 for(let i = 2; i &lt; n; i++)&#123; if(n % i === 0)&#123; return false; &#125; &#125; return true;&#125; 测试：isPrimeNumber1(2) // true 方法二（正则）123function isPrimeNumber1(n)&#123; return n&lt;2?false:!/^(11+?)\1+$/.test(Array(n+1).join(&apos;1&apos;))&#125; PS：该方法很巧妙，于2018-04-25在掘金上发现。方法详解 最小公约数12345678910111213141516171819202122232425262728function greatestCommonDivisor1(a, b)&#123; if(a &lt; 0 || b &lt; 0) throw new Error(&apos;参数只能为正整数&apos;); if(a &lt; 2 || b &lt; 2) return 1; let min = a, max = b, arymin = []; if(a &gt; b) &#123; min = b; max = a; &#125; for(let i = 1; i &lt;= min; i++)&#123; if(min % i === 0)&#123; arymin.push(i); console.log(1) &#125; &#125; arymin.reverse(); for(let j = 0, len = arymin.length; j &lt; len; j++)&#123; if(max % arymin[j] === 0)&#123; return arymin[j]; &#125; &#125;&#125; 测试：greatestCommonDivisor1(5, 10) // 5 金额转大写12345678910111213141516function money2Chinese(num) &#123; if(typeof num) throw new Error(&apos;参数为数字&apos;) let strOutput = &quot;&quot; let strUnit = &apos;仟佰拾亿仟佰拾万仟佰拾元角分&apos; num += &quot;00&quot; const intPos = num.indexOf(&apos;.&apos;) if (intPos &gt;= 0) &#123; num = num.substring(0, intPos) + num.substr(intPos + 1, 2) &#125; strUnit = strUnit.substr(strUnit.length - num.length) for (let i = 0; i &lt; num.length; i++) &#123; strOutput += &apos;零壹贰叁肆伍陆柒捌玖&apos;.substr(num.substr(i, 1), 1) + strUnit.substr(i, 1) &#125; return strOutput.replace(/零角零分$/, &apos;整&apos;).replace(/零[仟佰拾]/g, &apos;零&apos;).replace(/零&#123;2,&#125;/g, &apos;零&apos;).replace(/零([亿|万])/g, &apos;$1&apos;).replace(/零+元/, &apos;元&apos;).replace(/亿零&#123;0,3&#125;万/, &apos;亿&apos;).replace(/^元/, &quot;零元&quot;);&#125; 测试：money2Chinese(1234) // 壹仟贰佰叁拾肆元整]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我所了解的CSS包含块]]></title>
    <url>%2F2018%2F%E4%B8%80%E6%AC%A1%E8%AF%A6%E7%BB%86%E7%9A%84%E5%8C%85%E5%90%AB%E5%9D%97%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[指出错误观念许多开发者认为一个元素的包含块就是他的父元素的内容区，其实这是错误的（至少不完全正确）！一个元素的尺寸和位置经常受其包含块的影响。大多数情况下，包含块就是这个元素最近的祖先块元素的内容区，但也不是总是这样。下面我们看看盒模型：当浏览器展示一个文档的时候，对于每一个元素，它都产生了一个盒子。每一个盒子都被划分为四个区域： 内容区 内边距区 边框区 外边距区 什么是包含块？包含块有分为根元素包含块和其他元素的包含块。 根元素包含块根元素html的包含块是一个矩形,叫做初始化包含块(initial containing block)。可以看到html外面还有空间，这个包含html的块就被称为初始包含块(initial containing block)，它是作为元素绝对定位和固定定位的参照物。对于连续媒体设备（continuous media），初始包含块的大小等于视口viewpor的大小，基点在画布的原点（视口左上角）；对于分页媒体（paged media），初始包含块是页面区域（page area）。初始包含块的direction属性与根元素的相同。 其他元素的包含块大多数情况下，包含块就是这个元素最近的祖先块元素的内容区，但也不是总是这样，下面就来学习如何确定这些元素的包含块。 如何确定元素的包含块？确定包含块的过程完全依赖于这个包含块的 position 属性，大致分为下列场景： 如果 position 属性是 static 或 relative 的话，包含块就是由它的最近的祖先块元素（比如说inline-block, block 或 list-item元素）或格式化上下文BFC(比如说 a table container, flex container, grid container, or the block container itself)的内容区的边缘组成的。 如果 position 属性是 absolute 的话，包含块就是由它的最近的 position 的值不是 static （fixed, absolute, relative, or sticky）的祖先元素的内边距区的边缘组成的。 如果 position 属性是 fixed 的话，包含块就是由 viewport (in the case of continuous media) or the page area (in the case of paged media) 组成的。 如果 position 属性是 absolute 或 fixed，包含块也可能是由满足以下条件的最近父级元素的内边距区的边缘组成的：A transform or perspective value other than noneA will-change value of transform or perspectiveA filter value other than none or a will-change value of filter (only works on Firefox). 元素包含块的作用？元素的尺寸和位置经常受其包含块的影响。对于一个绝对定位的元素来说（他的 position 属性被设定为 absolute 或 fixed），如果它的 width, height, padding, margin, 和 offset 这些属性的值是一个比例值（如百分比等）的话，那这些值的计算值就是由它的包含块计算而来的。简单来说，如果某些属性被赋予一个百分值的话，它的计算值是由这个元素的包含块计算而来的。这些属性包括盒模型属性和偏移属性： height, top, bottom 这些属性由包含块的 height 属性的值来计算它的百分值。如果包含块的 height 值依赖于它的内容，且包含块的 position 属性的值被赋予 relative 或 static的话，这些值的计算值为0。 width, left, right, padding, margin, text-indent(2018-05-27修改)这些属性由包含块的 width 属性的值来计算它的百分值。 下面看些例子下面示例公用HTML代码12345&lt;body&gt; &lt;section&gt; &lt;p&gt;This is a paragraph!&lt;/p&gt; &lt;/section&gt;&lt;/body&gt; 示例一CSS代码123456789101112131415161718body &#123; background: beige;&#125;section &#123; display: block; width: 400px; height: 160px; background: lightgray;&#125;p &#123; width: 50%; /* == 400px * .5 = 200px */ height: 25%; /* == 160px * .25 = 40px */ margin: 5%; /* == 400px * .05 = 20px */ padding: 5%; /* == 400px * .05 = 20px */ background: cyan;&#125; 在这里，这个P标签position为默认的static，所以它的包含块为Section标签，通过我们的判断规则一来确定。 示例二CSS代码1234567891011121314body &#123; background: beige;&#125;section &#123; display: inline; background: lightgray;&#125;p &#123; width: 50%; /* == half the body&apos;s width */ height: 200px; /* Note: a percentage would be 0 */ background: cyan;&#125; 在这里，这个P标签position为默认的static且它的父标签Section的display为inline，所以P标签的包含块为body标签，通过我们的判断规则一来确定。 示例三CSS代码123456789101112131415161718192021body &#123; background: beige;&#125;section &#123; transform: rotate(0deg); width: 400px; height: 160px; background: lightgray;&#125;p &#123; position: absolute; left: 80px; top: 30px; width: 50%; /* == 200px */ height: 25%; /* == 40px */ margin: 5%; /* == 20px */ padding: 5%; /* == 20px */ background: cyan;&#125; 在这里，这个P标签position为absolute且它的父标签Section的transform不为none，所以P标签的包含块为Section标签，通过我们的判断规则四来确定。 示例四CSS代码12345678910111213141516171819202122body &#123; background: beige;&#125;section &#123; position: absolute; left: 30px; top: 30px; width: 400px; height: 160px; padding: 30px 20px; background: lightgray;&#125;p &#123; position: absolute; width: 50%; /* == (400px + 20px + 20px) * .5 = 220px */ height: 25%; /* == (160px + 30px + 30px) * .25 = 55px */ margin: 5%; /* == (400px + 20px + 20px) * .05 = 22px */ padding: 5%; /* == (400px + 20px + 20px) * .05 = 22px */ background: cyan;&#125; 在这里，这个P标签position为absolute且它的父标签Section的position不为static，所以P标签的包含块为Section标签的padding边缘算起（前提是不能 box-sizing设置为border-box），通过我们的判断规则二来确定。 示例五CSS代码1234567891011121314151617181920body &#123; background: beige;&#125;section &#123; width: 300px; height: 300px; margin: 30px; padding: 15px; background: lightgray;&#125;p &#123; position: fixed; width: 50%; /* == (50vw - (width of vertical scrollbar)) */ height: 50%; /* == (50vh - (height of horizontal scrollbar)) */ margin: 5%; /* == (5vw - (width of vertical scrollbar)) */ padding: 5%; /* == (5vw - (width of vertical scrollbar)) */ background: cyan;&#125; 在这里，这个P标签position为fixed,所以P标签的包含块为初始包含块（viewport），通过我们的判断规则三来确定。 如果本文对你有帮助，记得给我的博客项目star(⊙﹏⊙)，顺便找找成都氛围好的前端团队，也许我就是你们要找的の。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全面了解Object对象]]></title>
    <url>%2F2018%2F%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3Object%E5%AF%B9%E8%B1%A1.html</url>
    <content type="text"><![CDATA[为什么一切皆为对象‘一切皆为对象’，这可是javascript中‘圣经’，可是为什么这样说呢，我们来一探究竟吧？为了解决这个问题，我们的从javascript的原型链说起。 原型链在js几乎任何对象有一个 [[prototype]] 属性，在标准中，这是一个隐藏属性。虽然说 [[prototype]] 是一个隐藏属性，但很多浏览器都给每一个对象提供 __proto__ 这一属性，这个属性就是该对象的[[prototype]]。 Object.prototype 的 __proto__ 属性是一个访问器属性（一个getter函数和一个setter函数）, 暴露了通过它访问的对象的内部 [[Prototype]] (一个对象或 null)。使用 __proto__ 是有争议的，也不鼓励使用它。因为它从来没有被包括在EcmaScript语言规范中，但是现代浏览器都实现了它。__proto__ 属性已在ECMAScript 6语言规范中标准化，用于确保Web浏览器的兼容性，因此它未来将被支持。它已被不推荐使用, 赞成Object.getPrototypeOf/Reflect.getPrototypeOf 和Object.setPrototypeOf/Reflect.setPrototypeOf 来获取或设置对象的原型链。 下面我们用标准的方法来获取对象的原型123456789101112131415161718// 基本数据类型（Number,String,Boolean,Symbol）let str = &apos;strstr&apos;;// 1Object.getPrototypeOf(str) // String对象（这里包括字符串原型链上的所有方法如slice、indexOf等）// 2Object.getPrototypeOf(Object.getPrototypeOf(str)) // Object对象// 3Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(str))) // nullconsole.dir(Object.getPrototypeOf(str))// 其他类型（Object,Function,Array,Error,Math,Date,Map,Set,WeakMap,WeakSet,JSON）function demo() &#123;&#125;// 4Object.getPrototypeOf(demo) // anonymous函数// 5Object.getPrototypeOf(Object.getPrototypeOf(demo)) // Object对象// 6Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(demo))) // null PS：博主分别以基本数据类型Number,String,Boolean,Symbol（这里不考虑undefined和null，因为它们是特殊的两个值，木有原型）做了测试，上面代码注释1,2,3最终到达原型链的顶端null。对于其他类型也是同样的，通过4,5,6到达原型链顶端Object.prototype === null。从上面可以整个javascript语法系统都是基于这个原型链来实现方法和属性的继承的，并且可以看到原型链是有终点的值为 null。 搞清楚了原型链，在回到‘一切皆为对象’。明白了javascript的原型链，明白了所有的继承终点都到了Object上，就不难理解‘一切皆为对象’了吧。 对象创建的方式字面量12345let obj = &#123; name: &apos;yzf&apos;, age: 27, city: &apos;chengdu&apos;&#125; 这是大家最熟悉的创建方式。 Object实例化12345678let obj = new Object(&#123; // name: &apos;yzf&apos;, // age: 27, // city: &apos;chengdu&apos;&#125;);obj.name = &apos;yzf&apos;;obj.age = 27;obj.city = &apos;chengdu&apos;; 这里两种方式，为obj赋值，一种在实例化是进行，一种在实例化之后添加。 构造函数1234567function Person(name, age, city)&#123; this.name = name; this.age = age; this.city = city;&#125;let fanerge = new Person(&apos;yzf&apos;, 27, &apos;chengdu&apos;) Object对象的方法Object对象的方法分为Object静态方法和Object的实例方法，静态方法定义在Object自身上，而实例方法定义在Object.prototype上；在使用方式上也有区别，静态方法使用’如Object.keys(obj)’而实例方法使用’如obj.hasOwnProperty(prop)’。我认为我们学习API是需要重点了解一个API的使用方式、定义、参数说明、返回值，下面我给出Object标准库中的方法，其中有部分是ES6+的方法，存在一定的兼容性问题。 Object的静态方法Object.assign(target, …sources)定义：用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。参数：target为目标对象，sources为源对象。返回：目标对象。 Object.create(proto, [propertiesObject])定义：创建一个新对象，使用现有的对象来提供新创建的对象的proto。参数：proto为新创建对象的原型对象，propertiesObject为相关属性的描述符。返回：新对象。 Object.defineProperty(obj, prop, descriptor)定义：会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。参数：obj为要在其上定义属性的对象，prop为要定义或修改的属性的名称，descriptor为将被定义或修改的属性描述符。返回：obj。 Object.defineProperties(obj, props)定义：直接在一个对象上定义新的属性或修改现有属性，并返回该对象。参数：obj为要在其上定义属性的对象，props为要定义或修改的一个或多个属性的描述符。返回：obj。 Object.keys(obj)定义：返回一个由一个给定对象的自身可枚举属性组成的数组。参数：obj为要返回其枚举自身属性的对象。返回：一个表示给定对象的所有可枚举属性的字符串数组。 Object.values(obj)定义：返回一个给定对象自己的所有可枚举属性值的数组。参数：obj为要返回其枚举自身属性的对象。返回：一个包含对象自身的所有可枚举属性值的数组。 Object.values(obj)定义：返回一个给定对象自己的所有可枚举属性值的数组。参数：obj为要返回其枚举自身属性的对象。返回：给定对象自身可枚举属性的键值（键值对也为数组）对数组。 Object.preventExtensions(obj)定义：让一个对象变的不可扩展，也就是永远不能再添加新的属性。参数：obj为将要变得不可扩展的对象。返回：已经不可扩展的对象。PS：该对象的属性可能仍然可删除，且对象的原型仍然可以添加属性。 Object.isExtensible(obj)定义：判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。参数：obj为需要检测的对象。返回：表示给定对象是否可扩展的一个Boolean 。 Object.seal(obj)定义：封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。参数：obj为将要被密封的对象。返回：被密封的对象。PS：属性不可配置的效果就是属性变的不可删除，以及一个数据属性不能被重新定义成为访问器属性（get）。 Object.isSealed(obj)定义：判断一个对象是否被密封。参数：obj为需要检测的对象。返回：表示给定对象是否被密封的一个Boolean。 Object.freeze(obj)定义：可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。参数：obj为要被冻结的对象。返回：要被冻结的对象。 Object.isFrozen(obj)定义：判断一个对象是否被冻结。参数：obj为需要检测的对象。返回：表示给定对象是否被冻结的Boolean。 Object.getOwnPropertyDescriptor(obj, prop)定义：返回指定对象上一个自有属性对应的属性描述符。参数：obj为需要查找的目标对象，prop为目标对象内属性名称（String类型）。返回：如果指定的属性存在于对象上，则返回其属性描述符对象（property descriptor），否则返回 undefined。 Object.getOwnPropertyDescriptors(obj)定义：用来获取一个对象的所有自身属性的描述符。参数：obj为需要查找的目标对象。返回：所指定对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象。 Object.getOwnPropertyNames(obj)定义：返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。参数：obj为返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。返回：在给定对象上找到的属性对应的字符串数组。 Object.getOwnPropertySymbols(obj)定义：返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。参数：obj为要返回 Symbol 属性的对象。返回：在给定对象自身上找到的所有 Symbol 属性的数组。 Object.setPrototypeOf(obj, prototype)定义：设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或null。参数：obj为要设置其原型的对象，prototype为该对象的新原型(一个对象 或 null)。返回：返回obj对象。 Object.getPrototypeOf(object)定义：返回指定对象的原型（内部[[Prototype]]属性的值）。参数：要返回其原型的对象。返回：给定对象的原型。如果没有继承属性，则返回null。 Object.is(value1, value2);定义：判断两个值是否是相同的值。参数：value1为需要比较的第一个值，value2为需要比较的第二个值。返回：表示两个参数是否相同的Boolean 。 Object的实例方法下面obj为Object的实例。 obj.hasOwnProperty(prop)定义：返回一个布尔值，指示对象自身属性中是否具有指定的属性。参数：prop为要检测的属性String或者Symbol。返回：用来判断某个对象是否含有指定的属性的Boolean。 prototypeObj.isPrototypeOf(obj)定义：返回一个布尔值，指示对象自身属性中是否具有指定的属性。参数：obj为在该对象的原型链上搜寻。返回：表示调用对象是否在另一个对象的原型链上的Boolean。 obj.propertyIsEnumerable(prop)定义：返回一个布尔值，表示指定的属性是否可枚举。参数：prop为需要测试的属性名。返回：用来表示指定的属性名是否可枚举的Boolean。 obj.toLocaleString()定义：方法返回一个该对象的字符串表示。返回：表示对象的字符串。 obj.propertyIsEnumerable(prop)定义：返回一个表示该对象的字符串。返回：表示该对象的字符串。PS：ES6之前经常这样用Object.prototype.toString.call(obj) === ‘[object Object]’ 来区别Object和Array。 ob.valueOf()定义：返回指定对象的原始值。返回：返回值为该对象的原始值。 object instanceof constructor定义：instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。参数：object为要检测的对象，constructor为某个构造函数。返回：boolean值。[2018-03-21] 参考文档：MDN__proto____proto__和prototype的区别Object]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript标准库总结]]></title>
    <url>%2F2018%2Fjavascript%E6%A0%87%E5%87%86%E5%BA%93%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[值属性这部分属性只是简单的值，它们没有自己的属性和方法。 Infinity全局属性 Infinity 是一个数值，表示无穷大。 NaN全局属性 NaN 的值表示不是一个数字（Not-A-Number）。 undefined全局属性undefined表示原始值undefined。它是一个JavaScript的 原始数据类型 。 null值 null 特指对象的值未设置。它是 JavaScript 基本类型 之一。 函数属性全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。 eval(str)eval() 函数会将传入的字符串当做 JavaScript 代码进行执行。 PS：eval会造成安全和性能方面的问题，具体参见避免在不必要的情况下使用 eval。 isFinite(arg)判断被传入的值（非number类型将转换为number类型）是否为有限值。 isNaN()判断被传入的值（非number类型将转换为number类型）是否为NaN。 PS：使用Number.isNaN()来代替更有语义性。 parseFloat(str)parseFloat() 函数解析一个字符串参数并返回一个浮点数。 PS：如果在解析过程中遇到了正负号(+或-),数字(0-9),小数点,或者科学记数法中的指数(e或E)以外的字符,则它会忽略该字符以及之后的所有字符,返回当前已经解析到的浮点数.同时参数字符串首位的空白符会被忽略. 如果第一个字符不能解析，直接返回NaN。 parseInt(str, radix);parseInt() 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。 PS：radix一个介于2和36之间的整数，表示上述字符串的基数（默认为10）。 encodeURI(URI)函数通过将特定字符的每个实例替换为一个、两个、三或四转义序列来对统一资源标识符 (URI) 进行编码 (该字符的 UTF-8 编码仅为四转义序列)由两个 “代理” 字符组成)。PS：encodeURI 字母、数字、;、,、/、?、:、@、&amp;、=、+、$、-、_、.、!、~、*、’、(、)、#、之外的所有字符。 decodeURI(encodeURI)decodeURI() 函数解码一个由encodeURI 先前创建的统一资源标识符（URI）或类似的例程。 encodeURIComponent(str)encodeURIComponent()是对统一资源标识符（URI）的组成部分进行编码的方法。 PS：encodeURIComponent 转义除了字母、数字、(、)、.、!、~、*、’、-和_之外的所有字符。 为了避免服务器收到不可预知的请求，对任何用户输入的作为URI部分的内容你都需要用encodeURIComponent进行转义。 decodeURIComponent(encodedURI)decodeURIComponent() 方法用于解码由 encodeURIComponent 方法或者其它类似方法编码的部分统一资源标识符（URI）。 encodeURI和encodeURIComponent的区别与使用场景区别在于编码的字符范围不同。 encodeURI使用于编码整个URI而encodeURIComponent主要query部分（当你需要编码URL中的参数）。简单明了区分escape、encodeURI和encodeURIComponent Function全局的Function对象没有自己的属性和方法, 但是, 因为它本身也是函数，所以它也会通过原型链从Function.prototype上继承部分属性和方法。 原型属性length定义：指明函数的形参个数（确定多少个必须要传入的参数）区别于arguments.length实参个数（确定函数被调用时的实际传参个数）。 constructor定义：返回创建实例对象的 Object 构造函数的引用。 原型方法func.apply(thisArg, [argsArray])定义：调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数。参数：thisArg为func函数执行时this的指向，argsArray为类数组参数数组。返回：调用有指定this值和参数的函数的结果。 fun.call(thisArg, arg1, arg2, …)定义：调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表)。参数：thisArg为func函数执行时this的指向，arg1, arg2, …为指定的参数列表。返回：返回值是你调用的方法的返回值，若该方法没有返回值，则返回undefined。运用：1.使用call方法调用父构造函数（在一个子构造函数中，你可以通过调用父构造函数的call方法来实现继承） 2.使用call方法调用匿名函数3.使用call方法调用函数并且指定上下文的’this’运用举例 fun.bind(thisArg[, arg1[, arg2[, …]]])定义：调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数。参数：thisArg为当绑定函数被调用时，该参数会作为原函数运行时的 this 指向，arg1、arg2…为当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。返回：由指定的this值和初始化参数改造的原函数拷贝（返回一个函数）。运用：1.创建绑定函数（显式绑定this）2.偏函数（使一个函数拥有预设的初始参数）。运用举例 Function.prototype.toString()定义：返回一个表示当前函数源代码的字符串。参数：null。返回：表示函数源代码的一个字符串。 NumberJavaScript 的 Number 对象是经过封装的能让你处理数字值的对象。Number()，如果参数无法被转换为数字，则返回 NaN。 属性Number.EPSILON两个可表示(representable)数之间的最小间隔，在进行计算时误差在这个范围内被认为是合理的。 Number.MAX_SAFE_INTEGERJavaScript 中最大的安全整数 (2^53 - 1)。 Number.MIN_SAFE_INTEGERJavaScript 中最小的安全整数 (-(2^53 - 1)). Number.MAX_VALUE能表示的最大正数。最小的负数是 -MAX_VALUE。 Number.MIN_VALUE能表示的最小正数即最接近 0 的正数 (实际上不会变成 0)。最大的负数是 -MIN_VALUE。 Number.NaNNot A Number. Number.NEGATIVE_INFINITY特殊的负无穷大值，在溢出时返回该值。 Number.POSITIVE_INFINITY特殊的正无穷大值，在溢出时返回改值。 方法下列方法均不会发生将String转化为Number的过程。 Number.isNaN(value)定义：确定传递的值是否为 NaN和其类型是 Number。它是用于代替原始的全局isNaN()。参数：要被检测是否是 NaN 的值。返回：一个布尔值，表示给定的值是否是 NaN。PS：该方法不同于全局的isNaN()，不会将字符串转换为数字。 Number.isFinite(value)定义：用来检测传入的参数是否是一个有穷数（finite number）。参数：value要被检测有穷性的值。返回：一个布尔值表示给定的值是否是一个有穷数。PS：和全局的 isFinite() 函数相比，这个方法不会强制将一个非数值的参数转换成数值。 Number.isInteger(value)定义：用来判断给定的参数是否为整数。参数：value要判断此参数是否为整数。返回：判断给定值是否是整数的 Boolean 值。 Number.isSafeInteger(testValue)定义：用来判断传入的参数值是否是一个“安全整数”（safe integer）。参数：testValue需要检测的参数。返回：一个布尔值 表示给定的值是否是一个安全整数（safe integer）。 Number.parseFloat(string)定义：可以把一个字符串解析成浮点数。参数：string被解析的字符串。返回：对应的浮点数。PS：与全局函数 parseFloat()一样。 Number.parseInt(string[, radix])定义：可以根据给定的进制数的一个字符串数解析成整数。参数：string要解析的值，radix一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。 实例方法下列方法均返回为字符串。 numObj.toExponential([fractionDigits])定义：以指数表示法返回该数值字符串表示形式。参数：fractionDigits一个整数，用来指定小数点后有几位数字。返回：一个用幂的形式 (科学记数法) 来表示Number 对象的字符串。 numObj.toFixed(digits)定义：使用定点表示法来格式化一个数。参数：digits小数点后数字的个数。返回：所给数值的定点数表示法的字符串形式。 numObj.toPrecision(precision)定义：以指定的精度返回该数值对象的字符串表示。参数：precision一个用来指定有效数个数的整数。返回：以定点表示法或指数表示法表示的一个数值对象的字符串表示。 numObj.toLocaleString([locales [, options]])定义：返回这个数字在特定语言环境下的表示字符串。参数：locales为指定本地要使用的编号系统，options为有下列属性（localeMatcher、style、currency等等但存在一定的兼容性）返回：返回一个语言环境下的表示字符串。PS：通常用于格式化为某种货币形式。 numObj.toString([radix])定义：返回指定 Number 对象的字符串表示形式。参数：radix指定要用于数字到字符串的转换的基数(从2到36)。返回：转换后的字符串。 numObj.valueOf()定义：返回一个被 Number 对象包装的原始值。返回：表示指定 Number 对象的原始值的数字。 String静态方法String.fromCharCode(num1, …, numN)定义：返回使用指定的Unicode值序列创建的字符串。 String.fromCodePoint(num1[, …[, numN]])定义：返回使用指定的代码点序列创建的字符串，但是这个方法不能识别 32 位的 UTF-16 字符（Unicode 编号大于0xFFFF）。 String.raw(callSite, …substitutions) || String.rawtemplateString是用来获取一个模板字符串的原始字面量值的。 实例属性length返回：字符串的长度。 N返回：第N个字符串，但不能更改。 实例方法str.charAt(index)定义：从一个字符串中返回指定index的字符，缺省参数为0。 str.charCodeAt(index)定义：返回给定索引处字符的 UTF-16 代码单元值的数字；如果索引超出范围，则返回 NaN。 str.codePointAt(index)定义：返回 一个 Unicode 编码点值的非负整数。 str.concat(string2, string3[, …, stringN])定义：将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。 str.includes(searchString[, index])定义：判断一个字符串是否包含在另一个字符串中，根据情况返回true或false。 str.startsWith(searchString [, index])定义：用来判断当前字符串是否是以另外一个给定的子字符串“开头”的，根据判断结果返回 true 或 false。 str.endsWith(searchString [, index]);定义：判断当前字符串是否是以另外一个给定的子字符串“结尾”的，根据判断结果返回 true 或 false。 str.indexOf(searchValue[, index])定义：第一次出现的指定值的索引，开始在Index进行搜索，否则返回-1。 str.lastIndexOf(searchValue[, index])定义：返回指定值在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。 str.localeCompare(compareString[, locales[, options]])定义：localeCompare() 方法返回一个数字来指示一个参考字符串是否在排序顺序前面或之后或与给定字符串相同。 str.match(regexp);定义：当一个字符串与一个正则表达式匹配时， match()方法检索匹配项。 str.normalize([form]);定义：会按照指定的一种 Unicode 正规形式将当前字符串正规化。 str.padStart(targetLength [, padString])定义：会用一个字符串填充在当前字符串之前（如果需要的话则重复填充），返回填充后达到指定长度的字符串。 str.padEnd(targetLength [, padString])定义：会用一个字符串填充在当前字符串之后（如果需要的话则重复填充），返回填充后达到指定长度的字符串。 str.repeat(count);定义：返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本。PS：参数从零开始。 str.replace(regexp|substr, newSubStr|function)定义：返回一个由替换值替换一些或所有匹配的模式后的新字符串。如果第一个参数为regexp第二个参数为function时，该函数参数说明参数1：匹配模式的字符串。参数2–：子表达是匹配的子字符串（就是捕获分组）。倒数参数2：声明匹配在string中出现的位置。倒数参数1：进行匹配的sting本身。 str.search(regexp)定义：行正则表达式和 String对象之间的一个搜索匹配。返回：如果匹配成功，则 search() 返回正则表达式在字符串中首次匹配项的索引。否则，返回 -1。 str.slice(beginSlice[, endSlice])定义：提取一个字符串的一部分，并返回一新的字符串。参数：beginSlice从该索引（以 0 为基数）处开始提取原字符串中的字符。如果值为负数，会被当做 sourceLength + beginSlice 看待，这里的sourceLength 是字符串的长度。endSlice在该索引（以 0 为基数）处结束提取字符串，同样可为负数。 str.split([separator[, limit]])定义：使用指定的分隔符字符串将一个String对象分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置。 str.substr(start[, length])定义：返回一个字符串中从指定位置开始到指定字符数的字符。PS：start &gt;=str.length 或 length &lt;= 0 返回空字符串;start &lt; 0 则转换为start + str.length。 str.substring(indexStart[, indexEnd])定义：返回一个字符串在开始索引到结束索引之间的一个子集, 或从开始索引直到字符串的末尾的一个子集。PS：一些特殊情况。如果 indexStart 等于 indexEnd，substring 返回一个空字符串。如果省略 indexEnd，substring 提取字符一直到字符串末尾。如果任一参数小于 0 或为 NaN，则被当作 0。如果任一参数大于 stringName.length，则被当作 stringName.length。如果 indexStart 大于 indexEnd，则 substring 的执行效果就像两个参数调换了一样。 str.toLowerCase()定义：将调用该方法的字符串值转为小写形式，并返回新字符串。 str.toUpperCase()定义：将调用该方法的字符串值转换为大写形式，并返回新字符串。 str.toLocaleLowerCase()定义：根据任何特定于语言环境的案例映射，返回调用字符串值转换为小写的值。PS：在大多数情况下，该方法产生的结果和调用toLowerCase()的结果相同（除土耳其等）。 str.toLocaleUpperCase()定义：使用本地化（locale-specific）的大小写映射规则将输入的字符串转化成大写形式并返回结果字符串。 str.toString()定义：返回指定对象的字符串形式。 str.trim()定义：会从一个字符串的两端删除空白字符，返回一个新的字符串。PS：str.trimLeft() 和 str.trimRight() 不是标准方法。 string[Symbol.iterator]返回一个新的Iterator对象，它遍历字符串的代码点，返回每一个代码点的字符串值。PS：下列内置类型拥有默认迭代器行为Array、String、Set、Map等，而Object没有。 Array静态方法在 ES2015 中， Class 语法允许我们为内置类型（比如 Array）和自定义类新建子类（比如叫 SubArray）。这些子类也会继承父类的静态方法，比如 SubArray.from()，调用该方法后会返回子类 SubArray 的一个实例，而不是 Array 的实例。 Array.from(arrayLike[, mapFn[, thisArg]])定义：从一个类似数组或可迭代对象中创建一个新的数组实例。参数： arrayLike想要转换成数组的伪数组对象或可迭代对象。 mapFn (可选参数)如果指定了该参数，新数组中的每个元素会执行该回调函数。 thisArg (可选参数)可选参数，执行回调函数 mapFn 时 this 对象。返回：一个新的数组。PS：Array.from(obj, mapFn, thisArg) 就相当于 Array.from(obj).map(mapFn, thisArg)，ES6之前的做法：Array.prototype.slice.call(arrayLike)。 Array.isArray(obj)定义：确定传递的值是否是一个 Array。返回：boolean。PS：ES6之前的做法Object.prototype.toString.call(arg) === ‘[object Array]’。 Array.of(element0[, element1[, …[, elementN]]])定义：创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。参数：任意个参数，将按顺序成为返回数组中的元素。返回：参数列表组成的数组。PS：Array.of() 和 Array 构造函数之间的区别在于处理整数参数：Array.of(7) 创建一个具有单个元素 7 的数组，而 Array(7) 创建一个包含 7 个 undefined 元素的数组。 实例方法及属性ary.length返回：读写数组的长度。 修改器方法（改变原数组）arr.copyWithin(target[, start[, end]])定义：浅复制数组的一部分到同一数组中的另一个位置，并返回它，而不修改其大小。参数：target 0 为基底的索引，复制序列到该位置。如果是负数，target 将从末尾开始计算。如果 target 大于等于 arr.length，将会不发生拷贝。如果 target 在 start 之后，复制的序列将被修改以符合 arr.length。start 0 为基底的索引，开始复制元素的起始位置。如果是负数，start 将从末尾开始计算。如果 start 被忽略，copyWithin 将会从0开始复制。end 0 为基底的索引，开始复制元素的结束位置。copyWithin 将会拷贝到该位置，但不包括 end 这个位置的元素。如果是负数， end 将从末尾开始计算。如果 end 被忽略，copyWithin 将会复制到 arr.length。返回值：操作原数组。 arr.fill(value[, start[, end]])定义：用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。参数： value 用来填充数组元素的值。 start 开始索引，默认为0。 end 结束索引，默认为arr.length（不包括）。返回：修改后的数组。 arr.push(element1, …, elementN)定义：将一个或多个元素添加到数组的末尾，并返回新数组的长度。参数： elementN 被添加到数组末尾的元素。返回：操作后的数组的长度。 arr.pop()定义：从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。返回：从数组中删除的元素(当数组为空时返回undefined)。 arr.reverse()定义：将数组中元素的位置颠倒。返回：颠倒数组中元素的位置，并返回该数组的引用。 arr.sort(compareFunction)定义：可以根据指定方法对数组进行排序。compareFunction 可选。用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。返回：返回排序后的数组。原数组已经被排序后的数组代替。 arr.shift()定义：从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。返回：从数组中删除的元素; 如果数组为空则返回undefined。 arr.unshift(element1, …, elementN)定义：将一个或多个元素添加到数组的开头，并返回新数组的长度。参数：element1, …, elementN 要添加到数组开头的元素。返回：当一个对象调用该方法时，返回其 length 属性值。 array.splice(start, [deleteCount], [item1], [item2], …)定义：通过删除现有元素和/或添加新元素来更改一个数组的内容。参数： start 开始修改的位置。 deleteCount 移除数组元素的个数。 item1、item2…为添加的元素。返回：由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。 访问方法（不直接操作原理的数组）old_array.concat(value1[, value2[, …[, valueN]]])定义：用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。参数：valueN 将数组和/或值连接成新数组。返回：新数组。 arr.includes(searchElement, [fromIndex])定义：用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。参数： searchElement 需要查找的元素值。 fromIndex 从该索引处开始查找 searchElement。返回：boolean。 arr.join([separator])定义：将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。参数： searchElement 需要查找的元素值。 fromIndex 从该索引处开始查找 searchElement。返回：string。 arr.slice([begin], [end])定义：返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象。返回：一个含有提取元素的新数组。 arr.indexOf(searchElement[, fromIndex = 0])定义：返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。返回：首个被找到的元素在数组中的索引位置; 若没有找到则返回 -1。 arr.lastIndexOf(searchElement[, fromIndex = arr.length - 1])定义：返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。返回：数组中最后一个元素的索引，如未找到返回-1。 arr.toString()定义：返回一个字符串，表示指定的数组及其元素。返回：逗号分隔的字符串。 迭代方法array.forEach(callback(currentValue, index, array){ //do something}, this)定义：对数组的每个元素执行一次提供的函数。返回：undefined。PS：没有办法中止或者跳出 forEach 循环，需要跳出请使用循环代替。已删除（使用delete方法等情况）或者未初始化的项将被跳过（但不会跳过那些值为 undefined、null 的项）。 array.map(callback(currentValue, index, array){ //do something}, this)定义：创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。返回：一个新数组，每个元素都是回调函数的结果。 arr.keys()定义：返回一个新的Array迭代器，它包含数组中每个索引的键。返回：一个新的 Array 迭代器对象。 arr.values()定义：返回一个新的 Array Iterator 对象，该对象包含数组每个索引的值。返回：一个新的 Array 迭代器对象。 arr.entries()定义：返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。返回：一个新的 Array 迭代器对象。 arr.every(callback[, thisArg])定义：测试数组的所有元素是否都通过了指定函数的测试。返回：boolean。 arr.some(callback[, thisArg])定义：测试数组中的某些元素是否通过由提供的函数实现的测试。返回：boolean。 arr.filter(callback[, thisArg])定义：创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。返回：新数组。 arr.findIndex(callback[, thisArg])定义：返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。返回：当某个元素通过 callback 的测试时，返回数组中的一个值的索引，否则返回 -1。 arr.find(callback[, thisArg])定义：返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。返回：当某个元素通过 callback 的测试时，返回数组中的一个值，否则返回 undefined。 arr.reduce(callback[, initialValue])定义：对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。参数： callback 执行数组中每个值的函数，包含四个参数： accumulato 累加器累加回调的返回值; 它是上一次调用回调时返回的累积值，或initialValue（如下所示）。 currentValue 数组中正在处理的元素。 currentIndex可选 数组中正在处理的当前元素的索引。 如果提供了initialValue，则索引号为0，否则为索引为1。 array可选 调用reduce的数组。 initialValue 可选用作第一个调用 callback的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。返回：函数累计处理的结果。 arr.reduceRight(callback[, initialValue])定义：接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。 arrSymbol.iterator定义：默认为数组不说了迭代器，@@iterator 属性和 values() 属性的初始值均为同一个函数对象。返回：数组的 iterator 方法，默认情况下与 values() 返回值相同。 arr.flatten(depth)定义：会递归到指定深度将所有子数组连接，并返回一个新数组。参数：depth 可选指定嵌套数组中的结构深度，默认值为1。返回：一个将子数组连接的新数组。 arr.flatMap(function callback(currentValue[, index[, array]]) { // 返回新数组的元素}[, thisArg])定义：首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 和 深度值1的 flatten 几乎相同，但flatMap通常在合并成一种方法的效率稍微高一些。返回：一个新的数组，其中每个元素都是回调函数的结果，并且结构深度 depth 值为1。 Proxy &amp;&amp; ReflectProxy是一个构造函数（对对象的访问进行拦截），Reflect（操作对象提供的API）。Reflect它与Proxy对象的方法是一一对应的，这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。 ProxyProxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。12345678910111213141516171819Proxy方法：target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为var proxy = new Proxy(target, handler);var person = &#123; name: &quot;张三&quot;&#125;;var proxy = new Proxy(person, &#123; get: function(target, property) &#123; if (property in target) &#123; return target[property]; &#125; else &#123; throw new ReferenceError(&quot;Property \&quot;&quot; + property + &quot;\&quot; does not exist.&quot;); &#125; &#125;&#125;);proxy.name // &quot;张三&quot;proxy.age // 抛出一个错误 Proxy使用详解 Reflect将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。// 下列方法说明：target为目标对象，name为某个属性，receiver为如果name属性设置了赋值函数，则为函数的this指向Reflect.apply(target, thisArg, args) Reflect.apply方法等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。Reflect.construct(target, args) Reflect.construct方法等同于new target(…args)，这提供了一种不使用new，来调用构造函数的方法。Reflect.get(target, name, receiver) Reflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined。Reflect.set(target, name, value, receiver) Reflect.set方法设置target对象的name属性等于value。Reflect.defineProperty(target, name, desc) Reflect.defineProperty方法基本等同于Object.defineProperty，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用Reflect.defineProperty代替它。Reflect.deleteProperty(target, name) Reflect.deleteProperty方法等同于delete obj[name]，用于删除对象的属性。Reflect.has(target, name) Reflect.has方法对应name in obj里面的in运算符。Reflect.ownKeys(target) Reflect.ownKeys方法用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。Reflect.isExtensible(target) Reflect.isExtensible方法对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。Reflect.preventExtensions(target) Reflect.preventExtensions对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。Reflect.getOwnPropertyDescriptor(target, name) Reflect.getOwnPropertyDescriptor基本等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象，将来会替代掉后者。Reflect.getPrototypeOf(target) Reflect.getPrototypeOf方法用于读取对象的proto属性，对应Object.getPrototypeOf(obj)。Reflect.setPrototypeOf(target, prototype) Reflect.setPrototypeOf方法用于设置对象的proto属性，返回第一个参数对象，对应Object.setPrototypeOf(obj, newProto)。 EventEvent接口表示在DOM中发生的任何事件; 一些是用户生成的（例如鼠标或键盘事件），而其他由API生成(例如指示动画已经完成运行的事件，视频已被暂停等等)。有许多类型的事件，其中一些使用基于主要事件接口的其他接口。事件本身包含所有事件通用的属性和方法。 属性bubbles（只读）定义：用来表示该事件是否在DOM中冒泡的boolean值。 cancelBubble（废弃）定义：获取或设置当前事件是否要取消冒泡（使用e.stopPropagation()代替）。 cancelable（只读）定义：表示这个事件是否可以取消默认行为（阻止默认行为e.preventDefault()）。 composed（只读）定义：表示该事件是否可以Shadow DOM 传递到一般的 DOM。 currentTarget（只读）定义：当前注册事件的对象的引用，这个值会在传递途中发生变化。 deepPath定义：返回事件冒泡过程所有经过的节点所构成的Array数组。 defaultPrevented（只读）定义：返回是否已经调用了e.preventDefault()来阻止默认行为。 eventPhase（只读）定义：返回事件流正在哪个阶段。 returnValue（废弃）定义：获取或设置事件的默认操作是否已被阻止。 target（只读）定义：返回一个触发事件的对象的引用（ie的srcElement）。 timeStamp（只读）定义：事件创建时的时间戳，毫秒级别。 type（只读）定义：返回一个字符串（不区分大小写）, 表示该事件对象的事件类型。 isTrusted（只读）定义：指明事件是否是由浏览器（当用户点击实例后）或者由脚本（使用事件的创建方法，例如event.initEvent）启动。 target与currentTarget的区别event.target返回触发事件的元素event.currentTarget返回绑定事件的元素event对象中 target和currentTarget 属性的区别 方法document.createEvent(“UIEvents”)创建一个新的事件（Event），随之必须调用自身的 init 方法进行初始化。 event.initEvent(type, bubbles, cancelable)定义：Event.initEvent() 方法可以用来初始化由Document.createEvent() 创建的 event 实例，且在触发之前event.dispatchEvent()。 event.preventDefault()定义：如果此事件没有需要显式处理，那么它默认的动作也不要做（因为默认是要做的）。 event.stopPropagation()定义：阻止捕获和冒泡阶段中当前事件的进一步传播（只阻止当前侦听器）。 event.stopImmediatePropagation()定义：阻止调用相同事件的其他侦听器。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从对象的遍历到浅拷贝的思考]]></title>
    <url>%2F2017%2F%E4%BB%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86%E5%88%B0%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%80%9D%E8%80%83.html</url>
    <content type="text"><![CDATA[我们已经来到了现代ECMAScript的时代，以前的正确的方法，现在看来似乎有点考虑不全。比如在ES6之前要实现对象的浅拷贝，比较简单，因为当时对象的属性只有String类型，ES6之后对象的属性有String和Symbol类型。由于文章上下文关系，本文将按照’属性描述符’-&gt;’对象的属性遍历方法介绍’-&gt;’现代ECMAScript对象的浅拷贝’进行介绍，现代ECMAScript对象的深拷贝比较复杂，有时间在分析。 属性描述符对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。存取描述符是由getter-setter函数对描述的属性。描述符必须是这两种形式之一，不能同时是两者。 数据描述符configurable当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。 enumerable当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。数据描述符同时具有以下可选键值： value该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。 writable当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。 存取描述符get一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值。默认为 undefined。 set一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为 undefined。 属性描述符的读写操作我们可以通过Object.getOwnPropertyDescriptor(o,name)、Object.getOwnPropertyDescriptors(obj)来查看属性描述符，通过Object.defineProperty(o,name,desc)、Object.defineProperties(o,descriptors)、Object.create(proto,descriptors)等方法来更改属性描述符。 对象的属性遍历方法介绍上面，我们了解了属性描述符，其中枚举这个属性描述符，在不同方法对对象属性的遍历过程产生的作用差异很大，下面我开始介绍如何遍历对象的属性。本小结的测试代码，我就不贴出来了，都很简单，我这里直接给出结论，感兴趣的朋友可以自己尝试。 for…in定义：for…in语句以任意顺序遍历一个对象的可枚举属性。对于每个不同的属性，语句都会被执行。语法：123for (item in object) &#123;...&#125;// itme--在每次迭代时，将不同的属性名分配给变量。// object--被迭代枚举其属性的对象。 PS：这里我们需要记住该方法遍历属性的特点：1.可以遍历对象自身和原型链上可枚举的属性2.任意顺序，说明遍历的属性先后顺序不定（不同运行环境顺序不同）。不建议对数组使用for…in来遍历主要原因就是这个，另一方面为性能考虑for…in还会遍历到原型链上的可枚举属性。 Object.keys()定义：Object.keys() 方法会返回一个由该对象的自身的可枚举属性组成的数组。 语法：12Object.keys(obj)// obj--要返回其枚举自身属性的对象。 PS：这里我们需要记住该方法遍历属性的特点：1.属性是自身的2.属性是可枚举的3.任意顺序，枚举属性的顺序和for…in/Object.getOwnPropertyNames(obj)一致4.返回一个所有元素为字符串（不包括Symbol）的数组 Object.getOwnPropertyNames()定义：Object.getOwnPropertyNames()方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。语法：12Object.getOwnPropertyNames(obj)// obj--一个对象，其自身的可枚举和不可枚举属性的名称被返回。 PS：这里我们需要记住该方法遍历属性的特点：1.属性是自身的2.属性了枚举和不可枚举都可以遍历3.任意顺序，枚举属性的顺序和for…in/Object.keys(obj)一致 Object.getOwnPropertySymbols()定义：Object.getOwnPropertySymbols() 方法返回一个给定对象自身的所有 Symbol 属性的数组。语法：12Object.getOwnPropertySymbols(obj)// obj--要返回 Symbol 属性的对象。 PS：1.属性是自身的2.属性为Symbol类型 Reflect.ownKeys()定义：Reflect.ownKeys() 返回一个由目标对象自身的属性键组成的数组。语法：12Reflect.ownKeys(target)// target--获取自身属性键的目标对象。 PS：1.属性是自身的2.属性可以是字符串或Symbol3.属性是可枚举或不可枚举这里看，似乎能遍历出自身的所有属性，还差原型连上的属性。 总结下上面的方法为了好归纳，我这里将对象的属性分为以下类别：1.自身可枚举的属性，2.自身不可枚举的属性，3.Symbol类型的属性，4.原型链上的可枚举属性，5.原型链上的不可枚举属性，6.原型链上的Symbol属性2018-03-16更新 方法 可遍历的属性类别 for…in 1，4 Object.keys() 1 Object.getOwnPropertyNames() 1，2 Object.getOwnPropertySymbols() 3 Reflect.ownKeys() 1，2，3 从上表分析，还没有一个方法能完美解决，我们只能组合使用了。PS：除了for…in其余方法均返回数组。 现代ECMAScript对象的浅拷贝本小节会我们会实现各种浅拷贝，并分析各自的劣势，最终我们将实现一种比较完美的方法（暂不考虑兼容性）。 现看一个以前实现的方法123456789101112function shallowCopy (obj) &#123; if (typeof obj !== &apos;object&apos;) &#123; return &#125; var newObj = obj instanceof Array ? [] : &#123;&#125; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] = obj[key] &#125; &#125; return newObj&#125; 这中方法对于ES6之前的确可行，毕竟我也用过这样的方法，有了Symbol之后这个就不再正确了。 JSON.parse(JSON.stringify()) 该方式在遇到不安全的JSON值会自动将其忽略，在数组中则会返回null（以保证单元位置不变）。不安全的 JSON 值: undefined 、 function 、 symbol （ES6+）和包含循环引用（对象之间相互引用，形成一个无限循环）的 对象 都不符合 JSON 结构标准，支持 JSON 的语言无法处理它们 Object.assign 和 展开运算符（…）123456789101112131415let obj = &#123; name: &apos;yzf&apos;, age: 100, sex: &apos;male&apos;, [Symbol()]: &apos;symbol1&apos;,&#125;let obj2 = Object.assign(&#123;&#125;, obj)// obj2&#123; name: &apos;yzf&apos;, age: 100, sex: &apos;male&apos;, [Symbol()]: &apos;symbol1&apos;,&#125; 这个函数的定义：Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。特点：自身的可枚举的包括Symbol类型的，不包括不可枚举的属性和原型链上的属性，不完美。 Object.create() + Object.getPrototypeOf() + Object.getOwnPropertyDescriptors()首先需要介绍一下相关的方法，ES7的Object.getOwnPropertyDescriptors()。 Object.getOwnPropertyDescriptors()定义：Object.getOwnPropertyDescriptors() 方法用来获取一个对象的所有自身属性的描述符。语法：12Object.getOwnPropertyDescriptors(obj)// 需要获取自身属性的对象。 PS：1.属性是自身的2.属性可以是字符串或Symbol3.属性是可枚举或不可枚举4.包括了集体属性的描述符（value）到这里似乎我们已经找到了，比较完美的解决方案了，我们来组合一下这3个方法。123456// obj为需要浅拷贝的对象let obj1 = Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj) )// obj1就是我们浅拷贝的得到的对象。 PS：obj1对象通过Object.create()方法指定了自身的原型链（从原型链继承了相关属性），然后在通过Object.getOwnPropertyDescriptors()方法把自身的（包括可枚举的、不可枚举的、Symbol类型的）全部添加obj1上，这样是实现了我们的真正意义上的浅拷贝。 扩展数组的浅拷贝ary.slice()、 ary.concat()、[…ary]、JSON.parse(JSON.stringify(ary))期望加入一个技术氛围nice的团队-成都 参考文档：Object.createObject.assignObject.getOwnPropertySymbolsES6时代，你真的会克隆对象吗？]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梳理下浏览器对象模型知识（BOM）]]></title>
    <url>%2F2018%2F%E6%A2%B3%E7%90%86%E4%B8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%9F%A5%E8%AF%86%EF%BC%88BOM%EF%BC%89.html</url>
    <content type="text"><![CDATA[本文系统的梳理了下BOM的5个对象（有一些非标准属性及方法），这里暂且不考虑兼容性。下文中的图片你可能可不太清楚，可以点击后面的链接下载大图查看，注红色部分为常使用的属性或方法。 BOM介绍BOM(Browser Object Model) 是指浏览器对象模型，是用于描述这种对象与对象之间层次关系的模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的子对象（Screen、Location、History、Navigator）。浏览器对象模型的构成 Window对象Window对象，它表示浏览器窗口，在浏览器中最顶层的对象。在浏览器中，每个标签具有自己的 window 对象 。也就是说，同一个窗口的标签之间不会共享一个 window 对象。 Window对象的属性看不清，点这里 Window对象的方法看不清，点这里 Location对象Location 对象表示其链接到的对象的位置（URL）。所做的修改反映在与之相关的对象上。Document 和 Window 接口都有这样一个链接的Location，分别通过 Document.location和Window.location 访问。看不清，点这里 History对象History 对象允许操作浏览器的曾经在标签页或者框架里访问的会话历史记录。看不清，点这里 Navigator对象Navigator 接口表示用户代理的状态和标识。 它允许脚本查询它和注册自己进行一些活动。看不清，点这里 Screen对象Screen 对象包含有关用户屏幕的信息。看不清，点这里 document对象Document 对象提供了一些在浏览器服务中作为页面内容入口点而加载的一些页面，也就是 DOM 树。看不清，点这里]]></content>
      <categories>
        <category>BOM</category>
      </categories>
      <tags>
        <tag>BOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端常识-gj2]]></title>
    <url>%2F2018%2F%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%AF%86-gj2.html</url>
    <content type="text"><![CDATA[从浏览器地址栏输入url到显示页面的步骤(以HTTP为例) 在浏览器地址栏输入URL 浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤如果资源未缓存，发起新请求如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期 HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间 浏览器解析URL获取协议，主机，端口，path 浏览器组装一个HTTP（GET）请求报文 浏览器获取主机ip地址，过程如下：浏览器缓存本机缓存hosts文件路由器缓存ISP DNS缓存DNS递归查询（可能存在负载均衡导致每次IP不一样） 打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下：客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口服务器发回SYN=1， ACK=X+1， Seq=Y的响应包客户端发送ACK=Y+1， Seq=Z TCP链接建立后发送HTTP请求 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序 服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作 服务器将响应报文通过TCP连接发送回浏览器 浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下：主动方发送Fin=1， Ack=Z， Seq= X报文被动方发送ACK=X+1， Seq=Z报文被动方发送Fin=1， ACK=X， Seq=Y报文主动方发送ACK=Y， Seq=X报文 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同 如果资源可缓存，进行缓存 对响应进行解码（例如gzip压缩） 根据资源类型决定如何处理（假设资源为HTML文档） 解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释 构建DOM树：Tokenizing：根据HTML规范将字符流解析为标记Lexing：词法分析将标记转换为对象并定义属性和规则DOM construction：根据HTML标记关系将对象组成DOM树 解析过程中遇到图片、样式表、js文件，启动下载 构建CSSOM树：Tokenizing：字符流转换为标记流Node：根据标记创建节点CSSOM：节点创建CSSOM树 根据DOM树和CSSOM树构建渲染树:从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none对每一个可见节点，找到恰当的CSSOM规则并应用发布可视节点的内容和计算样式 js解析如下：浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loadingHTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素当文档完成解析，document.readState变成interactive所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write()浏览器在Document对象上触发DOMContentLoaded事件此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete,window触发load事件 显示页面（HTML解析过程中会逐步显示页面）css部分CSS选择器有哪些 通用选择器：选择所有元素，不参与计算优先级，兼容性IE6+#X id选择器：选择id值为X的元素，兼容性：IE6+.X 类选择器： 选择class包含X的元素，兼容性：IE6+X Y后代选择器： 选择满足X选择器的后代节点中满足Y选择器的元素，兼容性：IE6+X 元素选择器： 选择标所有签为X的元素，兼容性：IE6+:link，：visited，：focus，：hover，：active链接状态： 选择特定状态的链接元素，顺序LoVe HAte，兼容性: IE4+X + Y直接兄弟选择器：在X之后第一个兄弟节点中选择满足Y选择器的元素，兼容性： IE7+X &gt; Y子选择器： 选择X的子元素中满足Y选择器的元素，兼容性： IE7+X ~ Y兄弟： 选择X之后所有兄弟节点中满足Y选择器的元素，兼容性： IE7+[attr]：选择所有设置了attr属性的元素，兼容性IE7+[attr=value]：选择属性值刚好为value的元素[attr~=value]：选择属性值为空白符分隔，其中一个的值刚好是value的元素[attr|=value]：选择属性值刚好为value或者value-开头的元素[attr^=value]：选择属性值以value开头的元素[attr$=value]：选择属性值以value结尾的元素[attribute*=value]：选择属性值中包含value的元素X:after, X::after：after伪元素，选择元素虚拟子元素（元素的最后一个子元素），CSS3中::表示伪元素。兼容性:after为IE8+，::after为IE9+:hover：鼠标移入状态的元素，兼容性a标签IE4+， 所有元素IE7+:not(selector)：选择不符合selector的元素。不参与计算优先级，兼容性：IE9+::first-letter：伪元素，选择块元素第一行的第一个字母，兼容性IE5.5+::first-line：伪元素，选择块元素的第一行，兼容性IE5.5+:nth-child(an + b)：伪类，选择前面有an + b - 1个兄弟节点的元素，其中n&gt;= 0， 兼容性IE9+:nth-last-child(an + b)：伪类，选择后面有an + b - 1个兄弟节点的元素其中n &gt;= 0，兼容性IE9+X:nth-of-type(an+b)：伪类，X为选择器，解析得到元素标签，选择前面有an + b - 1个相同标签兄弟节点的元素。兼容性IE9+X:nth-last-of-type(an+b)：伪类，X为选择器，解析得到元素标签，选择后面有an+b-1个相同标签兄弟节点的元素。兼容性IE9+X:first-child：伪类，选择满足X选择器的元素，且这个元素是其父节点的第一个子元素。兼容性IE7+X:last-child：伪类，选择满足X选择器的元素，且这个元素是其父节点的最后一个子元素。兼容性IE9+X:only-child：伪类，选择满足X选择器的元素，且这个元素是其父元素的唯一子元素。兼容性IE9+X:only-of-type：伪类，选择X选择的元素，解析得到元素标签，如果该元素没有相同类型的兄弟节点时选中它。兼容性IE9+X:first-of-type：伪类，选择X选择的元素，解析得到元素标签，如果该元素是此此类型元素的第一个兄弟。选中它。兼容性IE9+css sprite是什么,有什么优缺点概念：将多个小图片拼接到一个图片中。通过background-position和元素尺寸调节需要显示的背景图案。优点： 减少HTTP请求数，极大地提高页面加载速度 增加图片信息重复度，提高压缩比，减少图片大小 更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现缺点： 图片合并麻烦 维护麻烦，修改一个图片可能需要从新布局整个图片，样式display: none;与visibility: hidden;的区别相同点：它们都能让元素不可见区别：display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility: hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘。读屏器不会读取display: none;元素内容；会读取visibility: hidden;元素内容specified value,computed value,used value计算方法specified value: 计算方法如下： 如果样式表设置了一个值，使用这个值 如果没有设置值，这个属性是继承属性，从父元素继承 如果没设置，并且不是继承属性，使用css规范指定的初始值及浏览器初始值computed value: 以specified value根据规范定义的行为进行计算，通常将相对值计算为绝对值，例如em根据font-size进行计算。一些使用百分数并且需要布局来决定最终值的属性，如width，margin。百分数就直接作为computed value。line-height的无单位值也直接作为computed value。这些值将在计算used value时得到绝对值。computed value的主要作用是用于继承used value：属性计算后的最终值，对于大多数属性可以通过window.getComputedStyle获得，尺寸值单位为像素。以下属性依赖于布局， background-position bottom, left, right, top height, width margin-bottom, margin-left, margin-right, margin-top min-height, min-width padding-bottom, padding-left, padding-right, padding-top text-indentlink与@import的区别 link是HTML方式， @import是CSS方式 link最大限度支持并行下载，@import过多嵌套导致串行下载，出现FOUC无样式内容闪烁(Flash Of Unstyled Content) link可以通过rel=”alternate stylesheet”指定候选样式 浏览器对link支持早于@import，可以使用@import对老浏览器隐藏样式 @import必须在样式规则之前，可以在css文件中引用其他文件 总体来说：link优于@importdisplay: block;和display: inline;的区别block元素特点： 1.处于常规流中时，如果width没有设置，会自动填充满父容器 2.可以应用margin/padding 3.在没有设置高度的情况下会扩展高度以包含常规流中的子元素 4.处于常规流中时布局时在前后元素位置之间（独占一个水平空间） 5.忽略vertical-aligninline元素特点 1.水平方向上根据direction依次布局 2.不会在元素前后进行换行 3.受white-space控制 4.margin/padding在竖直方向上无效，水平方向上有效 5.width/height属性对非替换行内元素无效，宽度由元素内容决定 6.非替换行内元素的行框高由line-height确定，替换行内元素的行框高由height,margin,padding,border决定 6.浮动或绝对定位时会转换为block 7.vertical-align属性生效PNG,GIF,JPG,webp,svg的区别及如何选GIF: 8位像素，256色 无损压缩 支持简单动画 支持boolean透明 适合简单动画JPEG： 颜色限于256 有损压缩 可控制压缩质量 不支持透明 适合照片PNG： 有PNG8和truecolor PNG PNG8类似GIF颜色上限为256，文件小，支持alpha透明度，无动画 适合图标、背景、按钮未来趋势： webp（google推出的图片格式，目前存在浏览器兼容） svg（矢量图如：iconfont）CSS有哪些继承属性关于文字排版的属性如： font word-break letter-spacing text-align text-rendering word-spacing white-space text-indent text-transform text-shadowline-heightcolorvisibilitycursor容器包含若干浮动元素时如何清理(包含)浮动容器元素闭合标签前添加额外元素并设置clear: both父元素触发块级格式化上下文(见块级可视化上下文部分)设置容器元素伪元素进行清理推荐的清理浮动方法123456789101112131415161718192021222324252627/*** 在标准浏览器下使用* 1 content内容为空格用于修复opera下文档中出现* contenteditable属性时在清理浮动元素上下的空白* 2 使用display使用table而不是block：可以防止容器和* 子元素margin-top折叠,这样能使清理效果与BFC，IE6/7* zoom: 1;一致* 3 overflow: hidden;**/.clearfix:before,.clearfix:after &#123; content: &quot; &quot;; /* 1 */ display: table; /* 2 */&#125;.clearfix:after &#123; clear: both;&#125;/*** IE 6/7下使用* 通过触发hasLayout实现包含浮动**/.clearfix &#123; *zoom: 1;&#125; 什么是FOUC?如何避免Flash Of Unstyled Content：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成页面闪烁。解决方法：把样式表放到文档的head使用link元素。 什么是BFC？如何创建块级格式化上下文(block formatting context),BFC有什么用BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于布局中的普通流。创建规则： 根元素 浮动元素（float不是none） 绝对定位元素（position取值为absolute或fixed） display取值为inline-block,table-cell, table-caption,flex, inline-flex之一的元素 overflow不是visible的元素作用： 可以包含浮动元素（父布局overflow: hidden） 不被浮动元素覆盖（两列自适应布局：子1浮动，子2不浮动且有overflow: hidden） 阻止父子元素的margin折叠（如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中） display,float,position的关系如果display为none，那么position和float都不起作用，这种情况下元素不产生框否则，如果position值为absolute或者fixed，框就是绝对定位的，float的计算值为none，display根据下面的表格进行调整。否则，如果float不是none，框是浮动的，display根据下表进行调整否则，如果元素是根元素，display根据下表进行调整其他情况下display的值为指定值总结起来：绝对定位、浮动、根元素都需要调整display 外边距折叠(collapsing margins)毗邻的两个或多个margin会合并成一个margin，叫做外边距折叠。规则如下：1.两个或多个毗邻的普通流中的块元素垂直方向上的margin会折叠2.浮动元素/inline-block元素/绝对定位元素的margin不会和垂直方向上的其他元素的margin折叠3.创建了块级格式化上下文的元素，不会和它的子元素发生margin折叠4.元素自身的margin-bottom和margin-top相邻时也会折叠 如何确定一个元素的包含块(containing block)1.根元素的包含块叫做初始包含块，在连续媒体中他的尺寸与viewport相同并且anchored at the canvas origin；对于paged media，它的尺寸等于page area。初始包含块的direction属性与根元素相同。2.position为relative或者static的元素，它的包含块由最近的块级（display为block,list-item, table）祖先元素的内容框组成。3.如果元素position为fixed。对于连续媒体，它的包含块为viewport；对于paged media，包含块为page area4.如果元素position为absolute，它的包含块由祖先元素中最近一个position为relative,absolute或者fixed的元素产生，规则如下： 如果祖先元素为行内元素，the containing block is the bounding box around the padding boxes of the first and the last inline boxes generated for that element. 其他情况下包含块由祖先节点的padding edge组成如果找不到定位的祖先元素，包含块为初始包含块 stacking context,布局规则z轴上的默认层叠顺序如下（从下到上）： 根元素的边界和背景 常规流中的元素按照html中顺序 浮动块 positioned元素按照html中出现顺序如何创建stacking context： 根元素 z-index不为auto的定位元素 a flex item with a z-index value other than ‘auto’ opacity小于1的元素 在移动端webkit和chrome22+，z-index为auto，position: fixed也将创建新的stacking context 如何水平居中一个元素如果需要居中的元素为常规流中inline元素，为父元素设置text-align: center;即可实现如果需要居中的元素为常规流中block元素，1）为元素设置宽度，2）设置左右margin为auto。如果需要居中的元素为浮动元素，1）为元素设置宽度，2）position: relative;，3）浮动方向偏移量（left或者right）设置为50%，4）浮动方向上的margin设置为元素宽度一半乘以-1如果需要居中的元素为绝对定位元素，1）为元素设置宽度，2）偏移量设置为50%，3）偏移方向外边距设置为元素宽度一半乘以-1如果需要居中的元素为绝对定位元素，1）为元素设置宽度，2）设置左右偏移量都为0,3）设置左右外边距都为auto 如何竖直居中一个元素需要居中元素为单行文本，为包含文本的元素设置大于font-size的line-height盘点8种CSS实现垂直居中水平居中的绝对定位居中技术6 Methods For Vertical Centering With CSS JavaScript概念部分DOM元素e的e.getAttribute(propName)和e.propName有什么区别和联系e.getAttribute()，是标准DOM操作文档元素属性的方法，具有通用性可在任意文档上使用，返回元素在源文件中设置的属性e.propName通常是在HTML文档中访问特定元素的特性，浏览器解析元素后生成对应对象（如a标签生成HTMLAnchorElement），这些对象的特性会根据特定规则结合属性设置得到，对于没有对应特性的属性，只能使用getAttribute进行访问e.getAttribute()返回值是源文件中设置的值，类型是字符串或者null（有的实现返回””）e.propName返回值可能是字符串、布尔值、对象、undefined等大部分attribute与property是一一对应关系，修改其中一个会影响另一个，如id，title等属性一些布尔属性’‘的检测设置需要hasAttribute和removeAttribute来完成，或者设置对应property像’link‘中href属性，转换成property的时候需要通过转换得到完整URL一些attribute和property不是一一对应如：form控件中’input value=”hello”‘对应的是defaultValue，修改或设置value property修改的是控件当前值，setAttribute修改value属性不会改变value property offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别offsetWidth/offsetHeight返回值包含content + padding + border，效果与e.getBoundingClientRect()相同clientWidth/clientHeight返回值只包含content + padding，如果有滚动条，也不包含滚动条scrollWidth/scrollHeight返回值包含content + padding + 溢出内容的尺寸 XMLHttpRequest通用属性和方法1.readyState:表示请求状态的整数，取值： UNSENT（0）：对象已创建 OPENED（1）：open()成功调用，在这个状态下，可以为xhr设置请求头，或者使用send()发送请求 HEADERS_RECEIVED(2)：所有重定向已经自动完成访问，并且最终响应的HTTP头已经收到 LOADING(3)：响应体正在接收 DONE(4)：数据传输完成或者传输产生错误2.onreadystatechange：readyState改变时调用的函数3.status：服务器返回的HTTP状态码（如，200， 404）4.statusText:服务器返回的HTTP状态信息（如，OK，No Content）5.responseText:作为字符串形式的来自服务器的完整响应6.responseXML: Document对象，表示服务器的响应解析成的XML文档7.abort():取消异步HTTP请求8.getAllResponseHeaders(): 返回一个字符串，包含响应中服务器发送的全部HTTP报头。每个报头都是一个用冒号分隔开的名/值对，并且使用一个回车/换行来分隔报头行9.getResponseHeader(headerName):返回headName对应的报头值10.open(method, url, asynchronous [, user, password]):初始化准备发送到服务器上的请求。method是HTTP方法，不区分大小写；url是请求发送的相对或绝对URL；asynchronous表示请求是否异步；user和password提供身份验证11.setRequestHeader(name, value):设置HTTP报头12.send(body):对服务器请求进行初始化。参数body包含请求的主体部分，对于POST请求为键值对字符串；对于GET请求，为null mouseover/mouseout与mouseenter/mouseleave的区别与联系mouseover/mouseout是标准事件，所有浏览器都支持；mouseenter/mouseleave是IE5.5引入的特有事件后来被DOM3标准采纳，现代标准浏览器也支持mouseover/mouseout是冒泡事件；mouseenter/mouseleave不冒泡。需要为多个元素监听鼠标移入/出事件时，推荐mouseover/mouseout托管，提高性能标准事件模型中event.target表示发生移入/出的元素,vent.relatedTarget对应移出/如元素；在老IE中event.srcElement表示发生移入/出的元素，event.toElement表示移出的目标元素，event.fromElement表示移入时的来源元素 sessionStorage,localStorage,cookie区别都会在浏览器端保存，有大小限制，同源限制cookie会在请求时发送到服务器，作为会话标识，服务器可修改cookie；web storage不会发送到服务器cookie有path概念，子路径可以访问父路径cookie，父路径不能访问子路径cookie有效期：cookie在设置的有效期内有效，默认为浏览器关闭；sessionStorage在窗口关闭前有效，localStorage长期有效，直到用户删除共享：sessionStorage不能共享，localStorage在同源文档之间共享，cookie在同源且符合path规则的文档之间共享localStorage的修改会促发其他文档窗口的update事件cookie有secure属性要求HTTPS传输浏览器不能保存超过300个cookie，单个服务器不能超过20个，每个cookie不能超过4k。web storage大小支持能达到5M javascript跨域通信同源：两个文档同源需满足 协议相同 域名相同 端口相同跨域通信：js进行DOM操作、通信时如果目标与当前窗口不满足同源条件，浏览器为了安全会阻止跨域操作。跨域通信通常有以下方法如果是log之类的简单单项通信，新建img,script,link,iframe元素，通过src，href属性设置为目标url。实现跨域请求如果请求json数据，使用script进行jsonp请求现代浏览器中多窗口通信使用HTML5规范的targetWindow.postMessage(data, origin);其中data是需要发送的对象，origin是目标窗口的origin。window.addEventListener(‘message’, handler, false);handler的event.data是postMessage发送来的数据，event.origin是发送窗口的origin，event.source是发送消息的窗口引用内部服务器代理请求跨域url，然后返回数据跨域请求数据，现代浏览器可使用HTML5规范的CORS功能，只要目标服务器返回HTTP头部Access-Control-Allow-Origin: *即可像普通ajax一样访问跨域资源 javascript有哪几种数据类型六种基本数据类型 undefined null string boolean number symbol(ES6)一种引用类型 Object 什么闭包,闭包有什么用闭包是在某个作用域内定义的函数，它可以访问这个作用域内的所有变量。闭包作用域链通常包括三个部分： 函数本身作用域。 闭包定义时的作用域。 全局作用域。闭包常见用途： 创建特权方法用于访问控制 事件处理程序及回调 javascript有哪几种方法定义函数函数声明表达式function操作符Function 构造函数ES6:arrow function 应用程序存储和离线web应用HTML5新增应用程序缓存，允许web应用将应用程序自身保存到用户浏览器中，用户离线状态也能访问。1.为html元素设置manifest属性:’‘，其中后缀名只是一个约定，真正识别方式是通过text/cache-manifest作为MIME类型。所以需要配置服务器保证设置正确2.manifest文件首行为CACHE MANIFEST，其余就是要缓存的URL列表，每个一行，相对路径都相对于manifest文件的url。注释以#开头3.url分为三种类型：CACHE:为默认类型。NETWORK：表示资源从不缓存。 FALLBACK:每行包含两个url，第二个URL是指需要加载和存储在缓存中的资源， 第一个URL是一个前缀。任何匹配该前缀的URL都不会缓存，如果从网络中载入这样的URL失败的话，就会用第二个URL指定的缓存资源来替代。以下是一个文件例子：123456789101112CACHE MANIFESTCACHE:myapp.htmlmyapp.cssmyapp.jsFALLBACK:videos/ offline_help.htmlNETWORK:cgi/ 客户端存储localStorage和sessionStoragelocalStorage有效期为永久，sessionStorage有效期为顶层窗口关闭前同源文档可以读取并修改localStorage数据，sessionStorage只允许同一个窗口下的文档访问，如通过iframe引入的同源文档。Storage对象通常被当做普通javascript对象使用：通过设置属性来存取字符串值，也可以通过setItem(key, value)设置，getItem(key)读取，removeItem(key)删除，clear()删除所有数据，length表示已存储的数据项数目，key(index)返回对应索引的key cookie及其操作cookie是web浏览器存储的少量数据，最早设计为服务器端使用，作为HTTP协议的扩展实现。cookie数据会自动在浏览器和服务器之间传输。通过读写cookie检测是否支持cookie属性有name，value，max-age，path, domain，secure；cookie默认有效期为浏览器会话，一旦用户关闭浏览器，数据就丢失，通过设置max-age=seconds属性告诉浏览器cookie有效期cookie作用域通过文档源和文档路径来确定，通过path和domain进行配置，web页面同目录或子目录文档都可访问通过cookie保存数据的方法为：为document.cookie设置一个符合目标的字符串如下读取document.cookie获得’; ‘分隔的字符串，key=value,解析得到结果 javascript有哪些方法定义对象对象字面量： var obj = {};构造函数： var obj = new Object();Object.create(): var obj = Object.create(Object.prototype); // Object.create(proto[, propertiesObject]) ===运算符判断相等的流程是怎样的如果两个值不是相同类型，它们不相等如果两个值都是null或者都是undefined，它们相等如果两个值都是布尔类型true或者都是false，它们相等如果其中有一个是NaN，它们不相等如果都是数值型并且数值相等，他们相等， -0等于0如果他们都是字符串并且在相同位置包含相同的16位值，他它们相等；如果在长度或者内容上不等，它们不相等；两个字符串显示结果相同但是编码不同和=都认为他们不相等如果他们指向相同对象、数组、函数，它们相等；如果指向不同对象，他们不相等 ==运算符判断相等的流程是怎样的如果两个值类型相同，按照===比较方法进行比较如果类型不同，使用如下规则进行比较如果其中一个值是null，另一个是undefined，它们相等如果一个值是数字另一个是字符串，将字符串转换为数字进行比较如果有布尔类型，将true转换为1，false转换为0，然后用==规则继续比较如果一个值是对象，另一个是数字或字符串，将对象转换为原始值然后用==规则继续比较其他所有情况都认为不相等 对象到字符串的转换步骤如果对象有toString()方法，javascript调用它。如果返回一个原始值（primitive value如：string number boolean）,将这个值转换为字符串作为结果如果对象没有toString()方法或者返回值不是原始值，javascript寻找对象的valueOf()方法，如果存在就调用它，返回结果是原始值则转为字符串作为结果否则，javascript不能从toString()或者valueOf()获得一个原始值，此时throws a TypeError 对象到数字的转换步骤 如果对象有valueOf()方法并且返回元素值，javascript将返回值转换为数字作为结果 否则，如果对象有toString()并且返回原始值，javascript将返回结果转换为数字作为结果 否则，throws a TypeError&lt;,&gt;,&lt;=,&gt;=的比较规则所有比较运算符都支持任意类型，但是比较只支持数字和字符串，所以需要执行必要的转换然后进行比较，转换规则如下:如果操作数是对象，转换为原始值：如果valueOf方法返回原始值，则使用这个值，否则使用toString方法的结果，如果转换失败则报错经过必要的对象到原始值的转换后，如果两个操作数都是字符串，按照字母顺序进行比较（他们的16位unicode值的大小）否则，如果有一个操作数不是字符串，将两个操作数转换为数字进行比较函数内部arguments变量有哪些特性,有哪些属性,如何将它转换为数组arguments所有函数中都包含的一个局部变量，是一个类数组对象，对应函数调用时的实参。如果函数定义同名参数会在调用时覆盖默认对象arguments[index]分别对应函数调用时的实参，并且通过arguments修改实参时会同时修改实参arguments.length为实参的个数（Function.length表示形参长度）arguments.callee为当前正在执行的函数本身，使用这个属性进行递归调用时需注意this的变化arguments.caller为调用当前函数的函数（已被遗弃）转换为数组：var args = Array.prototype.slice.call(arguments, 0); 列举数组相关的常用方法参考答案: push/pop, shift/unshift, split/join, slice/splice/concat, sort/reverse, map/reduce, forEach, filter列举字符串相关的常用方法参考答案: indexOf/lastIndexOf/charAt, split/match/test, slice/substring/substr, toLowerCase/toUpperCase请用代码写出(今天是星期x)其中x表示当天是星期几,如果当天是星期一,输出应该是”今天是星期一”1234var days = [&apos;日&apos;,&apos;一&apos;,&apos;二&apos;,&apos;三&apos;,&apos;四&apos;,&apos;五&apos;,&apos;六&apos;];var date = new Date();console.log(&apos;今天是星期&apos; + days[date.getDay()]); js里的作用域是什么样子的？参考答案：大多数语言里边都是块作作用域，以{}进行限定，js里边不是．js里边叫函数作用域，就是一个变量在全函数里有效．比如有个变量p1在函数最后一行定义，第一行也有效，但是值是undefined. var globalVar = &apos;global var&apos;; function test() { alert(globalVar); // undefined, 因为globalVar在本函数内被重定义了，导致全局失效，这里使用函数内的变量值，可是此时还没定义 var globalVar = &apos;overrided var&apos;; // globalVar在本函数内被重定义 alert(globalVar); // overrided var } alert(globalVar); // global var，使用全局变量 js里边的this指的是什么?参考答案: this指的是对象本身，而不是构造函数． apply, call和bind有什么区别?参考答案：三者都可以把一个函数应用到其他对象上，注意不是自身对象．apply,call是直接执行函数调用，bind是绑定，执行需要再次调用．apply和call的区别是apply接受数组作为参数，而call是接受逗号分隔的无限多个参数列表， caller, callee和arguments分别是什么?参考答案: caller,callee之间的关系就像是employer和employee之间的关系，就是调用与被调用的关系，二者返回的都是函数对象引用．arguments是函数的所有参数列表，它是一个类数组的变量．]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Babel工作原理及Babel插件开发探索]]></title>
    <url>%2F2018%2FBabel%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8ABabel%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E6%8E%A2%E7%B4%A2.html</url>
    <content type="text"><![CDATA[在掘金上看见了面试官: 你了解过Babel吗？写过Babel插件吗? 答: 没有。卒，正巧自己对Babel工作原理和Babel插件开发也不够了解，赶紧来补一波吧。 基础概念首先我们这里需要了解一些基本的概念，这篇文章介绍的很详细，我这边只提一下。 BabelBabel 是 JavaScript 编译器，更确切地说是源码到源码的编译器，通常也叫做“转换编译器（transpiler）”。意思是说你为 Babel 提供一些 JavaScript 代码，Babel 更改这些代码，然后返回给你新生成的代码。 AST抽象语法树（abstract syntax tree或者缩写为AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。和抽象语法树相对的是具体语法树（concrete syntaxtree），通常称作分析树（parse tree）。一般的，在源代码的翻译和编译过程中，语法分析器创建出分析树。一旦AST被创建出来，在后续的处理过程中，比如语义分析阶段，会添加一些信息。 静态分析 静态分析是在不需要执行代码的前提下对代码进行分析的处理过程 （执行代码的同时进行代码分析即是动态分析）。静态分析的目的是多种多样的， 它可用于语法检查，编译，代码高亮，代码转换，优化，压缩等等场景。 Babel 的三个主要处理步骤分别是： 解析（parse），转换（transform），生成（generate）解析接收代码并输出AST。这个步骤又分为两个阶段：词法分析（Lexical Analysis）和 语法分析（Syntactic Analysis）。 词法分析词法分析阶段把字符串形式的代码转换成令牌（tokens）流。你可以把令牌看作是一个扁平化的语法片段数组。如：n*n代码经过词法分析转换成令牌1234567// n*n[ &#123; type: &#123; ... &#125;, value: &quot;n&quot;, start: 0, end: 1, loc: &#123; ... &#125; &#125;, &#123; type: &#123; ... &#125;, value: &quot;*&quot;, start: 2, end: 3, loc: &#123; ... &#125; &#125;, &#123; type: &#123; ... &#125;, value: &quot;n&quot;, start: 4, end: 5, loc: &#123; ... &#125; &#125;, ...] 每一个type有一组属性来描述该令牌：12345678910111213141516&#123; type: &#123; label: &apos;name&apos;, keyword: undefined, beforeExpr: false, startsExpr: true, rightAssociative: false, isLoop: false, isAssign: false, prefix: false, postfix: false, binop: null, updateContext: null &#125;, ...&#125; 语法分析语法分析阶段会把一个令牌(tokens)流转换成 AST 的形式。 这个阶段会使用令牌中的信息把它们转换成一个 AST 的表述结构，这样更易于后续的操作。这个过程我们可以通过astexplorer来查看我们代码生成的AST。这个时候我们的AST就产生了，如下图。PS：上图左边为我们的源代码，右边为对应生成的抽象语法树AST。 转换转换步骤接收 AST 并对其进行遍历，在此过程中对节点进行添加、更新及移除等操作。 这是 Babel 或是其他编译器中最复杂的过程 同时也是插件将要介入工作的部分。 生成代码生成步骤把最终（经过一系列转换之后）的 AST 转换成字符串形式的代码，同时还会创建源码映射（source maps）。代码生成其实很简单：深度优先遍历整个 AST，然后构建可以表示转换后代码的字符串。Babel工作原理见下图表示。图片来源，探索 babel 和 babel 插件是怎么工作的 开发一个Babel插件Visitors（访问者）当我们谈及“进入”一个节点，实际上是说我们在访问它们， 之所以使用这样的术语是因为有一个访问者模式（visitor）的概念。访问者是一个用于 AST 遍历的跨语言的模式。 简单的说它们就是一个对象，定义了用于在一个树状结构中获取具体节点的方法。 12345678910111213const MyVisitor = &#123; Identifier: &#123; // 当进入Identifier节点的时候执行 enter() &#123; console.log(&quot;Entered&quot;); &#125;, // 当退出Identifier节点的时候执行 exit() &#123; console.log(&quot;Exited!&quot;); &#125; &#125;&#125;; PS： 许多时候我们只需要关心进入节点，就可以使用简写 Identifier() { … } 或者 Identifier: { enter() { … } } 。这是一个简单的访问者，把它用于遍历中时，每当在树中遇见一个 Identifier 的时候会调用 Identifier里面的enter方法和exit方法。 Paths（路径） 我们通过 visitor可以在遍历到对应节点执行对应的函数，当需要修改对应节点的信息，我们还需要拿到对应节点的信息以及节点和所在的位置 （即和其他节点间的关系）, visitor在遍历到对应节点执行对应函数时候会给我们传入 path参数，辅助我们完成上面这些操作。注意 Path 是表示两个节点之间连接的对象,而不是当前节点，我们上面访问到了 Identifier节点，它传入的 path参数看起来是这样的： 12345678910111213&#123; &quot;parent&quot;: &#123; &quot;type&quot;: &quot;VariableDeclarator&quot;, &quot;id&quot;: &#123; ... &#125;, .... &#125;, &quot;node&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;name&quot;: &quot;...&quot; &#125;&#125; 这里就可以通过：path.node.name 获得当前节点的name；path.parent.id 获得父节点的id另外path对象上还包含添加、更新、移动和删除节点有关的其他很多方法，我们可以通过文档去了解。 开始动手写插件了输入的源代码为：yuzhenfan === wangkemei生成的AST123456789101112&#123; type: &quot;BinaryExpression&quot;, operator: &quot;===&quot;, left: &#123; type: &quot;Identifier&quot;, name: &quot;yuzhenfan&quot; &#125;, right: &#123; type: &quot;Identifier&quot;, name: &quot;yuzhenfan&quot; &#125;&#125; 省略部分属性，可以通过http://astexplorer.net查看全部属性。123456789101112131415161718192021222324252627282930const babel = require(&apos;babel-core&apos;)// 我们的babel插件let MyVisitor = function(&#123; types: t &#125;) &#123; return &#123; visitor: &#123; BinaryExpression(path) &#123; if (path.node.operator !== &quot;===&quot;) &#123; return; &#125; // 改变当前节点的left、right（插件的核心代码） path.node.left = t.identifier(&quot;fanerge1&quot;); path.node.right = t.identifier(&quot;fanerge2&quot;); &#125; &#125; &#125;;&#125;const code = `yuzhenfan === wangkemei;`;let demo = babel.transform(code, &#123; // 使用我们的插件 plugins: [MyVisitor]&#125;)console.log(demo); // fanerge1===fanerge2 输出的代码为（经过我们的插件处理）：fanerge1===fanerge2下图为node打印出Balbel输出的代码：项目地址，非常简单的Babel插件，后续再继续学习 参考文档Babel 插件手册ESTreeAST Explorer探索 babel 和 babel 插件是怎么工作的掘金-babel插件]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>Babel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器工作原理-webkit内核研究]]></title>
    <url>%2F2018%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-webkit%E5%86%85%E6%A0%B8%E7%A0%94%E7%A9%B6.html</url>
    <content type="text"><![CDATA[从年前就开始梳理浏览器的工作原理（主要对webkit内核的浏览器进行分析）到现在差不多快一个月了，本文意在帮助前端工程师了解浏览器的工作原理，并据此来优化我们的网页性能。主要查阅了WebKit技术内幕、MDN、W3C等网站资料，下文中有若干图片摘自于《WebKit技术内幕》，在此表示感谢。本文略长，如有不适，实属意外。如有不正确的地方，还望指正，毕竟传播真理才不会误导其他同学，共同进步才是目的。 浏览器的内核浏览器内核由渲染引擎和JS引擎组成，不同的浏览器、即使同一浏览器不同型号可能渲染引擎和JS引擎都不一样。 渲染引擎1)Trident渲染引擎 –&gt; 老版本IE系列浏览器2)Edge渲染引擎 -&gt; Win10中IE浏览器3)Gecko渲染引擎 –&gt; Mozilla Firefox4)Presto渲染引擎 –&gt; Opera5)KHTML渲染引擎 –&gt; 早期的Safafi和Google Chrome6)Webkit渲染引擎 -&gt; 2001年后的Safari和Chrome以及国内的一些浏览器7)Blink渲染引擎 -&gt; 新版本的Chromium浏览器Google项目 JavaScript引擎1)JScript引擎 –&gt; IE系列浏览器2)spiderMonkey引擎 –&gt; Mozilla Firefox3)V8引擎 –&gt; Google Chrome4)linear b/futhark引擎 –&gt; Opera 浏览器渲染引擎的进度史为大家提供两个开发常用查询网站：该浏览器对html5的支持程度不同与Can I use 浏览器的渲染引擎及依赖模块分析上图中虚线部分表示渲染引擎所提供的功能。这里渲染引擎包含了JavaScript引擎，许多时候两者都不太区分。下面的内容大部分都是基于这张图来分析的，我们将逐步解释从用户输入URL到页面展示给用户这个过程中都发生了什么？我们先了解网页的基础知识。 网页基础知识html – 结构css – 样式JavaScript – 行为还需要一些静态资源：png、gif、webp、MP4、font、svg等等。由上面几部分就构成我们的网页。 输入URL到页面展示简图读者不要太关心上图所标的顺序，在某些时候可能会有出入。 浏览器内核各部分解释 HTML解释器：解释HTML文本的解释器，主要作用是将HTML文本解释成DOM树，DOM是一种文档表示方法。CSS解释器：级联样式表的解释器，它的作用是为DOM中的各个元素对象计算出样式信息，从而为计算最后网页的布局提供基础设施。布局：在DOM创建之后，webkit需要将其中的元素对象同样式信息结合起来，计算它们的大小位置等布局信息，形成一个能够表示这所有信息的内部比偶表示模型。JavaScript引擎：使用JavaScript代码可以修改网页的内容，也能修改CSS的信息，JavaScript引擎能过解释JavaScript代码并通过DOM接口和CSSOM接口来修改网页内容和样式信息，从而改变渲染结果。绘图：使用图形库将布局计算后的各个网页的节点绘制成图像结果。 PS：这些模块依赖许多其他基础模块，其中包括网络、存储、2D/3D图形、音频视频和图片解码器等。这里就不对基础模块做相应说明了。 下面，我就逐个过程进行分析，我这里省略一些非本文目的的过程，如DNS环节。 HTML解释器先来看看HTML解释器工作原理字节流（Bytes）–&gt; 字符流（Characters）–&gt; 词语（Tokens）–&gt; 节点 –&gt; DOM树 首先是字节流，经过解码之后是字符流，然后通过词法分析器会被解释成词语（Tokens），时候经过分析器构建成节点，最后这些节点被组建成一棵DOM树。词法分析：HTMLTokenizer 类（作用是词法分析，类似于状态机），输入的是字符串，输出的是一个个的词语。XSSAuditor验证词语：XSSAuditor （验证词语流Token Stream）XSS指的是Cross Site Security，主要是针对安全方面的考虑。词语到节点：webkit用来构建DOM节点，这一步骤由HTMLDocumentParser 类调用 HTMLTreeBuilder 类的 constructTree的函数来实现。节点到DOM树：树中的元素节点创建属性节点等工作由HTMLConstructionSite类来完成，该类中包含一个 HTMLElementStack 作为保存元素节点的栈。JavaScript的执行：webkit将DOM树创建过程中需要执行得我Javascript代码交由HTMLScriptRunner类来负责。DOM的事件机制：webkit中用EventTarget类来表示DOM规范中Events部分定义的事件目标，Node 节点继承自 EventTarget类，所以Node拥有EventTarget类的相关的方法。 这里需要提一下W3C新规范，影子（Shadow）DOMShadow DOM API的 ShadowRoot接口是一个DOM子树的根节点, 它与文档的主DOM树分开渲染。MDN-影子节点 影子（Shadow）DOM定义：Shadow DOM 为Web组件中的 DOM和 CSS提供了封装。Shadow DOM 使得这些东西与主文档的DOM保持分离。ShadowRoot 类继承自 DocumentFragment 类。PS：可以使用document.createDocumentFragment 方法或者构造函数来创建一个空的 DocumentFragment. CSS解释器和样式布局先看看CSS怎么和DOM结合展示页面的呢？css解释器和规则匹配处于DOM树建立之后，RenderObject树建立之前，css解释器解释后的结果会保存起来，然后RenderObject树基于该结果来进行规范匹配和布局计算。 CSSOM（CSS Object Model）CSSOM视图模块(CSSOM View Module)定义了一些 API，Web 开发人员使用这些 API 可以进行检查，也可以以编程方式更改文档及其内容的视觉属性，包括布局框定位、视区宽度和元素滚动。document.styleSheets 可以查看当前页面的StyleSheetList对象，每个link、style都会产生 CSSStyleSheet 作为 StyleSheetList对象的value。 CSS解释器和规则匹配（本区块内容会使我们对css选择器权重有更好的理解）DocumentStyleSheetCollection类（属于Document类），该类包含了所有CSS样式表，还包括了webkit的内部表示类CSSStyleSheet，它包含了CSS的href、类型、内容等信息。CSS解释过程：css字符串经过css解释器处理后变成渲染引擎的内部规则的过程，使用CSSParser类来负责该过程。在解释网页中自定义的CSS样式之前，实际上webkit渲染引擎会为每个网页设置一个默认样式，这也是我们为什么要重置浏览器样式的根本原因。规则匹配：StyleResolver类为DOM的元素节点匹配样式，StyleResolver类根据元素的信息，例如标签名、类别等，从样式规则中查找最匹配的规则，然后将样式信息保存到新建的RenderStyle对象中。最后，这些RenderStyle对象被RenderObject类所管理和使用。 其中，规则的匹配则是由ElementRuleCollector类来计算并获得，它根据元素的属性等信息，并从DocumentRuleSets类中获取规则集合，依次按照ID、CLASS、标签等选择器信息逐次匹配获得元素的样式。 然后webkit对这些规则进行排序，对于该元素需要的样式属性，webkit选择从高优先级规则中选取，并将样式属性值返回。这里，我引入一个不太相关的知识点，块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的部分，是块级盒布局发生的区域，也是浮动元素与其他元素交互的区域。不太了解的同学，请异步MDN-BFC webkit布局当webkit创建RenderObject对象之后，每个对象是不知道自己的位置、大小等信息的，webkit根据盒模型来计算他们的位置、大小等信息的过程称为布局计算/排版。 布局计算分类：第一类是对整个RenderObject树进行的计算；第二类是对RenderObject树中某个子树的计算，常见于文本元素或者overflow：auto块的计算。 布局计算：布局计算是一个递归的过程，这是因为一个节点的大小通常需要先计算它的子节点的位置、大小等信息。 扩展知识点我们常说的reflow和repaint。涉及到元素的几何属性改变会造成reflow会降低性能（transform、opacity等属性不会造成reflow）。扩展为什么说transform实现动画较直接设置几何属性性能较好？1.webkit渲染过程：style -&gt; Layout(reflow发生在这) -&gt; Paint（repaint发生在这） -&gt; Composite，transform是位于’Composite（渲染层合并）‘，而width、left、margin等则是位于‘Layout（布局）’层，这必定导致reflow。2.现代浏览器针对transform等开启GPU加速。 style -&gt; Layout(reflow发生在这) -&gt; Paint（repaint发生在这） -&gt; Composite（transform发生在这个时候）由这个过程我们可以看出，这也是为什么发生reflow必定会发生repaint的根本原因。CSS Animation性能优化从重绘重排角度讲解transform的动画性能 渲染过程的一些理论RenderObject树同其他树（如RenderLayer树等），构成了webkit渲染的主要基础设施。 RenderObject树（DOM树 -&gt; RenderObject树）一个RenderObject对象保存了为绘制DOM节点所需要的各种信息，例如样式布局信息，经过webkit的处理之后，RenderObject对象知道如何绘制自己。下列情况会使DOM树节点创建一个RenderObject对象（DOM和RenderObject并非一一对应）。1.DOM树的document节点。2.DOM树种的可视节点，例如html、body、div等。而webkit不会为非可视化节点创建RenderObject节点，例如meta、script。3.某些情况下webkit需要建立匿名的RenderObject节点，该节点不对应于DOM树种的任何节点，而是webkit处理上的需要，典型的例子例如匿名的RenderBlock节点。在html组建页面结构时，webkit为了提升网页性能，会引入分层结构。 网页层次结构（css也会对网页的分层策略产生重要影响）对于一个html文件webkit会为某些元素和它的子节点建立新层，这样webkit可以单独对某层操作提升性能，下列情况会产生新层。1.video标签 – webkit在新层中有效的处理视频解码器和浏览器之间的交互和渲染问题。2.div、p等普通标签 – 涉及到3D变换时。3.canvas标签 – 复杂的2D和3D绘图操作。 RenderLayer树webkit会为网页的层次创建相应的RenderLayer对象。当某些类型RenderObject的节点或者某些css样式的RenderObject节点出现的时候，webkit就会为这些节点创建RenderLayer对象。RenderLayer树是基于RenderObject树建立起来的一棵新树。RenderLayer节点和RenderObject节点不是一一对应关系，而是一对多的关系。哪些情况下的RenderObject节点需要建立新的RenderLayer节点呢？1.DOM树的Document节点对应的RenderView节点。2.DOM树中的Document的子节点，也就是HTML节点对应RenderBlock节点。3.显式的制定css位置的RenderObject节点。4.有透明效果的RenderObject节点。5.节点有溢出（overflow）、alpha或者反射效果的RenderObject节点。6.使用Canvas 2D和3D（WebGL）技术的RenderObject节点。7.Video节点对应的RenderObject节点。 渲染方式绘图上下文（绘图上下文可以分成两种类型）： 第一种是用来绘制2D图形的上下文，称之为2D绘图上下文（GraphicsContext）。 第二种是绘制3D图形的上下文，称之为3D绘图上下文（GraphicsContext3D）。网页的三种渲染方式：1.软件渲染（CPU内存）2.使用软件绘图的合成化渲染（GPU内存）css3D、WebGL3.硬件加速的合成化渲染（GPU内存） webkit软件渲染技术在不需要硬件加速内容的时候（包括但不限于css3 3D变形、css3 3D变换、WebGL和视频），webkit就可以使用软件渲染技术来完成页面绘制。对于每个RenderObject对象，需要三个阶段绘制自己：第一阶段是绘制该层中所有块的背景和边框。第二阶段是绘制浮动内容。第三阶段是前景（Foreground），也就是内容部分、轮廓、字体颜色、大小等（内嵌元素的背景、边框等发生在这一阶段）。 硬件加速机制硬件加速技术是指使用GPU的硬件能力来帮助渲染网页（GPU的作用主要是用来绘制3D图形并且性能特别好）。 Chrome的硬件加速机制canvas开发，可以将画布分解为更小的画布，这样在更新时只需要更新小画布从而减少开销。css3 3D变形技术，它能过让浏览器仅仅使用合成器来合成所有的层就可以达到动画效果（只触发Composite而不用触发style -&gt; Layout(reflow发生在这) -&gt; Paint）。 WebGLWebGL是Khronous组织提出的一套基于3D图形定义的javascript接口。它基于canvas元素，跟canvas2D不同的是，Web开发者可以使用3D图形接口来绘制各种3D图形。 css 3D变形这里包括3D变形和动画。webkit会建立一个新层来处理，从而提升性能。 JavaScript引擎推动JavaScript运行速度提高的利器JIT（Just-In-Time）。JIT：就是代码在目标平台上运行的时候，实时的把代码编译为目标机器上的机器码。编译原理：C++：源代码 –&gt; 抽象语法树 –&gt; 本地代码Java：源代码 –&gt; 抽象语法树 –&gt; 字节码（跨平台） –&gt; JIT –&gt; 本地代码 V8的一些特性（这里太多了，读者可以自己深究）常用的javascript引擎有v8和JavaScriptCore工作原理在js中，基本数据类型Boolean、Number、String、Null、Undefined、Symbol，其他数据都是对象。 数据表示在V8中，数据的表示分成两个部分 第一部分是数据的实际内容，它们是变长的，而且内容的类型也不一样，如String、对象等。 第二部分是数据的句柄，句柄的大小是固定的，句柄中包含指向数据的指针。 数据的存储Handle：句柄类，主要用来管理基础数据和对象，以便被垃圾回收器操作。主要有两个类型，一个Local类（继承自Handle类），表示本地栈上的数据，所以比较轻量。另一个是Persistent类（继承自Handle类）表示函数间的数据和对象访问。对于整形数据，由Handle本身来存储，同时也为了快速访问。其他的数据都是从堆中申请内存来存储它们，由于其他数据类型，受限于Handle的大小和变长等原因，都存储在堆中。V8的延迟（deferred）特性：它使的许多javascript代码的编译直到运行的时候被调用到才会发生，这样可以减少时间开销。 扩展常见的语言类型机器语言（它是计算机唯一能直接执行的语言，电子计算机的机器指令是一列二进制数字。）汇编语言 汇编指令是机器指令便于记忆的书写格式，但他需要进过编译器转换为机器语言，这样机器才能执行。 使用setTimeout或setInterval较requestAnimationFrame的缺点？时间间隔应该设置为多少才合适呢。跟屏幕的分辨率有关吗（不同浏览器存在一个极小值）。设置的时间会按照会准确执行吗。动画会被平滑地显示效果吗。回调函数时复杂的好还是简单的好呢。window.requestAnimationFrame 其他浏览器相关知识插件和Javascript扩展在早期的浏览器能力十分有限，Web前端开发者们希望能够通过一些机制来扩展浏览器的能力（插件机制如flash插件）。 NPAPI全称叫 Netscape plugin APINPAPI是当今最流行的插件架构，几乎所有浏览器都支持，不过存在很大的安全隐患，插件可以窃取系统底层权限，发起恶意攻击。 PPAPI也就是Pepper Plugin API2010年，Google开发了新的PPAPI，将外挂插件全部放到沙盒里运行，2012年Windows、Mac版本的Chrome浏览器先后升级了PPAPI Flash Player，并希望今年底之前彻底淘汰NPAPI。 JavaScript引擎的扩展机制通过如下url参看当前chrome浏览器安装的extensionschrome://extensions/ 多媒体WebRTCWebRTC实现了基于网页的视频会议，标准是WHATWG 协议，目的是通过浏览器提供简单的javascript就可以达到实时通讯（Real-Time Communications (RTC)）能力。MDN-WebRTC最重要的方法：navigator.mediaDevices.getUserMedia(constraints)还有Video、Audio等。 安全机制第一部分是网页的安全，包括但是不限于网页数据安全传输、跨域访问、用户数据安全等。第二部分是浏览器的安全，具体是指虽然网页或者Javascript代码有一些安全问题或者存在安全漏洞，浏览器也能够在运行它们的时候保证吱声的安全，不受到攻击从而泄漏数据或者使系统遭受破坏。 网页安全模型安全模型基础：域（Same Origin Policy）XMLHttpRequest、cookie的读写、DOM对象操作等。XSS（Cross Site Scripting）执行跨域的js脚本代码。开发者可以将用户输入的数据进行字符转换来避免。webkit通过XSSAuditor对象帮我们过滤（默认开启）。CSP （Content-Security-Policy）HTTP首部字段，内容安全策略（CSP）用于检测和减轻用于 Web 站点的特定类型的攻击，例如 XSS 和数据注入等。CORS（Cross Origin Resource Sharing）跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。 具体服务端代码设置1234567891011// 请求头header(&apos;Access-Control-Allow-Origin: http://arunranga.com&apos;); // header(&apos;Access-Control-Allow-Methods: POST, GET, OPTIONS&apos;);header(&apos;Access-Control-Allow-Headers: X-PINGARUNER&apos;);// 响应头Access-Control-Allow-Origin、Access-Control-Allow-Credentials、Access-Control-Allow-Headers、Access-Control-Expose-Headers、Access-Control-Allow-Methods、Access-Control-Max-Age Cross Document Messaging 通过 window.postMessage 和 message 事件来通信。HTTPS（安全传输协议）SPDY（读作“SPeeDY”）是Google开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。 SPDY核心思想为多路复用。QUIC（Quick UDP Internet Connection）是谷歌制定的一种基于UDP的低时延的互联网传输层协议。 CSP和CORS的区别：CSP定义了网页自身能够访问的某些域和资源。CORS定义一个网页如何才能访问被同源策略禁止的跨域资源，并规定了两者交互的协议和方式。 沙箱模型浏览器的沙箱模型是利用系统提供的安全技术，让网页在执行过程中不会修改操作系统或者是访问系统中的隐私数据，而需要访问系统资源或者说是系统调用的时候，通过一个代理机制来完成。 chrome浏览其使用技巧（以实用性排列）一下url直接输入在浏览器中，enter即可 URL 作用 chrome://inspect 移动端网页调试 chrome://net-internals net-internals是一套工具集合，用于帮助诊断网络请求与访问方面的问题，它通过监听和搜集 DNS，Sockets，SPDY，Caches等事件与数据来向开发者反馈各种网络请求的过程、状态以及可能产生影响的因素。如，查看DNS主机解析缓存chrome://net-internals/#dns chrome://view-http-cache/ 查看内部存储内容及其详情 chrome://downloads/ 下载内容管理，其快捷键是Ctrl+J chrome://extensions/ 扩展管理 chrome://bookmarks/ 书签管理 chrome://history 访问历史管理 chrome://restart 重启chrome浏览器 chrome://apps chrome网上应用店 chrome://flags/ 新特性管理 chrome://dns 查看DNS预取命名（从超链接等处来预测） chrome://quota-internals 查看浏览器所使用磁盘空间配额 chrome://settings 浏览器的设置 chrome://sync-internals 查看chrome 的同步状态 chrome://about/ 查看所有chrome命令 期望加入一个技术氛围nice的团队-成都]]></content>
      <categories>
        <category>webkit</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端常识-gj]]></title>
    <url>%2F2018%2F%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%AF%86-gj.html</url>
    <content type="text"><![CDATA[React virtualDOM（batching）在React中，render执行的结果返回的并不是真正的DOM节点，结果仅仅是轻量级的JavaScript对象，我们称之为virtual DOM。通过 React 的 diff，再由虚拟 DOM 来确保只对界面上真正变化的部分进行实际的DOM操作，这样就极大提升了性能。batching把所有的DOM操作搜集起来，一次性提交给真实的DOM。 DOM 操作真正的问题在于每次操作都会触发布局的改变、DOM树的修改和渲染。所以，当你一个接一个地去修改30个节点的时候，就会引起30次（潜在的）布局重算，30次（潜在的）重绘。当你在这个单独的 virtualDOM 树上也一个接一个地修改30个节点的时候，它不会每次都去触发重绘，所以修改节点的开销就变小了。一旦你要把这些改动传递给真实DOM，之前所有的改动就会整合成一次DOM操作。这一次DOM操作引起的布局计算和重绘可能会更大，但是相比而言，整合起来的改动只做一次，减少了（多次）计算。 React中一个没人能解释清楚的问题——为什么要使用Virtual DOM React diffReact diff 作为 Virtual DOM 的加速器，其算法上的改进优化是 React 整个界面渲染的基础。计算一棵树形结构转换成另一棵树形结构的最少操作，是一个复杂且值得研究的问题。传统 diff 算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到 O(n^3)，其中 n 是树中节点的总数。React 通过制定大胆的策略，将 O(n^3) 复杂度的问题转换成 O(n) 复杂度的问题。diff 策略（—为具体比对）1.Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计 — tree diff2.拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构 — component diff3.对于同一层级的一组子节点，它们可以通过唯一 id 进行区分 — element diff tree diffReact 通过 updateDepth 对 Virtual DOM 树进行层级控制，只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。 component diffReact 是基于组件构建应用的，对于组件间的比较所采取的策略也是简洁高效。1.如果是同一类型的组件，按照原策略继续比较 virtual DOM tree。2.如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。3.对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切的知道这点那可以节省大量的 diff 运算时间，因此 React 允许用户通过 shouldComponentUpdate() 来判断该组件是否需要进行 diff。 element diff当节点处于同一层级时，React diff 提供了三种节点操作，分别为：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）。1.INSERT_MARKUP，新的 component 类型不在老集合里， 即是全新的节点，需要对新节点执行插入操作。2.MOVE_EXISTING，在老集合有新 component 类型，且 element 是可更新的类型，generateComponentChildren 已调用 receiveComponent，这种情况下 prevChild=nextChild，就需要做移动操作，可以复用以前的 DOM 节点。3.REMOVE_NODE，老 component 类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者老 component 不在新集合里的，也需要执行删除操作。React 提出优化策略：允许开发者对同一层级的同组子节点，添加唯一 key 进行区分，这也是为什么React建议我们在列表项目中添加key属性的原因！ 知乎专栏-react diff，写的很不错 webkit 渲染机制先看下简单版的（我们从浏览器地址栏输入网址开始到web页面被完整的呈现在眼前做了哪些事，暂不考虑DNS缓存、本地资源缓存）网址被DNS解析为IP地址 -&gt; 通过IP地址建立TCP连接 -&gt; 发送HTTP请求 -&gt; 服务器处理请求并返回响应 -&gt; 浏览器解析渲染页面 -&gt; 断开TCP连接 渲染过程一般渲染引擎主要包括HTML解释器、CSS解释器、Javascript引擎、布局、绘图等模块。HTML解释器 ：HTML解释器的工作就是将网络或者本地磁盘获取到的HTML网页和资源从字节流解释成DOM树的结构（首先是字节流，经过解码之后是字符流，然后通过词法分析器会被解释成词语（TOKENS），经过语法分析器构建成节点，最后这些节点被组建成一颗DOM树）CSS解释器 ：CSS字符串被CSS解释器处理后变成渲染引擎的内部规则表示。（样式规则建立完成之后，webkit会保存规则结果，当DOM的节点建立之后，webkit会为可视化节点选择合适的样式信息，即作样式规则匹配）Javascript引擎 ：将Javascript代码处理并执行，一个Javascript引擎可以包括以下几个部分 编译器 -&gt; 主要工作是将源代码编译成抽象语法树，在某些引擎中还包括将抽象语法树转换为字节码（JavascriptCore 引擎）。 解释器 -&gt; 在某些引擎中，解释器主要是接收字节码，解释执行字节码，同时也依赖垃圾回收机制等。 JIT工具 -&gt; 将字节码或者抽象语法树转换为本地代码 （V8 引擎）。 垃圾回收器和分析工具。布局 ：计算RenderObject对象的位置、大小等信息。绘图 ：将构建好的渲染内部表示模型使用图形库绘制出来。WEBKIT渲染不可不知的这四棵树webkit 渲染机制 http1.1&amp;2较1有哪些新东西？长连接HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。 节约带宽HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础。 HOST域现在可以web server例如tomat，设置虚拟站点是非常常见的，也即是说，web server上的多个虚拟站点可以共享同一个ip和端口。 多路复用HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。 数据压缩HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。 服务器推送当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源 前端需要注意哪些SEO1.合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可2.语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页3.重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取4.重要内容不要用js输出：爬虫不会执行js获取内容（目前chrome浏览器可以了）5.少用iframe：搜索引擎不会抓取iframe中的内容6.非装饰性图片必须加alt7.提高网站速度：网站速度是搜索引擎排序的一个重要指标 点击穿透如何产生： 现在有两层DOM结构（但不嵌套），底层和弹出层（底层在弹出层下面且弹出层的投影在底层内部），弹出层有一个 touchend 事件，底层有一个 click 事件。当点击弹出层就会触发 touchend 事件（弹出层立即消失，这时事件的 target 为弹出层），300ms后触发 click 事件（由于弹出层消失了，这时事件的 target 就为底层了）。看出来了吗？这样就发生了‘点击穿透’。产生的原因： click事件延迟且弹出层消失了。解决方案： 1.只用touch事件 2.只用click事件（不推荐只用click事件，这样所有点击都有延迟了，实在要使用可以使用事件库 fastclick） 3.可以延迟（&gt;300ms,好像不太科学）弹出层消失点击穿透原理及解决 服务器’推‘技术webSocket、Comet、轮询Comet主要是利用客户端向服务器发出请求时，服务器发回响应内容，并利用javascript建立一个长时间链接的“长连接”，这个连接在没有接收到服务器或者没有到达连接时间限制时会一直等待服务器的消息，如果服务器有消息传来，立即显示最新信息。长连接每隔一段时间会重新向服务器发出连接请求。服务器在有新消息产生的时候立即检查消息的接收方是否存在长连接，如果存在马上发送，如果没有则不发送。 web开发中会话跟踪的方法有哪些1.cookie（一般不能存关键字段，最好存sessionID配合session使用）2.session3.url重写4.隐藏input5.ip地址 img的title和alt有什么区别title是global attributes之一，用于为元素提供附加的advisory information。通常当鼠标滑动到元素上的时候显示。alt是 img 的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。 doctype是什么,举例常见doctype及特点12345&lt;!doctype&gt;声明必须处于HTML文档的头部，在&lt;html&gt;标签之前，HTML5中不区分大小写&lt;!doctype&gt;声明不是一个HTML标签，是一个用于告诉浏览器当前HTMl版本的指令现代浏览器的html布局引擎通过检查doctype决定使用兼容模式还是标准模式对文档进行渲染，一些浏览器有一个接近标准模型。在HTML4.01中&lt;!doctype&gt;声明指向一个DTD，由于HTML4.01基于SGML，所以DTD指定了标记规则以保证浏览器正确渲染内容HTML5不基于SGML，所以不用指定DTD 常见dotype1234567HTML4.01 strict：不允许使用表现性、废弃元素（如font）以及frameset。声明：&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;HTML4.01 Transitional:允许使用表现性、废弃元素（如font），不允许使用frameset。声明：&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;HTML4.01 Frameset:允许表现性元素，废弃元素以及frameset。声明：&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;XHTML1.0 Strict:不使用允许表现性、废弃元素以及frameset。文档必须是结构良好的XML文档。声明：&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;XHTML1.0 Transitional:允许使用表现性、废弃元素，不允许frameset，文档必须是结构良好的XMl文档。声明： &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;XHTML 1.0 Frameset:允许使用表现性、废弃元素以及frameset，文档必须是结构良好的XML文档。声明：&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;HTML 5: &lt;!doctype html&gt; HTML全局属性(global attribute)有哪些accesskey:设置快捷键，提供快速访问元素如aaa在windows下的firefox中按alt + shift + a可激活元素class:为元素设置类标识，多个类名用空格分开，CSS和javascript可通过class、classList属性获取元素contenteditable: 指定元素内容是否可编辑contextmenu: 自定义鼠标右键弹出菜单内容data-*: 为元素增加自定义属性dir: 设置元素文本方向draggable: 设置元素是否可拖拽dropzone: 设置元素拖放类型： copy, move, linkhidden: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果id: 元素id，文档内唯一lang: 元素内容的的语言spellcheck: 是否启动拼写和语法检查style: 行内css样式tabindex: 设置元素可以获得焦点，通过tab可以导航title: 元素相关的建议信息translate: 元素和子孙节点内容是否需要本地化 什么是web语义化,有什么好处web语义化是指通过HTML标记表示页面包含的信息，包含了HTML标签的语义化和css命名的语义化。HTML标签的语义化是指：通过使用包含语义的标签（如h1-h6）恰当地表示文档结构css命名的语义化是指：为html标签添加有意义的class，id补充未表达的语义，如Microformat通过添加符合规则的class描述信息为什么需要语义化：1.去掉样式后页面呈现清晰的结构2.搜索引擎更好地理解页面，有利于收录3.便团队项目的可持续运作及维护5.盲人使用读屏器更好地阅读 HTTP method一台服务器要与HTTP1.1兼容，只要为资源实现GET和HEAD方法即可。GET是最常用的方法，通常用于请求服务器发送某个资源。HEAD与GET类似，但服务器在响应中值返回首部，不返回实体的主体部分PUT让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档，或者，如果那个URL已经存在的话，就用干这个主体替代它POST起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方。TRACE会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个TRACE响应并在响应主体中携带它收到的原始请求报文。TRACE方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。OPTIONS方法请求web服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。DELETE请求服务器删除请求URL指定的资源。 HTTP request报文结构是怎样的首行是Request-Line包括：请求方法，请求URI，协议版本，CRLF首行之后是若干行请求头，包括general-header，request-header或者entity-header，每个一行以CRLF结束请求头和消息实体之间有一个CRLF分隔根据实际请求需要可能包含一个消息实体一个请求报文例子如下：1234567891011121314GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1Host: www.w3.orgConnection: keep-aliveCache-Control: max-age=0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36Referer: https://www.google.com.hk/Accept-Encoding: gzip,deflate,sdchAccept-Language: zh-CN,zh;q=0.8,en;q=0.6Cookie: authorstyle=yesIf-None-Match: &quot;2cc8-3e3073913b100&quot;If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMTname=fanerge&amp;age=26 HTTP response报文结构是怎样的首行是状态行包括：HTTP版本，状态码，状态描述，后面跟一个CRLF首行之后是若干行响应头，包括：通用头部，响应头部，实体头部响应头部和响应实体之间用一个CRLF空行分隔最后是一个可能的消息实体响应报文例子如下：12345678910111213HTTP/1.1 200 OKDate: Tue, 08 Jul 2014 05:28:43 GMTServer: Apache/2Last-Modified: Wed, 01 Sep 2004 13:24:52 GMTETag: &quot;40d7-3e3073913b100&quot;Accept-Ranges: bytesContent-Length: 16599Cache-Control: max-age=21600Expires: Tue, 08 Jul 2014 11:28:43 GMTP3P: policyref=&quot;http://www.w3.org/2001/05/P3P/p3p.xml&quot;Content-Type: text/html; charset=iso-8859-1&#123;&quot;name&quot;: &quot;qiu&quot;, &quot;age&quot;: 25&#125; 如何进行网站性能优化content方面减少HTTP请求：合并文件、CSS精灵、inline Image减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询避免重定向：多余的中间访问使Ajax可缓存非必须组件延迟加载未来所需组件预加载减少DOM元素数量将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量减少iframe数量不要404 Server方面使用CDN添加Expires或者Cache-Control响应头对组件使用Gzip压缩配置ETagFlush Buffer EarlyAjax使用GET进行请求避免空src的img标签 Cookie方面减小cookie大小引入资源的域名不要包含cookie css方面将样式表放到页面顶部不使用CSS表达式使用不使用@import不使用IE的Filter Javascript方面将脚本放到页面底部将javascript和css从外部引入压缩javascript和css删除不需要的脚本减少DOM访问合理设计事件监听器 图片方面优化图片：根据实际颜色需要选择色深、压缩优化css精灵不要在HTML中拉伸图片保证favicon.ico小并且可缓存 移动方面保证组件小于25kPack Components into a Multipart Documentyahoo Best Practices for Speeding Up Your Web Site 什么是渐进增强渐进增强是指在web设计时强调可访问性、语义化HTML标签、外部样式表和脚本。保证所有人都能访问页面的基本内容和功能同时为高级浏览器和高带宽用户提供更好的用户体验。核心原则如下:所有浏览器都必须能访问基本内容所有浏览器都必须能使用基本功能所有内容都包含在语义化标签中通过外部CSS提供增强的布局通过非侵入式、外部javascript提供增强功能end-user web browser preferences are respected HTTP状态码及其含义1XX：信息状态码100 Continue：客户端应当继续发送请求。这个临时相应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求之后向客户端发送一个最终响应。101 Switching Protocols：服务器已经理解力客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到Upgrade消息头中定义的那些协议。2XX：成功状态码200 OK：请求成功，请求所希望的响应头或数据体将随此响应返回201 Created：202 Accepted：203 Non-Authoritative Information：204 No Content：205 Reset Content：206 Partial Content：3XX：重定向300 Multiple Choices：301 Moved Permanently：302 Found：303 See Other：304 Not Modified：305 Use Proxy：306 （unused）：307 Temporary Redirect：4XX：客户端错误400 Bad Request:401 Unauthorized:402 Payment Required:403 Forbidden:404 Not Found:405 Method Not Allowed:406 Not Acceptable:407 Proxy Authentication Required:408 Request Timeout:409 Conflict:410 Gone:411 Length Required:412 Precondition Failed:413 Request Entity Too Large:414 Request-URI Too Long:415 Unsupported Media Type:416 Requested Range Not Satisfiable:417 Expectation Failed:5XX: 服务器错误500 Internal Server Error:501 Not Implemented:502 Bad Gateway:503 Service Unavailable:504 Gateway Timeout:505 HTTP Version Not Supported:]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IndexDB探索之路]]></title>
    <url>%2F2018%2Fhtml5-IndexDB.html</url>
    <content type="text"><![CDATA[demo地址 什么是 IndexDB？IndexedDB 是一个用于在浏览器中储存较大数据结构的 Web API, 并提供索引功能以实现高性能查找. 像其他基于 SQL 的 关系型数据库管理系统 (RDBMS) 一样, IndexedDB 是一个事务型的数据库系统. 然而, 它是使用 JavaScript 对象而非列数固定的表格来储存数据的. IndexDB 的特点IndexDB 和大多数web存储解决方案相同，indexedDB也遵从同源协议(same-origin policy). 所以你只能访问同域中存储的数据，而不能访问其他域的。IndexDB API包含异步(asynchronous) API 和同步(synchronous)API两种。 异步API适合大多数情况, 同步API必须同 WebWorkers一同使用. 为什么我们要使用 IndexDB？WebStorage在浏览器中有大小限制，存放较大的数据就不能满足了。IndexedDB 是 WebSQL 数据库的取代品, W3C组织在2010年11月18日废弃了webSql.IndexedDB 和WebSQL的不同点在于WebSQL 是关系型数据库（复杂）IndexedDB 是key-value型数据库（简单好使）. 基本概念IndexedDB 数据库使用key-value键值对储存数据key可以是二进制对象。values 数据可以是结构非常复杂的对象，key可以是对象自身的属性。你可以对对象的某个属性创建索引（index）以实现快速查询和列举排序。 IndexedDB 是事务模式的数据库任何操作都发生在事务(transaction)中。IndexedDB API提供了索引(indexes), 表(tables), 指针(cursors)等等,但是所有这些必须是依赖于某种事务的。因此，你不能在事务外执行命令或者打开指针。当用户在不同的标签页同时打开Web应用的两个实例时，这个事务模型就会非常有用。如果没有事务操作的支持，这两个实例就会互相影响对方的修改。 IndexedDB API 基本上是异步的IndexedDB的API不通过return语句返回数据，而是需要你提供一个回调函数来接受数据。执行API时，你不以同步（synchronous）方式对数据库进行“存储”和“读取”操作，而是向数据库发送一个操作“请求”。当操作完成时，数据库会以DOM事件的方式通知你，同时事件的类型会告诉你这个操作是否成功完成。类似于XMLHttpRequest。 IndexedDB数据库“请求”无处不在数据库“请求”负责接受成功或失败的DOM事件。每一个“请求”都包含onsuccess和onerror事件属性，同时你还对“事件”调用addEventListener()和removeEventListener()。“请求”还包括readyState，result和errorCode属性，用来表示“请求”的状态。result属性尤其神奇，他可以根据“请求”生成的方式变成不同的东西，例如：IDBCursor实例、刚插入数据库的数值对应的键值（key）等。 IndexedDB在结果准备好之后通过DOM事件通知用户DOM事件总是有一个类型（type）属性（在IndexedDB中，该属性通常设置为success或error）。DOM事件还有一个目标（target）属性，用来告诉事件是被谁触发的。通常情况下，目标（target）属性是数据库操作生成的IDBRequest。成功（success）事件不弹出提示并且不能撤销，错误（error）事件会弹出提示且可以撤销。这一点是非常重要的，因为除非错误事件被撤销，否则他们会终止所在的任何事务。 IndexedDB是面向对象的indexedDB不是用二维表来表示集合的关系型数据库。这一点非常重要，将影响你设计和建立你的应用程序。​​​​传统的关系型数据库，你需要用到二维表来存储数据集合（每一行代表一个数据，每一列代表一个属性），indexedDB有所不同，它要求你为一种数据创建一个对象存储(object Store)，只要这种数据一个JavaScript对象即可。每个对象存储都有一个索引(index)集合以方便查询和迭代遍历。 indexedDB不使用结构化查询语言（SQL）它通过索引(index)所产生的指针(cursor)来完成查询操作，从而使你可以迭代遍历到结果集合。 IndexedDB遵循同源（same-origin）策略“源”指脚本所在文档URL的域名、应用层协议和端口。每一个“源”都有与其相关联的数据库。在同一个“源”内的所有数据库都有唯一、可区别的名称。 使用 IndexedDB检测浏览器支持情况12345if (window.indexedDB) &#123; // todo&#125; else &#123; alert(&apos;您的浏览器不支持indexdb&apos;)&#125; 下面我将会以demo来做常用的数据库操作说明，使用火狐浏览器做测试。 新建数据库/关闭数据库indexedDB 有一个open(indexDbName[, version])，这个方法会打开某个数据库，若不存在则新建。第一个参数为数据库名称 ‘demo’，第二个参数为 版本号。db为打开数据库成功回掉 event.target.result 戴白哦数据库实例，有 close() 为关闭该数据库123456789101112131415161718192021function createDatabase(indexDbName) &#123; // 不存在则新建，存在则打开 let openRequest = indexedDB.open(indexDbName); openRequest.onerror = function(event) &#123; console.log(&quot;Database error: &quot; + event.target.errorCode); &#125;; openRequest.onsuccess = function(event) &#123; console.log(&quot;Database created&quot;); let db = event.target.result; // db.close(); console.log(&quot;this is :&quot;+db); &#125;; //更改数据库，或者存储对象时候在这里处理 openRequest.onupgradeneeded = function (e) &#123; console.log(e); &#125;;&#125; 确定数据结构并添加数据onupgradeneeded 唯一可以修改数据库结构的地方。在 indexedDB 中一个数据库中可以包含多个objectStore，objectStore是一个灵活的数据结构，可以存放多种类型数据。创建 objectStore 的方法为数据库实例的 createObjectStore(name[, options]);删除 objectStore 的方法为数据库实例的 deleteObjectStore(name);其中options 有两个可选key，分别是 keyPath（选择objectStore中某个指定字段作为键值）、autoIncrement（若为true，objectStore有一个key generator）我们创建好的 objectStore 也有一些方法：createIndex(indexName, keyPath[, objectParameters]) 该方法作用为创建一个索引来通过 indexName 搜索 objectStore 里的数据。objectStore.add(value[, key]) 该方法作用为将数据添加到 objectStore 中。介绍了相关的方法，我们就通过循环来向 objectStore 添加数据。下面是具体实现代码：1234567891011121314151617181920212223242526272829303132333435function insertData(indexDbName)&#123; // 带写入的数据 const customerData = [ &#123; ssn: &quot;444-44-4444&quot;, name: &quot;Bill&quot;, age: 35, email: &quot;bill@company.com&quot; &#125;, &#123; ssn: &quot;555-55-5555&quot;, name: &quot;Donna&quot;, age: 32, email: &quot;donna@home.org&quot; &#125; ]; // 如果在没有新建数据库时写入数据，这里只能带高版本的数据库版本才能出发 onupgradeneeded 事件 let openRequest = indexedDB.open(indexDbName, &apos;3.0&apos;); openRequest.onerror = function(e) &#123; console.log(&quot;Database error: &quot; + e.target.errorCode); &#125;; openRequest.onsuccess = function(event) &#123; console.log(&quot;Database created&quot;); &#125;; openRequest.onupgradeneeded = function(event) &#123; console.log(&quot;开始写入数据&quot;); let db = event.target.result; // keyPath、autoIncrement let objectStore = db.createObjectStore(&quot;customers&quot;, &#123; keyPath: &quot;ssn&quot; &#125;); objectStore.createIndex(&quot;name&quot;, &quot;name&quot;, &#123; unique: false &#125;); objectStore.createIndex(&quot;email&quot;, &quot;email&quot;, &#123; unique: true &#125;); for (let item of customerData) &#123; objectStore.add(item); &#125; // 删除 objectStore // db.deleteObjectStore(&quot;customers&quot;); &#125;;&#125; PS： 这里有个坑，需要说明一下。onupgradeneeded事件在下列情况下被触发：1.数据库第一次被打开时即新建2.打开数据库时指定的版本号高于当前被持久化的数据库版本号 添加数据添加数据在 onsuccess 钩子中进行。IndexedDB 添加数据通过事务来添加数据。下面重点介绍下 transaction(storeNames[, mode]);第一个参数是事务希望跨越的对象存储空间的列表。第二个参数事务中可以执行的访问类型。返回一个事务对象。事务可以接收三种不同类型的 DOM 事件： error，abort，以及 complete。1234567891011121314151617181920212223function addData(storeName) &#123; const datas = [ &#123; ssn: &quot;666-66-6666&quot;, name: &quot;fanerge&quot;, age: 15, email: &quot;fanerge@company.com&quot; &#125;, &#123; ssn: &quot;777-77-7777&quot;, name: &quot;sdsd&quot;, age: 22, email: &quot;sdsd@home.org&quot; &#125; ]; let openRequest = indexedDB.open(&apos;demo&apos;, &apos;3.0&apos;); openRequest.onerror = function(e) &#123; console.log(&quot;Database error: &quot; + e.target.errorCode); &#125;; openRequest.onsuccess = function(event) &#123; let db = event.target.result; let transaction=db.transaction(storeName,&apos;readwrite&apos;); let store=transaction.objectStore(storeName); for(let i=0;i&lt;datas.length;i++)&#123; store.add(datas[i]); &#125; &#125;; &#125; 删除数据同样删除数据也使用 transaction。唯一区别是使用了 objectStore的 delete(key)，该方法为删除指定key的数据项。objectStore 还有一个方法 clear()清空该 store 中的数据。12345678910111213141516171819202122function del66(key)&#123; let openRequest = indexedDB.open(&apos;demo&apos;, &apos;3.0&apos;); openRequest.onerror = function(e) &#123; console.log(&quot;Database error: &quot; + e.target.errorCode); &#125;; openRequest.onsuccess = function(event) &#123; let db = event.target.result; let transaction = db.transaction(&apos;customers&apos;,&apos;readwrite&apos;); let store=transaction.objectStore(&apos;customers&apos;); let request = store.delete(key); request.onsuccess = function(event) &#123; console.log(&apos;删除成功&apos;); &#125;; request.onerror = function(event) &#123; console.log(&apos;删除失败&apos;); &#125;; &#125;;&#125; 查找数据同样查找数据也使用 transaction。唯一区别是使用了 objectStore的 get(key)，该方法为删除指定key的数据项。123456789101112131415161718192021222324function getDataByKey(key)&#123; let openRequest = indexedDB.open(&apos;demo&apos;, &apos;3.0&apos;); openRequest.onerror = function(e) &#123; console.log(&quot;Database error: &quot; + e.target.errorCode); &#125;; openRequest.onsuccess = function(event) &#123; let db = event.target.result; let transaction = db.transaction(&apos;customers&apos;,&apos;readwrite&apos;); let store=transaction.objectStore(&apos;customers&apos;); let request = store.get(key); request.onsuccess = function(event) &#123; let item =event.target.result; console.log(item); // 获得的该数据项 console.log(&apos;查找成功&apos;); &#125;; request.onerror = function(event) &#123; console.log(&apos;查找失败&apos;); &#125;; &#125;;&#125; 更新数据可以调用object store的put方法更新数据，会自动替换键值相同的记录，达到更新目的，没有相同的则添加，以使用keyPath做键为例1234567891011121314151617181920212223242526272829function updateDataByKey(key)&#123; let openRequest = indexedDB.open(&apos;demo&apos;, &apos;3.0&apos;); openRequest.onerror = function(e) &#123; console.log(&quot;Database error: &quot; + e.target.errorCode); &#125;; openRequest.onsuccess = function(event) &#123; let db = event.target.result; let transaction = db.transaction(&apos;customers&apos;,&apos;readwrite&apos;); let store=transaction.objectStore(&apos;customers&apos;); let request = store.get(key); request.onsuccess = function(event) &#123; let item =event.target.result; // &#123; ssn: &quot;666-66-6666&quot;, name: &quot;fanerge&quot;, age: 15, email: &quot;fanerge@company.com&quot; &#125; item.ssn = &quot;666-66-6666&quot; item.name = &quot;yuzhenfan&quot; item.age = 18 item.email = &quot;yzf@alipay.com&quot; store.put(item); console.log(&apos;更新成功&apos;); &#125;; request.onerror = function(event) &#123; console.log(&apos;更新失败&apos;); &#125;; &#125;;&#125; 参考文档数据库写入时机html5使用indexdb的代码实例分享wiki-数据库事务MDN-IndexedDBw3c-IndexDB-APIIndexDB-GuidesHTML5本地存储——IndexedDB（一：基本使用）]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5-svg开发手册]]></title>
    <url>%2F2018%2Fhtml5-svg%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C.html</url>
    <content type="text"><![CDATA[基础svg的使用 img的src background-image: url() object: data embed: src foreignObjectforeignObject元素允许包含外来的XML命名空间，其图形内容是别的用户代理绘制的。样式的写法（优先级逐渐降低）1.内联style&lt;g style=&quot;fill: red;&quot;&gt;&lt;/g&gt;2.class123456&lt;g class=&quot;font&quot;&gt;&lt;/g&gt;&lt;style type=&quot;text/css&quot;&gt;&lt;![CDATA[.font &#123; fill: red;&#125;]]&gt;&lt;/style&gt; 3.外链样式表&lt;?xml-stylesheet href=&quot;style.css&quot; type=&quot;text\css&quot; ?&gt;4.样式属性&lt;g fill=&quot;red&quot;&gt;&lt;/g&gt; other12&lt;![CDATA[解析器忽略的内容]]&gt;作用：xml解析器忽略解析，将表示为纯文本。 默认用户坐标（视口svg的width和height）指定用户坐标（viewBox属性）保持宽高比（SVG的宽高和viewBox的宽高比是不一样），使用preserveAspectRatio属性preserveAspectRatio=”xMidYMid meet”第1个值表示，viewBox如何与SVG viewport对齐；第2个值表示，如何维持高宽比（如果有）。 属性全局属性class、style 样式属性color、display、opacity、overflowfill、fill-opacity、fill-rulestroke、stroke-dasharray、stroke-dashoffset、stroke-linecap、stroke-linejoin、stroke-miterlimit、stroke-opacity、stroke-width 动画事件属性onbegin, onend, onload, onrepeat 动画属性目标属性attributeType, attributeName 动画定时属性begin, dur, end, min, max, restart, repeatCount, repeatDur, fill 动画值属性calcMode, values, keyTimes, keySplines, from, to, by, autoReverse, accelerate, decelerate 动画累加属性additive, accumulate 条件处理属性requiredExtensions, requiredFeatures, systemLanguage. 核心属性id, xml:base, xml:lang, xml:space 文档事件属性onabort, onerror, onresize, onscroll, onunload, onzoom 过滤器原始属性height, result, width, x, y 图形事件属性onactivate, onclick, onfocusin, onfocusout, onload, onmousedown, onmousemove, onmouseout, onmouseover, onmouseup svg 元素基本形状元素lineline元素是一个SVG基本形状，用来创建一条连接两个点的线。属性：x1、y1、x2、y2&lt;line x1=&quot;0&quot; y1=&quot;0&quot; x2=&quot;5&quot; y2=&quot;5&quot;&gt;&lt;/line&gt; rect用来创建矩形，基于一个角位置以及它的宽和高。它还可以用来创建圆角矩形。属性：x、y、width、height、rx、ry&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;10&quot; height=&quot;10&quot; rx=&quot;3&quot; ry=&quot;3&quot;&gt;&lt;/rect&gt; circle用来创建圆,基于一个圆心和一个半径。属性：cx、cy、r&lt;circle cx=&quot;10&quot; cy=&quot;10&quot; r=&quot;5&quot;&gt;&lt;/circle&gt; ellipse用来创建一个椭圆，基于一个中心坐标以及它们的x半径和y半径。利用transform属性椭圆的倾斜。属性：cx、cy、rx、ry&lt;ellipse cx=&quot;60&quot; cy=&quot;60&quot; rx=&quot;50&quot; ry=&quot;25&quot;/&gt; polygonpolygon元素定义了一个由一组点左边的构成的闭合多边形形状。属性：points&lt;polygon points=&quot;100,40 100,80 60,100 20,80 20,40&quot;/&gt; polyline用来创建一系列直线连接多个点。典型的一个polyline是用来创建一个开放的形状，最后一点不与第一点相连。属性：points&lt;polyline fill=&quot;none&quot; stroke=&quot;black&quot; points=&quot;20,100 40,60 70,80 100,20&quot;/&gt; pathpath元素是用来定义形状的通用元素。所有的基本形状都可以用path元素来创建。属性：d（data）、pathLengthPS：d属性有下列值（大写字母为绝对坐标，小写字母为相对坐标）M（m）-x，y-移动到给定坐标。L（l）-x，y-绘制一条到给定坐标的线，可以提供多组坐标来绘制折线。H（h）-x-绘制一条到给定x坐标的水平线。V（v）-y-绘制一条到指定y坐标的竖线。A（a）-rx ry x-axis-rotation large-arc-flag sweep-flag x y。Q（q）-x1，y1，x，y-绘制一条从当前点到（x，y），控制点为（x1，y1）的二次贝塞尔曲线。T（t）-x，y-绘制一条从当前点到（x，y）的二次贝塞尔曲线，控制点是前一个Q命令的控制点的中心对称点。如果没有前一条曲线，当前点会被用作控制点。C（c）-x1，y1，x2，y2，x，y-绘制一条从当前点到（x，y）的三次贝塞尔曲线，x1和x2分别为开始和终点控制点。S（s）-x2，y2，x，y-绘制一条从当前点到（x，y）的三次贝塞尔曲线，使用x2作为终点控制点，开始控制点为前一个C命令的终点控制点的中心对称点。&lt;path d=&quot;M 100 100 L 300 100 L 200 300 z&quot; /&gt;PS：x-axis-rotation为x轴旋转角度，large-arc-flag为角度大小，sweep-flag（弧线方向）large-arc-flag决定弧线是大于还是小于180度，0表示小角度弧，1表示大角度弧。sweep-flag表示弧线的方向，0表示从起点到终点沿逆时针画弧，1表示从起点到终点沿顺时针画弧。 功能元素title（提升可访问性）SVG绘图中的每个窗口元素或图形元素都可以提供一个title描述性字符串，该描述只能是纯文本。title元素必须是它的父元素的第一个子元素。12345&lt;g&gt; &lt;title&gt;SVG Title Demo example&lt;/title&gt; &lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;200&quot; height=&quot;50&quot; style=&quot;fill:none; stroke:blue; stroke-width:1px&quot;/&gt; &lt;desc&gt;提升可访问性&lt;/desc&gt;&lt;/g&gt; desc（提升可访问性）SVG绘画中的每个容器元素或图形元素都可以提供一个desc描述性字符串，这些描述只是纯文本的。 defsSVG 允许我们定义以后需要重复使用的图形元素， 建议把所有需要再次使用的引用元素定义在defs元素里面。需要使用\元素来呈现defs定义的元素。12345678&lt;defs&gt; &lt;linearGradient id=&quot;Gradient01&quot;&gt; &lt;stop offset=&quot;20%&quot; stop-color=&quot;#39F&quot; /&gt; &lt;stop offset=&quot;90%&quot; stop-color=&quot;#F3F&quot; /&gt; &lt;/linearGradient&gt;&lt;/defs&gt;&lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;60&quot; height=&quot;10&quot; fill=&quot;url(#Gradient01)&quot; /&gt;PS：radialGradient、linearGradient、pattern等元素必须要放在defs元素中 useuse元素在SVG文档内取得目标节点，并在别的地方复制它们。属性：x、y、width、height、href1234567&lt;defs&gt; &lt;g id=&quot;Port&quot;&gt; &lt;circle style=&quot;fill: inherit;&quot; r=&quot;10&quot;/&gt; &lt;/g&gt;&lt;/defs&gt;&lt;use x=&quot;50&quot; y=&quot;10&quot; href=&quot;#Port&quot; /&gt;&lt;use x=&quot;50&quot; y=&quot;30&quot; href=&quot;#Port&quot; class=&quot;classA&quot;/&gt; a使用 SVG 的锚元素\定义一个超链接。属性：href、target1234&lt;a href=&quot;www.alipay.com&quot; target=&quot;_blank&quot;&gt; &lt;rect height=&quot;30&quot; width=&quot;120&quot; y=&quot;0&quot; x=&quot;0&quot; rx=&quot;15&quot;/&gt; &lt;text fill=&quot;white&quot; text-anchor=&quot;middle&quot; y=&quot;21&quot; x=&quot;60&quot;&gt;SVG on MDN&lt;/text&gt;&lt;/a&gt; clipPathclipPath用于指定可绘制区域（超出了剪切路径所指定的区域，将不会被绘制。）。属性：clipPathUnits=”userSpaceOnUse’或’objectBoundingBox”。第二个值childern一个对象的边框，会使用掩码的一小部分单位（默认：”userSpaceOnUse”）”123456&lt;defs&gt; &lt;clipPath id=&quot;myClip&quot;&gt; &lt;circle cx=&quot;30&quot; cy=&quot;30&quot; r=&quot;20&quot;/&gt; &lt;/clipPath&gt;&lt;/defs&gt;&lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;100&quot; height=&quot;100&quot; clip-path=&quot;url(#myClip)&quot;/&gt; PS：其他元素通过clip-path=”引用剪贴路径和引用剪贴路径交叉” color-profile该元素允许描述用于图像的颜色配置文件。属性：local、name、rendering-intent、href foreignObjectforeignObject元素允许包含外来的XML命名空间，其图形内容是别的用户代理绘制的。这个被包含的外来图形内容服从SVG变形和合成。foreignObject元素通常与 switch 元素和requiredExtensions属性联用，来做兼容。 imageSVG文档中的SVG元素包含图像信息。它表现为图像文件或者其他SVG文件。属性：x、y、width、height、href、preserveAspectRatio（控制图像比例） linearGradientlinearGradient元素用来定义线性渐变，用于图形元素的填充或描边。1234567&lt;defs&gt; &lt;linearGradient id=&quot;MyGradient&quot;&gt; &lt;stop offset=&quot;5%&quot; stop-color=&quot;green&quot;/&gt; &lt;stop offset=&quot;95%&quot; stop-color=&quot;gold&quot;/&gt; &lt;/linearGradient&gt;&lt;/defs&gt;&lt;rect fill=&quot;url(#MyGradient)&quot; x=&quot;10&quot; y=&quot;10&quot; width=&quot;100&quot; height=&quot;100&quot;/&gt; 属性：gradientUnits、gradientTransform、x1、y1、x2、y2、spreadMethod、href radialGradientradialGradient用来定义径向，用于图形元素的填充或描边。属性：gradientUnits、gradientTransform、cx、cy、r、fx、fy、spreadMethod、href1234567&lt;defs&gt; &lt;radialGradient id=&quot;exampleGradient&quot;&gt; &lt;stop offset=&quot;10%&quot; stop-color=&quot;gold&quot;/&gt; &lt;stop offset=&quot;95%&quot; stop-color=&quot;green&quot;/&gt; &lt;/radialGradient&gt;&lt;/defs&gt;&lt;circle fill=&quot;url(#exampleGradient)&quot; cx=&quot;60&quot; cy=&quot;60&quot; r=&quot;50&quot;/&gt; stop一个渐变上的颜色坡度，是用stop元素定义的。stop元素可以是linearGradient、radialGradient的子元素。 markermarker元素定义了在特定的path、line、polyline、polygon上绘制的箭头或者多边标记图形。属性：marker-end、marker-mid、marker-start、markerUnits、refx、refy、markerWidth、markerHeight、orient123456&lt;defs&gt; &lt;marker id=&quot;Triangle&quot; viewBox=&quot;0 0 10 10&quot; refX=&quot;1&quot; refY=&quot;5&quot; markerWidth=&quot;6&quot; markerHeight=&quot;6&quot; orient=&quot;auto&quot;&gt; &lt;path d=&quot;M 0 0 L 10 5 L 0 10 z&quot; /&gt; &lt;/marker&gt;&lt;/defs&gt;&lt;polyline points=&quot;10,90 50,80 90,20&quot; fill=&quot;none&quot; stroke=&quot;black&quot; stroke-width=&quot;2&quot; marker-end=&quot;url(#Triangle)&quot; /&gt; mask在SVG中，你可以指一个透明的遮罩层和当前对象合成，形成背景。属性mask用来引用一个遮罩元素。属性：maskUnits、maskContentUnits、x、y、width、height metadatametadata是数据的结构化数据。 pattern使用预定义的图形对一个对象进行填充或描边，就要用到pattern元素，在下轴或y轴上重复。123456&lt;defs&gt; &lt;pattern id=&quot;Triangle&quot; width=&quot;10&quot; height=&quot;10&quot; patternUnits=&quot;userSpaceOnUse&quot;&gt; &lt;polygon points=&quot;5,0 10,10 0,10&quot;/&gt; &lt;/pattern&gt;&lt;/defs&gt;&lt;circle cx=&quot;60&quot; cy=&quot;60&quot; r=&quot;50&quot; fill=&quot;url(#Triangle)&quot;/&gt; texttext元素定义了一个由文字组成的图形。注意：我们可以将渐变、图案、剪切路径、遮罩或者滤镜应用到text上。属性：x、y、dx、dy、text-anchor、rotate、textLength、lengthAdjust123&lt;text x=&quot;0&quot; y=&quot;20&quot; transform=&quot;rotate(30 20,40)&quot;&gt; SVG Text Rotation example&lt;/text&gt; textPathtextPath使用path来展示文字。属性：startOffset、method、spacing、href123456&lt;path id=&quot;MyPath&quot; fill=&quot;none&quot; stroke=&quot;red&quot; d=&quot;M10,90 Q90,90 90,45 Q90,10 50,10 Q10,10 10,40 Q10,70 45,70 Q70,70 75,50&quot; /&gt;&lt;text&gt; &lt;textPath href=&quot;#MyPath&quot;&gt; The quick brown fox jumps over the lazy dog. &lt;/textPath&gt;&lt;/text&gt; tspan在text元素中，利用内含的tspan元素，可以调整文本和字体的属性以及当前文本的位置、绝对或相对坐标值。属性：x、y、dx、dy、rotate、textLength、lengthAdjust12345&lt;text x=&quot;15&quot; y=&quot;30&quot;&gt; You are &lt;tspan&gt;not&lt;/tspan&gt; a banana&lt;/text&gt; viewview元素是查看图片的一个限定方法，就像一个缩放级别或者一个详细视图。属性：viewBox、preserveAspectRatio、zoomAndPan、viewTarget 不显示元素g元素g是用来组合对象的容器，对与transform、属性会作用与子元素。通过\ 元素来实现组合对象的复制。1234&lt;g stroke=&quot;green&quot; fill=&quot;white&quot; stroke-width=&quot;5&quot;&gt; &lt;circle cx=&quot;25&quot; cy=&quot;25&quot; r=&quot;15&quot; /&gt; &lt;circle cx=&quot;40&quot; cy=&quot;25&quot; r=&quot;15&quot; /&gt;&lt;/g&gt; script一个SVG脚本元素等同于HTML中的script元素。 setset元素可以用来设定一个属性值，并为该值赋予一个持续时间。 stylestyle元素元素样式表直接在SVG内容中间嵌入。 svg如果svg不是根元素，svg 元素可以用于在当前文档内嵌套一个独立的svg片段 。这个独立片段拥有独立的视口和坐标系统。属性：version、baseProfile、x、y、width、height、preserveAspectRatio、contentScriptType、contentStyleType、viewBox switchswitch元素对它的直接子元素上的属性requiredFeatures、属性requiredExtensions 和 属性systemLanguage按照顺序进行评估，然后处理和呈现第一个评估为true的子元素。属性：allowReorder12345&lt;switch&gt; &lt;text systemLanguage=&quot;ar&quot;&gt;مرحبا&lt;/text&gt; &lt;text systemLanguage=&quot;ja&quot;&gt;こんにちは&lt;/text&gt; &lt;text&gt;☺&lt;/text&gt; &lt;/switch&gt; symbolsymbol元素用来定义一个图形模板对象，它可以用一个use元素实例化。symbol元素对图形的作用是在同一文档中多次使用，添加结构和语义。属性：preserveAspectRatio、viewBox1234567&lt;symbol id=&quot;sym01&quot; viewBox=&quot;0 0 150 110&quot;&gt; &lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke-width=&quot;8&quot; stroke=&quot;red&quot; fill=&quot;red&quot;/&gt; &lt;circle cx=&quot;90&quot; cy=&quot;60&quot; r=&quot;40&quot; stroke-width=&quot;8&quot; stroke=&quot;green&quot; fill=&quot;white&quot;/&gt;&lt;/symbol&gt;&lt;!-- actual drawing by &quot;use&quot; element --&gt;&lt;use href=&quot;#sym01&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;50&quot;/&gt;&lt;use href=&quot;#sym01&quot; x=&quot;0&quot; y=&quot;50&quot; width=&quot;75&quot; height=&quot;38&quot;/&gt; 动画元素animate动画元素放在形状元素的内部，用来定义一个元素的某个属性根据时间点如何改变。属性：attributeName、attributeType（CSS/XML）、from、to、dur、repeatCount123&lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;100&quot; height=&quot;100&quot;&gt; &lt;animate attributeType=&quot;XML&quot; attributeName=&quot;x&quot; from=&quot;-100&quot; to=&quot;120&quot; dur=&quot;10s&quot; repeatCount=&quot;indefinite&quot;/&gt;&lt;/rect&gt; animateMotionanimateMotion元素导致引用的元素沿着运动路径移动。属性：calcMode、path、keyPoints、rotate、origin123456&lt;path d=&quot;M10,110 A120,120 -45 0,1 110 10 A120,120 -45 0,1 10,110&quot; stroke=&quot;lightgrey&quot; stroke-width=&quot;2&quot; fill=&quot;none&quot; id=&quot;theMotionPath&quot;/&gt;&lt;circle cx=&quot;&quot; cy=&quot;&quot; r=&quot;5&quot; fill=&quot;red&quot;&gt; &lt;animateMotion dur=&quot;6s&quot; repeatCount=&quot;indefinite&quot;&gt; &lt;mpath xlink:href=&quot;#theMotionPath&quot;/&gt; &lt;/animateMotion&gt;&lt;/circle&gt; mpathanimateMotion元素的 mpath 子元素使 animateMotion 元素能够引用一个外部的 path 元素作为运动路径的定义。属性：href animateTransformanimateTransform元素变动了目标元素上的一个变形属性，从而允许动画控制转换、缩放、旋转或斜切。属性：by、from、to、type123456789&lt;polygon points=&quot;60,30 90,90 30,90&quot;&gt; &lt;animateTransform attributeName=&quot;transform&quot; attributeType=&quot;XML&quot; type=&quot;rotate&quot; from=&quot;0 60 70&quot; to=&quot;360 60 70&quot; dur=&quot;10s&quot; repeatCount=&quot;indefinite&quot;/&gt;&lt;/polygon&gt; 滤镜元素通用属性x、y、width、height属性置顶应用滤镜的画布的尺寸。filterUnits指定用来定义滤镜范围的单位。primitiveUnits为滤镜基元中的各种长度值指定坐标系统。 filterfilter元素作用是作为原子滤镜操作的容器。它不能直接呈现。可以利用目标SVG元素上的filter属性引用一个滤镜。属性：x、y、width、height、filterRes、filterUnits、primitiveUnits、href12345&lt;filter id=&quot;blurMe&quot;&gt; &lt;feGaussianBlur in=&quot;SourceGraphic&quot; stdDeviation=&quot;5&quot;/&gt;&lt;/filter&gt;&lt;circle cx=&quot;60&quot; cy=&quot;60&quot; r=&quot;50&quot; fill=&quot;green&quot; /&gt;&lt;circle cx=&quot;170&quot; cy=&quot;60&quot; r=&quot;50&quot; fill=&quot;green&quot; filter=&quot;url(#blurMe)&quot; /&gt; feBlendfeBlend滤镜把两个对象组合在一起，使它们受特定的混合模式控制。这类似于图像编辑软件中混合两个图层。该模式由属性mode定义。属性：in、in2、mode1234567&lt;defs&gt; &lt;filter id=&quot;spotlight&quot;&gt; &lt;feFlood result=&quot;floodFill&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;100%&quot; height=&quot;100%&quot; flood-color=&quot;green&quot; flood-opacity=&quot;1&quot;/&gt; &lt;feBlend in=&quot;SourceGraphic&quot; in2=&quot;floodFill&quot; mode=&quot;multiply&quot;/&gt; &lt;/filter&gt;&lt;/defs&gt;&lt;image xlink:href=&quot;/files/6457/mdn_logo_only_color.png&quot; x=&quot;10%&quot; y=&quot;10%&quot; width=&quot;80%&quot; height=&quot;80%&quot; style=&quot;filter:url(#spotlight);&quot;/&gt; feColorMatrix（颜色转换滤镜）该滤镜基于转换矩阵对颜色进行变换。每一像素的颜色值(一个表示为[R,G,B,A] 的矢量)都经过矩阵乘法计算出的新颜色。属性：in、type、values feComponentTransferSVG滤镜基元对每个像素执行颜色分量的数据重映射.它允许进行像亮度调整,对比度调整,色彩平衡或阈值的操作。属性：in feFuncR该滤镜为它的父元素的输入图形的红色成分定义了变换函数。属性：type、tableValues、slope、intercept、amplitude、exponent、offset feFuncG该滤镜为它的父feComponentTransfer元素的输入图形的绿色成分定义了变换函数。 feFuncB该滤镜为它的父feComponentTransfer元素的输入图形的蓝色成分定义了变换函数。 feFuncA该滤镜为它的父feComponentTransfer元素的输入图形的alpha成分定义了变换函数。 feComposite（合成滤镜）该滤镜执行两个输入图像的智能像素组合，在图像空间中使用以下Porter-Duff合成操作之一：over、in、atop、xor属性：in、in2、operator、k1、k2、k3、k4 feConvolveMatrixfeConvolveMatrix元素应用了一个矩阵卷积滤镜效果。一个卷积在输入图像中把像素与邻近像素组合起来制作出结果图像。属性：in、order、kernelMatrix、divisor、bias、targetX、targetY、edgeMode、kernelUnitLength、preserveAlpha feDiffuseLighting（散开照明滤镜）滤镜光照一个图像，使用alpha通道作为隆起映射。属性：in、surfaceScale、diffuseConstant、kernelUnitLength feDisplacementMap映射置换滤镜，该滤镜用来自图像中从in2到空间的像素值置换图像从in到空间的像素值。属性：in、in2、scale、xChannelSelector、yChannelSelector feDistantLight（平行光滤镜）该滤镜定义了一个距离光源，可以用在灯光滤镜feDiffuseLighting元素或feSpecularLighting元素的内部。属性：azimuth、elevation feFlood该滤镜用flood-color元素定义的颜色和flood-opacity元素定义的不透明度填充了滤镜子区域。属性：flood-color、flood-opacity feGaussianBlur（高斯模糊滤镜）该滤镜对输入图像进行高斯模糊，属性stdDeviation中指定的数量定义了钟形。属性：in、stdDeviation1234&lt;filter id=&quot;blurMe&quot;&gt; &lt;feGaussianBlur in=&quot;SourceGraphic&quot; stdDeviation=&quot;5&quot; /&gt;&lt;/filter&gt;&lt;circle cx=&quot;170&quot; cy=&quot;60&quot; r=&quot;50&quot; fill=&quot;green&quot; filter=&quot;url(#blurMe)&quot; /&gt; feImage（图片滤镜）feImage滤镜从外部来源取得图像数据，并提供像素数据作为输出（意味着如果外部来源是一个SVG图像，这个图像将被栅格化。）属性：preserveAspectRatio、href feMerge（合并滤镜）feMerge滤镜允许同时应用滤镜效果而不是按顺序应用滤镜效果。利用result存储别的滤镜的输出可以实现这一点，然后在一个feMergeNode子元素中访问它。1234567&lt;filter id=&quot;feOffset&quot; x=&quot;-40&quot; y=&quot;-20&quot; width=&quot;100&quot; height=&quot;200&quot;&gt; &lt;feMerge&gt; &lt;feMergeNode in=&quot;blur2&quot; /&gt; &lt;feMergeNode in=&quot;SourceGraphic&quot; /&gt; &lt;/feMerge&gt;&lt;/filter&gt;&lt;rect x=&quot;40&quot; y=&quot;40&quot; width=&quot;100&quot; height=&quot;100&quot; style=&quot;stroke: #000000; fill: green; filter: url(#feOffset);&quot; /&gt; feMergeNodefeMergeNode元素拿另一个滤镜的结果，让它的父feMerge元素处理。属性：in feMorphology（扩张滤镜）该滤镜用来侵蚀或扩张输入的图像。它在增肥或瘦身效果方面特别有用。属性：in、operator、radius feOffset（位移滤镜）该输入图像作为一个整体，在属性dx和属性dy的值指定了它的偏移量。属性：in、dx、dy1234&lt;filter id=&quot;offset&quot; width=&quot;180&quot; height=&quot;180&quot;&gt; &lt;feOffset in=&quot;SourceGraphic&quot; dx=&quot;60&quot; dy=&quot;60&quot; /&gt;&lt;/filter&gt;&lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;100&quot; stroke=&quot;black&quot; fill=&quot;green&quot; filter=&quot;url(#offset)&quot;/&gt; fePointLight（点光源滤镜）SVG创建一个点光源效果。属性：x、y、z feSpecularLighting（镜子照明滤镜）该滤镜照亮一个源图形，使用alpha通道作为隆起映射。属性：in、surfaceScale、specularConstant、specularExponent、kernelUnitLength feSpotLight（斑点照明滤镜）feSpotLight元素是一种光源元素，用于SVG文件。属性：x、y、z、pointsAtX、pointsAtY、pointsAtZ、specularExponent、limitingConeAngle feTile（平铺滤镜）输入图像是平铺的，结果用来填充目标。它的效果近似于一个pattern图案对象。属性：in feTurbulence该滤镜利用Perlin噪声函数创建了一个图像。它实现了人造纹理比如说云纹、大理石纹的合成。属性：baseFrequency、numOctaves、seed、stitchTiles、type 参考文档：MDN-SVG系列资料svg-属性参考掘金翻译-深入浅出 SVG]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web Worker]]></title>
    <url>%2F2018%2Fhtml5-webWorker.html</url>
    <content type="text"><![CDATA[先放上demo，打开控制台试试 什么是Web WorkerWeb Workers 使得一个Web应用程序可以在与主执行线程分离的后台线程中运行一个脚本操作。这样做的好处是可以在一个单独的线程中执行费时的处理任务，从而允许主（通常是UI）线程运行而不被阻塞/放慢。局限性：在worker内不能直接操作DOM节点，或者使用window对象的默认方法和属性。 Worker特性检测12345if(window.Worker)&#123; // todo&#125; else &#123; // 不支持web Worker&#125; PS：假设页面为index.html，页面js为main.js，这里的path是相对于index.html到该worker.js。 专用Worker生成一个专用worker1var myWorker = new Worker(&apos;worker.js&apos;); PS：假设页面为index.html，页面主线程js为main.js，这里的path是相对于index.html到该worker.js。 主线程js和Worker的通信（数据交互）主线程js（main.js 用来生成 myWorker）123456789101112131415161718192021let myWorkerif(window.Worker)&#123; // todo myWorker = new Worker(&apos;./js/worker.js&apos;)&#125; else &#123; // 不支持web Worker alert(&apos;不支持web Worker&apos;)&#125;let app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; num: 1000000, &#125;, methods: &#123; computed () &#123; console.log(`Message posted to worker=$&#123;this.num&#125;`); // 重点在这里，向 myWorker 发送我们 input 中的值，让它为去做耗时的计算 myWorker.postMessage(this.num) &#125; &#125;&#125;) PS：如果想发送多个消息，可以这样myWorker.postMessage([msg1, msg2…])，对应接收的e.data对象也就是一个数组了，若是对象的话需要序列化，接收的时候需要反序列化。 myWorker脚本代码12345678910111213141516// 有数据发过来，就触发onmessage = function(e) &#123; let num1 = e.data; let num2 = 0; console.time(&apos;计算耗时&apos;) for(let i = 0; i &lt; num1; i++)&#123; num2 += i; &#125; console.timeEnd(&apos;计算耗时&apos;) console.log(`Worker 计算结果=$&#123;num2&#125;`) // 当我们计算出结果，应该回传 postMessage(num2);&#125; 我向一个Worker发送一个较大num，然后求出该1到num的整数和。在页面中input的值分别为：1000000、10000000、100000000各执行了一次计算，最后一次花费了11s左右（算的上耗时计算了吧）。下面是我的测试截图就这么简单，我们就实现了主线程js和WebWorker的双向通信。 终止worker在主线程中终止如果你需要从主线程中立刻终止一个运行中的worker，可以调用worker的terminate 方法：myWorker.terminate();worker 线程会被立即杀死，不会有任何机会让它完成自己的操作或清理工作。 在Worker中终止（自杀）close() 处理错误当然我们刚刚仅仅考虑了正常情况，还有需要错误等待我们处理呢？当 worker 出现运行中错误时，它的 onerror 事件处理函数会被调用。它会收到一个扩展了 ErrorEvent 接口的名为 error的事件。该事件不会冒泡并且可以被取消；为了防止触发默认动作，worker 可以调用错误事件的 preventDefault() 方法。错误事件有以下三个用户关心的字段：123456message 可读性良好的错误消息。filename 发生错误的脚本文件名。lineno 发生错误时所在脚本文件的行号。 生成subworker如果需要的话 worker 能够生成更多的 worker。这就是所谓的subworker，它们必须托管在同源的父页面内。而且，subworker 解析 URI 时会相对于父 worker 的地址而不是自身页面的地址。这使得 worker 更容易记录它们之间的依赖关系。 在Worker中引入脚本与库Worker 线程能够访问一个全局函数importScripts()来引入脚本，该函数接受0个或者多个URI作为参数来引入资源。123importScripts(); importScripts(&apos;cube.js&apos;); importScripts(&apos;cube1.js&apos;, &apos;cube2&apos;); 共享Worker（SharedWorker）一个共享worker可以被多个脚本使用——即使这些脚本正在被不同的window、iframe或者worker访问。由于SharedWorker 与 专有Worker 非常相似，这里我只是提一下它们的区别。读者若需要做测试的话，可以考虑在2个html页面中的javascript代码使用的是同一个worker。 生成一个共享worker12345var myWorker = new SharedWorker(&apos;worker.js&apos;);// 父级线程中的调用myWorker.port.start();// worker线程中的调用, 假设port变量代表一个端口 port.start(); 一个非常大的区别在于，与一个共享worker通信必须通过端口对象——一个确切的打开的端口供脚本与worker通信（在专用worker中这一部分是隐式进行的）。在使用start()方法打开端口连接时，如果父级线程和worker线程需要双向通信，那么它们都需要调用start()方法。 共享worker中消息的接收和发送主线程发送消息给Worker改写我们的computed方法（vue组件中）12345computed () &#123; console.log(`Message posted to worker=$&#123;this.num&#125;`); // 重点在这里，向 myWorker 发送我们 input 中的值，让它为去做耗时的计算 myWorker.port.postMessage(this.num)&#125; Worker接收到消息并处理及回传123456789101112onconnect = function(e) &#123; var port = e.ports[0]; port.onmessage = function(e) &#123; // 同样e.data为主线程发送的数据 console.log(e.data) //复杂的计算 let result = e.data*1000*23*3 // Worker需要回传至主线程 port.postMessage(result); &#125;&#125; 主线程接收并处理消息1234myWorker.port.onmessage = function(e) &#123; result2.textContent = e.data; console.log(&apos;Message received from worker&apos;);&#125; PS：总结差异，主线程和Worker都要执行start()，通信时需要带上port。 线程安全Worker接口会生成真正的操作系统级别的线程，如果你不太小心，那么并发(concurrency)会对你的代码产生有趣的影响。然而，对于 web worker 来说，与其他线程的通信点会被很小心的控制，这意味着你很难引起并发问题。 内容安全策略CSPCSP全称Content Security Policy为了页面内容安全而制定的一系列防护策略. 通过CSP所约束的的规责指定可信的内容来源（这里的内容可以指脚本、图片、iframe、fton、style等等可能的远程的资源）。可以限制如下资源的加载：1234567891011script-src：外部脚本style-src：样式表img-src：图像media-src：媒体文件（音频和视频）font-src：字体文件object-src：插件（比如 Flash）child-src：框架frame-ancestors：嵌入的外部资源（比如&lt;frame&gt;、&lt;iframe&gt;、&lt;embed&gt;和&lt;applet&gt;）connect-src：HTTP 连接（通过 XHR、WebSockets、EventSource等）worker-src：worker脚本manifest-src：manifest 文件 除了Content-Security-Policy，还有一个Content-Security-Policy-Report-Only字段，表示不执行限制选项，只是记录违反限制的行为。但它必须与report-uri选项配合使用。Content-Security-Policy-Report-Only: default-src &#39;self&#39;; ...; report-uri /my_amazing_csp_report_parser; 运用meta标签&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#39;self&#39;; object-src &#39;none&#39;; style-src cdn.example.org third-party.org; child-src https:&quot;&gt; 服务器上设置以下语句设置在请求头部（Header）Content-Security-Policy &quot;default-src &#39;self&#39;;&quot;如果要为Worker指定CSP策略，可以为Worker脚本的请求的响应的头部设置CSP策略。这时这个Worker会继承它所属的文档或者创建它的Worker的CSP策略。 worker中数据的接收与发送在主页面与 worker 之间传递的数据是通过拷贝，而不是共享来完成的。传递给 worker 的对象需要经过序列化，接下来在另一端还需要反序列化。 参考手册 测试html5专用线程与共享线程的区别 MDN-WebWorker WebWorkerAPI vue HTML5 Web Workers CSP]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Geolocation（地理定位）]]></title>
    <url>%2F2018%2Fhtml5-Geolocation.html</url>
    <content type="text"><![CDATA[介绍Geolocation 接口是一个用来获取设备地理位置的可编程的对象，它可以让Web内容访问到设备的地理位置，这将允许Web应用基于用户的地理位置提供定制的信息。其实Geolocation 就是用来获取到当前设备的经纬度（位置）带有此接口的对象可以用由 Navigator实现的属性NavigatorGeolocation.geolocation 来获得。PS：鉴于该特性可能侵犯用户的隐私，除非用户同意，否则用户位置信息是不可用的。 详解检测是否支持地理定位12345if (navigator.geolocation) &#123; // 做相应的操作 &#125; else &#123; console.error(&apos;不支持地理&apos;)&#125; 获取当前定位Geolocation.getCurrentPosition(success, error, options) 确定设备的位置并返回一个携带位置信息的 Position 对象。参数： success成功得到位置信息时的回调函数，使用Position 对象作为唯一的参数。 Position.coords 只读（latitude、longitude、accuracy）返回一个定义了当前位置的Coordinates 对象. coords.latitude 十进制数的纬度 coords.longitude 十进制数的经度 coords.accuracy 位置精度 coords.altitude 海拔，海平面以上以米计 coords.altitudeAccuracy 位置的海拔精度 coords.heading 方向，从正北开始以度计 coords.speed 速度，以米/每秒计 Position.timestamp 只读返回一个时间戳DOMTimeStamp， 这个时间戳表示获取到的位置的时间。 error 可选获取位置信息失败时的回调函数，使用 PositionError 对象作为唯一的参数，这是一个可选项。 PositionError.code 只读返回无符号的、简短的错误码。 PERMISSION_DENIED–权限问题 POSITION_UNAVAILABLE–内部错误 TIMEOUT–超时 PositionError.message 只读返回一个开发者可以理解的 DOMString 来描述错误的详细信息。 options 可选一个可选的PositionOptions 对象。enableHighAccuracy: false;--是否高精度，默认false timeout: 5000;--超时事件ms maximumAge: 0; 地理位置缓存时长ms 监视定位Geolocation.watchPosition(success[, error[, options]]) 用于注册监听器，在设备的地理位置发生改变的时候自动被调用。也可以选择特定的错误处理函数。 该方法会返回一个 ID，如要取消监听可以通过 Geolocation.clearWatch() 传入该 ID 实现取消的目的。参数： success成功时候的回调函数， 同时传入一个 Position 对象当作参数。 error 可选失败时候的回调函数，可选， 会传入一个 PositionError 对象当作参数。 options 可选一个可选的 PositionOptions 对象。PS：Position、PositionError、PositionOptions对象和上面一样。 清理监视定位Geolocation.clearWatch(id) 这个方法主要用于使用 Geolocation.watchPosition() 注册的 位置/错误 监听器。参数： id希望移除的监听器所对应的 Geolocation.watchPosition() 返回的 ID 数字。 Geolocation.watchPosition()注册一个位置改变监听器，每当设备位置改变时，返回一个 long 类型的该监听器的ID值。Geolocation.clearWatch() 取消由 watchPosition()注册的位置监听器。 参考文档： Geolocation HTML5 Geolocation（地理定位） PositionError PositionOptions watchPosition]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拖放（Drag 和 Drop）]]></title>
    <url>%2F2018%2Fhtml5-DragAndDrop.html</url>
    <content type="text"><![CDATA[理论介绍拖放（Drag 和 drop）是 HTML5 标准的组成部分。DataTransfer 对象：拖拽对象用来传递的媒介，使用一般为Event.dataTransfer。draggable 属性：为需要拖拽的元素设置该属性。Event.effectAllowed 属性：就是拖拽的效果。Event.preventDefault() 方法：阻止默认的些事件方法等执行。在ondragover中一定要执行preventDefault()，否则ondrop事件不会被触发。 相关事件拖动目标上触发事件ondragstart 事件：当拖拽元素开始被拖拽的时候触发的事件。ondrag 事件：当元素或者选择的文本被拖动时触发 drag 事件，大约每几百毫秒的触发一次。ondragend 事件：当拖拽完成后触发的事件（比如松开鼠标按键或敲“Esc”键）。 释放目标时触发的事件ondragenter 事件：当拖曳元素进入目标元素的时候触发的事件。ondragover 事件：拖拽元素在目标元素上移动的时候触发的事件。ondragleave 事件：当被鼠标拖动的对象离开其容器范围内时触发此事件。ondrop 事件：被拖拽的元素在目标元素上同时鼠标放开触发的事件。ondragexit 事件：当一个元素不再拖动立即选择目标元素触发。 DataTransfer 对象详解在进行拖放操作时，DataTransfer 对象用来保存被拖动的数据。它可以保存一项或多项数据、一种或者多种数据类型。 属性dropEffect String 设置实际的放置效果，它应该始终设置成 effectAllowed 的可能值之一 。effectAllowed String 用来指定拖动时被允许的效果。files FileList 包含一个在数据传输上所有可用的本地文件列表。如果拖动操作不涉及拖动文件，此属性是一个空列表。types DOMStringList 保存一个被存储数据的类型列表作为第一项，顺序与被添加数据的顺序一致。 方法addElement(element) 设置拖动源。通常你不需要改变这项，如果修改这项将会影响拖动的哪个节点和dragend事件的触发。默认目标是被拖动的节点。setData(type,data) 为一个给定的类型设置数据。getData() 根据指定的类型检索数据，如果指定类型的数据不存在或者该 DataTransfer 对象中没有数据，方法将返回一个空字符串。clearData(type) 删除与给定类型关联的数据。类型参数是可选的。setDragImage(imgElement,offsetX,offsetY) 自定义一个期望的拖动时的图片。大多数情况下，这项不用设置，因为被拖动的节点被创建成默认图片。 实现拖拽确定什么是可拖动的让一个元素被拖动需要添加 draggable 属性，再加上全局事件处理函数ondragstart。12345678function dragstart_handler(ev) &#123; console.log(&quot;dragStart&quot;); ev.dataTransfer.setData(&quot;text/plain&quot;, ev.target.id);&#125;&lt;body&gt; &lt;p id=&quot;p1&quot; draggable=&quot;true&quot; ondragstart=&quot;dragstart_handler(event);&quot;&gt;This element is draggable.&lt;/p&gt;&lt;/body&gt; 定义拖动数据应用程序可以在拖动操作中包含任意数量的数据项。每个数据项都是一个 string 类型，典型的MIME类型，如：text/html。123456function dragstart_handler(ev) &#123; // 添加拖拽数据 ev.dataTransfer.setData(&quot;text/plain&quot;, ev.target.id); ev.dataTransfer.setData(&quot;text/html&quot;, &quot;&lt;p&gt;Example paragraph&lt;/p&gt;&quot;); ev.dataTransfer.setData(&quot;text/uri-list&quot;, &quot;http://developer.mozilla.org&quot;);&#125; 定义拖动图像拖动过程中，浏览器会在鼠标旁显示一张默认图片。当然，应用程序也可以通过setDragImage() 方法自定义一张图片.12345function dragstart_handler(ev) &#123; var img = new Image(); img.src = &apos;example.gif&apos;; ev.dataTransfer.setDragImage(img, 10, 10);&#125; PS：img 的 src 属性路径是以使用该 js 页面为基准。 定义拖动效果1234function dragstart_handler(ev) &#123; // Set the drag effect to copy ev.dataTransfer.dropEffect = &quot;copy&quot;;&#125; 定义一个放置区1234567891011121314function dragover_handler(ev) &#123; // 这里必须阻止默认行为，否则没有效果 ev.preventDefault(); ev.dataTransfer.dropEffect = &quot;move&quot;&#125;function drop_handler(ev) &#123; ev.preventDefault(); // Get the id of the target and add the moved element to the target&apos;s DOM var data = ev.dataTransfer.getData(&quot;text&quot;); ev.target.appendChild(document.getElementById(data));&#125;&lt;body&gt; &lt;div id=&quot;target&quot; ondrop=&quot;drop_handler(event);&quot; ondragover=&quot;dragover_handler(event);&quot;&gt;Drop Zone&lt;/div&gt;&lt;/body&gt; 处理放置效果123456789101112131415161718function dragstart_handler(ev) &#123; ev.dataTransfer.setData(&quot;text/plain&quot;, ev.target.id); ev.dropEffect = &quot;move&quot;;&#125;function dragover_handler(ev) &#123; ev.preventDefault(); // Set the dropEffect to move ev.dataTransfer.dropEffect = &quot;move&quot;&#125;function drop_handler(ev) &#123; ev.preventDefault(); var data = ev.dataTransfer.getData(&quot;text&quot;); ev.target.appendChild(document.getElementById(data));&#125;&lt;body&gt; &lt;p id=&quot;p1&quot; draggable=&quot;true&quot; ondragstart=&quot;dragstart_handler(event);&quot;&gt;This element is draggable.&lt;/p&gt; &lt;div id=&quot;target&quot; ondrop=&quot;drop_handler(event);&quot; ondragover=&quot;dragover_handler(event);&quot;&gt;Drop Zone&lt;/div&gt;&lt;/body&gt; 拖动结束在拖动目标元素上监听 dragend 事件，此时你可以做一起其他事情。 参考文档： HTML5 drag &amp; drop 拖拽与拖放简介 HTML5 拖放（Drag 和 Drop）详解与实例 DataTransfer Drag and Drop API]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试杂项]]></title>
    <url>%2F2018%2F%E9%9D%A2%E8%AF%95%E6%9D%82%E9%A1%B9.html</url>
    <content type="text"><![CDATA[防止网页被嵌入框架的代码任何页面都不可嵌套1234// 判断当前的window对象是否对顶层top对象还可以使用window.top !== window.selfif (window !== top) // 如果不是，将top对象的网址自动导向被嵌入网页的网址top.location.href = window.location.href; 本地域名可嵌套，其他域名不可12345678try&#123; top.location.hostname; if (top.location.hostname !== window.location.hostname) &#123; top.location.href = window.location.href; &#125;&#125;catch(e)&#123; top.location.href = window.location.href;&#125; PS：上面两种对于动态生产iframe标签和禁用js不会用效果。别人可能这样禁用你的js&lt;noscript&gt;&lt;iframe src=fillseo.html&gt;&lt;/iframe&gt;&lt;/noscript&gt; js如何判断是否在iframe中123456789101112//方式一 if (self.frameElement &amp;&amp; self.frameElement.tagName == &quot;IFRAME&quot;) &#123; alert(&apos;在iframe中&apos;); &#125; //方式二 if (window.frames.length != parent.frames.length) &#123; alert(&apos;在iframe中&apos;); &#125; //方式三 if (self != top) &#123; alert(&apos;在iframe中&apos;); &#125; 比较可靠的方式为了彻底防止别人用IFRAME框架嵌套调用自己的网页，如下方法是最可靠的.这里赋值为空页面,也可赋值为你的页面的URL地址.123if(top != self)&#123; location.href = &quot;about:blank&quot;; &#125; 在meta中设置&lt;meta http-equiv=&quot;X-FRAME-OPTIONS&quot; content=&quot;DENY&quot;&gt; 在http的header做手脚12header(‘X-Frame-Options:Deny&apos;);header(&quot;X-XSS-Protection: 0&quot;); 在Apache、IIS、Nginc主机中设置X-Frame-Options &quot;SAMEORIGIN&quot;; BFCBFC的定义块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域（可以理解为独立的布局作用域），也是浮动元素与其他元素的交互限定区域。具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。 BFC的触发body 根元素或包含根元素的元素浮动元素：float 除 none 以外的值绝对定位元素：position (absolute、fixed)display 为 inline-block、table-cells、flexoverflow 除了 visible 以外的值 (hidden、auto、scroll) BFC的运用同一个 BFC 下外边距会发生折叠BFC 可以包含浮动的元素（清除浮动）（父容器设置为overflow: hidden;即可清除浮动）BFC 可以阻止元素被浮动元素覆盖（为原本被覆盖的元素设置overflow: hidden;是该元素触发BFC解决问题）10 分钟理解 BFC 原理 Banner如何平滑的从最后一张过渡到第一张1.如有1,2,3,4张banner需要轮播，对应图片顺序为：4,1,2,3,4,12.动画结束后改变left定位到前面的1，这个过程页面看不出变化。图片轮播，第一张图片和最后一张图片怎么过渡？ Event Loop（浏览器环境）定义：为了协调事件（event），用户交互（user interaction），脚本（script），渲染（rendering），网络（networking）等，用户代理（user agent）必须使用事件循环（event loops）。即事件循环，是JavaScript引擎处理异步任务的方式。为了让单线程的JavaScript通畅的跑起来，所有的异步操作都要被合适的处理，这个处理逻辑就叫做Event Loop。HTML标准-Event loops 堆、栈、队列堆（heap）堆（heap）是指程序运行时申请的动态内存，在JS运行时用来存放对象。 栈（stack）栈（stack）遵循的原则是“先进后出”，JS种的基本数据类型与指向对象的地址存放在栈内存中，此外还有一块栈内存用来执行JS主线程–执行栈（execution context stack），这里只考虑执行栈。 队列（queue）队列（queue）遵循的原则是“先进先出”，JS中除了主线程之外还存在两个“任务队列”（微任务队列microTask和宏任务队列macroTask）。 js中的两个队列在JavaScript中，任务被分为Task（又称为MacroTask,宏任务）和MicroTask（微任务）两种。MicroTask: process.nextTick（node独有）, Promises, Object.observe(废弃), MutationObserverMacroTask: script(同步代码), setTimeout, setInterval, setImmediate（node独有）, I/O, UI rendering（浏览器独有）javascript执行：总的执行顺序为同步代码script—&gt;microTask—&gt;其他macroTask，在执行microTask、macroTask是产生新的异步操作，如此一来就形成了循环。具体来说，浏览器会不断从task队列中按顺序取task执行，每执行完一个task都会检查microtask队列是否为空（执行完一个task的具体标志是函数执行栈为空），如果不为空则会一次性执行完所有microtask。然后再进入下一个循环去task队列中取下一个task执行，以此类推。 Philip Roberts的演讲《Help, I’m stuck in an event-loop》的event-loop 图PS：在执行MicroTask和MacroTask时，如果产生了新的MicroTask则会在本次Event Loop中执行，产生的MacroTask会在下个Event Loop中执行。（更新于2018-09-12）带你彻底弄懂Event Loop 解释 当主线程运行的时候,JS会产生堆和栈(执行栈)主线程中调用的webaip所产生的异步操作(dom事件、ajax回调、定时器等)只要产生结果，就把这个回调塞进“任务队列”中等待执行。当主线程中的同步任务执行完毕，系统就会依次读取“任务队列”中的任务，将任务放进执行栈中执行。执行任务时可能还会产生新的异步操作，会产生新的循环，整个过程是循环不断的。JavaScript 运行机制–Event Loop详解一篇文章教会你Event loop——浏览器和Node Event Loop（Node环境）Node使用了libuv库来实现Event loop。 Event Loop顺序nodejs的event loop分为6个阶段，它们会按照顺序反复运行，分别如下： timers：执行setTimeout() 和 setInterval()中到期的callback。 I/O callbacks：上一轮循环中有少数的I/Ocallback会被延迟到这一轮的这一阶段执行 idle, prepare：队列的移动，仅内部使用 poll：最为重要的阶段，执行I/O callback，在适当的条件下会阻塞在这个阶段 check：执行setImmediate的callback close callbacks：执行close事件的callback，例如socket.on(“close”,func)不同于浏览器的是，在每个阶段完成后，而不是MacroTask任务完成后，microTask队列就会被执行。这就导致了同样的代码在不同的上下文环境下会出现不同的结果。另外需要注意的是，如果在timers阶段执行时创建了setImmediate则会在此轮循环的check阶段执行，如果在timers阶段创建了setTimeout，由于timers已取出完毕，则会进入下轮循环，check阶段创建timers任务同理。一篇文章教会你Event loop——浏览器和Node RegExp相关知识点RegExp 构造函数创建了一个正则表达式对象，用于将文本与一个模式匹配[2018-03-27]。 正则flags的说明g–全局匹配;找到所有匹配，而不是在第一个匹配后停止i–忽略大小写m–多行; 将开始和结束字符（^和$）视为在多行上工作（也就是，分别匹配每一行的开始和结束（由 \n 或 \r 分割），而不只是只匹配整个输入字符串的最开始和最末尾处u–Unicode; 将模式视为Unicode序列点的序列y–粘性匹配; 仅匹配目标字符串中此正则表达式的lastIndex属性指示的索引(并且不尝试从任何后续的索引匹配) 正则表达式中特殊字符的含义字符类别（Character Classes）.点号，小数点，匹配任意单个字符（但不包括行结束符\n \r等）。例如，/.y/ 匹配 “yes make my day” 中的 “my” 和 “ay”，但是不匹配 “yes”。 \d匹配任意阿拉伯数字。等价于[0-9]。例如，/\d/ 或 /[0-9]/ 匹配 “B2 is the suite number.” 中的 ‘2’。 \D匹配任意一个不是阿拉伯数字的字符。等价于[^0-9]。例如，/\D/ 或 /[^0-9]/ 匹配 “B2 is the suite number.” 中的 ‘B’。PS：由于没有全局匹配，只能匹配到一个’B’就结束匹配。 \w匹配任意来自基本拉丁字母表中的字母数字字符，还包括下划线。等价于 [A-Za-z0-9_]。例如，/\w/ 匹配 “apple” 中的 ‘a’，”$5.28” 中的 ‘5’ 和 “3D” 中的 ‘3’。 \W匹配任意不是基本拉丁字母表中单词（字母数字下划线）字符的字符。等价于 [^A-Za-z0-9]。例如，/\W/ 或 /[^A-Za-z0-9]/ 匹配 “50%” 中的 ‘%’。 \s匹配一个空白符，包括空格、制表符、换页符、换行符和其他 Unicode 空格。例如 /\s\w*/ 匹配 “foo bar” 中的 ‘ bar’。 \S匹配一个非空白符。例如，/\S\w*/ 匹配 “foo bar” 中的 ‘foo’。PS：经常使用[\s\S]来匹配所有字符。 其他\t 匹配一个水平制表符（tab）\r 匹配一个回车符（carriage return）\n 匹配一个换行符（linefeed）\v 匹配一个垂直制表符（vertical tab）\f 匹配一个换页符（form-feed）[\b] 匹配一个退格符（backspace）（不要与 \b 混淆）\0 匹配一个 NUL 字符。不要在此后面跟小数点。\xhh 匹配编码为 hh （两个十六进制数字）的字符。\uhhhh 匹配 Unicode 值为 hhhh （四个十六进制数字）的字符。\ 发生转义例如， 是一个特殊字符，表示匹配某个字符 0 或多次，如 /a/ 意味着 0 或多个 “a”。 为了匹配字面意义上的 ，在它前面加上一个反斜杠，例如，/a\/匹配 ‘a*’。 字符集合（Character Sets）[xyz]匹配集合中的任意一个字符。你可以使用连字符’-‘指定一个范围。例如，[abcd] 等价于 [a-d]，匹配”brisket”中的’b’和”chop”中的’c’。 [^xyz]一个反义或补充字符集，也叫反义字符组。例如，[^abc] 等价于 [^a-c]。 第一个匹配的是 “bacon” 中的’o’ 和 “chop” 中的 ‘h’。 边界（Boundaries）^匹配输入开始。如果多行（multiline）标志被设为 true，该字符也会匹配一个断行（line break）符后的开始处。例如，/^A/ 不匹配 “an A” 中的 “A”，但匹配 “An A” 中的 “A”。 $匹配输入结尾。如果多行（multiline）标志被设为 true，该字符也会匹配一个断行（line break）符的前的结尾处。例如，/t$/ 不匹配 “eater” 中的 “t”，但匹配 “eat” 中的 “t”。 \b如果符合要求就一直往后匹配，一直到无法匹配为止，这就是贪婪模式。所谓的惰性模式就是一旦匹配到合适的就结束，不在继续匹配下去了。 分组（Grouping）与反向引用（back references）先行断言（lookahead）先行肯定断言x(?=y)只有当 x 后面紧跟着 y 时，才匹配 x。/Jack(?=Sprat|Frost)/ 只有在 ‘Jack’ 后面紧跟着 ‘Sprat’ 或 ‘Frost’ 时，才会匹配它。然而，’Sprat’ 或 ‘Frost’ 都不是匹配结果的一部分。 先行否定断言x(?!y)只有当 x 后面不是紧跟着 y 时，才匹配 x。只有当 x 后面不是紧跟着 y 时，才匹配 x。例如，/\d+(?!.)/ 只有当一个数字后面没有紧跟着一个小数点时，才会匹配该数字。/\d+(?!.)/.exec(“3.141”) 匹配 141 而不是 3.141。 后行断言（lookbehind）这是ES2018新加的标准 后行肯定断言(?&lt;=y)x只有当 x 前面紧跟 y 时，才匹配 x。例如：/(?&lt;=\$)\d+/.exec(‘$1000’) // 1000 后行否定断言(?&lt;!y)x只有当 x 前面紧不是跟 y 时，才匹配 x。例如：/(?&lt;!\$)\d+/.exec(‘$99¥1000’) // 99 获取元素的尺寸window.getComputedStyle(element, [pseudoElt])定义：Window.getComputedStyle() 方法给出应用活动样式表后的元素的所有CSS属性的值，并解析这些值可能包含的任何基本计算。参数：element 用于获取计算样式的ElementpseudoElt 可选 指定一个要匹配的伪元素的字符串。必须对普通元素省略（或null）。返回：返回的样式是一个实时的 CSSStyleDeclaration 对象，当元素的样式更改时，它会自动更新本身。兼容性处理：window.getComputedStyle ? window.getComputedStyle(ele, null) : ele.currentStyle可以通过height属性和getPropertyValue(“height”)获取height值。 elem.getBoundingClientRect()定义：Element.getBoundingClientRect()方法返回元素的大小及其相对于视口的位置。返回：top、right、bottom、left（相对于视口）width、right。 元素的属性content+padding：clientWidth\clientHeightcontent+padding+border: offsetWidth\offsetHeight 埋点定义：埋点分析，是网站分析的一种常用的数据采集方法。数据埋点分为初级、中级、高级三种方式。数据埋点是一种良好的私有化部署数据采集方式。实现步骤：埋点阶段 -&gt; 数据收集阶段 -&gt; 后端处理阶段 买点分类适合前端埋点 运营初级阶段，产品功能相对简单（无明确业务数据、交易数据，仅通过UV、PV、点击量等基本指标分析即可满足需求） 需求分析与后端没有交互的前端行为（运营人员工作需要判断前端界面设计是否合理）适合后端埋点 追求精细化运营，需要进行多维度数据分析 包含用户资产、用户账户、风控辅助数据等重点业务数据 对数据安全性要求比较高 前端和后端都可以采集到的数据，应优先考虑后端埋点前端埋点（实现步骤）埋点以Google Analytics分析为例在页面上插入一段js代码，被称为埋点代码。123456789101112&lt;script type=&quot;text/javascript&quot;&gt; var _maq = _maq || []; // 全局的数组，放采集到的数据 _maq.push([&apos;_setAccount&apos;, &apos;uuid&apos;]); // 默认放了_setAccount用于设置网站标识ID，这个标识ID是在注册GA时分配的。 (function () &#123; var ma = document.createElement(&apos;script&apos;); ma.type = &apos;text/javascript&apos;; ma.async = true; ma.src = &quot;http://localhost:8091/data/js/ma.js&quot;; var s = document.getElementsByTagName(&apos;script&apos;)[0]; s.parentNode.insertBefore(ma, s); &#125;)(); &lt;/script&gt; PS：匿名函数，这段代码的主要目的就是引入一个外部的js文件（ga.js），方式是通过document.createElement方法创建一个script并根据协议（http或https）将src指向对应的ga.js，最后将这个element插入页面的dom树上。注意ga.async = true的意思是异步调用外部js文件，即不阻塞浏览器的解析，待外部js下载完成后异步执行。这个属性是HTML5新引入的。 数据采集（之前动态插入的ma.js）1234567891011121314151617181920212223242526272829303132333435363738394041424344(function () &#123; var params = &#123;&#125;; //Document对象数据 if(document) &#123; params.domain = document.domain || &apos;&apos;; params.url = document.URL || &apos;&apos;; params.title = document.title || &apos;&apos;; params.referrer = document.referrer || &apos;&apos;; &#125; //Window对象数据 if(window &amp;&amp; window.screen) &#123; params.sh = window.screen.height || 0; params.sw = window.screen.width || 0; params.cd = window.screen.colorDepth || 0; &#125; //navigator对象数据 if(navigator) &#123; params.lang = navigator.language || &apos;&apos;; &#125; //解析_maq配置 if(_maq) &#123; for(var i in _maq) &#123; switch(_maq[i][0]) &#123; case &apos;_setAccount&apos;: params.account = _maq[i][1]; break; default: break; &#125; &#125; &#125; //拼接参数串 var args = &apos;&apos;; for(var i in params) &#123; if(args != &apos;&apos;) &#123; args += &apos;&amp;&apos;; &#125; args += i + &apos;=&apos; + encodeURIComponent(params[i]); &#125; //通过Image对象请求后端脚本 var img = new Image(1, 1); img.src = &apos;http://analytics.codinglabs.org/1.gif?&apos; + args;&#125;)(); PS：为什么使用图片请求后端controller而不是ajax直接访问？原因在于ajax不能跨域请求，ma.js和后端分析的代码可能不在相同的域内，ajax做不到，而将image对象的src属性指向后端脚本并携带参数，就轻松实现了跨域请求。 后端处理后端脚本一般做下面几件事：（1）解析http请求参数的到信息。（2）从服务器（WebServer）中获取一些客户端无法获取的信息，如访客ip等。（3）将信息按格式写入log。（4）生成一副1×1的空gif图片作为响应内容并将响应头的Content-type设为image/gif。（5）在响应头中通过Set-cookie设置一些需要的cookie信息（作为跟踪唯一访客）。前端埋点和后端埋点，哪个更科学？用户行为日志-js埋点（一）实现整体流程开源埋点库MixPanel File文件(File) 接口提供有关文件的信息，并允许网页中的 JavaScript 访问其内容。 files属性用于获取当前文件数组相关的信息，每个元素有下列属性（均为只读属性）。File.lastModifiedFile.nameFile.size 单位为B。File.webkitRelativePathFile.type 返回文件的 多用途互联网邮件扩展类型 FileReader() 构造函数FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。FileReader.abort()该方法可以取消 FileReader 的读取操作，触发之后 readyState 为已完成（DONE）。FileReader.readAsArrayBuffer()开始读取指定的 Blob中的内容, 一旦完成, result 属性中保存的将是被读取文件的 ArrayBuffer 数据对象.FileReader.readAsBinaryString()开始读取指定的Blob中的内容。一旦完成，result属性中将包含所读取文件的原始二进制数据。FileReader.readAsBinaryString()开始读取指定的Blob中的内容。一旦完成，result属性中将包含所读取文件的原始二进制数据。FileReader.readAsText()开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个字符串以表示所读取的文件内容。 前端错误收集window.onerror（大部分的错误）window.onerror = function(message, source, lineno, colno, error) { … }PS： 由于网络请求异常事件不会冒泡，需要在捕获阶段进行处理 不能捕获promise的错误信息 跨域资源需要专门处理，需要在script标签加上crossorigin属性，服务器设置Access-Control-Allow-Origin window.onerror 函数只有在返回 true 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示 Uncaught Error: xxxxx。 promise的错误处理promise除了使用catch方法来捕获错误，还可以使用window的unhandledrejection事件捕获异常1234window.addEventListener(&quot;unhandledrejection&quot;, function (event) &#123; console.warn(&quot;WARNING: Unhandled promise rejection. Shame on you! Reason: &quot; + event.reason);&#125;); try catchtry catch只能捕获同步代码的异常，对回调，setTimeout，promise等无能为力 上报错误 后端提供接口，前端ajax上传 创建一个新的图片，url参数带上错误信息（跨域） 1234function report(error) &#123; var reportUrl = &apos;http://xxxx/report&apos;; new Image().src = reportUrl + &apos;error=&apos; + error;&#125; 阿里UED前端监控 npx引入这个命令的目的是为了提升开发者使用包内提供的命令行工具的体验。1npx create-react-app my-cool-new-app 这条命令会临时安装 create-react-app 包，命令完成后 create-react-app 会删掉，不会出现在 global 中。下次再执行，还是会重新临时安装。 判断浏览器对某个css3是否支持‘样式属性名’ in document.documentElement.style‘transform’ in document.documentElement.style // truePS：兼容性较好，ie6+ @supports此方法为css属性123456@supports (display: flex) &#123; div &#123; display: flex; &#125;&#125;@supports not (display: flex) &#123; div &#123; float: left; &#125; /* 替换样式 */&#125; 通常关系链接符有 not、or、and等 CSS.supportsCSS.supports(propertyName, value) || CSS.supports(supportCondition)CSS.supports() 静态方法返回一个Boolean值，用来校验浏览器是否支持一个给定的CSS特性。该方法有两种参数形式： propertyName：属性名，value：属性值。 supportCondition：需要一个匹配@supports条件的参数。 12result = CSS.supports(&apos;(--foo: red)&apos;); // true第一种形式result = CSS.supports(&quot;( transform-origin: 5% 5% )&quot;); // true第二种形式 装饰者模式装饰者模式（Decorator Pattern）：在不改变原类和继承的情况下动态扩展对象功能，通过包装一个对象来实现一个新的具有原对象相同接口的新的对象。装饰者用于通过重载方法的形式添加新功能，该模式可以在被装饰者前面或者后面加上自己的行为以达到特定的目的。装饰者模式是为已有功能动态地添加更多功能的一种方式，把每个要装饰的功能放在单独的函数里，然后用该函数包装所要装饰的已有函数对象，因此，当需要执行特殊行为的时候，调用代码就可以根据需要有选择地、按顺序地使用装饰功能来包装对象。1234567891011121314151617181920212223//需要装饰的类（函数）function Macbook() &#123; this.cost = function () &#123; return 1000; &#125;;&#125; //计算商品的包装费function PackagingFee(macbook) &#123; this.cost = function () &#123; return macbook.cost() + 75; &#125;;&#125;//计算商品的运费function Freight(macbook) &#123; this.cost = function () &#123; return macbook.cost() + 300; &#125;;&#125;let money1 = new Macbook() // 只包含mac 1000let money2 = new PackagingFee(new Macbook()) // 只包含mac + 包装费 1075 let money4 = new Freight(new Macbook()) // 只包含mac + 运费 1300let money3 = new Freight(new PackagingFee(new Macbook())) // 包含mac + 包装费 + 运费 1375 touchstart 和 click 的坑产生原因：1234var tap = &apos;ontouchstart&apos; in window ? &apos;touchstart&apos; : &apos;click&apos;;wrap.addEvenListener(tap, function()&#123; signUp();&#125;); 通过上面代码简单为用户设置事件类型，但我们忽略了‘联想触控笔记本’，由于该笔记本支持‘touchstart’事件，但当用户使用鼠标时却不能触发‘touchstart’事件，造成不能触发对应的事件处理函数。 有些 PC 设备屏幕为触摸屏，同时支持touchstart和click事件； 用户触发touchstart事件，默认必然会导致触发click事件，但是触发click事件，不一定会导致touchstart事件被触发； 此类设备外接鼠标时，通过上面的绑定方式，会绑定touchstart事件，但是鼠标操作只能触发click，导致touchstart不触发； 解决方案均使用click事件（移动端存在300ms延迟）通过UA判断设备是否为移动端，再确认事件类型1234function isMobile() &#123; return navigator.userAgent.match(/(blackberry|configuration\/cldc|hp |hp-|htc |htc_|htc-|iemobile|kindle|midp|mmp|motorola|mobile|nokia|opera mini|opera |Googlebot-Mobile|YahooSeeker\/M1A1-R2D2|android|iphone|ipod|mobi|palm|palmos|pocket|portalmmm|ppc;|smartphone|sonyericsson|sqh|spv|symbian|treo|up.browser|up.link|vodafone|windows ce|xda |xda_)/i) ? true : false;&#125; var tap = isMobile() ? &apos;touchstart&apos; : &apos;click&apos;; 全部使用click，通过FastClick解决300毫秒的延迟问题不再绑定的时候进行判断，而是对touchstart 和 click 同时绑定，但是在 touchstart 触发的时候暂停取消后续 click 的响应。具体实现： 在touchstart事件响应中调用preventDefault()方法，阻止后续click事件的触发（也会阻止多个事件绑定叠加和多人合作项目，导致以来 click 事件出现bug） 在touchstart事件中设置一些标记，或者取消click事件的绑定，使得click事件触发时不会触发我们绑定的逻辑，在一段时间（例如300-500ms）后再恢复 直接对事件处理函数进行节流（throttle），保证在一段时间内（300ms - 500ms），事件处理函数只触发一次 defer和asyncdefer：载入 JavaScript 文件时不阻塞 HTML 的解析（并行），执行阶段被放到 HTML 标签解析完成之后（DOMContentLoaded之前）。async：与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后，但一定在load触发之前执行。 从输入url到页面渲染优化大值步骤DNS域名解析-&gt;建立TCP连接-&gt;下载资源-&gt;解析页面 DNS域名解析将人们习惯使用的域名，映射为对应的ip，机器之间只能识别ip地址。域名解析的步骤：以www.baidu.com为例1、浏览器缓存：浏览器会按照一定的频率缓存DNS记录。2、操作系统缓存：如果浏览器缓存中找不到需要的DNS记录，那就去操作系统中找（hosts文件）。3、路由缓存：路由器也有DNS缓存(可能存在)。4、ISP的DNS服务器：ISP是互联网服务提供商(Internet Service Provider)的简称，ISP有专门的DNS服务器应对DNS查询请求。5、根服务器：ISP的DNS服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS服务器先问根域名服务器.域名服务器的IP地址，然后再问.com顶级域名服务器，依次类推）。PS：以www.baidu.com为例说明根域名、顶级域名、一级域名等根域名：为’.’,全球共13个ip地址（并不是13台机器）。顶级域名(一级域名)：为www.baidu.com的顶级域名为baidu.com，主机名为www。二级域名：a.www.baidu.com的二级域名为www.baidu.com，主机名为a。优化方案：域名预解析1234// 告知浏览器, 当前页面要做DNS预解析&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt;// 强制对DNS预解析（本网页需要跳转的页面，注意避免多页面重复DNS解析）&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://bdimg.share.baidu.com&quot; /&gt; 建立TCP连接经过域名解析，浏览器拿到了服务器的IP。TCP建立连接的三次握手：客户端创建socket，向服务器目标端口发送连接建立请求，数据段包含位码SYN（建立联机标志位） = 1，随机数seq（顺序号码）= x，和其他TCP标志和选项。服务器有一个专门处理连接请求的welcome socket，接收到连接建立请求，置位码SYN和ACK（确认标志位）为1，ack（确认号码）= x + 1，随机数seq = y，并返回。客户端检查ack是否等于x + 1，等于时，将ACK置为1，SYN置为0，将ack置为y + 1发送至服务器端。welcome socket检查ack等于y + 1和ACK等于1后，创建新的socket，此socket由源IP/源端口、目标IP/目标端口标识，之后客户端发送的数据都被引导向此新的socket，至此，TCP连接建立。优化方案：减少数据往返延迟（地理位置远近关系）可以使用CDN（客户端访问域名到距离最近的服务器）。使用HTTP2（多路复用 (Multiplexing)）、header压缩（减少传输数据大小）、服务端推送（server push）（有时只需要服务器发送数据到客户端，不需要客户端-&gt;服务端—&gt;客户端这样一个来回）减少cookie：每次请求都携带了本域的cookiePS：虽然HTTP 1.1有长链接，但资源下载事串行的，所以推荐使用HTTP2的多了复用。 下载资源（接收响应）避免不必要的重定向（非缓存重定向），重定向会导致浏览器再进行一次（DNS域名解析-&gt;建立TCP连接-&gt;下载资源-&gt;解析页面）。避免超出并行连接阀值（浏览器会在同域名并行连接限制，一般为6个） 解析页面（webkit工作原理）处理HTML标记，构建DOM树。处理CSS标记，构建CSSOM树。将DOM树和CSSOM树融合成渲染树（会忽略不需要渲染的dom）。根据渲染树来布局，计算每个节点的几何信息。在屏幕上绘制各个节点。中间遇到各种资源时，会进行资源的下载。优化：css放head中，js放body尾部，均以外链形式压缩js、css等文件使用CDN技术使用图片精灵、webp、图片base64等首屏优化（按需加载、首屏资源优先加载）避免重排（开启复合层，如使用3d变换、opacity等3d硬件加速的坑），减少重绘缓存技术：强缓存（Expires、Cache-Control：max-age=seconds）协商缓存（Last-Modified/If-Modified-Since、ETag/If-None-Match） CSS2Dtransform和Matrix的关系这里transform包括：translate、scale、rotate、skew没有任何变换时：matrix(1, 0, 0, 1, 0, 0)、matrix(a, b, c, d, e, f)translate(30, 30) 等价于 matrix(1, 0, 0, 1, 30, 30)ps：e、f分别表示x轴和y轴偏移距离scale(2, 3) 等价于 matrix(2, 0, 3, 1, 0, 0)ps：a、c分别表示x轴和y轴缩放比例rotate(θ) 等价于 matrix(cosθ,sinθ,-sinθ,cosθ,0,0)ps：a、b、c、d共同决定旋转角度θskew(θx, θy) 等价于 matrix(1,tan(θy),tan(θx),1,0,0)ps：θx表示x轴倾斜的角度，θy表示y轴 硬编码和非硬编码（软编码）的区别软编码可以在运行时确定，修改；而硬编码是不能够改变的。硬编码是指将可变变量用一个固定值来代替的方法，使用这样方法，编译后，如果想更改词变量就变的非常困难。因此， 在大部分的程序语言中，可以将一个固定值定义为一个标记， 然后用这个特殊的标记来取代变量名称。 当标记名称发生改变时， 变量名不变。这样在程序进行编译时，所有的变量都不再是固定值 这样就更容易实现改变变量的目的。 幂等在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。 Intersection Observer2018-05-28添加定义：IntersectionObserver构造函数为开发者提供了一种可以异步监听目标元素与其祖先或视窗(viewport)交叉状态的手段。祖先元素与视窗(viewport)被称为根(root)。语法：let io = new new IntersectionObserver(callback(entries), options)用法：1234567891011var intersectionObserver = new IntersectionObserver(function(entries) &#123; // entries 时一个数组，每个成员都是一个[IntersectionObserverEntry对象](https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry)。 if (entries[0].intersectionRatio &lt;= 0) return; // 元素与祖先元素交叉状态发生改变时触发 loadItems(10); console.log(&apos;Loaded new items&apos;);&#125;);// start observingintersectionObserver.observe(document.querySelector(&apos;.scrollerFooter&apos;)); 属性（options）：root – 所监听对象的具体祖先元素(element)。如果未传入任何值或值为null，则默认使用viewport。rootMargin – 计算交叉时添加到根(root)边界盒bounding box的矩形偏移量， 可以有效的缩小或扩大根的判定范围从而满足计算需要。此属性返回的值可能与调用构造函数时指定的值不同，因此可能需要更改该值，以匹配内部要求。所有的偏移量均可用像素(pixel)(px)或百分比(percentage)(%)来表达, 默认值为”0px 0px 0px 0px”。thresholds – 一个包含阈值的list, 升序排列, list中的每个阈值都是监听对象的交叉区域与边界区域的比率。当监听对象的任何阈值被越过时，都会生成一个通知(Notification)。如果构造器未传入值, 则默认值为0.方法：observe(element) – 使IntersectionObserver开始监听一个目标元素。unobserve(element) – 使IntersectionObserver停止监听特定目标元素。takeRecords() – 为所有监听目标返回一个IntersectionObserverEntry对象数组并且停止监听这些目标。disconnect() – 使IntersectionObserver对象停止监听工作。应用：惰性加载（lazy load）、无限滚动等MDN-Intersection ObserverIntersectionObserver API 使用教程查看浏览器支持情况 MutationObserver（异步的）2018-05-28添加定义：MutationObserver给开发者们提供了一种能在某个范围内的DOM树发生变化时作出适当反应的能力.该API设计用来替换掉在DOM3事件规范中引入的Mutation事件.语法：var observer = new MutationObserver(callback(mutations, observer));PS：mutations 为DOM变动数组，observer 为观察器实例。用法：123456789101112131415var observer = new MutationObserver(function (mutations, observer) &#123; mutations.forEach(function(mutation) &#123; console.log(mutation); &#125;);&#125;);var article = document.querySelector(&apos;article&apos;);var options = &#123; &apos;childList&apos;: true, &apos;attributes&apos;:true&#125; ;// start Observerobserver.observe(article, options); 方法：observe(element, options) – 给当前观察者对象注册需要观察的目标节点,在目标节点(还可以同时观察其后代节点)发生DOM变化时收到通知.PS：target 为观察该节点是否会发生DOM变化.options 为一个MutationObserverInit对象,指定要观察的DOM变化类型.disconnect() – 让该观察者对象停止观察指定目标的DOM变化.直到再次调用其observe()方法,该观察者对象包含的回调函数都不会再被调用.takeRecords() – 清空观察者对象的记录队列,并返回里面的内容.MDN-MutationObserverMutation Observer API 参考文档：HTTP/2DNS域名解析的过程从输入url开始能做哪些优化DNS解析过程详解]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MathML]]></title>
    <url>%2F2018%2Fhtml5-MathML.html</url>
    <content type="text"><![CDATA[介绍Mathematical Markup Language (MathML) 是一个用于描述数学公式、符号的一种 XML 标记语言。MathML 是一个用于标记数学表达式的 XML 词汇表，它包含两个子语言：Presentation MathML 和 Content MathML。Presentation MathML 主要负责描述数学表达式的布局（因此可与 TeX 或更早的 SGML 标记语言相比较，SGML 用于描述诸如 ISO 12083 之类格式的数学表达式的布局）。Content MathML 主要负责标记表达式的某些含义或数学结构。MathML 的这一方面受到 OpenMath 语言的很大影响，在 MathML3 中，与 OpenMath 更为贴近。 示例123456789&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt; &lt;mrow&gt; &lt;msup&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt; &lt;mo&gt;+&lt;/mo&gt; &lt;msup&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt; &lt;mo&gt;=&lt;/mo&gt; &lt;msup&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt; &lt;/mrow&gt;&lt;/math&gt; MathML 元素这是一份关于 MathML 呈现型元素的、按字母表排序的清单。MathML元素的细节和在桌面浏览器与移动设备浏览器上的兼容性情况。 math&lt;math&gt; （顶层元素） A123&lt;maction&gt; （绑定动作到子表达式）&lt;maligngroup&gt; （对齐分组）&lt;malignmark&gt; （对齐点） E12&lt;menclose&gt; （包含的内容）&lt;merror&gt; （包含的语法错误消息） F12&lt;mfenced&gt; （圆括号）&lt;mfrac&gt; （因子） G&lt;mglyph&gt; （显示非标准符号） I&lt;mi&gt; （标识符） L12&lt;mlabeledtr&gt;（表格或矩阵中的行标签）&lt;mlongdiv&gt;（长除法记号） M&lt;mmultiscripts&gt; （惯例和张量指标） N&lt;mn&gt; （数量） O12&lt;mo&gt; （运算符）&lt;mover&gt; （上标） P12&lt;mpadded&gt;（内容周围的填充空间）&lt;mphantom&gt; （预留空间的不可见内容） R12&lt;mroot&gt; （带指定根数的根号）&lt;mrow&gt; （分组后的子表达式） S123456789101112131415&lt;ms&gt; （字符串字面量）&lt;mscarries&gt; （诸如进位的附注）&lt;mscarry&gt; （单位进位， &lt;mscarries&gt;的子元素）&lt;msgroup&gt; （在 &lt;mstack&gt; 和 &lt;mlongdiv&gt;元素中分组后的若干行）&lt;msline&gt; （在 &lt;mstack&gt; 内部的水平行）&lt;mspace&gt; （空格）&lt;msqrt&gt; （不带根数的平方根）&lt;msrow&gt; （在&lt;mstack&gt;元素中的行）&lt;mstack&gt; （堆叠式对齐）&lt;mstyle&gt; （样式变更）&lt;msub&gt; （下角标）&lt;msup&gt; （上角标）&lt;msubsup&gt; （上下角标对） T1234&lt;mtable&gt; （表格或矩阵）&lt;mtd&gt; （表格或矩阵中的单元格）&lt;mtext&gt; （文本）&lt;mtr&gt; （表格或矩阵中的行） U12&lt;munder&gt; （下标）&lt;munderover&gt; （上标-下标对） other123&lt;semantics&gt; （语义附注的容器）&lt;annotation&gt; （数据附注）&lt;annotation-xml&gt; （XML 附注） MathML 属性关于MathML属性的参考文档。用这些属性可以修改这些元素的显示效果。 PS：MathML的 mstyle 和 math 元素接受所有 MathML 的描述元素。 请参阅MathML中值（values）和单位的注释值。 参考文档： MDN-MathML html5-mathml MathML 介绍]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码重构技巧]]></title>
    <url>%2F2017%2F%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84%E6%8A%80%E5%B7%A7.html</url>
    <content type="text"><![CDATA[重构技巧任何不会被修改的变量都可以当做参数传入新的函数；一个变量会被修改可以把它当做返回值。 重构方法-重新组织函数Extract Method（提炼函数）将这段代码放进一个独立地函数中，并让函数名称解释该函数的用途。包装函数的粒度小，复用的几率就大。适用于：为一些代码提供一个清晰的函数名。函数命名：以它“做什么”来命名，而不是以它“怎么做”命名。 Inline Method（内联函数）在函数调用点插入函数本体，然后移除该函数。适用于：原函数内部代码清晰易读，不需要提炼为一个单独的函数。 Inline Temp（内联临时变量）将所有对该变量的引用动作，替换为对它赋值的哪个表达式自身。适用于：只使用了一次，或许可以移除该临时变量。 Replace Temp with Query（以查询取代临时变量）将这个表达式提炼到一个独立函数中。将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可以被其它函数使用。适用于：由于临时变量作用域只在函数内部，如果把临时变量替换为一个查询，那么同一个类中的所有函数都可以获取这份信息。 Introduce Explaining Variable（引入解释性变量）将该复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途。适用于：用一个命名清晰的变量来代替难以理解的代码或函数。 Split Temporary Variable（分解临时变量）针对每次赋值，创造一个独立、对应的临时变量（再多一个临时变量）。适用于：你的程序有某个临时变量被赋值超过一次，它即不是循环变量，而不被用于收集计算结果。 Remove Assignments to Parameters（移除对参数的赋值）以一个临时变量取代该参数的位置。适用于：用一个临时变量（有意义的名字）保存参数。 Replace Method with Method Object（以函数对象取代函数）将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段。然后你可以在同一个对象中将这个大型函数分解为多个小型函数。适用于：你有一个大型函数，其中对局部变量的使用使你无法采用Extract Method。 Substitute Algorithm（替换算法）将函数本体代替为另一个算法。适用于：你想要把某个算法替换为另一个更加清晰的算法。 重构方法-在对象之间搬移特性Move Method（搬移函数）在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数编程一个单纯的委托函数，或是将旧函数完全移除。适用于：一个类有太多行为，或一个类与另一个类有太多合作而形成高度耦合。 Move Field（搬移字段）在目标类新建一个字段，修改源字段的所有用户，令它们改用新字段。适用于：对于一个字段，在其所驻类之外的另一个类中有更多函数使用了它。 Extract Class（提炼类）建立一个新类，将相关的字段和函数从旧类搬移到新类。适用于：某个类做了应该由两个类做的事。 Inline Class（将类内联化）将这个类的所有特性搬移到另一个类中，然后移除原类。适用于：某个类没有做太多事情。 Hide Delegate（隐藏“委托关系”）在服务类上建立客户所需的所有函数，用以隐藏委托关系。适用于：客户通过一个委托类来调用另一个对象。 Remove Middle Man（移除中间人）让客户直接调用受托类。适用于：某个类做了过多的简单委托动作。 Introduce Foreign Method（引入外加函数）在客户类中建立一个函数，并以第一参数形式传入一个服务类实例。适用于：你需要为提供服务的类添加一个函数，但你无法修改这个类。外加函数终归是权益之计，尽量将其搬移到服务类中去（Introduce Local Extension）。 Introduce Local Extension（引入本地扩展）建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的子类或包装类。适用于：你需要为服务类提供一些额外函数，但你无法修改这个类。 重构方法-重新组织数据Self Encapsulate Field（自封装字段）为这个字段建立取值/设置函数，并且只以这些函数来访问字段。适用于：你直接访问一个字段，但与字段之间的耦合关系逐渐变得笨拙。 Replace Data Value with Object（以对象取代数据值）将数据项变成对象。适用于：你有一个数据项，需要与其他数据和行为一起使用才有意义。 Change Value to Reference（将值对象改为引用对象）将这个值对象变成引用对象。适用于：你从一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象。 Change Reference to Value（将引用对象改为值对象）将它变成一个值对象。适用于：你有一个引用对象，很小且不可该表，而且不易管理。 Replace Array with Object（以对象取代数组）以对象替换数组。对于数组中的每个元素，以一个字段来表示。适用于：你有一个数组，其中的元素各自代表不同的东西。 Duplicate Observed Data（复制“被监视数据”）将该数据复制到一个领域对象中。建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据。MVC模型 Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）添加一个反向指针，并使修改函数能够同时更新两条连接。适用于：两个类都需要使用对方特性，但其间只有一条单向连接。 Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）去除不必要的关联。适用于：两个类之间有双向关联，但其中一个类如今不需要另一个类的特性。 Replace Magic Number with Symbolic Constant（以字面常量取代魔法数）创造一个常量，根据其意义为它命名，并将上述的字面量替换为这个常量。适用于：你有一个字面数值，带上特别含义。 Encapsulate Field（封装字段）将它声明为private，并提供相应的访问函数get和set。适用于：你的类中存在一个public字段。 Encapsulate Collection（封装集合）让这个函数返回集合的一个只读副本，并在这个类中提供添加/移除集合元素的函数。适用于：有一个函数返回一个集合。 Replace Record with Data Class（以数据类取代记录）为该记录创建一个“哑”数据对象。适用于：你需要面对传统编程环境中的记录结构。 Replace Type Code with Class（以类取代类型码）以一个新的类替换该数值类型码。适用于：类之中有一个数值类型码，但它并不影响类的行为。 Replace Type Code with Subclasses（以子类取代类型码）以自带取代这个类型码（多态）。适用于：你有一个不可变的类型码，它会影响类的行为。 Replace Type Code with State/Strategy（以State/Strategy取代类型码）以状态对象取代类型码。适用于：你有一个类型码，它会影响类的行为，但你无法通过继承手法消除它。 Replace Subclass with Fields（以字段取代子类）修改这些函数，使它们返回超类中的某个（新增）字段，然后销毁子类。适用于：你的各个子类的唯一差别只在“返回常量数据”的函数身上。 重构方法-简化条件表达式Decompose Conditional（分解条件表达式）从if、then、else三个段落中分别提炼出独立函数。适用于：你有一个复杂的条件（if-then-else）语句。 Consolidate Conditional Expression（合并条件表达式）将这些测试合并为一个条件表达式，并将这个表达式提炼成一个独立的函数。适用于：你有一系列条件测试，都得到相同结果。 Consilidate Duplicate Conditional Fragments（合并重复的条件片段）将这个端重复代码搬移到条件表达式之外。适用于：在条件表达式的每个分支上有着相同的一段代码。 Remove Control Flag（移除控制标记）以break语句或return语句取代控制标记。适用于：在一系列布尔表达式中，某个变量带有“控制标记”（control flag）的作用。 Replace Nested Conditional with Guard Clauses（以卫语句取代嵌套条件表达式）使用卫语句表现所有特殊情况（尽量不要转换成嵌套）。适用于：函数中的条件逻辑使人难以看清正常的执行路径。 Replace Conditional with Polymorphism（以多态取代条件表达式）将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数。适用于：你手上有个条件表达式，它根据对象类型的不同而选择不同的行为。 Introduce Null Object（引入Null对象）将null值替换为null对象。适用于：你需要再三检查对象是否为null。 Introduce Assertion（引入断言）以断言明确表现这种假设。适用于：某一段代码需要对程序状态做出某种假设。 重构方法-简化函数调用Rename Method（函数改名）修改函数的名称。适用于：函数的名称未能解释函数的用途。函数命名，参考“做什么”而不是“怎么做”。 Add Parameter（添加参数）为此函数添加一个对象参数，让该对象带进函数所需信息。适用于：某个函数需要从调用端得到更对信息。这样做有一个好处，不用关心参数的位置。 Remove Parameter（移除参数）将该参数去除。适用于：函数本体不再需要某个参数。 Separate Query from Modifier（将查询函数和修改函数分离）建立两个不同的函数，其中一个负责查询，另一个负责修改。适用于：某个函数既返回对象状态值，又修改对象状态。 Parameterize Method（令函数携带参数）建立单一函数，以参数表达那些不同的值。适用于：若干函数做了类似的工作，但在函数本体中却包含了不同的值。 Replace Parameter with Explicit Methods（以明确函数取代参数）针对该参数的每一个可能值，建立一个独立函数。适用于：你有一个函数，其中完全取决于参数值而不采取不同行为。 Preserve Whole Object（保持对象完整）改为传递整个对象（传递整个对象，不要值传递对象的某些属性）。适用于：你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。 Replace Parameter with Methods（以函数取代参数）让参数接受者去除该项参数，并直接调用前一个函数。适用于：对象调用某一个函数，并将所得结果作为参数，传递给另一个函数。而接受参数的函数本身也能够用前一个函数。 Introduce Parameter Object（引入参数对象）以一个对象取代这些参数。适用于：某些参数总是很自然地同时出现。 Remove Setting Method（移除设置函数）去掉该字段的所有设值函数。适用于：类中的某个字段应该在对象创建时被设值，然后不再改变。 Hide Method（隐藏函数）将这个函数修改为private。适用于：有一个函数，从来没有被其他任何类用到。 Replace Constructor with Factory Method（以工厂函数取代构造函数）将构造函数替换为工厂函数。适用于：你希望在创建对象时不仅仅时做简单的建构动作。 Enucapsulate Downcast（封装向下转型）将向下转型动作移到函数中。适用于：某个函数返回的对象，需要由函数调用者执行向下转型（downcast）。 Replace Error Code with Exception（异常取代错误代码）改用异常。适用于：某个函数返回一个特定的代码，用以表示某种错误情况。 Replace Exception with Test（以测试取代异常）修改调用者，使它在调用函数之前先做检查。适用于：面对一个调用这可以预先检查的条件，你抛出了一个异常。 重构方法-处理概括关系（继承关系）Pull Up Field（字段上移）将该字段移至超类。适用于：两个子类都拥有相同的字段。 Pull Up Method（函数上移）将函数移至超类。适用于：有些函数，在各个子类中产生完全相同的结果。 Pull Up Constructor Body（构造函数本体上移）在超类中新建一个构造函数，并在子类构造函数中调用它。适用于：你在各个子类中拥有一些构造函数，它们的本体机会完全一致。 Push Down Method（函数下移）将这个函数移到相关的那些子类去。适用于：超类中的某个函数只与部分（而非全部）子类有关。 Push Down Field（字段下移）将这个字段移到需要它的那些子类去。适用于：超类中的某个字段只被部分（而非全部）子类用到。 Extract Subclass（提炼子类）新建一个子类，将上面所说的那一部分特性移到子类中。适用于：类中的某些特性只被某些（而非全部）实例用到。 Extract Superclass（提炼超类）为这两个类建立建立一个超类，将相同特性移至超类。适用于：这两个类有相似特性。 Extract Interface（提炼接口）将相同的子集提炼到一个独立接口中。适用于：若干客户适用类接口中的同一子集，或者两个类的接口有部分相同。 Collapse Hierarchy（折叠继承体系）将它们合为一体。适用于：超类和子类之间无太大区别。 Form Template Method（塑造模板函数）将这些操作分别放进独立函数中，并保持它们都有相同的签名，于是原函数也就变得相同了。然后将原函数上移至超类。适用于：你有一些子类，其中相应的某些函数以相同顺序执行类似的操作，但各个操作的细节有所不同。 Replace Inheritance with Delegation（以委托取代继承）在子类中新建一个字段用以保存超类；调整子类函数，令它改而委托超类；然后去掉两者之间的继承关系。适用于：某个子类只适用超类接口中的一部分，或是根本不需要继承而来的数据。 Replace Delegation with Inheritance（以继承取代委托）让委托类继承受托类。适用于：你在两个类之间委托关系，并经常为整个接口编写许多极简单的委托函数。 重构方法-大型重构Tease Apart Inheritance（梳理并分解继承体系）建立两个继承体系，并通过委托关系让其中一个可以调用另一个。适用于：某个继承体系同时承担两项责任。 ConvertProcedural Design to Objects（将过程化设计转化为对象设计）将数据记录变成对象，将大块的行为分成小块，并将行为移入相关对象之中。适用于：你手上有一些传统过程化风格的代码。 Separate Domain from Presentation（将领域和表述/显示分离）将领域逻辑分离出来，为它们建立独立地领域类。适用于：某些GUI类之中包含了领域逻辑。 Extract Hierarchy（提炼继承体系）建立继承体系，以一个子类表示一种特殊情况。适用于：你有某个类做了太多工作，其中一部分工作是以大量表达式完成的。 代码的坏味道–及解决方案Duplicated Code（重复代码）Extract Method（提炼函数）Pull Up Method（函数上移到超类）Form Template Method（塑造模板函数）Substitute Algorithm（替换算法）Extract Class（提炼类） Long Method（过长函数）Extract Method（提炼函数）Replace Temp with Query（以查询取代临时变量）Introduce Parameter Object（引入参数对象）Preserve Whole Object（保持对象完整）Replace Method with Method Object（以函数对象取代函数）Decompose Conditional（分解条件表达式） Large Class（过大的类）Extract Class（提炼类）Extract Subclass（提炼子类）Extract Interface（提炼接口）Duplicate Observed Data（复制“被监视数据”） Long Parameter List（过长参数列）Replace Parameter with Method（用函数替换参数）Preserve Whole Object（保持对象完整）Introduce Parameter Object（引入参数对象） Divergent Change（发散式变化）Extract Class（提炼类） Shotgun Surgery（霰xian弹式修改）Move Method（移动函数）Move Field（移动字段）Inline Class（内联类） Feature Envy（依恋情结）Move Method（移动函数）Extract Method（提炼方法） Data Clumps（数据泥团）Extract Class（提炼类）Introduce Parameter Object（引入参数对象）Preserve Whole Object（保持整个对象） Primitive Obsession（基本类型偏执）Replace Data Value with Object（用对象替换数据值）Replace Type Code with Class（用类替换类型代码）Extract Class（提炼类）Introduce Parameter Object（引入参数对象）Replace Array with Object（用对象代替数组） Switch Statements（switch 惊悚现身）Extract Method（提炼函数）Move Method（移动函数）Replace Type Code with Subclass（以子类替换类型代码）Replace Type Code with State/Strategy（以State/Strategy取代类型码）Replace Conditional with Polymorphism（以多态取代条件表达式）Replace Parameter with Explicit Methods（以明确函数取代参数）Introduce Null Object（引入null对象） Parallel Inheritance Hierarchies（平行继承体系）Move Method（移动函数）Move Field（移动字段） Lazy Class（冗赘类）Collapse Hierarchy（折叠继承体系）Inline Class（内联类） Speculative Generality（夸夸其谈未来性）Collapse Hierarchy（折叠继承体系）Inline Class（内联类）Remove Parameter（移除参数）Rename Method（移除函数） Temporary Field（令人迷惑的暂时字段）Extract Class（提炼类）Introduce Null Object（引入Null对象） Message Chains（过渡耦合的消息链）Hide Delegate（隐藏“委托关系”）Extract Method（提炼函数）Move Method（移动函数） Middle Man（中间人）Remove Middle Man（中间人）Inline Method（内联方法）Replace Delegation with Inheritance（以继承取代委托） Inappropriate Intimacy（狎昵关系）–两个类过于亲密Move Method（移动函数）Move Field（移动字段）Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）Extract Class（提炼类）Hide Delegate（隐藏“委托关系”）Replace Inheritance with Delegation（以委托取代继承） Alternative Classes with Different Interfaces（异曲同工的类）Rename Method（重命名函数）Move Method（移动函数）Extract Superclass（提炼超类） Incomplete Library Class（不完美的库类）Move Method（移动函数）Intorduce Foreign Method（引入外加函数）Introduce Local Extension（引入本地扩展） Data Class（纯稚的数据类）Encapsulate Field（自封装字段）Encapsulate Collection（封装集合）Remove Setting Method（移除设置函数）Move Method（移除函数）Extract Method（提炼函数）Hide Method（隐藏函数） Refused Bequest（被拒绝的馈赠）Push Down Method（函数下移）–移动子类Push Down Field（字段下移）Replace Inheritance with Delegation（以委托取代继承） Comments（过多的注释）Rename Metho（重命名方法）Introduce Assertion（引入断言） 总结本文整理于《重构改善既有代码的设计》，这本书是用java写的，整理的目的是为了自己能写出更健壮、更具扩展性的代码，为以后的编码做参考。个人能力有限，如有理解不当还望指出，更深入的了解还请参阅次书籍。]]></content>
      <categories>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>代码重构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用手册]]></title>
    <url>%2F2018%2Fgit%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.html</url>
    <content type="text"><![CDATA[git基础知识git工作流你的本地仓库由 git 维护的三棵“树”组成。第一个是你的 工作目录，它持有实际文件；第二个是 暂存区（Index），它像个缓存区域，临时保存你的改动；最后是 HEAD，它指向你最后一次提交的结果。下图展示其关系 git配置用户信息Git是分布式版本控制系统，SVN都是集中式的版本控制系统（需要中央服务器）12git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot; PS：注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 版本相关创建版本库版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。1234mkdir dirname cd dirnamepwd // pwd命令用于显示当前目录(绝对路径)git init // 把这个目录变成Git可以管理的仓库 PS：目录名和文件名不可有中文 .git 文件就是Git来跟踪管理版本库，千万别手动更改。 如果没有.git 文件（系统隐藏关键文件），可以 ls -ah命令来查看 把文件添加到版本库第一步，用命令git add告诉Git，把文件添加到仓库：实际上就是把文件修改添加到暂存区12345git add fileNamegit add *.js // 通配符git add -u 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)git add . 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件git add -A 提交所有变化（是git add .和git add -u的结合，git add -all的简写） git add . ：他会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。git add -u ：（git add –update的缩写）他仅监控已经被add的文件（即tracked file），他会将被修改的文件提交到暂存区。2018-03-16更新PS：可以向git库多次添加文件，并一次提交第二步，用命令git commit告诉Git，把文件提交到仓库：实际上就是把暂存区的所有内容提交到当前分支（默认是master分支）git commit -m &quot;说明文本&quot;PS：-m后面输入的是本次提交的说明，方便以后查看更好的理解：需要提交的文件修改通过放到暂存区，然后，一次性提交暂存区的所有修改。git commit -am &#39;说明&#39;PS：git add 和 git commit的简写清屏reset + Enter该命令可以让我们时刻掌握仓库当前的状态（当前是否有需要提交的修改）git mv &lt;oldName&gt; &lt;nemeName&gt;PS：git mv 命令用于移动或重命名一个文件、目录、软连接。git statusPS：列出当前目录所有还没有被git管理的文件和 被git管理且被修改但还未提交（git commit）的文件。查看具体修改了什么内容12345678git diffgit diff HEAD -- fileName // 比对某个文件git diff &lt;source_branch&gt; &lt;target_branch&gt; 比对两个分支尚未缓存的改动：git diff查看已缓存的改动： git diff --cached查看已缓存的与未缓存的所有改动：git diff HEAD显示摘要而非整个 diff：git diff --stat PS：提交仓库前最好看一下，这是不是我们更改的。经过对比后，就可以放心的添加和提交文件了12git add fileNamegit commit -m &apos;note&apos; 版本回退该命令显示从最近到最远的提交日志1234567git log // 下面命令仅仅显示commit id（版本号），它是16进制数git log --oneline // 历史记录的简洁的版本git log --oneline --graph // 查看历史中什么时候出现了分支、合并git log --reverse --oneline // 逆向显示所有日志git log --author=fanerge // 查找指定用户的提交日志git log --oneline --before=&#123;3.weeks.ago&#125; --after=&#123;2010-04-18&#125; --no-merges // --since 和 --before，但是你也可以用 --until 和 --after 回到上一个版本12// 当前版本是HEAD，上一个版本就是HEAD^，上上一个版本就是HEAD^^，前100的版本HEAD~100git reset --hard HEAD^ // 回到上一个版本 回到未来的版本git reset --hard 版本号 // 版本号可以只写几位，git帮我们完善显示文件cat fileName如果忘记版本号想回到最新的版本怎么办？该命令可以查看到版本号git reflogPS：可以查看所有分支的所有操作记录（包括（包括commit和reset的操作），包括已经被删除的commit记录，git log则不能察看已经删除了的commit记录。 工作区和暂存区工作区（Working Directory）就是之前mkdir生产的目录，存放git项目的目录。 版本库（Repository）工作区有一个隐藏目录.git，这个就是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。PS：其实git add fileName命令就是讲对应的文件添加到暂存区 其实git commit 命令仅仅是将暂存区的东西提交到当前分支 管理修改Git跟踪并管理的是修改，而非文件。Git是如何跟踪修改的，每次修改，如果不add到暂存区，那就不会加入到commit中。 撤销修改把 fileName 文件在工作区的修改全部撤销，这里有三种情况： 一是 fileName 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 二是 fileName 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 三是 fileName 已经提交到本地版本库中，请使用 git reset –hard HEAD^总之，就是让这个文件回到最近一次git commit或git add时的状态。 处理方式： 尚未存在暂存区1git checkout -- fileName PS：git checkout -- fileName命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令。 已存在暂存区12git reset HEAD fileName git checkout -- fileName // 必须要使用第一点的方式 PS：git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。上面的四条命令在工作目录、暂存目录(也叫做索引)和仓库之间复制文件。 git add files 把当前文件放入暂存区域。 git commit 给暂存区域生成快照并提交。 git reset – files 用来撤销最后一次git add files，你也可以用git reset 撤销所有暂存区域文件。 git checkout – files 把文件从暂存区域复制到工作目录，用来丢弃本地修改。 删除文件直接右键或命令删除文件rm fileNamePS：此时，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了这是有两种处理方式： 真的想删除这个文件 12git rm fileName // git中删除对应文件git commit -m &apos;说明&apos; // 同步工作区和版本库 删错了，你想从版本库中恢复（无论工作区是修改还是删除，都可以“一键还原”）git checkout -- fieNamePS：命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 远程仓库设置ssh（以github举例）第1步：创建SSH Key。ssh-keygen -t rsa -C &quot;youremail@example.com&quot;如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa（私钥）和id_rsa.pub（公钥）两个文件第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：这里包括title和key字段 添加远程库git remote add origin git@github.com:fanerge/repositoryName.git把本地库与远程库进行关联（在本地库目录下进行）远程库的名字就是origin，这是Git默认的叫法git push -u origin master把本地库的所有内容推送到远程库上其实git push 是把当前分支如 master 推送到远程PS：由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。以后推送只需下面命令：git push origin master 从远程库克隆假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。 12345git clone git@github.com:fanerge/仓库名.git orgit clone &lt;repo&gt; &lt;directory&gt; // 克隆到指定的目录cd 仓库名ls PS：git支持多种协议 ssh、https等 分支管理你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 创建与合并分支当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上123456git checkout -b branchName git checkout命令加上-b参数表示创建并切换，相当于以下两条命令： git branch branchName // 创建分支 git checkout branchName // 切换到分支git branch 查看分支 PS：git branch 命令会列出所有分支，当前分支前面会标一个*号。1234git checkout master dev分支的工作完成，我们就可以切换回master分支git merge branchName git merge命令用于合并指定分支到当前分支（这里是将dev合并到master）。 PS：这个操作只能在主分支master上进行。 Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。 删除分支git branch -d branchName 解决冲突当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容。 假如 readme.txt 存在冲突。第一步：打开 readme.txt 文件手动处理冲突第二步：添加到暂存区 git add readme.txt第三步：提交到当前分支 git commit -m ‘说明’123git log --graph --pretty=oneline --abbrev-commit 用带参数的git log也可以看到分支的合并情况 用git log --graph命令可以看到分支合并图。 分支管理策略通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。1234567git checkout -b dev git add readme.txt git commit -m &quot;add merge&quot; git checkout master git merge --no-ff -m &quot;merge with no-ff&quot; dev 准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward。 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。 分支策略首先，master 分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；所有人都在 dev 分支上开发，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 Bug分支在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。使用场景，在开发过程中新接收到一个bug需要紧急处理。12git stash Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作 现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。12git checkout master git checkout -b issue-101 创建bug分支修复bug之后（提交修复bug相关的代码）12345git add readme.txt git commit -m &quot;fix bug 101&quot;git checkout mastergit merge --no-ff -m &quot;merged bug fix 101&quot; issue-101git branch -d issue-101 现在需要切换到原来分支继续开发123git checkout devgit statusgit stash list PS：工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：一种 git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除一种 git stash pop，恢复的同时把stash内容也删了PS：修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。 Feature分支添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。git branch -D branchName 强行删除一个没有合并的分支PS：开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D 强行删除。 多人协作当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。git remote 查看远程库的信息（origin）git remote -v 显示更详细的信息，显示了可以抓取（fetch）和推送（push）的origin的地址。如果没有推送权限，就看不到push的地址。 推送分支推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上git push origin master master 表示你要往远程那个分支推送PS：一般 master、dev 分支需要推送到远程库，其它分支不需要。 抓取分支git branch --set-upstream dev origin/dev 把本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接git fetchPS：相当于是从远程获取最新版本到本地，不会自动mergegit pullPS：相当于是从远程获取最新版本并merge到本地（git fetch + git merge） 把最新的提交从origin/dev抓下来（提交前需要拉取分支的最新代码）手动处理冲突12git commit -m &quot;说明&quot;git push origin dev 推送到远程dev分支 多人协作的工作模式的步骤： 首先，可以试图用git push origin branch-name推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ PS：如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name。 标签管理发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。 创建标签1234567891011121314151617git branchgit checkout master 切换到需要打标签的分支git tag tagName 打标签git tag -a tagName -a 选项意为&quot;创建一个带注解的标签&quot;（谁打的，什么时候打的）git tag 查看所有标签git tag tagName commitId 给特定版本号打标签git show tagName 查看标签信息git tag -a tagName -m &quot;说明&quot; commitId 创建带有说明的标签，用-a指定标签名，-m指定说明文字git tag -s tagName -m &quot;说明&quot; commitId 通过-s用私钥签名（PGP签名标签）一个标签 操作标签git tag -d tagName 如果标签打错了，也可以删除PS：因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。1234567git push origin tagName 推送某一个标签到远端git push origin --tags 推送全部尚未推送到远端的本地标签git tag -d tagName git push origin :refs/tags/tagName 如果标签已经推送到远程，先本地删除，再远程删除。 自定义Git12345678910111213git config --global user.name &quot;fanerge&quot;git config --global user.email fanerge@example.com 配置用户信息git config --global color.ui true 让Git显示颜色，会让命令输出看起来更醒目。git config --global core.editor notepad++ 配置文本编辑器git config --global merge.tool vimdiff 配置差异分析工具git config --list 查看全部配置信息git config configName 查看单个配置信息 忽略特殊文件创建一个特殊的.gitignore文件，把需要忽略的文件名填进去就可。 在这个目录的文件 所有配置文件可以直接在线浏览忽略文件的原则是： 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。有时需要向git添加文件，但又添加不上，需要检查.gitignore哪里写错了git check-ignore -v fileName暴力向git添加文件git add -f fileName // 不建议使用 配置别名配置Git的时候，加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。123git config --global alias.st status 为status 设置为 st 别名 git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot; 配置文件每个仓库的Git配置文件都放在.git/config文件中。cat .git/config 查看本仓库的配置 搭建Git服务器搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的apt命令就可以完成安装。具体步骤管理公钥管理权限 速记手册工作区：就是git版本管理的目录。暂存区（stage或index）：git add添加到暂存区当前分支：git commit将暂存区内容提交到当前分支常用注释前缀：issue、bug、feature、fix、 把这个目录变成Git可以管理的仓库 git init把文件添加到版本库（实际上就是把文件修改添加到暂存区） git add fileName git add *.js // 通配符 git add -u 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new) git add . 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件 git add -A 提交所有变化（是git add .和git add -u的结合，git add -all的简写）把文件提交到当前仓库（实际上就是把暂存区的所有内容提交到当前分支） git commit -m “本次提交注释” 当前版本设置（跳转版本，HEAD为当前版本的指针） git reset –hard HEAD^ // 回到上一个版本 git reset –hard HEAD~100 // 回到前100个版本 git reset –hard commitId // 回到commitId的版本 撤销操作 还没git add放入暂存区 git checkout – readme.txt 文件已经git add添加到暂存区（依次执行） git reset HEAD fileName.txt git checkout – readme.txt 文件已经提交到当前版本（版本回退） git reset HEAD^ 文件已经提交到远程库 无力回天查看当前仓库的状态 git status 删除文件 第一步： rm fileName.txt 第二步： git rm fileName.txt // 告诉git确实要删除 or git checkout – fileName.txt // 删错了想恢复文件 本地分支代码推送到远端 git push -u origin master // 这里本地代码推送到了master主干上了 git push origin master // 将当前分支推送到master分支分支操作（新需求，主要是为了不影响其他人开发） git branch // 查看所有分支（*表示当前分支） git branch Name // 新建分支 git checkout Name // 切换到分支 or git checkout -b Name // 新建并切换到分支 git branch -d Name // 删除Name分支 git branch -D Name // 强行删除Name分支（危险） git checkout -b branch-name origin/branch-name // 新建并切换并建立本地分支和远程分支的联系分支 git branch –set-upstream branch-name origin/branch-name // 设置本地的dev分支与远端的dev分支的链接 git push origin dev:dev // 提交本地dev分支作为远程的dev分支远程分支操作远程分支的新建和关联 新建并切换至dev分支 git checkout -b ‘dev’ 本地dev分支作用远程dev分支并推送至远端 git push origin dev:dev 当前分支关联远程分支（dev-&gt;origin/dev） git branch –set-upstream-to=origin/dev合并分支 git merge Name // 将Name分支合并到当前分支，直接把当前指向Name分支的当前提交（快进模式） // Git就会在merge时生成一个新的commit（仅一个） git merge –no-ff -m “部分注释” dev // 禁用Fast forward进行合并处理冲突 git pull // 拉最新代码，no tracking information表示本地分支和远程分支的链接关系没有创建 git branch –set-upstream dev origin/dev // 设置本地的dev分支与远端的dev分支的链接 储藏工作现场（用于临时处理bug但目前代码又不可提交的场景，等修复bug后再回来处理） git stash // 向储藏室添加工作现场，在其他分支上处理bug // 处理完bug，有回到之前的工作现场 git stash list // 查看所有储藏室的工作现场 // 恢复工作现场 git stash apply // 只恢复 git stash apply stash@{0} // 恢复某个工作现场 git stash drop // 从储藏室删除 or git stash pop关联远程库 git remote // 查看远程库的信息 git remote -v // 更详细的信息 git remote add origin git@server-name:path/repo-name.git从远程clone git clone git@github.com:fanerge/gitskills.git 标签管理 git tag // 为最新的commit打一个标签 git tag // 查看所有标签 git tag commitId // 为某次commitId打标签 git tag -a -m “blablabla…” // 可以指定标签信息 git tag -s -m “blablabla…” // 可以用PGP签名标签 git show // 查看说明文字 git tag -d // 删除某个标签 git push origin // 推送某个标签到远程 git push origin –tags // 一次性推送全部尚未推送到远程的本地标签 // 如果标签在远程要删除 git tag -d // 删除某个标签 git push origin :refs/tags/ // 删除一个远程标签 diff文件（difference） git diff fileName.txt git diff HEAD – readme.txt // 查看工作区和版本库里面最新版本的区别查看提交日志 git log git log –pretty=oneline // git log –graph // 查看分支合并图 git log –graph –pretty=oneline –abbrev-commit // 查看分支合并情况查看历史命令（用于回到未来版本） git relog 参考文档： git 手册 git官网 git - 简明指南 廖雪峰-git教程 Git 教程 Git fetch和git pull的区别 git reflog 图解git]]></content>
      <categories>
        <category>代码管理</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas开发参考手册]]></title>
    <url>%2F2018%2Fcanvas%E5%BC%80%E5%8F%91%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C.html</url>
    <content type="text"><![CDATA[介绍学完canvas的相关知识可以做一些小动画了最早由Apple引入WebKit，用于Mac OS X 的 Dashboard。canvas 是 HTML5 新增的元素，可用于通过使用JavaScript中的脚本来绘制图形。例如，它可以用于绘制图形，制作照片，创建动画，交互式游戏，甚至可以进行实时视频处理或渲染。 基本用法canvas 它是一个元素，当然具有元素通用的属性，如id、class等。 渲染上下文（The rendering context）canvas 元素创造了一个固定大小的画布，它公开了一个或多个渲染上下文，其可以用来绘制和处理要展示的内容。123// 获取渲染上下文let canvas = document.querySelector(&apos;#canvas&apos;)let ctx = canvas.getContext(&apos;2d&apos;) 检查支持性12345if (canvas.getContext) &#123; // 支持&#125; else &#123; // 不支持&#125; 绘制形状矩形fillRect(x, y, width, height) 绘制一个填充的矩形strokeRect(x, y, width, height) 绘制一个矩形的边框clearRect(x, y, width, height) 清除指定矩形区域，让清除部分完全透明。 常用于清理画布。 路径图形的基本元素是路径。路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。 首先，你需要创建路径起始点。 然后你使用画图命令去画出路径。 之后你把路径封闭。 一旦路径生成，你就能通过描边或填充路径区域来渲染图形。beginPath()新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。closePath()闭合路径之后图形绘制命令又重新指向到上下文中。stroke() – 轮廓通过线条来绘制图形轮廓。fill() – 整体通过填充路径的内容区域生成实心的图形。PS：fill会自动闭合儿stroke不会。moveTo(x, y) – 移动笔触将笔触移动到指定的坐标x以及y上。当canvas初始化或者beginPath()调用后，你通常会使用moveTo()函数设置起点。我们也能够使用moveTo()绘制一些不连续的路径lineTo(x, y) – 直线绘制一条从当前位置到指定x以及y位置的直线。arc(x, y, radius, startAngle, endAngle, anticlockwise) – 圆弧画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针）来生成。arcTo(x1, y1, x2, y2, radius)根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点。PS：角度是以x轴为基准且为弧度，转化公式：radians=(Math.PI/180)*degreesquadraticCurveTo(cp1x, cp1y, x, y) – 二次贝塞尔曲线绘制二次贝塞尔曲线，cp1x,cp1y为一个控制点，x,y为结束点。bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) – 三次贝塞尔曲线绘制三次贝塞尔曲线，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点。PS：贝塞尔曲线都会以开始路径作为起点，实际上二次贝塞尔曲线由3个点控制，N次贝塞尔曲线由n+1个点控制。wiki-贝塞尔曲线绘制矩形的额外方法rect(x, y, width, height)绘制一个左上角坐标为（x,y），宽高为width以及height的矩形。 Path2D 对象为了简化代码和提高性能，Path2D对象已可以在较新版本的浏览器中使用，用来缓存或记录绘画命令，这样你将能快速地回顾路径。Path2D()Path2D()会返回一个新初始化的Path2D对象（可能将某一个路径作为变量——创建一个它的副本，或者将一个包含SVG path数据的字符串作为变量）。Path2D.addPath(path [, transform])​添加了一条路径到当前路径（可能添加了一个变换矩阵）。12// 使用 SVG pathsvar p = new Path2D(&quot;M10 10 h 80 v 80 h -80 Z&quot;); 使用样式和颜色色彩 ColorsfillStyle = color 设置图形的填充颜色。strokeStyle = color 设置图形轮廓的颜色。PS：orange、#ffa500、rgb(255, 165, 0)、rgba(255, 165, 0, 1)、hsl(360, 50%, 50%)、hsla(360, 50%, 50%, 1) 透明度 TransparencyglobalAlpha = transparencyValue 这个属性影响到 canvas 里所有图形的透明度，有效的值范围是 0.0 （完全透明）到 1.0（完全不透明），默认是 1.0。ctx.strokeStyle = “rgba(255,0,0,0.5)”;ctx.fillStyle = “rgba(255,0,0,0.5)”; 线型 Line styles可以通过一系列属性来设置线的样式。lineWidth = value 设置线条宽度。 线宽是指给定路径的中心到两边距离之和的粗细。换句话说就是在路径的两边各绘制线宽的一半。lineCap = type 设置线条末端样式。 butt，round 和 square。 默认是 butt。lineJoin = type 设定线条与线条间接合处的样式。 round, bevel 和 miter。 默认是 miter。miterLimit = value 限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度。getLineDash() 返回一个包含当前虚线样式，长度为非负偶数的数组。 [a, b] a表示实线，b表示空白，这样交替出现。setLineDash(segments) 设置当前虚线样式。lineDashOffset = value 设置虚线样式的起始偏移量。 渐变 Gradients（新建的渐变对象）线性渐变let lineargradient = createLinearGradient(x1, y1, x2, y2) createLinearGradient 方法接受 4 个参数，表示渐变的起点 (x1,y1) 与终点 (x2,y2)。 径向渐变let radialgradient = createRadialGradient(x1, y1, r1, x2, y2, r2) createRadialGradient 方法接受 6 个参数，前三个定义一个以 (x1,y1) 为原点，半径为 r1 的圆，后三个参数则定义另一个以 (x2,y2) 为原点，半径为 r2 的圆。gradient.addColorStop(position, color) addColorStop 方法接受 2 个参数，position 参数必须是一个 0.0 与 1.0 之间的数值，表示渐变中颜色所在的相对位置。例如，0.5 表示颜色会出现在正中间。color 参数必须是一个有效的 CSS 颜色值（如 #FFF， rgba(0,0,0,1)，等等）。 图案样式 PatternscreatePattern(image, type) 该方法接受两个参数。Image 可以是一个 Image 对象的引用，或者另一个 canvas 对象。Type 必须是下面的字符串值之一：repeat，repeat-x，repeat-y 和 no-repeat。 你需要确认 image 对象已经装载(onload)完毕，否则图案可能效果不对的。 阴影 ShadowsshadowOffsetX = float shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。shadowOffsetY = float shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。shadowBlur = float shadowBlur 用于设定阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响，默认为 0。shadowColor = color shadowColor 是标准的 CSS 颜色值，用于设定阴影颜色效果，默认是全透明的黑色。 Canvas 填充规则当我们用到 fill（或者 clip和isPointinPath ）你可以选择一个填充规则，该填充规则根据某处在路径的外面或者里面来决定该处是否被填充，这对于自己与自己路径相交或者路径被嵌套的时候是有用的。“nonzero”: 默认值.“evenodd” 绘制文本canvas 提供了两种方法来渲染文本:fillText(text, x, y [, maxWidth]) 在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的.strokeText(text, x, y [, maxWidth]) 在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的. 有样式的文本font = value 当前我们用来绘制文本的样式. 这个字符串使用和 CSS font 属性相同的语法. 默认的字体是 10px sans-serif。textAlign = value 文本对齐选项. 可选的值包括：start, end, left, right or center. 默认值是 start。textBaseline = value 基线对齐选项. 可选的值包括：top, hanging, middle, alphabetic, ideographic, bottom。默认值是 alphabetic。direction = value 文本方向。可能的值包括：ltr, rtl, inherit。默认值是 inherit。 先进的文本测量当你需要获得更多的文本细节时，下面的方法可以给你测量文本的方法。measureText() 将返回一个 TextMetrics对象的宽度、所在像素，这些体现文本特性的属性。var text = ctx.measureText(&quot;foo&quot;); // TextMetrics object text.width; // 16; 使用图像 Using imagescanvas更有意思的一项特性就是图像操作能力。可以用于动态的图像合成或者作为图形的背景，以及游戏界面（Sprites）等等。引入图像到canvas里需要以下两步基本操作： 获得一个指向HTMLImageElement的对象或者另一个canvas元素的引用作为源，也可以通过提供一个URL的方式来使用图片（参见例子） 使用drawImage()函数将图片绘制到画布上获得需要绘制的图片HTMLImageElement这些图片是由Image()函数构造出来的，或者任何的元素HTMLVideoElement用一个HTML的 元素作为你的图片源，可以从视频中抓取当前帧作为一个图像HTMLCanvasElement可以使用另一个 元素作为你的图片源。ImageBitmap这是一个高性能的位图，可以低延迟地绘制，它可以从上述的所有源以及其它几种源中生成。PS：这些源统一由 CanvasImageSource类型来引用。 使用相同页面内的图片document.images集合document.getElementsByTagName()方法document.getElementById()获得这个图片 使用其它域名下的图片在 HTMLImageElement上使用crossOrigin属性，你可以请求加载其它域名上的图片。 由零开始创建图像（需要onload保证图片加载完毕）var img = new Image(); // 创建一个&lt;img&gt;元素 img.src = &#39;myImage.png&#39;; // 设置图片源地址 通过 data: url 方式嵌入图像img.src = &#39;data:image/gif;base64,...&#39; 使用视频帧return document.getElementById(&#39;myvideo&#39;); 绘制图片drawImage(image, x, y)其中 image 是 image 或者 canvas 对象，x 和 y 是其在目标 canvas 里的起始坐标。 缩放 ScalingdrawImage(image, x, y, width, height)这个方法多了2个参数：width 和 height，这两个参数用来控制 当向canvas画入时应该缩放的大小切片 SlicingdrawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)第一个参数和其它的是相同的，都是一个图像或者另一个 canvas 的引用。其它8个参数最好是参照右边的图解，前4个是定义图像源的切片位置和大小，后4个则是定义切片的目标显示位置和大小。 控制图像的缩放行为 Controlling image scaling behaviorGecko 1.9.2 引入了 mozImageSmoothingEnabled 属性，值为 false 时，图像不会平滑地缩放。默认是 true 。cx.mozImageSmoothingEnabled = false;变形 Transformations状态的保存和恢复 Saving and restoring statesave()restore()save 和 restore 方法是用来保存和恢复 canvas 状态的，都没有参数。Canvas 的状态就是当前画面应用的所有样式和变形的一个快照。PS：Canvas状态存储在栈中，每当save()方法被调用后，当前的状态就被推送到栈中保存。 绘画状态包括：当前应用的变形（即移动，旋转和缩放，见下）strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation 的值当前的裁切路径（clipping path）移动 Translating我们先介绍 translate 方法，它用来移动 canvas 和它的原点到一个不同的位置。translate(x, y)translate 方法接受两个参数。x 是左右偏移量，y 是上下偏移量，如右图所示。PS：在做变形之前先保存状态是一个良好的习惯。在绘制螺旋（spirograph）图案，如果不使用 translate 方法，那么只能看见其中的四分之一。旋转 Rotating它用于以原点为中心旋转 canvas。rotate(angle)这个方法只接受一个参数：旋转的角度(angle)，它是顺时针方向的，以弧度为单位的值。旋转的中心点始终是 canvas 的原点，如果要改变它，我们需要用到 translate 方法。缩放 Scaling我们用它来增减图形在 canvas 中的像素数目，对形状，位图进行缩小或者放大。scale(x, y)scale 方法接受两个参数。x,y 分别是横轴和纵轴的缩放因子，它们都必须是正值。值比 1.0 小表示缩小，比 1.0 大则表示放大，值为 1.0 时什么效果都没有。PS：默认情况下，canvas 的 1 单位就是 1 个像素。举例说，如果我们设置缩放因子是 0.5，1 个单位就变成对应 0.5 个像素，这样绘制出来的形状就会是原先的一半。变形 Transforms允许对变形矩阵直接修改。transform(m11, m12, m21, m22, dx, dy)这个方法是将当前的变形矩阵乘上一个基于自身参数的矩阵，在这里我们用下面的矩阵：m11 m21 dx m12 m22 dy 0 0 1m11：水平方向的缩放m12：水平方向的偏移m21：竖直方向的偏移m22：竖直方向的缩放dx：水平方向的移动dy：竖直方向的移动setTransform(m11, m12, m21, m22, dx, dy)这个方法会将当前的变形矩阵重置为单位矩阵，然后用相同的参数调用 transform 方法。从根本上来说，该方法是取消了当前变形,然后设置为指定的变形,一步完成。resetTransform()重置当前变形为单位矩阵，它和调用以下语句是一样的：ctx.setTransform(1, 0, 0, 1, 0, 0);组合 Compositing对合成的图形来说，绘制顺序会有限制。不过，我们可以利用 globalCompositeOperation 属性来改变这种状况。此外, clip属性允许我们隐藏不想看到的部分图形. globalCompositeOperationglobalCompositeOperation = type这个属性设定了在画新图形时采用的遮盖策略，其值是一个标识12种遮盖方式的字符串。具体type值1234567891011source-over 默认。在目标图像上显示源图像。source-atop 在目标图像顶部显示源图像。源图像位于目标图像之外的部分是不可见的。source-in 在目标图像中显示源图像。只有目标图像内的源图像部分会显示，目标图像是透明的。source-out 在目标图像之外显示源图像。只会显示目标图像之外源图像部分，目标图像是透明的。destination-over 在源图像上方显示目标图像。destination-atop 在源图像顶部显示目标图像。源图像之外的目标图像部分不会被显示。destination-in 在源图像中显示目标图像。只有源图像内的目标图像部分会被显示，源图像是透明的。destination-out 在源图像外显示目标图像。只有源图像外的目标图像部分会被显示，源图像是透明的。lighter 显示源图像 + 目标图像。copy 显示源图像。忽略目标图像。xor 使用异或操作对源图像与目标图像进行组合。 裁切路径 Clipping paths裁切路径和普通的 canvas 图形差不多，不同的是它的作用是遮罩，用来隐藏不需要的部分。clip() 来创建一个新的裁切路径。 默认情况下，canvas 有一个与它自身一样大的裁切路径（也就是没有裁切效果）。 基本的动画如果需要移动Canvas中的shape，我们不得不对所有东西（包括之前的）进行重绘。重绘是相当费时的，而且性能很依赖于电脑的速度。 动画的基本步骤1.清空 canvas 除非接下来要画的内容会完全充满 canvas （例如背景图），否则你需要清空所有。最简单的做法就是用 clearRect 方法。2.保存 canvas 状态 如果你要改变一些会改变 canvas 状态的设置（样式，变形之类的），又要在每画一帧之时都是原始状态的话，你需要先保存一下。3.绘制动画图形（animated shapes） 这一步才是重绘动画帧。4.恢复 canvas 状态 如果已经保存了 canvas 的状态，可以先恢复它，然后重绘下一帧。 操控动画 Controlling an animation为了实现动画，我们需要一些可以定时执行重绘的方法。 有安排的更新画布 Scheduled updateswindow.setInterval(), window.setTimeout(),和window.requestAnimationFrame()来设定定期执行一个指定函数。requestAnimationFrame(callback) 方法告诉浏览器您希望执行动画并请求浏览器调用指定的函数在下一次重绘之前更新动画。 该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。window.cancelAnimationFrame(ID) 以取消回调函数。 高级动画添加速率window.requestAnimationFrame(callback) 该方式帮助我们控制动画。ctx.clearRect(0,0, canvas.width, canvas.height) 在callback前面调用清除画布。 设置边界物体碰到边缘，反弹回来，将速度更换方向即可。if (ball.y + ball.vy &gt; canvas.height || ball.y + ball.vy &lt; 0 ) { ball.vy = -ball.vy; }PS：这里对垂直方向上分析，水平方向类似。小球的y坐标+小球y的速度大于canvas的高度（下边缘）或者小球的y坐标+小球y的速度小于0（上边缘）反向 添加加速度ball.vy *= .99; ball.vy += .25; 长尾效果用一个半透明的 fillRect 函数取代之，就可轻松制作长尾效果。ctx.fillStyle = &#39;rgba(255,255,255,0.3)&#39;; ctx.fillRect(0,0,canvas.width,canvas.height); 添加鼠标控制为canvas元素添加 mousemove、 mouseout、click等事件，在通过 canvas 的 shape 来进行精确控制 像素操作可以直接通过ImageData对象操纵像素数据，直接读取或将数据数组写入该对象中。 ImageData 对象ImageData对象中存储着canvas对象真实的像素数据，它包含以下几个只读属性：width 图片宽度，单位是像素height 图片高度，单位是像素data Uint8ClampedArray类型的一维数组，包含着RGBA格式的整型数据，范围在0至255之间（包括255）。 每一个像素又数组4为组成，分别对应r、g、b、a 创建一个ImageData对象去创建一个新的，空白的ImageData对象，你应该会使用createImageData() 方法。有2个版本的createImageData()方法。var myImageData = ctx.createImageData(width, height); 上面代码创建了一个新的具体特定尺寸的ImageData对象。所有像素被预设为透明黑。var myImageData = ctx.createImageData(anotherImageData); 你也可以创建一个被anotherImageData对象指定的相同像素的ImageData对象。这个新的对象像素全部被预设为透明黑。这个并非复制了图片数据。 得到场景像素数据为了获得一个包含画布场景像素数据的ImageData对像，你可以用getImageData()方法：var myImageData = ctx.getImageData(left, top, width, height); 这个方法会返回一个ImageData对象，它代表了画布区域的对象数据，此画布的四个角落分别表示为(left, top), (left + width, top), (left, top + height), 以及(left + width, top + height)四个点。这些坐标点被设定为画布坐标空间元素。 在场景中写入像素数据你可以用putImageData()方法去对场景进行像素数据的写入。ctx.putImageData(myImageData, dx, dy); dx和dy参数表示你希望在场景内左上角绘制的像素数据所得到的设备坐标。 缩放和反锯齿在drawImage() 方法， 第二个画布和imageSmoothingEnabled 属性的帮助下，我们可以放大显示我们的图片及看到详情内容。因为反锯齿默认是启用的，我们可能想要关闭它以看到清楚的像素。禁用反锯齿ctx.imageSmoothingEnabled = false; ctx.mozImageSmoothingEnabled = true; ctx.webkitImageSmoothingEnabled = true; ctx.msImageSmoothingEnabled = true; 保存图片HTMLCanvasElement 提供一个toDataURL()方法，此方法在保存图片的时候非常有用。它返回一个包含被类型参数规定的图像表现格式的数据链接。返回的图片分辨率是96dpi。canvas.toDataURL(‘image/png’) 默认设定。创建一个PNG图片。canvas.toDataURL(‘image/jpeg’, quality) 创建一个JPG图片。你可以有选择地提供从0到1的品质量，1表示最好品质，0基本不被辨析但有比较小的文件大小。canvas.toBlob(callback, type, encoderOptions) 这个创建了一个在画布中的代表图片的Blob对像。PS：这里是canvas对象上的方法，而不是画布上下文对象的方法。 点击区域和无障碍访问canvas 标签只是一个位图，它并不提供任何已经绘制在上面的对象的信息。 内容兼容1&lt;canvas&gt; ... &lt;/canvas&gt;标签里的内容被可以对一些不支持canvas的浏览器提供兼容。 ARIA 规则Accessible Rich Internet Applications (ARIA) 定义了让Web内容和Web应用更容易被有身体缺陷的人获取的办法。你可以用ARIA属性来描述canvas元素的行为和存在目的 点击区域（hit region）判断鼠标坐标是否在canvas上一个特定区域里一直是个有待解决的问题。hit region API让你可以在canvas上定义一个区域，这让无障碍工具获取canvas上的交互内容成为可能。它能让你更容易地进行点击点击检测并把事件转发到DOM元素去。这个API有以下三个方法（都是实验性特性，请先在浏览器兼容表上确认再使用）。CanvasRenderingContext2D.addHitRegion() 在canvas上添加一个点击区域。 ctx.addHitRegion({control: element}); addHitRegion()方法也可以带一个control选项来指定把事件转发到哪个元素上（canvas里的元素）。ctx.removeHitRegion() 从canvas上移除指定id的点击区域。ctx.clearHitRegions() 移除canvas上的所有点击区域。PS：实验性方法，浏览器暂不支持 焦点圈当用键盘控制时，焦点圈是一个能帮我们在页面上快速导航的标记。要在canvas上绘制焦点圈，可以使用drawFocusIfNeeded 属性。ctx.drawFocusIfNeeded() 如果给定的元素获得了焦点，这个方法会沿着在当前的路径画个焦点圈。ctx.scrollPathIntoView() 把当前的路径或者一个给定的路径滚动到显示区域内。 scrollPathIntoView()方法可以让一个元素获得焦点的时候在屏幕上可见(滚动到元素所在的区域)。 canvas的优化性能贴士下面是一些改善性能的建议 在离屏canvas上预渲染相似的图形或重复的对象 12345myEntity.offscreenCanvas = document.createElement(&quot;canvas&quot;);myEntity.offscreenCanvas.width = myEntity.width;myEntity.offscreenCanvas.height = myEntity.height;myEntity.offscreenContext = myEntity.offscreenCanvas.getContext(&quot;2d&quot;);myEntity.render(myEntity.offscreenContext); 避免浮点数的坐标点，用整数取而代之 123当你画一个没有整数坐标点的对象时会发生子像素渲染。ctx.drawImage(myImage, 0.3, 0.5);浏览器为了达到抗锯齿的效果会做额外的运算。为了避免这种情况，请保证在你调用drawImage()函数时，用Math.floor()函数对所有的坐标点取整。 不要在用drawImage时缩放图像（多个 canvas 元素）在离屏canvas中缓存图片的不同尺寸，而不要用drawImage()去缩放它们。 使用多层画布去画一个复杂的场景你可能会发现，你有些元素不断地改变或者移动，而其它的元素，例如外观，永远不变。这种情况的一种优化是去用多个画布元素去创建不同层次。 用CSS设置大的背景图如果像大多数游戏那样，你有一张静态的背景图，用一个静态的元素，结合background 特性，以及将它置于画布元素之后。这么做可以避免在每一帧在画布上绘制大图。 用CSS transforms特性缩放画布CSS transforms 特性由于调用GPU，因此更快捷。最好的情况是，不要将小画布放大，而是去将大画布缩小。 使用moz-opaque属性(仅限Gecko)如果你的游戏使用画布而且不需要透明，请在画布上设置moz-opaque属性。这能够用于内部渲染优化。1&lt;canvas id=&quot;mycanvas&quot; moz-opaque&gt;&lt;/canvas&gt; 其他优化将画布的函数调用集合到一起（例如，画一条折线，而不要画多条分开的直线）避免不必要的画布状态改变渲染画布中的不同点，而非整个新状态尽可能避免 shadowBlur特性尽可能避免text rendering使用不同的办法去清除画布(clearRect() vs. fillRect() vs. 调整canvas大小)有动画，请使用window.requestAnimationFrame() 而非window.setInterval()请谨慎使用大型物理库用JSPerf测试性能demo地址这里向大家推荐一下阿里开源的数据可视化库antV（g2、g6、f2） 参考文档： MDN-canvas教程 廖雪峰老师的Canvas MDN-canvas标签 Canvas 的基本原理 HTML5画布(CANVAS)速查简表]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端总结]]></title>
    <url>%2F2017%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[css部分meta标签viewport&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,user-scalable=no&quot;/&gt; width：控制 viewport 的大小，可以指定的一个值，如 600，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）。 height：和 width 相对应，指定高度。 initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。 maximum-scale：允许用户缩放到的最大比例。 minimum-scale：允许用户缩放到的最小比例。 user-scalable：用户是否可以手动缩放。 IOS中safari允许全屏浏览1234567891011121314151617181920212223&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;&lt;meta name=&quot;apple-touch-fullscreen&quot; content=&quot;yes&quot; /&gt;``` ### IOS中Safari顶端状态条样式`&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt;`PS：如果要去除全部的，就把default ：状态栏背景是白色。black ：状态栏背景是黑色。black-translucent ：状态栏背景是半透明。 如果设置为 default 或 black ,网页内容从状态栏底部开始。如果设置为 black-translucent ,网页内容充满整个屏幕，顶部会被状态栏遮挡。### 忽略将数字变为电话号码`&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;`### 忽略识别email`&lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot; &gt;`### 添加到主屏后的标题（IOS）`&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt;`### 百度禁止转码`&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt;`### 优先使用最新版本 IE 和 Chrome`&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;`### 设置缓存`&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache&quot; /&gt;`## 小技巧### select 下拉选择设置右对齐 select option { direction: rtl;}123### 消除 IE10 里面的那个叉号`input:-ms-clear&#123;display:none;&#125;`### 关于 iOS 与 OS X 端字体的优化(横竖屏会出现字体加粗不一致等) -webkit-text-size-adjust: 100%;-ms-text-size-adjust: 100%;text-size-adjust: 100%;123456### 关于 iOS 系统中，中文输入法输入英文时，字母之间可能会出现一个六分之一空格可以通过正则去掉`this.value = this.value.replace(/\u2006/g, &apos;&apos;);`### 移动端 HTML5 input date 不支持 placeholder 问题`&lt;input placeholder=&quot;Date&quot; class=&quot;textbox-n&quot; type=&quot;text&quot; onfocus=&quot;(this.type=&apos;date&apos;)&quot; id=&quot;date&quot;&gt;`### 部分机型存在type为search的input，自带close按钮样式修改方法 #Search::-webkit-search-cancel-button{ display: none;}1### 开启电话功能和短信和发邮件 123456123456&lt;a mailto:dooyoe@gmail.com”&gt;dooyoe@gmail.com123456789### IOS Web app启动动画&lt;link href=&quot;apple-touch-startup-image-320x460.png&quot; media=&quot;(device-width: 320px)&quot; rel=&quot;apple-touch-startup-image&quot;&gt;&lt;link href=&quot;apple-touch-startup-image-640x960.png&quot; media=&quot;(device-width: 320px) and (-webkit-device-pixel-ratio: 2)&quot; rel=&quot;apple-touch-startup-image&quot;&gt;&lt;link href=&quot;apple-touch-startup-image-768x1004.png&quot; media=&quot;(device-width: 768px) and (orientation: portrait)&quot; rel=&quot;apple-touch-startup-image&quot;&gt;&lt;link href=&quot;apple-touch-startup-image-748x1024.png&quot; media=&quot;(device-width: 768px) and (orientation: landscape)&quot; rel=&quot;apple-touch-startup-image&quot;&gt;&lt;link href=&quot;apple-touch-startup-image-1536x2008.png&quot; media=&quot;(device-width: 1536px) and (orientation: portrait) and (-webkit-device-pixel-ratio: 2)&quot; rel=&quot;apple-touch-startup-image&quot;&gt;&lt;link href=&quot;apple-touch-startup-image-2048x1496.png&quot; media=&quot;(device-width: 1536px) and (orientation: landscape) and (-webkit-device-pixel-ratio: 2)&quot; rel=&quot;apple-touch-startup-image&quot;&gt;（landscape：横屏 | portrait：竖屏）### 添加到主屏后的APP图标 1### 去除webkit的滚动条 element::-webkit-scrollbar{ display: none;}123456PS：如果要去除全部的，就把 element去掉。 添加这个属性滚动如丝般顺滑： -webkit-overflow-scrolling : touch;### 去除button在ios上的默认样式``` -webkit-appearance: none;border-radius: 0; 长时间按住页面出现闪退123element &#123; -webkit-touch-callout: none;&#125; Retina屏的1px边框123element&#123; border-width: thin;&#125; transition闪屏1234/设置内嵌的元素在 3D 空间如何呈现：保留3D /-webkit-transform-style: preserve-3d;/ 设置进行转换的元素的背面在面对用户时是否可见：隐藏 /-webkit-backface-visibility:hidden; 旋转屏幕时，字体大小调整的问题123html, body, form, fieldset, p, div, h1, h2, h3, h4, h5, h6 &#123; -webkit-text-size-adjust:100%;&#125; placeholder元素样式的修改12input::-webkit-input-placeholder&#123;color:red;&#125;input:focus::-webkit-input-placeholder&#123;color:green;&#125; 不想让按钮 touch时有蓝色的边框或半透明灰色遮罩对于a,button,input,textarea-webkit-tap-highlight-color:rgba(0,0,0,0); 移动端做动画效果采用css3transition、transform（scale、translate、rotate、skew）或者 animation动画尽量少用margin、top等集合属性，因为这样会触发浏览器重排（reflow） 使用图片时去除图片下4px的空白12img&#123;display:block&#125;；img&#123;vertical-align:top&#125; 如何禁止保存或拷贝图像（IOS）img { -webkit-touch-callout: none; } 手机拍照和上传图片1234&lt;!-- 选择照片 --&gt; &lt;input type=file accept=&quot;image/*&quot;&gt; &lt;!-- 选择视频 --&gt; &lt;input type=file accept=&quot;video/*&quot;&gt; 弹性盒子的过渡123display:-webkit-box; // 早期的版本display:-webkit-box-flex; // 过渡版本display:-webkit-flex; // 最新的版本 禁止用户选中文字-webkit-user-select:none; 定义新的盒模型box-sizing:border-box css权重（逐次降低）style--1000 !important id--100 class--10 标签--1 使用rem1234567891011html &#123; font-size: 625%; // 相当于 12px *6.25 = 100px&#125;以后的元素的width、height、padding等集合属性都可以用rem来表示。``` ### 移动端字体`font-family: Helvetica,sans-serif;`### iphone原生键盘统计字数时在 iphone原生键盘上用 keyup统计字符数时，系统不会自动监控你选择文字的事件，应该使用input事件。### 毛玻璃效果实现毛玻璃效果，透过背景看其他元素模糊，自身元素不模糊。 -webkit-backdrop-filter: saturate(180%) blur(20px);background: rgba(0,0,0,0.5);123### 需要展示小于12px的文字`transform:scale(%);`### 禁止IOS弹出各种操作窗口及关闭自动大写与自动修正 -webkit-touch-callout:none 12345678910111213141516171819202122232425### Andriod 上去掉语音输入按钮`input::-webkit-input-speech-button &#123;display: none&#125;`# js部分## 移动端事件click事件有300ms的延迟### 触摸事件touch类事件touchstart：手指触摸到屏幕会触发touchmove：当手指在屏幕上移动时，会触发touchend：当手指离开屏幕时，会触发touchcancel：可由系统进行的触发，比如手指触摸屏幕的时候，突然alert了一下，或者系统中其他打断了touch的行为，则可以触发该事件### 敲击事件tap类事件tap: 手指碰一下屏幕会触发longTap: 手指长按屏幕会触发singleTap: 手指碰一下屏幕会触发doubleTap: 手指双击屏幕会触发### swipe类事件swipe：手指在屏幕上滑动时会触发swipeLeft：手指在屏幕上向左滑动时会触发swipeRight：手指在屏幕上向右滑动时会触发swipeUp：手指在屏幕上向上滑动时会触发swipeDown：手指在屏幕上向下滑动时会触发### 旋转屏幕事件`onorientationchange` ### audio、video默认播放事件window.onload或计时器等都不能触发播放，必须用 JS写事件让用户手动点击触发才会开始播放 $(document).one(‘touchstart’,function(){ audio.play();})``` 移动事件三方库Hammer.JSFastClick 参考文档： 移动端前端常见的触摸相关事件touch、tap、swipe等整理 web前端 —— 移动端知识的一些总结 移动端事件介绍 移动端web开发技巧 瀑布流框架 倾力总结40条常见的移动端Web页面问题解决方案]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础知识学习]]></title>
    <url>%2F2017%2Fjava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[常用指令介绍javac HelloWorld.java – 该命令用于将 java 源文件编译为 class 字节码文件，如： javac HelloWorld.java。如果成功编译没有错误的话，会出现一个 HelloWorld.class 的文件。java HelloWorld – java 后面跟着的是java文件中的类名,例如 HelloWorld 就是类名，如: java HelloWorld。 配置环境变量JAVA_HOME：JDK安装在C:\jdk1.6.0目录里，则设置JAVA_HOME为该目录路径, 那么以后要使用这个路径的时候, 只需输入%JAVA_HOME%即可, 避免每次引用都输入很长的路径串path 变量：path 变量使得我们能够在系统中的任何地方运行java应用程序，比如 javac、java、javah 等等,这就要找到我们安装 JDK 的目录，假设我们的JDK安装在 C:\jdk1.6.0 目录下,那么在 C:\jdk1.6.0\bin 目录下就是我们常用的 java 应用程序,我们就需要把 C:\jdk1.6.0\bin 这个目录加到 path 环境变量里面。classpath 变量：classpath 环境变量，是当我们在开发java程序时需要引用别人写好的类时，要让 java 解释器知道到哪里去找这个类。通常，sun 为我们提供了一些额外的丰富的类包，一个是 dt.jar，一个是 tools.jar，这两个 jar 包都位于 C:\jdk1.6.0\lib 目录下，所以通常我们都会把这两个 jar 包加到我们的 classpath 环境变量中 set classpath=.;C:\jdk1.6.0\lib\tools.jar;C:\jdk1.6.0\lib\dt.jar。 Java 基础语法一个Java程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。 基本概念类：类是一个模板，它描述一类对象的行为和状态。对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。 基本语法大小写敏感：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。类名：对于所有的类来说，都使用大驼峰。方法名：所有的方法名都应该使用小驼峰。源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。主方法入口：所有的Java 程序由public static void main(String []args)方法开始执行。 Java标识符Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。跟其他语言类似。 Java修饰符Java可以使用修饰符来修饰类中方法和属性。访问控制修饰符 : default, public , protected, private非访问控制修饰符 : final, abstract, strictfp Java变量局部变量类变量（静态变量）成员变量（非静态变量） Java数组数组是储存在堆上的对象，可以保存多个同类型变量。这里有别于js的数组，同类型限制。 Java枚举枚举限制变量只能是预先设定好的值。例如，我们为果汁店设计一个程序，它将限制果汁为小杯、中杯、大杯。这就意味着它不允许顾客点除了这三种尺寸外的果汁。 Java关键字这些保留字不能用于常量、变量、和任何标识符的名称。跟其他语言类似。 Java注释单行 //多行 /**/ 继承如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类。被继承的类称为超类（super class），派生类称为子类（subclass）。 接口在Java中，接口可理解为对象间相互通信的协议。接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。 Java 对象和类对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。类：类是一个模板，它描述一类对象的行为和状态。 Java中的类123456789101112131415161718192021222324252627public class Dog&#123; String breed; // 成员变量 int age; String color; // 构造方法 public Dog(String name)&#123; // 这个构造器仅有一个参数：name &#125; // 入口函数 public static void main(String []args)&#123; // 下面的语句将创建一个Dog对象 Dog myDog = new Dog( &quot;tommy&quot; ); &#125; Static demo; // 类变量 void barking()&#123; &#125; void hungry()&#123; String dd; // 局部变量 &#125; void sleeping()&#123; &#125;&#125; 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。成员变量：成员变量是定义在类中，方法体之外的变量。类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。 构造方法构造方法的名称必须与类同名，一个类可以有多个构造方法。 123public Dog(String name)&#123; // 这个构造器仅有一个参数：name&#125; 访问实例变量和方法12345muDog = new Dog();/* 访问类中的变量 */muDog.breed;/* 访问类中的方法 */muDog.hungry(); 源文件声明规则当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则。 一个源文件中只能有一个public类 一个源文件可以有多个非public类 源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java。 如果一个类定义在某个包中，那么package语句应该在源文件的首行。 如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。 import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。 Java包包主要用来对类和接口进行分类。当开发Java程序时，可能编写成百上千的类，因此很有必要对类和接口进行分类。 Import语句Import语句用来提供一个合理的路径，使得编译器可以找到某个类。例如，下面的命令行将会命令编译器载入java_installation/java/io路径下的所有类 import java.io.*; Java 基本数据类型变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。实际上，JAVA中还存在另外一种基本类型void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。Java 的两大数据类型: 内置数据类型 引用数据类型 内置数据类型Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。 bytebyte 数据类型是8位、有符号的，以二进制补码表示的整数； 范围：-128（-2^7） 到 127（2^7-1）； byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一； 例子：byte a = 100，byte b = -50。 shortshort 数据类型是 16 位、有符号的以二进制补码表示的整数 范围：-32768（-2^15） 到 32767（2^15 - 1）； Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一； 例子：short s = 1000，short r = -20000。 intint 数据类型是32位、有符号的以二进制补码表示的整数； 范围：-2,147,483,648（-2^31） 到 2,147,483,647（2^31 - 1）； 一般地整型变量默认为 int 类型； 例子：int a = 100000, int b = -200000。 longlong 数据类型是 64 位、有符号的以二进制补码表示的整数； 范围：-9,223,372,036,854,775,808（-2^63） 到 9,223,372,036,854,775,807（2^63 -1）； 这种类型主要使用在需要比较大整数的系统上； 例子： long a = 100000L，Long b = -200000L。 floatfloat 数据类型是单精度、32位、符合IEEE 754标准的浮点数； float 在储存大型浮点数组的时候可节省内存空间； 浮点数不能用来表示精确的值，如货币； 例子：float f1 = 234.5f。 doubledouble 数据类型是双精度、64 位、符合IEEE 754标准的浮点数； 浮点数的默认类型为double类型； double类型同样不能表示精确的值，如货币； 例子：double d1 = 123.4d 或者 123.4。 booleanboolean数据类型表示一位的信息； 只有两个取值：true 和 false； 默认值是 false； 例子：boolean one = true。 charchar类型是一个单一的 16 位 Unicode 字符； 范围：\u0000（即为0） 到 \uffff（即为65,535）； char 数据类型可以储存任何字符； 例子：char letter = ‘A’;。 引用类型对象、数组都是引用数据类型。 所有引用类型的默认值都是null。 一个引用变量可以用来引用任何与之兼容的类型。 例子：Site site = new Site(&quot;Runoob&quot;)。 Java 常量常量在程序运行时是不能被修改的。 在 Java 中使用 final 关键字来修饰常量。 final double PI = 3.1415927; 自动类型转换整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。转换从低级到高级。低 ————————————&gt; 高byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double 自动类型转换必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。强制类型转换 1. 条件是转换的数据类型必须是兼容的。 2. 格式：(type)value type是要强制类型转换后的数据类型。 隐含强制类型转换 1. 整数的默认类型是 int。 2. 浮点型不存在这种情况，因为在定义 float 类型时必须在数字后面跟上 F 或者 f。 Java 变量类型在Java语言中，所有的变量在使用前必须声明。 声明格式：type identifier [ = value][, identifier [= value] …] ;Java语言支持的变量类型有： 类变量：独立于方法之外的变量，用 static 修饰。 实例变量：独立于方法之外的变量，不过没有 static 修饰。 局部变量：类的方法中的变量。 Java 局部变量局部变量声明在方法、构造方法或者语句块中； 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁； 访问修饰符不能用于局部变量； 局部变量只在声明它的方法、构造方法或者语句块中可见； 局部变量是在栈上分配的。 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。 实例变量实例变量声明在一个类中，但在方法、构造方法和语句块之外；当一个对象被实例化之后，每个实例变量的值就跟着确定；实例变量在对象创建的时候创建，在对象被销毁的时候销毁；实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；实例变量可以声明在使用前或者使用后；访问修饰符可以修饰实例变量；实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。1234// 这个实例变量对子类可见public String name;// 私有变量，仅在该类可见private double salary; 类变量（静态变量）类变量也称为静态变量，在类中以static关键字声明，但必须在方法构造方法和语句块之外。无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。静态变量在程序开始时创建，在程序结束时销毁。与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。静态变量可以通过：ClassName.VariableName的方式访问。类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。 Java 修饰符Java语言提供了很多修饰符，主要分为以下两类： 访问修饰符 非访问修饰符 访问控制修饰符Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Javav支持 4 种不同的访问权限。 权限有4中：当前类、同一包内、子孙类、其他包 public : 对所有类可见。使用对象：类、接口、变量、方法。 protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。 default (即缺省，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）访问控制和继承 父类中声明为 public 的方法在子类中也必须为 public。 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。 父类中声明为 private 的方法，不能够被继承。 非访问修饰符static 修饰符，用来修饰类方法和类变量。final final 变量能被显式地初始化并且只能初始化一次。被声明为 final 的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。也就是说 final 对象的引用不能改变，但是里面的值可以改变。 类中的 final 方法可以被子类继承，但是不能被子类修改。abstract 抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。 抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。synchronized 关键字声明的方法同一时间只能被一个线程访问。transient 序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。volatile volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。 Java 运算符算术运算符 关系运算符 位运算符 逻辑运算符 赋值运算符 其他运算符 instanceof 运算符 该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。 ( Object reference variable ) instanceof (class/interface type) 类别 操作符 关联性 后缀 () [] . (点操作符) 左到右 一元 ++ -- ！~ 从右到左 乘性 * /％ 左到右 加性 + - 左到右 移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt; 左到右 关系 &gt;&gt; = &lt;&lt; = 左到右 相等 == != 左到右 按位与 ＆ 左到右 按位异或 ^ 左到右 按位或 | 左到右 逻辑与 &amp;&amp; 左到右 逻辑或 | | 左到右 条件 ？： 从右到左 赋值 = + = - = * = / =％= &gt;&gt; = &lt;&lt; =＆= ^ = | = 从右到左 逗号 ， 左到右 注：只有一元、条件（三目）、赋值运算符关联性为从右向左，其余全是从左向右 Java 循环结构while 循环 do…while 循环 对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。 do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。 for 循环 Java 增强 for 循环（对于数组） 1234for(声明语句 : 表达式)&#123; //代码句子&#125; break 关键字 break 主要用在循环语句或者 switch 语句中。 break 在循环语句中作用是跳出本层（并非本次）的循环。 break 在switch语句中作用是跳出该switch语句体。 continue 关键字 continue 适用于任何循环语句中。作用是让程序立刻跳转到下一次循环的迭代。 在 for 循环中，continue 语句使程序立即跳转到更新语句i++。 在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。 return 关键字 返回数据给函数的调用者。 函数一旦执行到了return关键字，那么该函数马上结束。 (能结束一个函数) Java 分支结构if 语句 switch 语句 Java Number &amp; Math 类所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 Number 的子类。这种由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型。Number 类属于 java.lang 包。 Java Math 类Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。 Number &amp; Math 类方法 Java Character 类Character 类用于对单个字符进行操作。Character 类在对象中包装一个基本类型 char 的值 转义序列前面有反斜杠（\）的字符代表转义字符，它对编译器来说是有特殊含义的。 Character 类方法 Java String 类字符串广泛应用 在Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。注意:String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了。如果需要对字符串做很多修改，那么应该选择使用 StringBuffer &amp; StringBuilder 类。 创建字符串String greeting = &quot;fanerge&quot;; 字符串长度int len = greeting.length(); 连接字符串string1.concat(string2); String 类方法 Java StringBuffer 和 StringBuilder 类当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。 StringBuffer 和 StringBuilder 类方法 Java 数组Java 语言中提供的数组是用来存储固定大小的同类型元素。 声明数组变量格式：dataType[] arrayRefVar; // 首选的方法 dataType arrayRefVar[]; // 效果相同，但不是首选方法实例：double[] myList; // 声明一个为double类型的数组 创建数组arrayRefVar = new dataType[arraySize]; 数组变量的声明，和创建数组可以用一条语句完成，如下所示： dataType[] arrayRefVar = new dataType[arraySize]; 处理数组循环处理 forforeach 循环 Array类方法 Java 日期时间Date 类 Date类方法 Calendar类Calendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可。 GregorianCalendar类 Calendar类实现了公历日历，GregorianCalendar是Calendar类的一个具体实现。 Java 正则表达式java正则在java.util.regex包中Pattern 类： pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。Matcher 类： Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。PatternSyntaxException： PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。 捕获组捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。 正则表达式语法正则方法 Java 方法方法的定义修饰符 返回值类型 方法名(参数类型 参数名){ ... 方法体 ... return 返回值; } 方法调用注：main 方法是被 JVM 调用的，除此之外，main 方法和其它方法没什么区别。 void 关键字方法的重载 创建另一个有相同名字但参数不同的方法 – 方法的重载 就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。变量作用域 变量的范围是程序中该变量可以被引用的部分。 方法的参数范围涵盖整个方法。参数实际上是一个局部变量。 for循环的初始化部分声明的变量，其作用范围在整个循环。 但循环体内声明的变量其适用范围是从它声明到循环体结束。命令行参数的使用构造方法 构造方法和它所在类的名字相同，但构造方法没有返回值。（可不写）可变参数 语法：typeName… parameterNamefinalize() 方法 Java 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( )，它用来清除回收对象。 Java 流(Stream)、文件(File)和IOJava.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。 读取控制台输入BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int read( ) throws IOException 从控制台读取字符串String readLine( ) throws IOException 控制台输出控制台的输出由 print( ) 和 println() 完成。这些方法都由类 PrintStream 定义，System.out 是该类对象的一个引用。PrintStream 继承了 OutputStream类，并且实现了方法 write()。这样，write() 也可以用来往控制台写操作。 读写文件一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。FileInputStream 该流用于从文件读取数据，它的对象可以用关键字 new 来创建。FileOutputStream 该类用来创建一个文件并向文件中写数据。 文件和I/OFile Class(类) FileReader Class(类) FileWriter Class(类) Java中的目录创建目录： mkdir( )方法创建一个文件夹，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。 mkdirs()方法创建一个文件夹和它的所有父文件夹。读取目录： 一个目录其实就是一个 File 对象，它包含其他文件和文件夹。删除目录或文件 删除文件可以使用 java.io.File.delete() 方法。 Java Scanner 类java.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。 通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据next() 与 nextLine() 区别next(): 1、一定要读取到有效字符后才可以结束输入。 2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。 3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。next() 不能得到带有空格的字符串。nextLine()： 1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。 2、可以获得空白。 Java 异常处理异常发生的原因有很多，通常包含以下几大类： 用户输入了非法数据。 要打开的文件不存在。 网络通信时连接中断，或者JVM内存溢出。要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常： 检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。 运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。 错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。 Exception 类的层次异常类有两个主要的子类：IOException 类和 RuntimeException 类。 Java 内置异常类异常方法捕获异常多重捕获块throws/throw 关键字finally关键字声明自定义异常Java 继承类的继承格式12345class 父类 &#123;&#125; class 子类 extends 父类 &#123;&#125; 继承的特性子类拥有父类非private的属性，方法。子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。子类可以用自己的方式实现父类的方法。Java的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类，这是java继承区别于C++继承的一个特性。提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系）。 继承关键字继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object extends关键字在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。 implements关键字使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。 12public class C implements A,B &#123;&#125; super 与 this 关键字super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。 this关键字：指向自己的引用。 final关键字final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写： 声明类： final class 类名 {//类体} 声明方法： 修饰符(public/private/default/protected) final 返回值类型 方法名(){//方法体} 构造器子类不能继承父类的构造器（构造方法或者构造函数），但是父类的构造器带有参数的，则必须在子类的构造器中显式地通过super关键字调用父类的构造器并配以适当的参数列表。 Java 重写(Override)与重载(Overload)重写(Override)重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。 方法的重写规则参数列表必须完全与被重写方法的相同；返回类型必须完全与被重写方法的返回类型相同；访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。父类的成员方法只能被它的子类重写。声明为final的方法不能被重写。声明为static的方法不能被重写，但是能够被再次声明。子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。构造方法不能被重写。如果不能继承一个方法，则不能重写这个方法。 Super关键字的使用当需要在子类中调用父类的被重写方法时，要使用super关键字。 重载(Overload)重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。 Java 多态多态是同一个行为具有多个不同表现形式或形态的能力。 多态存在的三个必要条件继承 重写 父类引用指向子类对象 Parent p = new Child(); 虚方法当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。 要想调用父类中被重写的方法，则必须使用关键字super。 多态的实现方式方式一：重写： 这个内容已经在上一章节详细讲过，就不再阐述，详细可访问：Java 重写(Override)与重载(Overload)。方式二：接口 生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。 java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看 java接口 这一章节的内容。方式三：抽象类和抽象方法 详情请看 Java抽象类 章节。 Java 抽象类在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。 抽象类 在Java语言中使用abstract class来定义抽象类。 继承抽象类 尽管我们不能实例化一个Employee类的对象，但是如果我们实例化一个Salary类对象，该对象将从 Employee 类继承7个成员方法，且通过该方法可以设置或获取三个成员变量。 抽象方法 如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。 Abstract关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。 声明抽象方法会造成以下两个结果： 如果一个类包含抽象方法，那么该类必须是抽象类。 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。 Java 封装在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。要访问该类的代码和数据，必须通过严格的接口控制。封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。 实现Java封装的步骤. 修改属性的可见性来限制对属性的访问（一般限制为private）. 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问getter和setter方法. 采用 this 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name变量）之间发生的同名的冲突。 Java 接口接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。 接口的声明[可见度] interface 接口名称 [extends 其他的类名] { // 声明变量 // 抽象方法 } 接口的实现 class Cat implements 接口名称[, 其他接口, 其他接口…, …] … 接口的继承 一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。 接口的多继承 public interface Hockey extends Sports, Event 标记接口 最常用的继承接口是没有包含任何方法的接口。 标识接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。 标识接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。 Java 包(package)为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。语法：package pkg1[．pkg2[．pkg3…]]; 例如,一个Something.java 文件它的内容 package net.java.util public class Something{ ... } 那么它的路径应该是 net/java/util/Something.java 这样保存的。 创建包 创建包的时候，你需要为这个包取一个合适的名字。之后，如果其他的一个源文件包含了这个包提供的类、接口、枚举或者注释类型的时候，都必须将这个包的声明放在这个源文件的开头。 包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它。 如果一个源文件中没有使用包声明，那么其中的类，函数，枚举，注释等将被放在一个无名的包（unnamed package）中。 import 关键字 为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。使用 “import” 语句可完成此功能。 在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前，可以没有，也可以有多条语法：import package1[.package2…].(classname|); 用 import 关键字引入，使用通配符 ““ import payroll.*; package 的目录结构 1.创建 vehicle 目录 2.在目录中新建 Car.java // 文件名 : Car.java package vehicle; public class Car { // 类实现 } 设置 CLASSPATH 系统变量 类目录的绝对路径叫做 class path。设置在系统变量 CLASSPATH 中。编译器和 java 虚拟机通过将 package 名字加到 class path 后来构造 .class 文件的路径。用下面的命令显示当前的CLASSPATH变量： Windows 平台（DOS 命令行下）：C:> set CLASSPATH UNIX 平台（Bourne shell 下）：# echo $CLASSPATH删除当前CLASSPATH变量内容： Windows 平台（DOS 命令行下）：C:> set CLASSPATH= UNIX 平台（Bourne shell 下）：# unset CLASSPATH; export CLASSPATH设置CLASSPATH变量: Windows 平台（DOS 命令行下）： C:> set CLASSPATH=C:\users\jack\java\classes UNIX 平台（Bourne shell 下）：# CLASSPATH=/home/jack/java/classes; export CLASSPATH]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>服务端</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我使用过的面试题]]></title>
    <url>%2F2017%2F%E6%88%91%E4%BD%BF%E7%94%A8%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html</url>
    <content type="text"><![CDATA[技术基础HTMLdoctype的作用告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。 HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。 data-属性的作用和相关的API操作HTML 5 增加了一项新功能是 自定义数据属性 ，也就是 data-* 自定义属性。 在HTML5中我们可以使用以 data- 为前缀来设置我们需要的自定义属性，来进行一些数据的存放。 data数据都属于页面私有，不会被搜索引擎等外部系统引用。相关的API 123456789101112&lt;div id=&quot;user&quot; data-id=&quot;001&quot; data-uname=&quot;fanerge&quot; data-date-of-birth=&quot;1991-10-15&quot;&gt; &lt;/div&gt;&lt;script&gt;let dom = document.querySelector(&apos;#user&apos;)// 老的访问方式dom.getAttribute(&apos;data-uname&apos;) // fanergedom.setAttribute(&apos;data-uname&apos;, &apos;余真帆&apos;) // 余真帆// HTML5 提供的访问方法(存在一定的兼容性)dom.dataset // 一个DOMStringMapdom.dataset.id // 001dom.dataset.dateOfBirth // 1991-10-15&lt;/script&gt; 扩展，data-属性选择器 1234567// css.user[data-name=&apos;fanerge&apos;] &#123; color: brown; &#125;// jsdocument.querySelectorAll(&apos;[data-text-colour=&quot;red&quot;]&apos;) defer和async属性defer和async是script标签的两个属性，用于在不阻塞页面文档解析的前提下，控制脚本的下载和执行。 defer (延迟脚本) 相当于告诉浏览器立即下载，但延迟执行（整个页面都解析完毕）。 async(异步脚本) 指定async属性的目的是不让页面等待脚本下载和执行，从而异步加载页面其他内容（css、图片、font等）。 需要注意，异步脚本不要在加载期间修改DOM。 事件DOMContentLoaded和load的区别它们触发的时机不一样，先触发DOMContentLoaded事件，后触发load事件。 DOM文档加载的步骤为 1. 解析HTML结构。 2. 加载样式表文件和外部脚本。 3. 解析并执行脚本代码。 4. DOM树构建完成。//DOMContentLoaded（这里也是jquery的ready方法绑定的时机） 5. 加载图片等外部文件。 6. 页面加载完毕。//load HTML5localStorage 与Cookie的比较来看MDN定义： sessionStorage 为每一个给定的源（given origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。 localStorage 同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。 Cookie 是一个请求首部，其中含有先前由服务器通过 Set-Cookie 首部投放并存储到客户端的 HTTP cookies。共同点：都是保存在浏览器端、且同源的区别点： 1.cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下 2.存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 3.数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭 4.作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的 5.web Storage提供了良好的api如length、key、setItem、getItem、removeItem、clear等方法个人认为产生这些客户端存储的目的是由于 http协议 是无状态，客户端帮助存储客户的操作，发送给服务端以便服务端做出相应的判断。cookie语法： 123456document.cookie=&quot;name=value; domain=cookieDomain; path=/; &quot;;;path=path (例如 &apos;/&apos;, &apos;/mydir&apos;) 如果没有定义，默认为当前文档位置的路径。;domain=domain (例如 &apos;example.com&apos;， &apos;.example.com&apos; (包括所有子域名), &apos;subdomain.example.com&apos;) 如果没有定义，默认为当前文档位置的路径的域名部分。;max-age=max-age-in-seconds (例如一年为60*60*24*365);expires=date-in-GMTString-format 如果没有定义，cookie会在对话结束时过期这个值的格式参见Date.toUTCString() ;secure (cookie只通过https协议传输) cookie的值字符串可以用encodeURIComponent()来保证它不包含任何逗号、分号或空格(cookie值中禁止使用这些值). cookie的路径：（路径能解决在同一个域下访问 cookie 的问题） 出于安全方面的考虑，只有与创建 cookie 的页面处于同一个目录或在创建cookie页面的子目录下的网页才可以访问。那么此时如果希望其父级或者整个网页都能够使用cookie，就需要进行路径的设置。 让这个设置的cookie 能被其他目录或者父级的目录访问的方法： document.cookie = “userName = 独行冰海; path=/“;cookie的域：（域能解决同一个主域下的访问问题） 让 “www.baidu.com” 下的cookie被 “mp3.baidu.com” 访问，我们就需要用到 cookie 的domain属性，并且需要把path属性设置为 “/“ document.cookie = “username=独行冰海; path=/; domain=baidu.com” 扩展-缓存相关的知识http头部缓存相关key request header缓存相关 1.cache-control：no-cache、no-store、max-age 2.if-none-match：该字段与响应中的eTag一起使用，表示检查实体是否有更新改变 3.if-modified-since: 该字段与last-modified配合使用 response header缓存相关： 1.Etag： 2.expires： 3.last-modified: 应用场景首次注册用户的引导等 在什么情况是失效 1.浏览器清除缓存 2.5M大小的限制 3.IOS safari 的隐私模式（主要我查MDN上有说明，其他浏览器隐私模式会新建 Storage对象，不会与普通模式公用，且关闭隐私模式时 Storage对象 就消失） 浏览器内多个标签页之间的通信1.localstorge + storage 事件 页面1：localStorage.setItem(“name”, ‘测试’); 页面2: window.addEventListener(‘stroge’, (e)=&gt; { console.log(${e.key} = ${e.newValue}) }, false)2.cookie + setInterval（类似于轮询） CanvasHistory APIHistory.length History.scrollRestoration (实验性)-- 允许Web应用程序在历史导航上显式地设置默认滚动恢复行为。 History.state 返回一个表示历史堆栈顶部的状态的值。这是一种可以不必等待popstate 事件而查看状态而的方式。 History.back() History.forward() History.go() History.pushState() History.replaceState() postMessage通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为https），端口号（443为https的默认值），以及主机 (两个页面的模数 Document.domain设置为相同的值) 时，这两个脚本才能相互通信。作用：解决上面问题，window.postMessage() 方法可以安全地实现跨源通信。语法：otherWindow.postMessage(message, targetOrigin, [transfer]);参数：otherWindow 其他窗口的一个引用，比如iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames。 message 将要发送到其他 window的数据。它将会被结构化克隆算法序列化。这意味着你可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化。 targetOrigin（安全性从这里入手） 通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*“（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口；例如，当用postMessage传送密码时，这个参数就显得尤为重要，必须保证它的值与这条包含密码的信息的预期接受者的orign属性完全一致，来防止密码被恶意的第三方截获。如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的targetOrigin，而不是*。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。 transfer 可选 是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。其他window监听message事件 1234567891011window.addEventListener(&quot;message&quot;, receiveMessage, false);function receiveMessage(event)&#123; // For Chrome, the origin property is in the event.originalEvent // object. var origin = event.origin || event.originalEvent.origin; if (origin !== &quot;http://example.org:8080&quot;) return; // todo...&#125; PS：message 的属性有: data 从其他 window 中传递过来的对象。 origin 调用 postMessage 时消息发送方窗口的 origin . 这个字符串由 协议、“://“、域名、“ : 端口号”拼接而成。例如 “https://example.org (implying port 443)”、“http://example.net (implying port 80)”、“http://example.com:8080”。请注意，这个origin不能保证是该窗口的当前或未来origin，因为postMessage被调用后可能被导航到不同的位置。 source 对发送消息的窗口对象的引用; 您可以使用此来在具有不同origin的两个窗口之间建立双向通信。 关注下安全性问题 1.如果您不希望从其他网站接收message，请不要为message事件添加任何事件侦听器。 2.请始终使用origin和source属性验证发件人的身份，还应该始终验证接收到data的消息的语法。 3.当您使用postMessage将数据发送到其他窗口时，始终指定精确的目标origin，而不是*。详细需了解-MDN WebSocket对象作用： 提供了用于创建和管理 WebSocket 连接，以及可以通过该连接发送和接收数据的 API。 WebSocket构造器方法接受一个必须的参数和一个可选的参数：语法： WebSocket WebSocket(in DOMString url,in optional DOMString[] protocols);具体参数： url – 表示要连接的URL。这个URL应该为响应WebSocket的地址。 protocols 可选 – 可以是一个单个的协议名字字符串或者包含多个协议名字字符串的数组。这些字符串用来表示子协议，这样做可以让一个服务器实现多种WebSocket子协议（例如你可能希望通过制定不同的协议来处理不同类型的交互）。如果没有制定这个参数，它会默认设为一个空字符串。属性： binaryType、onclose、onerror、onmessage、onopen（EventListener）方法： void send(in DOMString data); void close(in optional unsigned long code, in optional DOMString reason);构造器方法可能抛出以下异常： SECURITY_ERR – 试图连接的端口被屏蔽。示例： 123456789101112// Create WebSocket connection.const socket = new WebSocket(&apos;ws://localhost:8080&apos;);// Connection openedsocket.addEventListener(&apos;open&apos;, function (event) &#123; socket.send(&apos;Hello Server!&apos;);&#125;);// Listen for messagessocket.addEventListener(&apos;message&apos;, function (event) &#123; console.log(&apos;Message from server&apos;, event.data);&#125;); MDN-WebSocket 扩展（Ajax轮询）这是比较原始的方案 定义：轮询（polling）：客户端按规定时间定时向服务端发送ajax请求，服务器接到请求后马上返回响应信息并关闭连接。 1window.setInterval(function()&#123;$.ajax(getting)&#125;,1000); 长轮询（递归） 12345678910111213var getting = &#123; url:&apos;server.php&apos;, dataType:&apos;json&apos;, success:function(res) &#123; // todo... $.ajax(getting); //关键在这里，回调函数内再次请求Ajax &#125; error:function(res)&#123; $.ajax(getting); &#125;&#125;;$.ajax(getting); // 这里第一次调用ajax CMD和AMD以及UMD，UMD的实现AMD（浏览器环境）– RequireJSCMD（Node） – CommonJSUMD: 通用模块规范（兼容低版本浏览器设置在window上的属性如window.$ – 代表jquery）123456789101112131415161718192021222324252627// 自己封装一个符合UMD的功能函数库取名 fanerge(function (window, factory) &#123; if (typeof exports === &apos;object&apos;) &#123; // UMD先判断是否支持Node.js的模块（exports）是否存在，存在则使用Node.js模块模式。 module.exports = factory(); &#125; else if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123; // 再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。 define(factory); &#125; else &#123; // 否则就绑定到全局的一个属性上，这里绑定到window对象的fanerge属性上 window.fanerge = factory(); &#125;&#125;)(this, function () &#123; let fanerge = &#123;&#125;; fanerge.alert = function alert() &#123; alert(&apos;fanerge&apos;); &#125; fanerge.log = function log() &#123; console.log(&apos;fanerge&apos;); &#125; return fanerge;&#125;);// 使用时fanerge.log() Web Worker分类：专用worker（一个专用worker仅仅能被生成它的脚本所使用）、共享worker作用：Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面。限制：在worker内直接操作DOM节点，或者使用window对象的默认方法和属性。主线程与worker数据传递：workers和主线程间的数据传递通过这样的消息机制进行——双方都使用postMessage()方法发送各自的消息，使用onmessage事件处理函数来响应消息（消息被包含在Message事件的data属性中）。这个过程中数据并不是被共享而是被复制。终止worker： 在主线程中终止：workerName.terminate(); worker 线程会被立即杀死，不会有任何机会让它完成自己的操作或清理工作。 在worker中终止：close();处理错误：onerror 事件处理函数会被调用，对应的参数，message – 可读性良好的错误消息；filename – 发生错误的脚本文件名；lineno – 发生错误时所在脚本文件的行号。生成subworker： 在worker 中能够生成 worker。这就是所谓的subworker，它们必须托管在同源的父页面内。引入脚本与库：Worker 线程能够访问一个全局函数importScripts()来引入脚本，该函数接受0个或者多个URI作为参数来引入资源；共享worker与专有worker的区别： 1.创建worker var myWorker = new Worker(‘worker.js’); // 专有 var myWorker = new SharedWorker(‘worker.js’); // 共享 2.通信（发送消息和接收消息都需要携带port） 父级线程和worker线程需要双向通信，那么它们都需要调用start()方法。 myWorker.port.start(); // 父级线程中的调用 port.start(); // worker线程中的调用, 假设port变量代表一个端口 共享worker中消息的接收和发送 消息可以像之前那样发送到worker了，但是postMessage() 方法必须被端口对象调用。详情参考MDN-web Worker File API1、File- 单个文件；提供了诸如file name、file size、mimetype等只读文件属性。2、FileList- 一个类数组File对象集合；构造函数 File() 返回一个新构建的文件对象（File）。属性 File.lastModified – 返回当前 File 对象所引用文件最后修改时间， 自 1970年1月1日0:00 以来的毫秒数。 File.name – 返回当前 File 对象所引用文件的名字。 File.size – 返回文件的大小。 File.type – 返回文件的 多用途互联网邮件扩展类型。获取用户选择文件的方式 来自用户在一个input元素上选择文件后返回的FileList对象。 e.target.files; //FileList 来自拖放操作生成的 DataTransfer对象。 e.dataTransfer.files; //FileList 来自在一个HTMLCanvasElement上执行mozGetAsFile()方法后返回结果。 FileReader APIFileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。构造函数 FileReader() – 返回一个新构造的FileReader。属性： error DOMError 在读取文件时发生的错误. 只读. readyState unsigned short 表明FileReader对象的当前状态. 值为State constants中的一个. 只读 result jsval 读取到的文件内容.这个属性只在读取操作完成之后才有效,并且数据的格式取决于读取操作是由哪个方法发起的. 只读.方法： void abort(); void readAsArrayBuffer(in Blob blob); void readAsBinaryString(in Blob blob); void readAsDataURL(in Blob blob); void readAsText(in Blob blob, [optional] in DOMString encoding);事件处理程序： onabort – 当读取操作被中止时调用. onerror – 当读取操作发生错误时调用. onload – 当读取操作成功完成时调用. onloadend – 当读取操作完成时调用,不管是成功还是失败.该处理程序在onload或者onerror之后调用. onloadstart – 当读取操作将要开始之前调用. onprogress – 在读取数据过程中周期性调用.示例（本地文件预览） 12345678910111213141516171819let oFReader = new FileReader(), // 新建一个 FileReader实例 rFilter = /^(?:image\/bmp|image\/)$/i; // 可以读取的文件格式 // 文件异步读取完成时，将设置预览组件的 src 属性oFReader.onload = function (oFREvent) &#123; document.getElementById(&quot;uploadPreview&quot;).src = oFREvent.target.result;&#125;;// 加载用户选择的图片function loadImageFile() &#123; // 没有选择文件 if (document.getElementById(&quot;uploadImage&quot;).files.length === 0) &#123; return; &#125; var oFile = document.getElementById(&quot;uploadImage&quot;).files[0]; // 文件的 MIMETYPE 不满足当前正则 if (!rFilter.test(oFile.type)) &#123; return; &#125; // 读取文件 oFReader.readAsDataURL(oFile);&#125;loadImageFile() CSS盒子模型块级元素和行内元素的区别CSS spritesline-height 和 vertical-alignline-height的值由font-size和字体类型共同决定。vertical-align的值 vertical-align: top / bottom，表示与 line-box 的顶部或底部对齐 vertical-align: text-top / text-bottom，表示与 content-area 的顶部或底部对齐 z-index需要配合脱离文档流的属性使用，position: relative, absolute, fixed。 栅格系统以Bootstrap3为例（12栅格系统） 采用float + width(百分比) + @media(媒体查询实现适配)以Bootstrap4为例 采用容器flex布局（容器6个属性，子项目6个属性） Media Query语法： 1.link元素中的CSS媒体查询 &lt;link rel=&quot;stylesheet&quot; media=&quot;(max-width: 800px)&quot; href=&quot;example.css&quot; /&gt; 2.样式表中的CSS媒体查询 @media (max-width: 600px) { … }逻辑操作符: all（默认） not – not 关键字应用于整个媒体查询，在媒体查询为假时返回真 (比如 monochrome 应用于彩色显示设备上或一个600像素的屏幕应用于 min-width: 700px 属性查询上 )。 and – and关键字用于合并多个媒体属性或合并媒体属性与媒体类型。 @media tv and (min-width: 700px) and (orientation: landscape) { … } only – only关键字防止老旧的浏览器不支持带媒体属性的查询而应用到给定的样式 &lt;link rel=&quot;stylesheet&quot; media=&quot;only screen and (color)&quot; href=&quot;example.css&quot; /&gt; CSS选择器的性能优化说明： 1.样式系统从最右边的选择符开始向左进行匹配规则。只要当前选择符的左边还有其他选择符，样式系统就会继续向左移动，直到找到和规则匹配的元素，或者因为不匹配而退出。 2.如果你非常在意页面的性能那千万别使用CSS3选择器。实际上，在所有浏览器中，用 class 和 id 来渲染，比那些使用同胞，后代选择器，子选择器（sibling, descendant and child selectors）对页面性能的改善更值得关注。CSS选择器的效率从高到低排序： 1.id选择器（#myid）2.类选择器（.myclassname）3.标签选择器（div,h1,p）4.相邻选择器（h1+p）5.子选择器（ul &gt; li）6.后代选择器（li a）7.通配符选择器（*）8.属性选择器（a[rel=”external”]）9.伪类选择器（a:hover,li:nth-child）具体做法： 1.不要在编写id规则时用标签名或类名 2.不要在编写class规则时用标签名 3.把多层标签选择规则用class规则替换，减少css查找 4.避免使用子选择器 5.依靠继承 参考阿里文章 CSS预处理器（SASS，Compass，Stylus，LESS），实践经验以及思考SASS Webfonts作用：WebFont 技术可以让网页使用在线字体，而无需使用图片，从而有机会解决开头设计师提到的问题。它通过 CSS 的@font-face语句引入在线字体，使用 CSS 选择器指定运用字体的文本，与此同时专用于 Web 展示的 woff 格式字体也得到各大浏览器厂商支持，进一步减少了字体的体积。语法： 12345678@font-face &#123; font-family: &apos;ciclefina&apos;; src: url(&apos;fonts/cicle_fina-webfont.eot&apos;); src: url(&apos;fonts/cicle_fina-webfont.eot?#iefix&apos;) format(&apos;embedded-opentype&apos;), url(&apos;fonts/cicle_fina-webfont.woff2&apos;) format(&apos;woff2&apos;); font-weight: normal; font-style: normal;&#125; WebFont的优势： 支持选中、复制 支持 Ctrl+F 查找 对搜索引擎友好 支持工具翻译 支持无障碍访问，支持朗读 字体是矢量图形，支持矢量缩放，自动适配高清屏 文本修改方便 字形可以重复利用，节省网络资源中文 WebFont 的困境： 1、中文字体体积 2、浏览器类型（各种壳的浏览器） 3、操作系统（主要是XP系统）现有的中文 WebFont 解决方案： 1.本地制作 通过字体制作工具来删除没有使用的字符，即制作精简版字体，这也是我之前实践过的方案。 2. 字体云服务 https://www.youziku.com/ 3开源工具字蛛（Font-Spider）参考Webfont Flexbox说明：Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 由容器 Container 和 子项目 Item 构成。 Container 容器相关的属性首先 display: flex / inline-flex;flex-direction – 决定主轴的方向（即项目的排列方向）。flex-wrap – 如果一条（主轴）轴线排不下，如何换行。flex-flow – 是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。justify-content – 定义了项目在主轴上的对齐方式。align-items – 定义项目在交叉轴上如何对齐。align-content – 定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 Item 子项目相关的属性order – 定义项目的排列顺序。数值越小，排列越靠前，默认为0。flex-grow – 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。flex-shrink – 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。flex-basis – 定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。flex – 是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。align-self – 允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。阮老师博客-Flex 适配retina屏幕什么是retina屏幕适配？ 当一个图像在标准设备下全屏显示时，一位图像素对应的就是一设备像素，导致一个完全保真的显示，因为一个位置像素不能进一步分裂。而当在Retina屏幕下时，他要放大四倍来保持相同的物理像素的大小，这样就会丢失很多细节，造成失真的情形。 换句话说，每一位图像素被乘以四填补相同的物理表面在视网膜屏幕下显示。适配方法：1.直接加载2倍大小的图片。 假如要显示的图片大小为200px300px，你准备的实际图片大小应该为400px600px，并且使用以下代码控制即可： 1&lt;img src=&quot;pic.png&quot; height=&quot;200px&quot; width=&quot;300px&quot; /&gt; 缺点： 对于普通屏来说加载多倍图势必会导致页面加载时间加长，用户体验不佳。 更好的方案： 开源retina.js原理是通过window.devicePixelRatio &gt; 1判断是不同屏还是retina屏，然后再加载对应的几倍图。2.Image-set控制 假如要显示的图片大小为200px300px，你准备的图片应有两张：一张大小为200px300px，命名为pic.png；另一张大小为400px*600px，命名为pic@2x.png（@2x是Retina图标的标准命名方式），然后使用以下css代码控制： 背景方式使用： 1234567#logo &#123; background: url(pic.png) 0 0 no-repeat; background-image: -webkit-image-set(url(pic.png) 1x, url(pic@2x.png) 2x); background-image: -moz-image-set(url(pic.png) 1x,url(images/pic@2x.png) 2x); background-image: -ms-image-set(url(pic.png) 1x,url(images/pic@2x.png) 2x); background-image: -o-image-set(url(url(pic.png) 1x,url(images/pic@2x.png) 2x);&#125; 在img标签属性中使用： 1&lt;img src=&quot;pic.png&quot; srcset=&quot;pic@2x.png 2x&quot; /&gt; 3.使用@media控制 实际是判断屏幕的像素比来取舍是否显示高分辨率图像，代码如下： 123456789@media only screen and (-webkit-min-device-pixel-ratio: 1.5), only screen and (min--moz-device-pixel-ratio: 1.5), /* 注意这里的写法比较特殊 */ only screen and (-o-min-device-pixel-ratio: 3/2), only screen and (min-device-pixel-ratio: 1.5) &#123; #logo &#123; background-image: url(pic@2x.png); background-size: 100px auto; &#125;&#125; 参考文章 CSS3新增伪类以含义p:first-letter 选择每一个P元素的第一个字母p:first-line 选择每一个P元素的第一行p:first-child 指定只有当p元素是其父级的第一个子级的样式p:last-child 选择每个p元素是其父级的最后一个子级。p:first-of-type 选择每个p元素是其父级的第一个p元素p:last-of-type 选择每个p元素是其父级的最后一个p元素p:only-of-type 选择每个p元素是其父级的唯一p元素p:only-child 选择每个p元素是其父级的唯一子元素p:nth-child(2) 选择每个p元素是其父级的第二个子元素p:nth-last-child(2) 选择每个p元素的是其父级的第二个子元素，从最后一个子项计数p:nth-of-type(2) 选择每个p元素是其父级的第二个p元素p:nth-last-of-type(2) 选择每个p元素的是其父级的第二个p元素，从最后一个子项计数 :root 选择文档的根元素p:empty 选择每个没有任何子级的p元素（包括文本节点）input:enabled 选择每一个已启用的输入元素input:disabled 选择每一个禁用的输入元素input:checked 选择每个选中的输入元素:not(p) 选择每个并非p元素的元素::selection 匹配元素中被用户选中或处于高亮状态的部分 a[src^=”https”] 选择每一个src属性的值以”https”开头的元素a[src$=”.pdf”] 选择每一个src属性的值以”.pdf”结尾的元素a[src*=”runoob”] 选择每一个src属性的值包含子字符串”runoob”的元素 javascriptJavaScript语言闭包定义：定义在一个函数内部的函数（将函数内部的变量保留在内存中，这样外部就可以改函数内相关的变量）。 闭包就是能够读取其他函数内部变量的函数。用途：一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 1.匿名自执行函数 (function(){ // todo… })() 2.缓存（针对于复杂的计算，每次计算前先读缓存如果没有在进行计算并添加到缓存） 3.实现封装（可以将函数内部的变量通过暴露接口在函数外可以访问） 12345678910111213var person = function()&#123; //变量作用域为函数内部，外部无法访问 var name = &quot;default&quot;; return &#123; getName : function()&#123; return name; // 可以访问 name 属性 &#125;, setName : function(newName)&#123; name = newName; // 可以为 name 赋值 &#125; &#125; &#125;(); 4.闭包的另一个重要用途是实现面向对象中的对象 1234567891011121314151617function Person()&#123; var name = &quot;default&quot;; return &#123; getName : function()&#123; return name; &#125;, setName : function(newName)&#123; name = newName; &#125; &#125; &#125;; var john = Person(); john.getName(); john.setName(&quot;john&quot;); john.getName(); 51脚本 作用域变量作用域函数作用域块级作用域 ES6提出，let 和 const 声明。{}范围为该区域 建议在支持的环境尽量使用 let 和 const 代替 var。作用域链 动态作用域 – 函数执行时才确定的。this（4种情况，资料较多这里不再阐述） 静态作用域 – 函数定义时就确定的。 函数的可以允许嵌套的。例如有一个全局函数a， 在 a 在有又定义了函数 b，此时就形成了一条作用域链。 b -&gt; a -&gt; window(浏览器)/global(Node环境) 原型（-&gt; 代表指向）Number.prototype(有一些自己的方法如，toFixed) -&gt; Object.prototype (对象所有的方法) -&gt; undefined(原型链的顶层，为null)Number、String、Boolean、Array、Date、RegExp、都是上面的原型链。Math对象有点特殊，无需在使用这个对象之前对它进行定义。类似于在该对象上定义了许多静态属性和静态方法，可以直接使用（Math.PI、Math.abs(-3)）。 面向对象/继承面向对象继承JS实现继承的几种方式 this（也就是说的动态作用域）1.普通函数（挂载到全局上面） 在 ‘use strict’ 严格模式中指向 undefined 在非严格模式中指向window/global（适执行环境而定）2.对象的方法 this 指向该对象3.作为构造函数调用 this 指向该构造函数的实例4.call、apply以及bind方法可以改变this指向 this 均指向第一个参数 区别：call、apply返回值是你调用的方法的返回值；而bind返回由指定的this值和初始化参数改造的原函数拷贝。关于这三个方法的区别，请访问MDN call和apply的作用，以及区别参见上面 匿名函数1.过去常用于设计为一个独立的作用域 (function(形参){ // todo })(实参);2.函数声明也是匿名函数 let demo = function(){}; 正则1.描述几个正则的语法含义，比如：[]、{}、\w、\d、\s等 [abc] 查找方括号之间的任何字符。 [^abc] 查找任何不在方括号之间的字符。 [0-9] 查找任何从 0 至 9 的数字。 n{X} 匹配包含 X 个 n 的序列的字符串。 n{X,} 前面的模式 n 连续出现至少 X 次时匹配。 n{X,Y} 前面的模式 n 连续出现至少 X 次，至多 Y 次时匹配。 PS：所有的大写均表示非。 \w 查找单词字符。 \d 查找数字。 \s 查找空白字符。包括空格符、制表符、回车符、换行符、垂直换行符、换页符 \b 匹配单词边界。2.i/g/m等的含义（ES6中添加u、y） i – ignore（忽略大小写） g – global（全局匹配及查找所有匹配而非在找到第一个匹配后停止） m – multiple（执行多行匹配） ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\uFFFF的 Unicode 字符。 ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。3.replace方法 第二个参数为string – string.replace(searchvalue,newvalue) 第二个参数是回调函数 1234this.replace(/(^\s+)|(\s+$)/g,function(result,$1,$2,offset,source)&#123; //arguments中的每个元素对应一个参数 console.log(arguments);&#125;); 具体参数说明：result: 本次匹配到的结果$1,…$9: 正则表达式中有几个()，就会传递几个参数，$1~$9分别代表本次匹配中每个()提取的结果，最多9个offset:记录本次匹配的开始位置source:接受匹配的原始字符串4.匹配任意字符（使用互补的方式来实现） [\s\S] 或 [\w\W] 或 [.\r\n] 注：\w 等价于 [A-Za-z0-9_]51job 事件1.DOM事件流 冒泡：事件冒泡的过程是：a –&gt; div –&gt; body 。 产生的原因：因为事件源本身（可能）并没有处理事件的能力，即处理事件的函数（方法）并未绑定在该事件源上。 处理问题：event.stopPropagation()阻止事件的传递行为。 应用：事件委托 捕获：事件从Document节点自上而下向目标节点传播的阶段 完整的DOM事件流模型： 捕获阶段 、目标阶段 、冒泡阶段2.兼容性问题（优先级逐渐升高） html的onclick属性绑定 dom.onclick = function(){} dom.attachEvent(“onclick”, callback) // dom.detachEvent(“onclick”, callback) dom.addEventListener(‘click’, callback, userCapture) // dom.removeEventListener(‘click’, callback, userCapture)3.事件代理 原理为事件冒泡 例如一下DOM结构 ul li li 对ul绑定事件，而不是对li绑定事件。在通targe.tagName，以及点的是哪一个li做不用的操作。4.自定义事件 如何实现一个自定义事件的系统 定义：自定义事件就是自己定义事件类型，自己定义事件处理函数，在合适的时候需要哪个事件类型，就去调用哪个处理程。 实现过程：（其实就是发布订阅模式或监听者模式）1.定义自定义事件构造函数 1234function EventTarget()&#123; //保存事件处理程序数组集合，每个实例不共享 this.handlers = &#123;&#125;;&#125; 2.在构造函数的原型上添加实例共享的方法 123456789EventTarget.prototype = &#123; constructor: EventTarget, // 矫正原型链指向 addEvent: function(type, handler) &#123;&#125;, // 添加一个事件处理函数 addEvents: function(obj)&#123;&#125;, // 批量添加事件 removeEvent: function(type, handler)&#123;&#125;, // 移除一个事件处理函数 removeEvents: function(params) &#123;&#125;, // 批量移除事件 fireEvent: function(type) &#123;&#125;, // 触发一个事件 fireEvents: function(array) &#123;&#125; // 批量触发事件&#125;; 3.调用 12345678function b()&#123; console.log(123);&#125; var target = new EventTarget();target.addEvent(&quot;eat&quot;, b); target.fireEvent(&#123; type: &quot;eat&quot; &#125;); // 12 详细信息参考博客 BOM/DOMBOM – 浏览器对象模型（Browser Object Model，简称BOM）。 提供了独立于内容而与浏览器窗口进行交互的对象。描述了与浏览器进行交互的方法和接口，可以对浏览器窗口进行访问和操作，譬如可以弹出新的窗口，改变状态栏中的文本，对Cookie的支持等。 Window 对象 Navigator 对象 Screen 对象 History 对象 Location 对象DOM – 文档对象模型（Document Object Model，简称DOM）。 DOM 就是针对 HTML 和 XML 提供的一个API。 兼容性问题 常规的增删改查等操作的原生方法的考核 查： getElementById()、 getElementsByTagName()、 getElementsByName()、 getElementsByClassName()、 querySelector()、 querySelectorAll() 改： document.getElementById(id).innerHTML=new value：修改HTML元素 document.getElementById(id).attribute=new value：修改元素属性 document.getElementById(id).style.property=new style：修改元素CSS setAttribute()：setAttribute()方法将设置元素中某个属性和值 parent.replaceChild(child,oldElem)：替换节点 增： A.append(B) : 把B追加到A内部（所有的A元素，以下类似） A.appendTo(B) : 把A追加到B内部 A.prepend(B) : 把B追加到A内部的内容前(即B成为A第一个子元素) A.prependTo(B) : 把A追加到B的内容前（即A成为B第一个子元素） A.after(B) : 在A后追加B A.before(B): 在A前追加B node.insertBefore(A,B): 在父节点node里面的B节点前面追加A parent.replaceChild(child,oldElem)：替换节点 删： dom.remove()：删除该元素 parent.removeChild(child)：删除子元素 动画1.JS实现一个动画的方式 setTimeout、 setInterval、 setImmediate（window.clearImmediate）微软取消该方法，不建议使用、 window.requestAnimationFrame(callback)（window.cancelAnimationFrame() ） 参数：一个在每次需要重新绘制动画时调用的包含指定函数的参数。 这个回调函数有一个传参，DOMHighResTimeStamp，指示从触发 requestAnimationFrame 回调到现在的时间。2.CSS3的动画 申明一个动画： 1234@keyframes animationName &#123; from &#123;background: red;&#125; to &#123;background: yellow;&#125;&#125; PS：参数说明，animationname、keyframes-selector（from（0%）、to（100%））、css-styles 使用一个动画： 1234div:hover &#123; animation: animationName 5s;&#125;PS：animation: name duration timing-function delay iteration-count direction fill-mode play-state; 3.如何优化动画的流畅度 每一帧都需要在16ms内渲染 动画添加到opacity和transform等属性之上。 将内容藏在不起眼的地方，使用pointer-events:通过透明度为0来隐藏元素。 不要同一时间所有元素都做动画，除非使用编排。 轻微地增加延迟，让编排动作变得简单。 使用全局倍数来设计慢动画，然后加速之后所有的元素。 拍下你的UI，并且重放他们，以获取有价值的第三方关点。 网络活动导致滞后，你需要提前或者滞后加载大的http请求。 不要直接绑定滚动。 尽早&amp;经常在手机上测试。 在不同的设备上经常测试，屏幕大小，像素，或者设备都有着极大的暗示。4.animation-fill-mode animation-fill-mode 这个 CSS 属性用来指定在动画执行之前和之后如何给动画的目标应用样式。 属性值：none | forwards | backwards | both流畅web动画的十个法则 组合动画动画事件/自定义事件（start、process、end等）animationstart - CSS 动画开始后触发animationiteration - CSS 动画重复播放时触发animationend - CSS 动画完成后触发 shim和polyfillpolyfill 是 shim 的一种。shim 是将不同 api 封装成一种，比如 jQuery 的 $.ajax 封装了 XMLHttpRequest 和 IE 用 ActiveXObject 方式创建 xhr 对象；polyfill 特指 shim 成的 api 是遵循标准的，其典型做法是在IE浏览器中增加 window.XMLHttpRequest ，内部实现使用 ActiveXObject。 Ajax/跨域1.对Ajax的作用、API方法的理解 Ajax 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。 XMLHttpRequest(ActiveXObject 兼容版本ie)或新的Fetch API 重点研究下Fetch API Fetch API提供了一个 JavaScript接口，用于访问和操纵HTTP管道的部分，例如请求和响应。 Fetch 接口GlobalFetch 包含了 fetch() 方法，用于获取资源。Headers（构造器） 相当于 response/request 的头信息，可以修改它，或者针对不同的结果做不同的操作。 Headers.append() 给现有的header添加一个值, 或者添加一个未存在的header并赋值. Headers.delete() 从Headers对象中删除指定header. Headers.get() 从Headers对象中返回指定header的第一个值. Headers.getAll() 以数组的形式从Headers对象中返回指定header的全部值. Headers.has() 以布尔值的形式从Headers对象中返回是否存在指定的header. Headers.keys() 以迭代器的形式返回Headers对象中所有存在的header名. Headers.set() 替换现有的header的值, 或者添加一个未存在的header并赋值. Headers.values() 以迭代器的形式返回Headers对象中所有存在的header的值. Headers.entries() 以 迭代器 的形式返回Headers对象中所有的键值对. 123456var myHeaders = new Headers();myHeaders.append(&quot;Content-Type&quot;, &quot;text/plain&quot;);myHeaders.set(&quot;Content-Type&quot;, &quot;text/html&quot;);console.log(myHeaders.get(&quot;Content-Length&quot;)); // 11myHeaders.delete(&quot;X-Custom-Header&quot;);myHeaders.has(&quot;Content-Type&quot;) Body 代表响应/请求的正文，允许你声明其内容类型是什么以及应该如何处理。 Body.bodyUsed（属性） 包含一个指示body是否被读取过的 Boolean 值。 Body.arrayBuffer() 使用一个buffer数组来读取 Response流中的数据，并将bodyUsed状态改为已使用。 Body.blob() 使用一个Blob对象来读取 Response流中的数据，并将bodyUsed状态改为已使用。 Body.formData() 使用一个 FormData 对象来读取 Response流中的数据，并将bodyUsed状态改为已使用。 Body.json() 使用一个 JSON 对象来读取 Response流中的数据，并将bodyUsed状态改为已使用。 Body.text() 使用一个USVString (文本) 对象来读取 Response流中的数据，并将bodyUsed状态改为已使用。 MDN-Fetch-bodyRequest（构造器） 相当于一个资源请求。 Request.method 只读 请求使用的方法 (GET, POST, 等.) Request.url 只读 请求使用的 URL。 Request.headers 只读 请求所关联的 Headers 对象。 Request.context 只读 请求的上下文 例如：(例如：audio, image, iframe, 等) Request.referrer 只读 请求的来源 (例如：client). Request.mode 只读 请求的模式 (例如： cors, no-cors, same-origin). Request.credentials 只读 请求的凭证 (例如： omit, same-origin). Request.redirect 只读 如何处理重定向模式 (例如： follow, error, or manual) Request.integrity 只读 请求内容的 subresource integrity 值 (例如： sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=). Request.cache 只读 请求的缓存模式 (例如： default, reload, no-cache). Body.bodyUsed 只读 指示body是否被使用， 类型为Boolean Request.clone() 创建当前request的副本。 Request implements Body, so it also has the following methods available to it: Body.arrayBuffer() Returns a promise that resolves with an ArrayBuffer representation of the request body. Body.blob() Returns a promise that resolves with an Blob representation of the request body. Body.formData() Returns a promise that resolves with an FormData representation of the request body. Body.json() Returns a promise that resolves with an JSON representation of the request body. Body.text() Returns a promise that resolves with an USVString (text) representation of the request body. MDN-Fetch-requestResponse（构造器） 相当于请求的响应。 Response.type 只读 包含Response的类型 (例如, basic, cors). Response.url 只读 包含Response的URL. Response.useFinalURL 包含了一个布尔值来标示这是否是该Response的最终URL. Response.status 只读 包含Response的状态码 (例如, 200 成功). Response.ok 只读 包含了一个布尔值来标示该Response成功(状态码200-299) 还是失败. Response.redirected 只读 表示该Response是否来自一个重定向，如果是的话，它的URL列表将会有多个 Response.statusText 只读 包含了与该Response状态码一致的状态信息 (例如, OK对应200). Response.headers 只读 包含此Response所关联的Headers 对象. Response 实现了 Body, 所以以下属性同样可用: Body.bodyUsed 只读 包含了一个布尔值来标示该Response是否读取过Body. Response.clone() 创建一个Response对象的克隆 Response.error() 返回一个绑定了网络错误的新的Response对象 Response.redirect() 用另一个URL创建一个新的 response. Response 实现了 Body, 所以以下方法同样可用: Body.arrayBuffer() 读取 Response对象并且将它设置为已读（因为Responses对象被设置为了 stream 的方式，所以它们只能被读取一次） ,并返回一个被解析为ArrayBuffer格式的promise对象 Body.blob() 读取 Response对象并且将它设置为已读（因为Responses对象被设置为了 stream 的方式，所以它们只能被读取一次） ,并返回一个被解析为Blob格式的promise对象 Body.formData() 读取Response对象并且将它设置为已读（因为Responses对象被设置为了 stream 的方式，所以它们只能被读取一次） ,并返回一个被解析为FormData格式的promise对象 Body.json() 读取 Response对象并且将它设置为已读（因为Responses对象被设置为了 stream 的方式，所以它们只能被读取一次） ,并返回一个被解析为JSON格式的promise对象 Body.text() 读取 Response对象并且将它设置为已读（因为Responses对象被设置为了 stream 的方式，所以它们只能被读取一次） ,并返回一个被解析为USVString格式的promise对象 参数： 123456var myHeaders = new Headers();var myInit = &#123; method: &apos;GET&apos;, headers: myHeaders, mode: &apos;cors&apos;, cache: &apos;default&apos; &#125;; fetch(&apos;flowers.jpg&apos;,myInit) 返回值： Promise 对象 PS：就算是404也会返回promise resolved 还需要使用Response.ok 是不是为 true进一步判断。 2.同步和异步3.同源策略 作用：同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。 定义：同domain（或ip）,同端口，同协议视为同一个域，一个域内的脚本仅仅具有本域内的权限，可以理解为本域脚本只能读写本域内的资源，而无法访问其它域的资源。这种安全限制称为同源策略。 同源主要的限制： （1） Cookie、LocalStorage 和 IndexDB 无法读取。 （2） DOM和js对象无法获得。 （3） AJAX 请求不能发送。4.跟后端的数据交互的方式：JSON/XML，JS如何解析JSON为对象 // json字符串 var str1 = ‘{ “name”: “cxh”, “sex”: “man” }’; // json对象 var str2 = { “name”: “cxh”, “sex”: “man” }; // JSON字符串转换为JSON对象方法一 // var obj = eval(&apos;(&apos; + str1 + &apos;)&apos;); // JSON字符串转换为JSON对象方法二 // var obj = JSON.parse(str1) // JSON对象转换为JSON字符串方法一 JSON.stringify(str2) 对HTTP协议的理解1.常见的状态码 200 OK 301 Moved Permanently 302 Found 304 Not Modified 307 Temporary Redirect 400 Bad Request 401 Unauthorized 403 Forbidden 404 Not Found 410 Gone 500 Internal Server Error 501 Not Implemented 前端同学需要了解的通信知识2.常见的HTTP请求和响应 参考博客3.1同源策略限制了一下行为： 1.Cookie、LocalStorage 和 IndexDB 无法读取 2.DOM 和 JS 对象无法获取 3.Ajax请求发送不出去3.2解决跨域的方法 window.name + iframe location.hash + iframe jsonp（jsonp的原理和优缺点） 1.原理：动态创建script标签,利用script标签的src属性可以获取任何域下的js脚本,通过这个特性(也可以说漏洞),服务器端不在返回json格式,而是返回一段调用某个函数的js代码（该页面中存在该函数），在src中进行了调用，这样实现了跨域。 前面3中方式均只支持get方式 document.domain + iframe（跨子域） HTML5中postMessage方案 window.postMessage(msg,targetOrigin) window.addEventListener(‘message’,function(e) {} 跨域资源共享 CORS WebSocket协议跨域 后端主要配置，Access-Control-Allow-Origin node代理跨域 nginx代理跨域 详细请自行参考MDN相关文档 正确面对跨域，别慌4.JSONP请求如何取消？ 删除script标签（存在兼容性问题） 将callback函数置为空函数5.GET/POST方法的区别和使用场景 get只应该用于获取数据，post用于提交数据（存在副作用）。6.JavaScript模板引擎 Template.js pug Mustache 参考segmentfault7.JavaScript设计模式 javascript设计模式 Mobile Web重要概念 设备像素：设备屏幕的物理像素，对于任何设备来讲物理像素的数量是固定的。 CSS像素：这是一个抽象的像素概念，它是为web开发者创造的（是可以改变的，取决于用于是否缩放）。 设备像素比(DPR) = 设备像素个数 / 理想视口CSS像素个数(device-width) 最重要的两个视口，布局视口和理想 布局视口：移动端CSS布局的依据视口，即CSS布局会根据布局视口来计算。 理想视口，定义了理想视口的宽度，比如对于iphone5来讲，理想视口是320*568。但是最终作用的还是布局视口，因为我们的css是依据布局视口计算的，所以你可以这样理解理想视口：理想的布局视口。 下面这段代码可以告诉手机浏览器要把布局视口设为理想视口： 屏幕适配 – 主要是屏幕分辨率、尺寸、屏幕方向这些因素。 CSS3的媒体查询（media query） &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0&quot; /&gt; width=device-width - 布局视口等于理想视口 device-width - 设备的宽度 initial-scale - 初始的缩放比例 minimum-scale - 允许用户缩放到的最小比例 maximum-scale - 允许用户缩放到的最大比例 user-scalable - 用户是否可以手动缩放 &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no,email=no&quot; &gt; //禁止自动识别电话号码和邮箱 &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; &gt; //苹果手机：会删除默认的工具栏和菜单栏，网站开启对web app程序的支持 &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt; //苹果手机：在web app应用下状态条（屏幕顶部条）的颜色,默认值为default（白色），可以定为black（黑色）和black-translucent（灰色半透明）。 &lt;meta name=&quot;apple-touch-fullscreen&quot; content=&quot;yes&quot; /&gt; //苹果手机：如果把一个web app添加到了主屏幕中，那么从主屏幕中打开这个web app则全屏显示 &lt;link rel=&quot;apple-touch-icon&quot; href=&quot;/static/images/identity/HTML5_Badge_64.png&quot; /&gt; //苹果手机：将应用添加到手机主屏幕，会有一个icon可以直接进入重置部分css 12345678910111213141516171819202122232425262728293031body &#123; font: 16px/1.5 Helvetica, Arial; //这里是设置字体，Helvetica字体在移动端各系统都支持（都不支持微软雅黑） -webkit-text-size-adjust: none; //设置文本不会放大，普通网页在移动端打开文本是会跟随网页结构缩放的&#125;* &#123; -webkit-tap-highlight-color: transparent; //在一些手机上，如iphone，点击按钮等元素会出现点击态的背景色，设置为透明就看不出来了 -webkit-user-select:none; //设置元素内的文字及其子元素将不会被选中&#125;// 去除webkit的滚动条 ::-webkit-scrollbar&#123; display: none; &#125; div &#123; -webkit-overflow-scrolling : touch; &#125;// 去除button在ios上的默认样式 button &#123; -webkit-appearance: none; border-radius: 0; &#125;// placeholder元素样式的修改 input::-webkit-input-placeholder&#123;color:red;&#125; input:focus::-webkit-input-placeholder&#123;color:green;&#125;// 使用css3的transition、transform（translate、scale、rotate、skew）、或者animation来进行动画或过度。// 使用图片时，会发现图片下总是有大概4px的空白 img&#123;display:block&#125;； img&#123;vertical-align:top&#125; 事件 touchstart：当手指放在屏幕上触发; touchmove：当手指在屏幕上滑动时，连续地触发; touchend：当手指从屏幕上离开时触发; touchcancel： 当系统停止跟踪时触发; event.touches.length // 当前几个手指在触屏上 综合模块化1.对AMD、CMD（node.js）、UMD等规范的了解，以及ES6中关于模块的标准定义2.使用过常用的模块化框架：Requirejs、Seajs等3.使用模块化的方式，能够解决什么问题？ 命名空间冲突（全局变量覆盖） 文件依赖管理 立即执行函数 + 闭包(实现模块的基本方法)4.动态加载JavaScript有几种方式？ 1.使用document.write/writeln(）方式 document.writeln(““); 2.使用jquery getScript(url,callback)方法实现动态加载js文件 $.getScript(‘test.js’,function(){ // TODO… }); 3.动态改变已有script的src属性 4.使用原生js 动态创建script标签，并指定script的src属性 1234567891011121314151617181920212223242526function loadJs(url,callback)&#123; var script=document.createElement(&apos;script&apos;); script.type=&quot;text/javascript&quot;; if(typeof(callback)!=&quot;undefined&quot;)&#123; if(script.readyState)&#123; script.onreadystatechange=function()&#123; if(script.readyState == &quot;loaded&quot; || script.readyState == &quot;complete&quot;)&#123; script.onreadystatechange=null; callback(); &#125; &#125; &#125;else&#123; script.onload=function()&#123; callback(); &#125; &#125; &#125; script.src=url; document.body.appendChild(script);&#125;loadJs(&quot;test.js&quot;,function()&#123; // todo...&#125;); 5.用XHR取得要脚本的内容，再创建 Script 对象。 6.如何判断动态脚本是否加载完成 为scriptdom节点添加监听事件 onload 和 onreadystatechange 12345scriptDom.onload = scriptDom.onreadystatechange = function()&#123; // 这里处理了兼容性，不同浏览器 readyState 的值不一样 if(!this.readyState||this.readyState==&apos;loaded&apos;||this.readyState==&apos;complete&apos;)&#123; // todo...&#125; 5.动态加载CSS方法 1.导入css文件 @import url(style.css); 2.简单的在页面中加载一个外部CSS文件 document.createStyleSheet(cssFile); 3.用createElement方法创建CSS的Link标签7.分析依赖的方式 动态分析，也是运行时分析 本地编译分析出依赖链8.如何做好模块加载的性能优化 Promise参见阮一峰教程 MVVMAngularjsReact （重点）BabkboneVuejs （重点） 前端安全（XSS、CSRF等，攻击和防范方案）在项目中有遇到过前端方面的安全问题吗？什么是XSS、CSRF？常见的漏洞场景有哪些？如何防范XSS、CSRF网站登陆都加验证码是为了解决哪方面的安全问题？有没有更好的方案？ 性能优化1.请减少HTTP请求（代理模式合并http请求） 合并图片（css sprites），合并CSS和JS文件；图片较多的页面也可以使用 lazyLoad 等技术进行优化。2.请正确理解 Repaint重绘 和 Reflow重排3.减少DOM操作（缓存dom节点） 对DOM操作的代价是高昂的，这在网页应用中的通常是一个性能瓶颈。4.尽量使用json数据与后端交互而不是xml5.高效使用HTML标签和CSS样式 （语义化利于seo）6.使用CDN加速（内容分发网络）7.将CSS和JS放到外部文件中引用，CSS放头，JS放尾8.精简CSS和JS文件（压缩）9.压缩图片和使用图片Sprite技术10.注意控制Cookie大小和污染（使用storage代替） cookie会在每次http请求自动添加，有点浪费11.按需加载资源12.缓存（主要是http头部字段和service workers） 浏览器1.有哪几种浏览器内核 Trident – ie4-ie8 Gecko – 网景-firefox Presto – Opera（Opera现已改用Google Chrome的Blink内核） Webkit – Chrome、Safari2.排版引擎 KHTML WebCore3.浏览器兼容性 css前缀 js自带方法的适配 对各种资源的支持webP图片格式4.浏览器渲染页面的原理（不同浏览器不一样） DOM Tree：浏览器将HTML解析成树形的数据结构。 CSS Rule Tree：浏览器将CSS解析成树形的数据结构。 Render Tree: DOM和CSSOM合并后生成Render Tree。 layout: 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置。 painting: 按照算出来的规则，通过显卡，把内容画到屏幕上。 reflow（重排）和repaint（重绘） 参考5.浏览器检测和识别 根据浏览器特性来判断 根据UA来检测 – navigator.userAgent 字符串比较 框架1.框架的设计方案 2.解决哪些问题 前端架构设计前端架构是一系列工具和流程的集合，旨在提升前端代码质量，并实现高效、可持续的工作流。1.前端架构四个核心： ● 代码——如何实现系统架构中的HTML、CSS和JavaScript ● 流程——构建高效并且防止出错的工作流所需要的工具和流程 ● 测试——为网站搭建稳固基础 ● 文档——规划好系统设计蓝图2.前端架构师职责： ● 体系设计——清晰描绘产品和代码的最终形态 ● 工作规划——制定完整开发工作流 ● 监督跟进——保证项目高效率完成 跨终端开发1.响应性设计（Mobile web），Media Queries 栅格系统（bootstrap）具体实现float + width百分比 + @media query 松软盒子flex 具体实现flex布局 + width百分比 + @media query2.Hybird APP（PhoneGap、AppCan、Titanium等）大致的原理，以及解决的问题 Web App、Hybrid App、 Native App 原理：通过JSBridge,web页面可以调用Native的api,Native也可调用web页面的api或者通知H5页面回调。3.React Native 和 weex4.重构 主要考虑（性能优化和扩展性） 性能优化5.前端工程化 借助Node.js的功能（读写文件、搭建服务器、读写数据库等等）帮我们完成如图片、代码压缩、代码检测等事情。 模块化与组件化: npm, es6, react/angularjs 代码版本管理: git 代码风格管理: jscs, editorconfig 代码编译: babel, scss, imgmin, csssprit, inline-svg 代码质量管理 (QA): eslint, mocha 代码构建: webpack 项目脚手架: yeoman 持续集成/持续交付/持续部署: jenkins 本地化与国际化6.系统架构/设计 开放性问题 描述一个你遇到过的技术问题，你是如何解决的？ 是否有设计过通用的组件？请设计一个 Dialog（弹出层）等组件你会提供什么接口？调用过程是怎样的？可能会遇到什么细节问题？API visible – 对话框是否可见 title – 标题 closable – 是否显示右上角的关闭按钮 mask – 是否展示遮罩 maskClosable – 点击蒙层是否允许关闭 maskStyle – 遮罩样式 bodyStyle – Dialog body 样式 footer – 底部内容，当不需要默认底部按钮时，可以设为 footer={null} cancelText – 取消按钮文字 okText – 确认按钮文字 onCancel – 点击遮罩层或右上角叉或取消按钮的回调 onOk – 点击确定回调 zIndex 设置 Modal 的 z-index（特殊情况使用） 请描述一下你做过的哪个前端方面的功能让你特别有成就感 在制作一个Web应用或Web站点的过程中，你是如何考虑它的UI、安全性、高性能、SEO、可维护性以及技术因素的？ 说说最近最流行的一些东西吧？常去哪些网站？ 潜力（加分项） 熟悉一门非前端语言，并且有项目开发经验，包括且不限于C/C++/Python/PHP/Java/Ruby等 在Native开发上有相关的经验（iOS、Android）等 有自己的独立博客并且有自己的思考和总结性质的文章、github有自己维护的仓库并且活跃（即开源项目） 对技术的追求有热情，特别对新技术的敏感性，能够积极主动学习新技术，并且能够有实践性的应用，比如：HTML5、Nodejs、MVVM、Promise、React、React Native、Angular等等 有较好的产品意识，并且有积极推动业务进步并拿到结果的案例 主动性、逻辑性、沟通、协同等方面的软实力良好 项目管理PM角色的经历（团队合作、沟通、协调能力） 你对break和continue的理解break 关键字 break 主要用在循环语句或者 switch 语句中。 break 在循环语句中作用是跳出本层（并非本次）的循环。 break 在switch语句中作用是跳出该switch语句体。continue 关键字 continue 适用于任何循环语句中。作用是让程序立刻跳转到下一次循环的迭代。 在 for 循环中，continue 语句使程序立即跳转到更新语句i++。 在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端适配]]></title>
    <url>%2F2017%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D.html</url>
    <content type="text"><![CDATA[简单webApp的处理方案这种app是一种典型的弹性布局：关键元素高宽和位置都不变，只有容器元素在做伸缩变换。对于这类app，记住一个开发原则就好：文字流式，控件弹性，图片等比缩放。 网易的做法（以设计稿为640的计算，还有750等等）（1）先拿设计稿竖着的横向分辨率除以100得到body元素的宽度 如果设计稿基于iphone4/5，横向分辨率为640，body的width为640 / 100 = 6.4rem（2）布局时，设计图标注的尺寸除以100得到css中的尺寸 播放器高度为210px，写样式的时候css应该这么写：height: 2.1rem。之所以取一个100作为参照，就是为了这里计算rem的方便！（3）在dom ready以后，通过以下代码设置html的font-size。 document.documentElement.style.fontSize = document.documentElement.clientWidth / 6.4 + ‘px’; 这里的目的是保证，1rem等于100px，方便后面计算（4）font-size可能需要额外的媒介查询，并且font-size不能使用rem @media screen and (max-width:321px){ .m-navlist{font-size:15px} } @media screen and (min-width:321px) and (max-width:400px){ .m-navlist{font-size:16px} }PS：第一，需要设置视口 第二，当deviceWidth大于设计稿的横向分辨率时，html的font-size始终等于横向分辨率/body元素宽 var deviceWidth = document.documentElement.clientWidth; if(deviceWidth &gt; 640) deviceWidth = 640; document.documentElement.style.fontSize = deviceWidth / 6.4 + ‘px’; 第三，当物理分辨率大于1280时，应该去访问PC网站了。 淘宝的做法（1）动态设置viewport的scale var scale = 1 / devicePixelRatio; document.querySelector(‘meta[name=”viewport”]’).setAttribute(‘content’,’initial-scale=’ + scale + ‘, maximum-scale=’ + scale + ‘, minimum-scale=’ + scale + ‘, user-scalable=no’);（2）动态计算html的font-size document.documentElement.style.fontSize = document.documentElement.clientWidth / 10 + ‘px’;（3）布局的时候，各元素的css尺寸=设计稿标注尺寸/设计稿横向分辨率/10（4）font-size可能需要额外的媒介查询，并且font-size不使用rem，这一点跟网易是一样的。PS：第一，当设备竖着时横向物理分辨率大于1080时，应该去访问PC网站了。 淘宝开源的布局库lib-flexible详细介绍 整理于互联网]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>移动端, 布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用dos命令总结]]></title>
    <url>%2F2017%2F%E5%B8%B8%E7%94%A8dos%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[什么是DOS命令DOS命令，计算机术语，是指DOS操作系统的命令，是一种面向磁盘的操作命令，主要包括目录操作类命令、磁盘操作类命令、文件操作类命令和其它命令。 常用命令目录命令md/mkdir作用：创建一个子目录（make directory）。语法：md[C:][path]〈subPath〉 cd作用：改变或显示当前目录（change directory）。语法：cd [C:][path]PS：路径可以使用绝对路径和相对路径两种。 cd\ 表示退回到根目录。 cd.. 表示退回到上级目录。 如果只有cd而没有参数，则只显示当前路径。 注意：子目录中一定有两个“特殊目录”，即“.”“..”，其中一点表示当前目录，两点表示上一层目录。 从简单实用的角度来看，我们只要学会逐层进入（cd 下一层某目录名），和逐层退出（cd..）就可以解决所有问题。 rd作用：删除空子目录（remove directory）。语法：rd [c:][path]PS：rd是专门删除空子目录的命令。 del 删除文件命令。 注意两条：一是不能删除非空目录；二是不能删除当前目录。 dir作用：主要用来显示一个目录下的文件和子目录。(directory)语法：dir [C:][path][filename][/o][/s][/p][/w][/a]PS：斜杠表示后面的内容是参数。 /p 显示信息满一屏时，暂停显示，按任意键后显示下一屏 /o 排序显示。o后面可以接不同意义的字母 /w 只显示文件名目录名，每行五个文件名。即宽行显示 /s 将目录及子目录的全部目录文件都显示 /a 显示隐藏文件 path作用：设备可执行文件的搜索路径，只对文件有效。语法：path[盘符1：][路径1][盘符2：][路径2]…PS：当运行一个可执行文件时，dos会先在当前目录中搜索该文件，若找到则运行之；若找不到该文件，则根据path命令所设置的路径，顺序逐条地到目录中搜索该文件 tree作用：显示指定驱动器上所有目录路径和这些目录下的所有文件名。语法：tree [盘符：][/f][&gt;prn] deltree作用：删除目录树。语法：DELTREE [C1:][path1]PS：这个命令将整个指定目录树全部消灭，而不管它是否是只读、隐藏与否。使用应特别小心。它是一个危险命令。 tasklist作用：将整个计算机的进程显示出来，同任务管理器。语法：tasklist 磁盘命令format作用：磁盘格式化。语法：format〈盘符：〉[/s][/4][/q] unformat作用：对进行过格式化误操作丢失数据的磁盘进行恢复。语法：unformat〈盘符〉[/l][/u][/p][/test] chkdsk作用：显示磁盘状态、内存状态和指定路径下指定文件的不连续数目。语法：chkdsk [盘符：][路径][文件名][/f][/v]PS：PS：例如要检查A盘使用情况，就输入chkdsk A: ，检查c盘使用情况，就输入chkdsk C: ，如果直接输入chkdsk，就检查当前磁盘的使用情况。 diskcopy 作用：复制格式和内容完全相同的软盘。语法：diskcopy[盘符1：][盘符2：] label作用：建立、更改、删除磁盘卷标。语法：label[盘符：][卷标名] vol作用：查看磁盘卷标号。语法：vol[盘符：] scandisk作用：检测磁盘的fat表、目录结构、文件系统等是否有问题，并可将检测出的问题加以修复。语法：scandisk[盘符1：]{[盘符2：]…}[/all] defrag作用：整理磁盘，消除磁盘碎块。语法：defrag[盘符：][/f]PS：选用/f参数，将文件中存在盘上的碎片消除，并调整磁盘文件的安排，确保文件之间毫无空隙。从而加快读盘速度和节省磁盘空间。 sys作用：将当前驱动器上的dos系统文件io.sys,msdos.sys和command 传送到指定的驱动器上。语法：sys[盘符：] 文件命令copy作用：拷贝一个或多个文件到指定盘上。语法：copy [源盘][路径]（源文件名） [目标盘][路径](目标文件名） xcopy作用：复制指定的目录和目录下的所有文件连同目录结构。语法：xcopy [源盘：]〈源路径名〉[目标盘符：][目标路径名][/s][/v][/e]PS：xcopy是copy的扩展，可以把指定的目录连文件和目录结构一并拷贝，但不能拷贝隐藏文件和系统文件。 type作用：显示ascii码文件的内容。语法：type [C:][path][filename.ext]PS：type命令用来在屏幕上快速、简便地显示文本文件的内容，扩展名为TXT的文件是文本文件。 ren作用：对指定磁盘、目录中的一个文件或一组文件更改名称（rename）。语法：ren[盘符：][路径]〈旧文件名〉〈新文件名〉PS：改名操作只限于某个文件某组文件的名称，它不会更改文件所在的目录。 fc作用：比较文件的异同，并列出差异处。语法：fc[盘符：][路径名]〈文件名〉[盘符：][路径名][文件名][/a][/c][/n] attrib作用：修改指定文件的属性。语法：attrib[文件名][r][—r][a][—a][h][—h][—s] del作用：删除指定的文件。语法：del[盘符：][路径]〈文件名〉[/p] undelete作用：恢复被误删除文件。语法：undelete[盘符：][路径名]〈文件名〉[/dos][/list][/all] 其他命令 cls——清屏幕命令 ver查看系统版本号命令 date日期设置命令date[mm——dd——yy] time系统时钟设置命令time[hh：mm：ss：xx] mem显示系统的硬件和操作系统的状况。mem[/c][/f][/m][/p] msg显示系统的硬件和操作系统的状况。msg[/s] ping命令Ping命令的独特用法作用：Ping命令不仅可以测试网络是否通，而且还可以粗略的判断网络传输质量。语法：ping +空格+“IP地址或者域名” [-t][-l][-n]PS：-t：不停的Ping对方的机器，直到用户按Ctrl＋C键终止。因为如果想用Ping命令测试网络传输质量，至少要查看Ping命令三分钟到五分钟的结果。 -l：定义echo数据包大小。我们可以将数据包的大小定义在极限值附近，以此可以测试出网络传输质量的优劣，尤其是测试外网的传输质量，非常明显。 -n：在默认情况下，Ping命令一般都会发送四个数据包，通过这个命令可以自己定义发送的个数，对测试网络传输质量很有帮助。我们结合实例说明一下如何通过Ping命令的测试结果判断网络传输质量。 tracert命令的使用技巧作用：tracert命令可以测试路由器的工作是否正常（部分网站无法访问）。 我们根据返回的结果来判断，哪一个环节的网络出现了问题。语法：tracert +空格+“IP地址或者域名” 用netstat命令判断是否被攻击作用：netstat命令可以查看单位的网络是否被攻击。语法：netstat [-a][-n][-b]PS：-a：显示所有连接和监听端口 -n：以数字形式显示地址和端口号 -b：显示包含于创建每个连接或监听端口的可执行组件。另外，使用该参数之后，还可以显示占用TCP协议端口的一些程序名称 巧用ARP命令防范ARP病毒作用：Ping命令不仅可以测试网络是否通，而且还可以粗略的判断网络传输质量。语法：arp -s ip地址 MAC 灵活使用ipconfig命令作用：ipconfig这个命令查看计算机当前的网络配置信息。ps：Ipconfig /all：完全显示计算机的网络信息，IP地址、MAC地址及其他相关的信息，都可以显示出来。 Ipconfig /release：释放计算机当前获得的IP地址。对于使用动态IP地址的单位来说，如果发现机器无法上网，而计算机从DHCP服务器处获得的IP地址等相关信息不完全，可以将该地址释放。 Ipconfig /renew：从DHCP服务器重新获得IP地址。释放了IP地址及相关信息之后，必须重新获得一个IP地址，直接输入此命令之后，便可以从DHCP服务器处获得一个IP地址。如果不用此命令，要想重新获得一个IP地址信息，需要重新启动计算机或注销计算机才行。 其他 net 系列 tlist -t 以树行列表显示进程（为系统的附加工具，默认是没有安装的，在安装目录的support/tools文件夹内） kill -f 进程名 加-f参数后强制结束某进程（为系统的附加工具，默认是没有安装的，在安装目录的support/tools文件夹内） shutdownshutdown.exe -a 取消关机shutdown.exe -s 关机shutdown.exe -f 强行关闭应用程序。shutdown.exe -m \计算机名 控制远程计算机。shutdown.exe -i 显示图形用户界面，但必须是Shutdown的第一个参数。shutdown.exe -l 注销当前用户。shutdown.exe -r 关机并重启。shutdown.exe -t时间 设置关机倒计时。shutdown.exe -c”消息内容” 输入关机对话框中的消息内容（不能超127个字符）。示例： 电脑要在24:00关机 – at 24:00 Shutdown -s 倒计时的方式关机 – Shutdown.exe -s -t 7200 杂项nbtstat作用：该命令使用TCP/IP上的NetBIOS显示协议统计和当前TCP/IP连接，使用这个命令你可以得到远程主机的NETBIOS信息，比如用户名、所属的工作组、网卡的MAC地址等。在此我们就有必要了解几个基本的参数。PS：-a 使用这个参数，只要你知道了远程主机的机器名称，就可以得到它的NETBIOS信息（下同）。 -A 这个参数也可以得到远程主机的NETBIOS信息，但需要你知道它的IP。 -n 列出本地机器的NETBIOS信息。 netstat作用：这是一个用来查看网络状态的命令，操作简便功能强大。PS：-a 查看本地机器的所有开放端口，可以有效发现和预防木马，可以知道机器所开的服务等信息 这里可以看出本地机器开放有FTP服务、Telnet服务、邮件服务、WEB服务等。用法：netstat -a IP。 -r 列出当前的路由信息，告诉我们本地机器的网关、子网掩码等信息。用法：netstat -r IP。 tracert作用：跟踪路由信息，使用此命令可以查出数据从本地机器传输到目标主机所经过的所有途径，这对我们了解网络布局和结构很有帮助。 net作用：这个命令是网络命令中最重要的一个，必须透彻掌握它的每一个子命令的用法，因为它的功能实在是太强大了在这里，我们重点掌握几个常用的子命令。 net view使用此命令查看远程主机的所有共享资源。命令格式为net view \IP。 net use把远程主机的某个共享资源影射为本地盘符，图形界面方便使用。命令格式为net use x: \IP\sharename。 net start使用它来启动远程主机上的服务。用法：net start servername net stop入侵后发现远程主机的某个服务碍手碍脚，怎么办？利用这个命令停掉就ok了，用法和net start同。 net user查看和帐户有关的情况，包括新建帐户、删除帐户、查看特定帐户、激活帐户、帐户禁用等。1，net user abcd 1234 /add，新建一个用户名为abcd，密码为1234的帐户，默认为user组成员。2，net user abcd /del，将用户名为abcd的用户删除。3，net user abcd /active:no，将用户名为abcd的用户禁用。4，net user abcd /active:yes，激活用户名为abcd的用户。5，net user abcd，查看用户名为abcd的用户的情况 net localgroup 查看所有和用户组有关的信息和进行相关操作。 net time这个命令可以查看远程主机当前的时间。 at作用：这个命令的作用是安排在特定日期或时间执行某个特定的命令和程序。 用法：at time command \computer ftp作用：首先在命令行键入ftp回车，出现ftp的提示符，这时候可以键入“help”来查看帮助（任何DOS命令都可以使用此方法查看其帮助）。 1.ftp 2.open 主机IP ftp端口 3.录入用户名和密码，就可以进行相应操作了。 dir 跟DOS命令一样，用于查看服务器的文件，直接敲上dir回车，就可以看到此ftp服务器上的文件。 cd 进入某个文件夹。 get 下载文件到本地机器。 put 上传文件到远程服务器。这就要看远程ftp服务器是否给了你可写的权限了，如果可以，呵呵，该怎么 利用就不多说了，大家就自由发挥去吧。 delete 删除远程ftp服务器上的文件。这也必须保证你有可写的权限。 bye 退出当前连接。 quit 同上。 telnet作用：功能强大的远程登陆命令，几乎所有的入侵者都喜欢用它，屡试不爽。为什么？它操作简单，如同使用自己的机器一样，只要你熟悉DOS命令，在成功以administrator身份连接了远程机器后，就可以用它来**想干的一切了。下面介绍一下使用方法，首先键入telnet回车，再键入help查看其帮助信息。 特殊命令 向上箭头”↑”和向下箭头”↓”—–回看上一次执行的命令 “Ctrl+C” 组合键或”Break”键 —–中断操作 鼠标操作”标记” —————–用来选中文本 鼠标操作”粘贴” —————–用来把剪贴板内容粘贴到提示符下 程序进程作用：ntsd 是一条dos命令，功能是用于结束一些常规下结束不了的死进程。使用： 1.利用进程的PID结束进程 命令格式：ntsd -c q -p pid 命令范例：ntsd -c q -p 1332 （结束explorer.exe进程） 2.利用进程名结束进程 命令格式：ntsd -c q -pn .exe （.exe 为进程名，exe不能省） 命令范例：ntsd -c q -pn explorer.exe 3.taskkill结束进程 命令格式：taskkill /pid 1234 /f （ 也可以达到同样的效果） 参考文档： 20种常用的DOS命令小结 DOS中的PING命令的几种用法 百度文库-dos命令]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>dos命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript数据结构与算法]]></title>
    <url>%2F2017%2FJavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[数组及矩阵（二维数组）和多维数组（a, b 均为数组）最好使用数组存储一系列同一种数据类型的值（与其它语言保持一致）。数组的优点：可以直接访问数组的某一项（相对于链表）。数组的缺点：（在大多数语言中）数组的大小是固定的，从数组的起点或中间插入或移除项的成本很高，因为需要移动元素（尽管我们已经学过的JavaScript的 Array 类方法可以帮我们做这些事，但背后的情况同样是这样）。 改变原数组的方法模拟栈数据结构a.pop() 删除数组的最后一个元素并返回删除的元素。a.push(item1, item2, …, itemX) 向数组的末尾添加一个或更多元素，并返回新的长度。 模拟队列数据结构a.shift() 删除并返回数组的第一个元素。a.unshift(item1,item2, …, itemX) 可向数组的开头添加一个或更多元素，并返回新的长度。 排序相关方法a.sort(sortfunction) 方法用于对数组的元素进行排序。a.reverse() 用于颠倒数组中元素的顺序。 其它a.splice(index,howmany,item1,…..,itemX) 用于插入、删除或替换数组的元素。 参数说明：1.规定从何处添加/删除元素。2.删除多少元素。3.插入的项目。 这里返回类型为数组!!!a.copyWithin(target, start, end) 从数组的指定位置拷贝元素到数组的另一个指定位置中。 参数说明：1.复制到指定目标索引位置。2,3为复制的起始和结束位置。a.fill(value, start, end) 将一个固定值替换数组的元素。 PS：删除元素的方法，返回被删除的元素。 添加元素的方法，返回数组长度。 不操作原数组方法返回Boolean值的方法a.every(function(currentValue,index,arr), thisValue) 检测数值元素的每个元素是否都符合条件。a.some(function(currentValue,index,arr),thisValue) 用于检测数组中的元素是否满足指定条件（函数提供）。a.includes(searchElement, fromIndex) 判断该数组是否存在该数组中。 返回新数组的方法a.concat(b) 连接两个或更多的数组，并返回连接后的数组。a.filter(function(currentValue,index,arr), thisValue) 创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。a.slice(start, end) 可从已有的数组中返回选定的元素。a.map(function(currentValue,index,arr), thisValue) 返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。 返回数组中的某项索引值a.findIndex(function(currentValue, index, arr), thisValue) 返回符合传入测试（函数）条件的数组元素索引。a.indexOf(item,start) 返回某个指定的字符串值在字符串中首次出现的位置。a.lastIndexOf(item,start) 返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。 返回数组中的某项值a.find(function(currentValue, index, arr),thisValue) 返回传入一个测试条件（函数）符合条件的数组第一个元素。 输出为字符串的方法a.join(separator) 用于把数组中的所有元素通过分隔符转换一个字符串。a.toString() 返回已逗号分割元素的字符串。 其它对数组进行操作a.forEach(function(currentValue, index, arr), thisValue) （not return a new array! &amp; no return value!）对数组的每个元素执行一次提供的函数。a.reduce(function(total, currentValue, currentIndex, arr), initialValue) 将数组元素计算为一个值（从左到右）。a.reduceRight(function(total, currentValue, currentIndex, arr), initialValue) 将数组元素计算为一个值（从右到左）。Array方法参考手册 栈栈，一种具有特殊行为的数组，具有后进先出（LIFO）原则的有序集合。 （数组头部）栈底[]栈顶（数组尾部） 栈应该具有的方法push(element(s)) ：添加一个（或几个）新元素到栈顶。pop() ：移除栈顶的元素，同时返回被移除的元素。peek() ：返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）。isEmpty() ：如果栈里没有任何元素就返回 true ，否则返回 false 。clear() ：移除栈里的所有元素。size() ：返回栈里的元素个数。这个方法和数组的 length 属性很类似。 构建栈及相应的方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function Stack() &#123; // 使用数组来模拟栈 let items = []; // push方法 this.push = function(element)&#123; items.push(element); &#125;; // pop方法 this.pop = function()&#123; return items.pop(); &#125;; // peek方法 this.peek = function()&#123; return items[items.length-1]; // return items.slice().pop(); &#125;; // isEmpty方法 this.isEmpty = function()&#123; return items.length === 0; &#125;; // size方法 this.size = function()&#123; return items.length; &#125;; // clear方法 this.clear = function()&#123; items = []; &#125;; // print调试方法 this.print = function()&#123; console.log(items.toString()); &#125;;&#125;// 测试代码let stack1 = new Stack();stack1.print(); // &apos;&apos;stack1.push(1);stack1.print(); // &apos;1&apos;stack1.clear(); stack1.print(); // &apos;&apos; 栈的应用10进制转2进制1234567891011121314151617function divideBy2(decNumber)&#123; let remStack = new Stack(), rem, binaryString = &apos;&apos;; while (decNumber &gt; 0)&#123; //&#123;1&#125; rem = Math.floor(decNumber % 2); //&#123;2&#125; remStack.push(rem); //&#123;3&#125; decNumber = Math.floor(decNumber / 2); //&#123;4&#125; &#125; while (!remStack.isEmpty())&#123; //&#123;5&#125; binaryString += remStack.pop().toString(); &#125; return binaryString;&#125; 队列队列是遵循FIFO（First In First Out，先进先出，也称为先来先服务）原则的一组有序的项。 队列需要的方法enqueue(element(s)) ：向队列尾部添加一个（或多个）新的项。dequeue() ：移除队列的第一（即排在队列最前面的）项，并返回被移除的元素。front() ：返回队列中第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息——与 Stack 类的 peek 方法非常类似）。isEmpty() ：如果队列中不包含任何元素，返回 true ，否则返回 false 。size() ：返回队列包含的元素个数，与数组的 length 属性类似。 构建队列1234567891011121314151617181920212223242526272829303132333435function Queue() &#123; // 保存数据 let items = []; // enqueue方法 this.enqueue = function(element)&#123; items.push(element); &#125;; // dequeue 方法 this.dequeue = function()&#123; return items.shift(); &#125;; // front 方法 this.front = function()&#123; return items[0]; &#125;; // isEmpty 方法 this.isEmpty = function()&#123; return items.length === 0; &#125;; // size方法 this.size = function()&#123; return items.length; &#125;; // print 调试方法 this.print = function()&#123; console.log(items.toString()); &#125;;&#125; 优先队列可以设置优先级的队列12345678910111213141516171819202122232425262728293031323334353637function PriorityQueue() &#123; let items = []; function QueueElement (element, priority)&#123; // &#123;1&#125; this.element = element; this.priority = priority; &#125; this.enqueue = function(element, priority)&#123; var queueElement = new QueueElement(element, priority); if (this.isEmpty())&#123; items.push(queueElement); // &#123;2&#125; &#125; else &#123; var added = false; for (var i=0; i&lt;items.length; i++)&#123; if (queueElement.priority &lt; items[i].priority)&#123; items.splice(i,0,queueElement); // &#123;3&#125; added = true; break; // &#123;4&#125; &#125; &#125; if (!added)&#123; //&#123;5&#125; items.push(queueElement); &#125; &#125; &#125;; //其他方法和默认的Queue实现相同&#125;// 测试代码var priorityQueue = new PriorityQueue();priorityQueue.enqueue(&quot;John&quot;, 2);priorityQueue.enqueue(&quot;Jack&quot;, 1);priorityQueue.enqueue(&quot;Camila&quot;, 1);priorityQueue.print(); // Jack, Camila, John 循环队列–击鼓传花1234567891011121314151617181920212223function hotPotato (nameList, num)&#123; var queue = new Queue(); // &#123;1&#125; for (var i=0; i&lt;nameList.length; i++)&#123; queue.enqueue(nameList[i]); // &#123;2&#125; &#125; var eliminated = &apos;&apos;; while (queue.size() &gt; 1)&#123; for (var i=0; i&lt;num; i++)&#123; queue.enqueue(queue.dequeue()); // &#123;3&#125; &#125; eliminated = queue.dequeue();// &#123;4&#125; console.log(eliminated + &apos;在击鼓传花游戏中被淘汰。&apos;); &#125; return queue.dequeue();// &#123;5&#125;&#125;var names = [&apos;John&apos;,&apos;Jack&apos;,&apos;Camila&apos;,&apos;Ingrid&apos;,&apos;Carl&apos;];var winner = hotPotato(names, 7);console.log(&apos;胜利者：&apos; + winner); 链表链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。然而，链表需要使用指针，因此实现链表时需要额外注意。数组的另一个细节是可以直接访问任何位置的任何元素，而要想访问链表中间的一个元素，需要从起点（表头）开始迭代列表直到找到所需的元素。链表的优点：相对于传统的数组，链表的一个好处在于，添加或移除元素的时候不需要移动其他元素。链表的缺点：数组的另一个细节是可以直接访问任何位置的任何元素，而要想访问链表中间的一个元素，需要从起点（表头）开始迭代列表直到找到所需的元素。 创建一个链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146function LinkedList() &#123; // 表示要加入列表的项 let Node = function(element)&#123; // &#123;1&#125; this.element = element; // 填加到列表的值 this.next = null; // 列表中下一个节点项的引用 &#125;; let length = 0; // &#123;2&#125; // 用于存在第一个节点的引用 let head = null; // 取得链表首元素 this.getHead = function()&#123; return head; &#125;; // 向列表尾部添加一个新的项 this.append = function(element)&#123; let node = new Node(element); current; if (head === null) &#123; // 列表中第一节点 head = node; &#125; else &#123; current = head; // 循环列表，直到找到最后一项 wihle(current.next)&#123; current = current.next; &#125; // 找到最后一项，将其next赋值为node，建立链接 current.next = node; &#125; length++; // 链表长度加1 &#125;; // 向列表的特定位置插入一个新的项 this.insert = function(position, element)&#123; //检查越界值 if (position &gt;= 0 &amp;&amp; position &lt;= length)&#123; //&#123;1&#125; var node = new Node(element), current = head, previous, index = 0; if (position === 0)&#123; //在第一个位置添加 node.next = current; //&#123;2&#125; head = node; &#125; else &#123; while (index++ &lt; position)&#123; //&#123;3&#125; previous = current; current = current.next; &#125; node.next = current; //&#123;4&#125; previous.next = node; //&#123;5&#125; &#125; length++; //更新列表的长度 return true; &#125; else &#123; return false; //&#123;6&#125; &#125; &#125;; // 从列表的特定位置移除一项 this.removeAt = function(position)&#123; //检查越界值 if (position &gt; -1 &amp;&amp; position &lt; length)&#123; // &#123;1&#125; var current = head, // &#123;2&#125; previous, // &#123;3&#125; index = 0; // &#123;4&#125; //移除第一项 if (position === 0)&#123; // &#123;5&#125; head = current.next; &#125; else &#123; while (index++ &lt; position)&#123; // &#123;6&#125; previous = current; // &#123;7&#125; current = current.next; // &#123;8&#125; &#125; //将previous与current的下一项链接起来：跳过current，从而移除它 previous.next = current.next; // &#123;9&#125; &#125; length--; // &#123;10&#125; return current.element; &#125; else &#123; return null; // &#123;11&#125; &#125; &#125;; // 从列表中移除一项 this.remove = function(element)&#123; var index = this.indexOf(element); return this.removeAt(index); &#125;; // 返回元素在列表中的索引 this.indexOf = function(element)&#123; var current = head, //&#123;1&#125; index = -1; while (current) &#123; //&#123;2&#125; if (element === current.element) &#123; return index; //&#123;3&#125; &#125; index++; //&#123;4&#125; current = current.next; //&#123;5&#125; &#125; return -1; &#125;; // 如果链表中不包含任何元素，返回 true ，如果链表长度大于0则返回 false this.isEmpty = function() &#123; return length === 0; &#125;; // 返回链表包含的元素个数。与数组的 length 属性类似 this.size = function() &#123; return length; &#125;; // 由于列表项使用了 Node 类，就需要重写继承自JavaScript对象默认的toString 方法，让其只输出元素的值 this.toString = function()&#123; var current = head, //&#123;1&#125; string = &apos;&apos;; //&#123;2&#125; while (current) &#123; //&#123;3&#125; string = current.element; //&#123;4&#125; current = current.next; //&#123;5&#125; &#125; return string; //&#123;6&#125; &#125;; // 调试方法 this.print = function()&#123;&#125;;&#125; 双向链表双向链表的特点：双向链表和普通链表的区别在于，在链表中，一个节点只有链向下一个节点的链接，而在双向链表中，链接是双向的：一个链向下一个元素，另一个链向前一个元素。当我们访问链表项时，在单向链表中，如果迭代列表时错过了要找的元素，就需要回到列表起点，重新开始迭代。这是双向链表的一个优点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384function DoublyLinkedList()&#123; var Node = function(element)&#123; this.element = element; this.next = null; this.prev = null; //新增的 &#125;; var length = 0; var head = null; var tail = null; //新增的 this.insert = function(position, element)&#123; //检查越界值 if (position &gt;= 0 &amp;&amp; position &lt;= length)&#123; var node = new Node(element), current = head, previous, index = 0; if (position === 0)&#123; //在第一个位置添加 if (!head)&#123; //新增的 &#123;1&#125; head = node; tail = node; &#125; else &#123; node.next = current; current.prev = node; //新增的 &#123;2&#125; head = node; &#125; &#125; else if (position === length) &#123; //最后一项 //新增的 current = tail; // &#123;3&#125; current.next = node; node.prev = current; tail = node; &#125; else &#123; while (index++ &lt; position)&#123; //&#123;4&#125; previous = current; current = current.next; &#125; node.next = current; //&#123;5&#125; previous.next = node; current.prev = node; //新增的 node.prev = previous; //新增的 &#125; length++; //更新列表的长度 return true; &#125; else &#123; return false; &#125; &#125;; this.removeAt = function(position)&#123; //检查越界值 if (position &gt; -1 &amp;&amp; position &lt; length)&#123; var current = head, previous, index = 0; //移除第一项 if (position === 0)&#123; head = current.next; // &#123;1&#125; //如果只有一项，更新tail //新增的 if (length === 1)&#123; // &#123;2&#125; tail = null; &#125; else &#123; head.prev = null; // &#123;3&#125; &#125; &#125; else if (position === length-1)&#123; //最后一项 //新增的 current = tail; // &#123;4&#125; tail = current.prev; tail.next = null; &#125; else &#123; while (index++ &lt; position)&#123; // &#123;5&#125; previous = current; current = current.next; &#125; //将previous与current的下一项链接起来——跳过current previous.next = current.next; // &#123;6&#125; current.next.prev = previous; //新增的 &#125; length--; return current.element; &#125; else &#123; return null; &#125; &#125;;&#125; 循环链表单向循环链表的特点：循环链表和链表之间唯一的区别在于，最后一个元素指向下一个元素的指针（ tail.next ）不是引用 null ，而是指向第一个元素（ head ）。双向循环链表有指向 head 元素的 tail.next ，和指向 tail 元素的 head.prev 。 集合（es6的Set）集合的定义：集合是由一组无序且唯一（即不能重复）的项组成的。集合的操作：集合也有并集、交集、差集等基本操作。 创建一个集合12345678910111213141516171819202122232425262728293031323334353637function Set()&#123; let items = &#123;&#125;; // js对象不允许两个不同的属性，保证集合元素的唯一性 this.has = function(value)&#123; // 区别 in可以查找原型链而 hasOwnProperty方法只会查找自身 // return value in items; return items.hasOwnProperty(value); &#125;; this.add = function(value)&#123; if (!this.has(value)) &#123; items[value] = value; return ture; &#125; return false; &#125;; this.remove = function(value)&#123; if (this.has(value)) &#123; delete items[value]; return ture; &#125; return false; &#125;; this.clear = function()&#123; items = &#123;&#125;; &#125;; this.size = function()&#123; return Object.keys(items).length; &#125;; this.values = function()&#123; return Object.keys(items); &#125;;&#125; 集合操作并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。子集：验证一个给定集合是否是另一集合的子集。一下假设A、B为两个集合。 并集运算公式：A∪B = { x | x ∈ A∨x ∈ B }为Set类的union方法 12345678910111213// 思路先将原集合和新集合循环添加到并集合中this.union = function(otherSet)&#123; let unionSet = new Set(); let values = this.values(); for (let i = 0; i &lt; values.length; i++) &#123; unionSet.add(values[i]); &#125; values = otherSet.values(); for (let i = 0; i &lt; values.length; i++) &#123; unionSet.add(values[i]); &#125; return unionSet;&#125;; 交集运算公式：A∩B = { x | x ∈ A∧x ∈ B } 1234567891011this.intersection = function(otherSet)&#123; let intersectionSet = new Set(); let values = this.values(); for (let i = 0; i &lt; values.length; i++) &#123; if (otherSet.has(values[i])) &#123; intersectionSet.add(values[i]); &#125; &#125; return intersectionSet;&#125;; 差集计算公式：AB = { x | x ∈ A ∧ x  B } 1234567891011this.difference = function(otherSet)&#123; let differenceSet = new Set(); let values = this.values(); for (let i = 0; i &lt; values.length; i++) &#123; if (!otherSet.has(values[i])) &#123; differenceSet.add(values[i]); &#125; &#125; return differenceSet;&#125;; 子集运算公式：∀x { x ∈ A → x ∈ B } 12345678910111213this.subset = function(otherSet)&#123; if (this.size() &gt; otherSet.size()) &#123; return false; &#125; else &#123; values = this.values(); for (let i = 0; i &lt; values.length; i++) &#123; if (!otherSet.has(values[i])) &#123; return false; &#125; &#125; return true; &#125;&#125;; 字典（映射es6的Map）字典和散列表是用来存储唯一值（不重复的值）的数据结构。两者都是[键，值]的形式来存储数据 创建一个字典1234567891011121314151617181920212223242526272829303132333435363738394041function Dictionary()&#123; let items = &#123;&#125;; this.has = function(key)&#123; return key in items; &#125;; this.set = function(key, value)&#123; items[key] = value; &#125;; this.remove = function(key)&#123; if (this.has(key)) &#123; delete items[key]; return true; &#125; return false; &#125;; this.get = function(key)&#123; return this.has(key) ? items[key] : undefined; &#125;; this.values = function()&#123; let values = &#123;&#125;; for (let k in items) &#123; if (this.has(k)) &#123; values.push(items[k]); &#125; &#125; return values; &#125;; this.clear = function()&#123; items = &#123;&#125;; &#125;; this.getItems = function()&#123; return items; &#125;;&#125; 散列表散列算法的作用是尽可能快地在数据结构中找到一个值。使用散列函数，就知道值的具体位置，因此能够快速检索到该值。散列函数的作用是给定一个键值，然后返回值在表中的地址。 创建一个散列表12345678910111213141516171819202122232425function HashTable()&#123; var table = []; // 私有方法-散列函数 let loseloseHashCode = function(key)&#123; let hash = 0; for (let i = 0; i &lt; key.length; i++) &#123; hash += key.charCodeAt(i); &#125; return hash % 37; &#125;; this.put = function(key, value)&#123; let position = loseloseHashCode(key); console.log(position + &apos; - &apos; + key); //&#123;6&#125; table[position] = value; &#125;; this.get = function(key)&#123; return table[loseloseHashCode(key)]; &#125;; this.remove = function(key)&#123; table[loseloseHashCode(key)] = undefined; &#125;;&#125; 处理散列表的冲突（同名的地址覆盖）可以通过分离链接、线性探查和双散列法来解决冲突。 分离链接法定义：包括为散列表的每一个位置创建一个链表并将元素存储在里面。为了实现一个使用了分离链接的 HashTable 实例，我们需要一个新的辅助类来表示将要加入LinkedList 实例的元素。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162let ValuePair = function(key, value)&#123; this.key = key; this.value = value; this.toString = function() &#123; return &apos;[&apos; + this.key + &apos; - &apos; + this.value + &apos;]&apos;; &#125;&#125;;this.put = function(key, value)&#123; let position = loseloseHashCode(key); if (table[position] == undefined) &#123; table[position] = new LinkedList(); &#125; table[position].append(new ValuePair(key, value));&#125;;this.get = function(key)&#123; let position = loseloseHashCode(key); if (table[position] !== undefined) &#123; // 遍历链表来寻找键/值 let current = table[position].getHead(); while (current.next) &#123; if (current.elment.key === key) &#123; return current.element.value; &#125; current = current.next; &#125; // 检查元素在链表第一个或最后一个节点的情况 if (current.element.key === key)&#123; //&#123;9&#125; return current.element.value; &#125; &#125; return undefined;&#125;;this.remove = function(key)&#123; var position = loseloseHashCode(key); if (table[position] !== undefined)&#123; var current = table[position].getHead(); while(current.next)&#123; if (current.element.key === key)&#123; //&#123;11&#125; table[position].remove(current.element); //&#123;12&#125; if (table[position].isEmpty())&#123; //&#123;13&#125; table[position] = undefined; //&#123;14&#125; &#125; return true; //&#123;15&#125; &#125; current = current.next; &#125; // 检查是否为第一个或最后一个元素 if (current.element.key === key)&#123; //&#123;16&#125; table[position].remove(current.element); if (table[position].isEmpty())&#123; table[position] = undefined; &#125; return true; &#125; &#125; return false; //&#123;17&#125; &#125;; 线性探查当想向表中某个位置加入一个新元素的时候，如果索引为index的位置已经被占据了，就尝试index+1的位置。如果index+1的位置也被占据了，就尝试index+2的位置，以此类推。 123456789101112131415161718192021222324252627282930this.put = function(key, value)&#123; var position = loseloseHashCode(key); // &#123;1&#125; if (table[position] == undefined) &#123; // &#123;2&#125; table[position] = new ValuePair(key, value); // &#123;3&#125; &#125; else &#123; var index = ++position; // &#123;4&#125; while (table[index] != undefined)&#123; // &#123;5&#125; index++; // &#123;6&#125; &#125; table[index] = new ValuePair(key, value); // &#123;7&#125; &#125;&#125;;this.get = function(key) &#123; var position = loseloseHashCode(key); if (table[position] !== undefined)&#123; //&#123;8&#125; if (table[position].key === key) &#123; //&#123;9&#125; return table[position].value; //&#123;10&#125; &#125; else &#123; var index = ++position; while (table[index] === undefined || table[index].key !== key)&#123; //&#123;11&#125; index++; &#125; if (table[index].key === key) &#123; //&#123;12&#125; return table[index].value; //&#123;13&#125; &#125; &#125; &#125; return undefined; //&#123;14&#125;&#125;; 创建更好的散列函数比较好的散列函数，不会产生太多的冲突。 1234567var djb2HashCode = function (key) &#123; var hash = 5381; //&#123;1&#125; for (var i = 0; i &lt; key.length; i++) &#123; //&#123;2&#125; hash = hash * 33 + key.charCodeAt(i); //&#123;3&#125; &#125; return hash % 1013; //&#123;4&#125;&#125;; 树树，它对于存储需要快速查找的数据非常有用。树是一种分层数据的抽象模型。 树的相关术语位于树顶部的节点叫作根节点。树中的每个元素都叫作节点，节点分为内部节点和外部节点。至少有一个子节点的节点称为内部节点。没有子元素的节点称为外部节点或叶节点。有关树的另一个术语是子树。子树由节点和它的后代构成。树的高度取决于所有节点深度的最大值。 二叉树和二叉搜索树（BST）二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。这些定义有助于我们写出更高效的向树中插入、查找和删除节点的算法。二叉搜索树（BST）是二叉树的一种，但是它只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大（或者等于）的值。遍历一棵树是指访问树的每个节点并对它们进行某种操作的过程。访问树的所有节点有三种方式：中序、先序和后序。中序遍历 – 是以从最小到最大的顺序访问所有节点（第二层到第一层左中右）。先序遍历 – 是以优先于后代节点的顺序访问每个节点的（第一层到第二层中左右）。后序遍历 – 是先访问节点的后代节点，再访问节点本身（第二层到第一层左右中）。中序遍历的一种应用就是对树进行排序操作。先序遍历的一种应用是打印一个结构化的文档。后序遍历的一种应用是计算一个目录和它的子目录中所有文件所占空间的大小。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170function BinarySearchTree() &#123; let Node = function(key)&#123; this.key = key; this.left = null; this.right = null; &#125;; // 根节点 let root = null; // 插入节点，小的节点插入left，大的节点插入right let insertNode = function(node, newNode)&#123; if (newNode.key &lt; node.key) &#123; if (node.left === null) &#123; node.left = newNode; &#125; else &#123; insertNode(node.left, newNode); &#125; &#125; else &#123; if (node.right === null) &#123; node.right = newNode; &#125; else &#123; insertNode(node.right, newNode); &#125; &#125; &#125;; // 向树中插入一个新的键 this.insert = function (key)&#123; var newNode = new Node(key); //&#123;1&#125; if (root === null)&#123; //&#123;2&#125; root = newNode; &#125; else &#123; // 递归 insertNode(root,newNode); //&#123;3&#125; &#125; &#125;; // 私有方法-中序遍历 let inOrderTraverseNode = function(node, callback)&#123; if (node !== null) &#123; inOrderTraverseNode(node.left, callback); callback(node.key); inOrderTraverseNode(node.right, callback); &#125; &#125;; // 中序遍历（左中右）小到大 this.inOrderTraverse = function(callback)&#123; inOrderTraverseNode(root, callback); &#125;; // 私有方法-先序遍历 var preOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; callback(node.key); //&#123;1&#125; preOrderTraverseNode(node.left, callback); //&#123;2&#125; preOrderTraverseNode(node.right, callback); //&#123;3&#125; &#125; &#125;; // 先序遍历（中左右） this.preOrderTraverse = function(callback)&#123; preOrderTraverseNode(root, callback); &#125;; // 私有方法-后序遍历 var postOrderTraverseNode = function (node, callback) &#123; if (node !== null) &#123; postOrderTraverseNode(node.left, callback); //&#123;1&#125; postOrderTraverseNode(node.right, callback); //&#123;2&#125; callback(node.key); //&#123;3&#125; &#125; &#125;; // 后序遍历（左右中） this.postOrderTraverse = function(callback)&#123; postOrderTraverseNode(root, callback); &#125;; // 私有方法-最小值 let minNode = function(node)&#123; if (node) &#123; while (node &amp;&amp; node.left !== null) &#123; node = node.left &#125; return node.key; &#125; return null; &#125;; // 搜索最小值 this.min = function()&#123; return minNode(node); &#125;; // 私有方法-最大值 var maxNode = function (node) &#123; if (node)&#123; while (node &amp;&amp; node.right !== null) &#123; //&#123;5&#125; node = node.right; &#125; return node.key; &#125; return null; &#125; // 搜索最大值 this.max = function() &#123; return maxNode(root); &#125;; // 私有方法-搜索节点 var searchNode = function(node, key)&#123; if (node === null)&#123; //&#123;2&#125; return false; &#125; if (key &lt; node.key)&#123; //&#123;3&#125; return searchNode(node.left, key); //&#123;4&#125; &#125; else if (key &gt; node.key)&#123; //&#123;5&#125; return searchNode(node.right, key); //&#123;6&#125; &#125; else &#123; return true; //&#123;7&#125; &#125; &#125;; // 搜索节点 this.search = function(key)&#123; return searchNode(root, key); //&#123;1&#125; &#125;; // 私有方法-移除节点 var removeNode = function(node, key)&#123; if (node === null)&#123; //&#123;2&#125; return null; &#125; if (key &lt; node.key)&#123; //&#123;3&#125; node.left = removeNode(node.left, key); //&#123;4&#125; return node; //&#123;5&#125; &#125; else if (key &gt; node.key)&#123; //&#123;6&#125; node.right = removeNode(node.right, key); //&#123;7&#125; return node; //&#123;8&#125; &#125; else &#123; //键等于node.key //第一种情况——一个叶节点 if (node.left === null &amp;&amp; node.right === null)&#123; //&#123;9&#125; node = null; //&#123;10&#125; return node; //&#123;11&#125; &#125; //第二种情况——一个只有一个子节点的节点 if (node.left === null)&#123; //&#123;12&#125; node = node.right; //&#123;13&#125; return node; //&#123;14&#125; &#125; else if (node.right === null)&#123; //&#123;15&#125; node = node.left; //&#123;16&#125; return node; //&#123;17&#125; &#125; //第三种情况——一个有两个子节点的节点 var aux = findMinNode(node.right); //&#123;18&#125; node.key = aux.key; //&#123;19&#125; node.right = removeNode(node.right, aux.key); //&#123;20&#125; return node; //&#123;21&#125; &#125; &#125;; // 移除节点 this.remove = function(key)&#123; root = removeNode(root, key); //&#123;1&#125; &#125;; &#125; 更多关于二叉树的知识BST存在一个问题：取决于你添加的节点数，树的一条边可能会非常深 有一种树叫作阿德尔森-维尔斯和兰迪斯树（AVL树）。AVL树是一种自平衡二叉搜索树，意思是任何一个节点左右两侧子树的高度之差最多为1。相关知识：红黑树、堆积树 图图的相关术语图是网络结构的抽象模型。图是一组由边连接的节点（或顶点）。任何二元关系都可以用图来表示。一个图G = (V, E)由以下元素组成。 V：一组顶点 E：一组边，连接V中的顶点相邻顶点：由一条边连接在一起的顶点称为相邻顶点。顶点的度：一个顶点的度是其相邻顶点的数量。路径：路径是顶点v 1 , v 2 ,…,v k 的一个连续序列，其中v i 和v i+1 是相邻的。图是无环：如果图中不存在环，则称该图是无环的。图是连通：如果图中每两个顶点间都存在路径，则该图是连通的。有向图和无向图：图可以是无向的（边没有方向）或是有向的（有向图）。图是强连通：如果图中每两个顶点间在双向上都存在路径，则该图是强连通的。图是加权：图还可以是未加权的或是加权的。 图的表示邻接矩阵每个节点都和一个整数相关联，该整数将作为数组的索引。我们用一个二维数组来表示顶点之间的连接。如果索引为i的节点和索引为j的节点相邻，则array[i][j]=== 1，否则array[i][j] === 0存在的问题：不是强连通的图（稀疏图）如果用邻接矩阵来表示，则矩阵中将会有很多0，这意味着我们浪费了计算机存储空间来表示根本不存在的边。 邻接表邻接表由图中每个顶点的相邻顶点列表所组成。存在好几种方式来表示这种数据结构。我们可以用列表（数组）、链表，甚至是散列表或是字典来表示相邻顶点列表。 关联矩阵在关联矩阵中，矩阵的行表示顶点，列表示边。我们使用二维数组来表示两者之间的连通性，如果顶点v是边e的入射点，则array[v][e] === 1；否则，array[v][e] === 0。 使用场景：关联矩阵通常用于边的数量比顶点多的情况下，以节省空间和内存。 创建图类12345678910111213141516function Graph()&#123; let vertices = []; let adjList = new Dictionary(); // 添加顶点，参数为一个顶点 this.addVertex = function(v)&#123; vertices.push(v); adjList.set(v, []); &#125;; // 添加顶点之间的边，参数为两个顶点 this.addEdge = function(v, w)&#123; adjList.get(v).push(w); adjList.get(w).push(v); &#125;;&#125; 字典将会使用顶点的名字作为键，邻接顶点列表作为值。vertices数组和 adjList 字典两者都是我们 Graph 类的私有属性。 图的遍历有两种算法可以对图进行遍历：广度优先搜索（Breadth-First Search，BFS）和深度优先搜索（Depth-First Search，DFS）。图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径，检查图是否连通，检查图是否含有环等。深度优先搜索 栈 通过将顶点存入栈中，顶点是沿着路径被探索的，存在新的相邻点就去访问广度优先搜索 队列 通过将顶点存入队列中，最先入队列的顶点先被探索 广度优先搜索广度优先搜索算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访问图的一层。先宽后深地访问顶点。 12345678910111213141516171819202122232425262728var initializeColor = function()&#123; var color = []; for (var i=0; i&lt;vertices.length; i++)&#123; color[vertices[i]] = &apos;white&apos;; //&#123;1&#125; &#125; return color;&#125;;this.bfs = function(v, callback)&#123; var color = initializeColor(), //&#123;2&#125; queue = new Queue(); //&#123;3&#125; queue.enqueue(v); //&#123;4&#125; while (!queue.isEmpty())&#123; //&#123;5&#125; var u = queue.dequeue(), //&#123;6&#125; neighbors = adjList.get(u); //&#123;7&#125; color[u] = &apos;grey&apos;; // &#123;8&#125; for (var i=0; i&lt;neighbors.length; i++)&#123; // &#123;9&#125; var w = neighbors[i]; // &#123;10&#125; if (color[w] === &apos;white&apos;)&#123; // &#123;11&#125; color[w] = &apos;grey&apos;; // &#123;12&#125; queue.enqueue(w); // &#123;13&#125; &#125; &#125; color[u] = &apos;black&apos;; // &#123;14&#125; if (callback) &#123; // &#123;15&#125; callback(u); &#125; &#125;&#125;; 1.使用BFS寻找最短路径 123456789101112131415161718192021222324252627282930this.BFS = function(v)&#123; var color = initializeColor(), queue = new Queue(), d = [], //&#123;1&#125; pred = []; //&#123;2&#125; queue.enqueue(v); for (var i=0; i&lt;vertices.length; i++)&#123; //&#123;3&#125; d[vertices[i]] = 0; //&#123;4&#125; pred[vertices[i]] = null; //&#123;5&#125; &#125; while (!queue.isEmpty())&#123; var u = queue.dequeue(), neighbors = adjList.get(u); color[u] = &apos;grey&apos;; for (i=0; i&lt;neighbors.length; i++)&#123; var w = neighbors[i]; if (color[w] === &apos;white&apos;)&#123; color[w] = &apos;grey&apos;; d[w] = d[u] + 1; //&#123;6&#125; pred[w] = u; //&#123;7&#125; queue.enqueue(w); &#125; &#125; color[u] = &apos;black&apos;; &#125; return &#123; //&#123;8&#125; distances: d, predecessors: pred &#125;;&#125;; 2.深入学习最短路径算法 如果要计算加权图中的最短路径（例如，城市A和城市B之间的最短路径——GPS和Google Maps中用到的算法） 深度优先搜索12345678910111213141516171819202122this.dfs = function(callback)&#123; var color = initializeColor(); //&#123;1&#125; for (var i=0; i&lt;vertices.length; i++)&#123; //&#123;2&#125; if (color[vertices[i]] === &apos;white&apos;)&#123; //&#123;3&#125; dfsVisit(vertices[i], color, callback); //&#123;4&#125; &#125; &#125;&#125;;var dfsVisit = function(u, color, callback)&#123; color[u] = &apos;grey&apos;; //&#123;5&#125; if (callback) &#123; //&#123;6&#125; callback(u); &#125; var neighbors = adjList.get(u); //&#123;7&#125; for (var i=0; i&lt;neighbors.length; i++)&#123; //&#123;8&#125; var w = neighbors[i]; //&#123;9&#125; if (color[w] === &apos;white&apos;)&#123; //&#123;10&#125; dfsVisit(w, color, callback); //&#123;11&#125; &#125; &#125; color[u] = &apos;black&apos;; //&#123;12&#125;&#125;; 1.探索深度优先算法 123456789101112131415161718192021222324252627282930313233343536373839var time = 0; //&#123;1&#125;this.DFS = function()&#123; var color = initializeColor(), //&#123;2&#125; d = [], f = [], p = []; time = 0; for (var i=0; i&lt;vertices.length; i++)&#123; //&#123;3&#125; f[vertices[i]] = 0; d[vertices[i]] = 0; p[vertices[i]] = null; &#125; for (i=0; i&lt;vertices.length; i++)&#123; if (color[vertices[i]] === &apos;white&apos;)&#123; DFSVisit(vertices[i], color, d, f, p); &#125; &#125; return &#123; //&#123;4&#125; discovery: d, finished: f, predecessors: p &#125;;&#125;;var DFSVisit = function(u, color, d, f, p)&#123; console.log(&apos;discovered &apos; + u); color[u] = &apos;grey&apos;; d[u] = ++time; //&#123;5&#125; var neighbors = adjList.get(u); for (var i=0; i&lt;neighbors.length; i++)&#123; var w = neighbors[i]; if (color[w] === &apos;white&apos;)&#123; p[w] = u; // &#123;6&#125; DFSVisit(w,color, d, f, p); &#125; &#125; color[u] = &apos;black&apos;; f[u] = ++time; //&#123;7&#125; console.log(&apos;explored &apos; + u);&#125;; 2.拓扑排序——使用深度优先搜索 排序和搜索排序排序算法冒泡排序 选择排序 插入排序 归并排序 快速排序 算法我这里就不再多讲了，如果感兴趣可以查看我之前的系列算法文章 搜索排序顺序排序12345678this.sequentialSearch = function(item)&#123; for (var i=0; i&lt;array.length; i++)&#123; //&#123;1&#125; if (item === array[i]) //&#123;2&#125; return i; //&#123;3&#125; &#125; &#125; return -1; //&#123;4&#125;&#125;; 二分搜索(1) 选择数组的中间值。(2) 如果选中值是待搜索值，那么算法执行完毕（值找到了）。(3) 如果待搜索值比选中值要小，则返回步骤1并在选中值左边的子数组中寻找。(4) 如果待搜索值比选中值要大，则返回步骤1并在选种值右边的子数组中寻找。 123456789101112131415161718this.binarySearch = function(item)&#123; this.quickSort(); //&#123;1&#125; var low = 0, //&#123;2&#125; high = array.length - 1, //&#123;3&#125; mid, element; while (low &lt;= high)&#123; //&#123;4&#125; mid = Math.floor((low + high) / 2); //&#123;5&#125; element = array[mid]; //&#123;6&#125; if (element &lt; item) &#123; //&#123;7&#125; low = mid + 1; //&#123;8&#125; &#125; else if (element &gt; item) &#123; //&#123;9&#125; high = mid - 1; //&#123;10&#125; &#125; else &#123; return mid; //&#123;11&#125; &#125; &#125; return -1; //&#123;12&#125;&#125;; 算法补充知识递归每款浏览器的javascript调用栈大小的限制。 ECMAScript 6有尾调用优化（tail call optimization），使递归变快了。 斐波那契数列 动态规划动态规划（Dynamic Programming，DP）是一种将复杂问题分解成更小的子问题来解决的优化技术。 贪心算法贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择（当前最好的解），从而达到全局的最优（全局最优解）。它不像动态规划那样计算更大的格局。 大 O 表示法时间复杂度O(n)的代码只有一层循环，而O(n 2 )的代码有双层嵌套循环。如果算法有三层遍历数组的嵌套循环，它的时间复杂度很可能就是O(n 3 )。 总结序列数据结构1.数组（列表）2.栈3.队列&nbsp;&nbsp;普通队列&nbsp;&nbsp;优先队列&nbsp;&nbsp;循环队列4.链表&nbsp;&nbsp;单向链表&nbsp;&nbsp;双向链表&nbsp;&nbsp;循环单向链表&nbsp;&nbsp;循环双向链表5.集合 Set 非序列数据结构1.散列2.字典 Map]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法-总结性文章]]></title>
    <url>%2F2017%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%80%BB%E7%BB%93%E6%80%A7%E6%96%87%E7%AB%A0.html</url>
    <content type="text"><![CDATA[排序算法的基本概念什么叫排序？排序(Sorting) 是计算机程序设计中的一种重要操作，它的功能是将一个数据元素（或记录）的任意序列，重新排列成一个关键字有序的序列。 排序算法的性质稳定性稳定的算法，就是当有两个相等记录的关键字R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。反之，不稳定的算法，就是当有两个相等记录的关键字R和S，且在原本的列表中R出现在S之前，在排序过的列表中S在R之前。 时间复杂度（最差、平均、和最好性能）T(n)一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称O(f(n))为算法的渐进时间复杂度(O是数量级的符号 )，简称时间复杂度。 T(n) = O(f(n))一般而言，好的性能是 O(nlogn)，且坏的性能是 O(n^2)。对于一个排序理想的性能是 O(n)。查看时间复杂度计算方式 空间复杂度S(n)空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。 排序方式内排序：所有排序操作都在内存中完成。外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行。更多详情 先来张总结性图片 冒泡排序（Bubble Sort）定义它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（尾部），故名。 实现步骤1.比较相邻的元素。如果第一个比第二个大，就交换他们两个。2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。3.针对所有的元素重复以上的步骤，除了最后一个（因为每次最后遍历的最后一个数都是最大的，所以不需要再次比较了）。4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。或许你还是不太了解，这里有该算法的详细实现过程 选择排序（Selection Sort）定义选择排序法是对定位比较交换法（也就是冒泡排序法）的一种改进。选择排序的基本思想是：每一趟在n-i+1（i=1，2，…n-1）个记录中选取关键字最小的记录作为有序序列中第i个记录。基于此思想的算法主要有简单选择排序、树型选择排序和堆排序。 实现步骤1.第1趟，在待排序记录r[0]~r[n-1]中选出最小的记录，将它与r[0]交换，2.第2趟，在待排序记录r[1]~r[n-1]中选出最小的记录，将它与r[1]交换，3.以此类推…4.第i趟，在待排序记录r[i-1]~r[n-1]中选出最小的记录，将它与r[i-1]交换，5.使有序序列不断增长直到全部排序完毕。PS：冒泡排序是逐次把当前序列中最大值推到后面去。 选择排序是逐次把当前序列中最小值放到前面去。或许你还是不太了解，这里有该算法的详细实现过程 插入排序（Insertion Sort）定义每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。包括：直接插入排序，二分插入排序（又称折半插入排序），链表插入排序，希尔排序（又称缩小增量排序）。 直接插入排序实现步骤n个记录的文件的直接选择排序可经过n-1趟直接选择排序得到有序结果：①初始状态：无序区为R[1..n]，有序区为空。②第1趟排序在无序区R[1..n]中选出关键字最小的记录R[k]，将它与无序区的第1个记录R[1]交换，使R[1..1]和R[2..n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。……③第i趟排序第i趟排序开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。或许你还是不太了解，这里有该算法的详细实现过程 二分法排序定义二分法插入排序是在插入第i个元素时，对前面的0～i-1元素进行折半，先跟他们中间的那个元素比，如果小，则对前半再进行折半，否则对后半进行折半，直到left&lt;right，然后再把第i个元素前1位与目标位置之间的所有元素后移，再把第i个元素放在目标位置上。 实现步骤1.二分法查找插入位置 如果R&lt;R[m]成立，那右指针就要向左移动中间指针一位，否则，左指针要向右移动中间指针一位。反复查找，直到左指针大于右指针时停止。2.后移，有点迷惑，什么时候需要后移呢？有哪些记录需要移动呢？ 虽然我们很清楚的知道，我们需要后移那些排序码大于R的记录，但难免会问自己这样几个问题。其实它相当于需要移动从i-1到左指针的记录。3.插入 由1中得到的左指针其实就是元素要插入的位置。或许你还是不太了解，这里有该算法的详细实现过程 希尔排序（Shell Sort）定义先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量 =1( &lt; …&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止。 实现步骤对数组arr，长度为n进行排序1.第一个增量为Math.floor(n/2)，再最每个小的分租进行直接插入排序；2.第二个增量为Math.floor(n/4)，再最每个小的分租进行直接插入排序；3.以此类推…，直到增量为1，这是排序完成。或许你还是不太了解，这里有该算法的详细实现过程 归并排序（Merge Sort）定义归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 实现步骤1.申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列2.设定两个指针，最初位置分别为两个已经排序序列的起始位置3.比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置重复步骤3直到某一指针超出序列尾将另一序列剩下的所有元素直接复制到合并序列尾,这时完成排序。或许你还是不太了解，这里有该算法的详细实现过程 快速排序（Quicksort）定义通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 实现步骤一趟快速排序的算法是：排序序列A，N为排序序列长度1.找基准（一般是以当前数组的第一项的值）2.遍历数组，小于基准的放在left，大于基准的放在right3.递归（再分别对数组 left 和 right 1,2步骤，直到不能再分组为止）或许你还是不太了解，这里有该算法的详细实现过程 堆排序(Heapsort)定义堆排序是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。 实现步骤1.将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；2.将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；3.由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。或许你还是不太了解，这里有该算法的详细实现过程 计数排序定义计数排序的基本思想是对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有17个元素的值小于x的值，则x可以直接存放在输出序列的第18个位置上。当然，如果有多个元素具有相同的值时，我们不能将这些元素放在输出序列的同一个位置上，因此，上述方案还要作适当的修改。 实现步骤1.找出待排序的数组中最大和最小的元素；2.统计数组中每个值为i的元素出现的次数，存入数组C的第i项；3.对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；4.反向填充目标数组：将每个元素i放在新数组的第C[i]项，每放一个元素就将C[i]减去1。或许你还是不太了解，这里有该算法的详细实现过程 桶排序 (Bucket SORT）定义输入是由一个随机过程产生的[0, 1)区间上均匀分布的实数。将区间[0, 1)划分为n个大小相等的子区间（桶），每桶大小1/n：[0, 1/n)， [1/n, 2/n)， [2/n, 3/n)，…，[k/n, (k+1)/n )，…将n个输入元素分配到这些桶中，对桶中元素进行排序，然后依次连接桶输入0 ≤A[1..n] &lt;1辅助数组B[0..n-1]是一指针数组，指向桶（链表）。 实现步骤1.找出排序数组 arr 中最小值min和最大值max，并设定用来排序的桶的数量 N。2.计算出每个桶中的数据范围为 L = (max - min)/N。3.再计算出 N 个桶的数值范围，如第一个桶[min, min + L),第二个桶[min + L, min + 2L),依次类推…4.将数组arr分配到相应的桶中，再在每个桶的数据进行排序（一般插入排序就可）。5.将桶中的数据依次取出放入新数组，这时新数组就是排好序的数组了。或许你还是不太了解，这里有该算法的详细实现过程 基数排序（Radix Sort）定义基数排序属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。 实现步骤 首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中。以下红色字体代表桶编号得到：01 812 223 73 93 434 145 55 65678 289 39再将这些桶子中的数值重新串接起来，成为以下的数列。81, 22, 73, 93, 43, 14, 55, 65, 28, 39 接着再进行一次分配，这次是根据十位数来分配01 142 22 283 394 435 556 657 738 819 93接下来将这些桶子中的数值重新串接起来，成为以下的数列：14, 22, 28, 39, 43, 55, 65, 73, 81, 93或许你还是不太了解，这里有该算法的详细实现过程 总结这些算法我还记得在大学时学过的，只不过当然并没有太在意，这也许就是–欠下的债，终究是要还的。]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法-基数排序]]></title>
    <url>%2F2017%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[基数排序（radix sort）的基础技术排序的定义：基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。 基数排序步骤以LSD为例，排序数组arr = [73, 22, 93, 43, 55, 14, 28, 65, 39, 81]; 注：最低位优先(Least Significant Digit first)法，简称LSD法 最高位优先(Most Significant Digit first)法，简称MSD法 首先根据个位数的数值，在走访数值时将它们分配至编号0到9的桶子中。以下红色字体代表桶编号得到：01 812 223 73 93 434 145 55 65678 289 39再将这些桶子中的数值重新串接起来，成为以下的数列。81, 22, 73, 93, 43, 14, 55, 65, 28, 39 接着再进行一次分配，这次是根据十位数来分配01 142 22 283 394 435 556 657 738 819 93接下来将这些桶子中的数值重新串接起来，成为以下的数列：14, 22, 28, 39, 43, 55, 65, 73, 81, 93这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至最高位数为止。PS：LSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好。MSD的方式与LSD相反，是由高位数为基底开始进行分配，但在分配之后并不马上合并回一个数组中，而是在每个“桶子”中建立“子桶”，将每个桶子中的数值按照下一数位的值分配到“子桶”中。在进行完最低位数的分配后再合并回单一的数组中。 代码实现123456789101112131415161718192021222324252627282930313233343536373839/** * 基数排序适用于： * (1)数据范围较小，建议在小于1000 * (2)每个数值都要大于等于0 * @param arr 待排序数组 * @param maxDigit 最大位数 *///LSD Radix Sortfunction radixSort(array, maxDigit) &#123; var mod = 10; var dev = 1; var counter = []; var arr = array.slice(); console.time(&apos;基数排序耗时&apos;); for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123; for(var j = 0; j &lt; arr.length; j++) &#123; var bucket = parseInt((arr[j] % mod) / dev); if(counter[bucket]== null) &#123; counter[bucket] = []; &#125; counter[bucket].push(arr[j]); &#125; var pos = 0; for(var j = 0; j &lt; counter.length; j++) &#123; var value = null; if(counter[j]!=null) &#123; while ((value = counter[j].shift()) != null) &#123; arr[pos++] = value; &#125; &#125; &#125; &#125; console.timeEnd(&apos;基数排序耗时&apos;); return arr;&#125;var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];var demo = radixSort(arr,2);console.log(arr); // [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];console.log(demo); // [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]; 动图展示 参考文档： JS的十大经典算法排序 十大经典排序算法 基数排序]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法-桶排序]]></title>
    <url>%2F2017%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%A1%B6%E6%8E%92%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[桶排序的基础桶排序的定义：假定：输入是由一个随机过程产生的[0, 1)区间上均匀分布的实数。将区间[0, 1)划分为n个大小相等的子区间（桶），每桶大小1/n：[0, 1/n)， [1/n, 2/n)， [2/n, 3/n)，…，[k/n, (k+1)/n )，…将n个输入元素分配到这些桶中，对桶中元素进行排序，然后依次连接桶输入0 ≤A[1..n] &lt;1辅助数组B[0..n-1]是一指针数组，指向桶（链表）。桶排序的说明：桶排序 (Bucket sort)或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（O(n)）。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。 桶排序的步骤1. 找出排序数组 arr 中最小值min和最大值max，并设定用来排序的桶的数量 N。2. 计算出每个桶中的数据范围为 L = (max - min)/N。3. 再计算出 N 个桶的数值范围，如第一个桶[min, min + L),第二个桶[min + L, min + 2L),依次类推…4. 将数组arr分配到相应的桶中，再在每个桶的数据进行排序（一般插入排序就可）。5. 将桶中的数据依次取出放入新数组，这时新数组就是排好序的数组了。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 插入排序function insertionSort(arr) &#123; var len = arr.length; var preIndex, current; for (var i = 1; i &lt; len; i++) &#123; preIndex = i - 1; current = arr[i]; while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123; arr[preIndex+1] = arr[preIndex]; preIndex--; &#125; arr[preIndex+1] = current; &#125; return arr;&#125;// 桶排序function bucketSort(array, bucketSize) &#123; let arr = array.slice(); let i; let minValue = arr[0]; let maxValue = arr[0]; // 空数组时直接返回空数组 if (arr.length === 0) &#123; return arr; &#125; for (i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &lt; minValue) &#123; minValue = arr[i]; //输入数据的最小值 &#125; else if (arr[i] &gt; maxValue) &#123; maxValue = arr[i]; //输入数据的最大值 &#125; &#125; // 桶的初始化 let DEFAULT_BUCKET_SIZE = 5; //设置桶的默认数量为5 bucketSize = bucketSize || DEFAULT_BUCKET_SIZE; let bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; let buckets = new Array(bucketCount); // 二维数组，每个桶初始化为空数组 for (i = 0; i &lt; buckets.length; i++) &#123; buckets[i] = []; &#125; // 利用映射函数将数据分配到各个桶中 for (i = 0; i &lt; arr.length; i++) &#123; buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]); &#125; arr.length = 0; for (i = 0; i &lt; buckets.length; i++) &#123; insertionSort(buckets[i]); //对每个桶进行插入排序 for (var j = 0; j &lt; buckets[i].length; j++) &#123; arr.push(buckets[i][j]); &#125; &#125; return arr;&#125;let arr = [63,157,189,51,101,47,141,121,157,156,194,117,98,139,67,133,181,13,28,109];var demo = bucketSort(arr, 4); // 这里我分配了4个桶，桶越多越快但需要的内存就越多console.log(arr); // [63, 157, 189, 51, 101, 47, 141, 121, 157, 156, 194, 117, 98, 139, 67, 133, 181, 13, 28, 109]console.log(demo); // [13, 28, 47, 51, 63, 67, 98, 101, 109, 117, 121, 133, 139, 141, 156, 157, 157, 181, 189, 194] PS：桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点： 在额外空间充足的情况下，尽量增大桶的数量 使用的映射函数能够将输入的N个数据均匀的分配到K个桶中同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。什么时候最快（Best Cases）： 当输入的数据可以均匀的分配到每一个桶中什么时候最慢（Worst Cases）： 当输入的数据被分配到了同一个桶中 图片展示 参考文档： JS的十大经典算法排序 十大经典排序算法 桶排序]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法-计数排序]]></title>
    <url>%2F2017%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[计数排序的基础定义：计数排序是一个非基于比较的排序算法。它的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。[1-2] 当然这是一种牺牲空间换取时间的做法，而且当O(k)&gt;O(nlog(n))的时候其效率反而不如基于比较的排序（基于比较的排序的时间复杂度在理论上的下限是O(nlog(n)), 如归并排序，堆排序）计数排序对输入的数据有附加的限制条件： 1、输入的线性表的元素属于有限偏序集S； 2、设输入的线性表的长度为n，|S|=k（表示集合S中元素的总数目为k），则k=O(n)。 计数排序算法思想计数排序的基本思想是对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有17个元素的值小于x的值，则x可以直接存放在输出序列的第18个位置上。当然，如果有多个元素具有相同的值时，我们不能将这些元素放在输出序列的同一个位置上，因此，上述方案还要作适当的修改。 现实计数算法具体算法实现步骤. 找出待排序的数组中最大和最小的元素； . 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； . 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； . 反向填充目标数组：将每个元素i放在新数组的第C[i]项，每放一个元素就将C[i]减去1。 12345678910111213141516171819202122232425262728293031323334function countingSort(arr)&#123; let len = arr.length, Result = [], // 保存排序后的数组 Count = [], // 保存各项出现次数的数组 min = max = arr[0]; console.time(&apos;计数排序计时&apos;); // 查找最大、最小值,并将arr数置入Count数组中,统计出现次数 for(var i = 0; i &lt; len; i++)&#123; Count[arr[i]] = Count[arr[i]] ? Count[arr[i]] + 1 : 1; // 求各项出现次数 min = min &lt;= arr[i] ? min : arr[i]; // 求数组最小值 max = max &gt;= arr[i] ? max : arr[i]; // 求数组最大值 &#125; // 从最小值-&gt;最大值,将计数逐项相加 for(var j = min; j &lt; max; j++)&#123; Count[j+1] = (Count[j+1]||0)+(Count[j]||0); &#125; // Count中,下标为arr数值,数据为arr数值出现次数;反向填充数据进入Result数据 for(var k = len - 1; k &gt;= 0;k--)&#123; /*Result[位置] = arr数据*/ Result[Count[arr[k]] - 1] = arr[k]; /*减少Count数组中保存的计数*/ Count[arr[k]]--; /*显示Result数组每一步详情*/ console.log(Result); &#125; console.timeEnd(&apos;计数排序计时&apos;); return Result;&#125;var arr = [3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];console.log(countingSort(arr)); PS：时间复杂度：T(n) = O(n) 空间复杂度：S(n) = O(k) 是否稳定：是 排序方式：外排序 运行结果为:[ , , , , , , , , , , , , , 48 ][ , , , , , , , , , , , , , 48, 50 ][ , , , , , 19, , , , , , , , 48, 50 ][ , , 4, , , 19, , , , , , , , 48, 50 ][ , , 4, , , 19, , , , , , 46, , 48, 50 ][ 2, , 4, , , 19, , , , , , 46, , 48, 50 ][ 2, , 4, , , 19, , 27, , , , 46, , 48, 50 ][ 2, , 4, , , 19, 26, 27, , , , 46, , 48, 50 ][ 2, , 4, , , 19, 26, 27, 36, , , 46, , 48, 50 ][ 2, , 4, , 15, 19, 26, 27, 36, , , 46, , 48, 50 ][ 2, , 4, , 15, 19, 26, 27, 36, , , 46, 47, 48, 50 ][ 2, , 4, 5, 15, 19, 26, 27, 36, , , 46, 47, 48, 50 ][ 2, , 4, 5, 15, 19, 26, 27, 36, 38, , 46, 47, 48, 50 ][ 2, , 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50 ][ 2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50 ]计数排序计时: 16ms[ 2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50 ] 动图展示 参考文档： 基本算法学习(四)之计数排序(JS) 计数排序 十大经典排序算法]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法-堆排序]]></title>
    <url>%2F2017%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[堆排序（Heapsort）的基础定义：堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。 我们需要了解什么叫堆定义n个关键字序列Kl，K2，…，Kn称为（Heap），当且仅当该序列满足如下性质（简称为堆性质）： (1)ki&lt;=k(2i）且ki&lt;=k(2i+1)(1≤i≤ n/2），当然，这是小根堆，大根堆则换成&gt;=号。//k(i）相当于二叉树的非叶子结点，K(2i）则是左子节点，k(2i+1）是右子节点 若将此序列所存储的向量R[1..n]看做是一棵完全二叉树的存储结构，则堆实质上是满足如下性质的完全二叉树：树中任一非叶子结点的关键字均不大于（或不小于）其左右孩子（若存在）结点的关键字。 来个例子说明【例】关键字序列（10，15，56，25，30，70）和（70，56，30，25，15，10）分别满足堆性质（1）和（2），故它们均是堆，其对应的完全二叉树分别如小根堆示例和大根堆示例所示。 小根堆：根结点（亦称为堆顶）的关键字是堆里所有结点关键字中最小者的堆称为小根堆，又称最小堆。 大根堆：根结点（亦称为堆顶）的关键字是堆里所有结点关键字中最大者，称为大根堆，又称最大堆。 注意：①堆中任一子树亦是堆。②以上讨论的堆实际上是二叉堆（Binary Heap），类似地可定义k叉堆。 来张图表示一下： 堆的高度堆可以被看成是一棵树，结点在堆中的高度可以被定义为从本结点到叶子结点的最长简单下降路径上边的数目；定义堆的高度为树根的高度。我们将看到，堆结构上的一些基本操作的运行时间至多是与树的高度成正比，为O（lgn）。 算法描述 .将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； .将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]； .由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 代码实现``` /** * 对数组中的前n项整理成堆 * @param array * @param n */ function refreshHeap(array, n){ if(array.length&lt;n)n = array.length; //array[n/2-1]表示的是最后一个有子节点的节点 for(let i=Math.floor(n/2)-1;i&gt;=0;i--){ //对于有子节点的节点i，2*i+1表示的是其第一个子节点，即左子节点 //这个while是判断当前节点与其子节点是否需要调整 while(2*i+1&lt;n){ let j = 2*i+1; //如果节点j不是其父节点的唯一子节点，也就是说如果存在右子节点 if(j+1&lt;n){ //如果右子节点大于左子节点，则使j指向右边（总之要找到最大的子接点） if(array[j]&lt;a[j+1]){ j++; } } //如果最大子节点大于其父节点，则交换 if(a[i]&lt;a[j]){ let tmp = a[i]; a[i] = a[j]; a[j] = tmp; //交换之后整个堆被破坏，需要重新调整，故令i=j //这个调整表示的是从j节点开始判断堆是否需要调整 //比如交换j、i节点后，结果j的子节点又大于j了，那么就需要重新调整 i = j; }else{ break; } } } return array; } function heapSort(array, n){ if(array.length&lt;n)n = array.length; while(n&gt;0){ //刷新堆之后，将array[0]（最大值）与最后一个子节点交换 //然后重新刷新堆(不包括最后那些排好序的节点了) refreshHeap(array, n--); let tmp = array[n]; array[n] = array[0]; array[0] = tmp; } return array; } var a = [16,7,3,20,17,8]; console.log(a); // [16, 7, 3, 20, 17, 8] heapSort(a,a.length); console.log(a); // [3, 7, 8, 16, 17, 20] ``` 时间复杂度：T(n) = O(nlogn)空间复杂度：S(n) = O(1)稳定性：不稳定排序方式：内排序 动图展示 参考文档： JavaScript数据结构之 堆排序 十大经典排序算法 堆排序]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法-快速排序]]></title>
    <url>%2F2017%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[快速排序（Quicksort）的基础定义：快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 快速排序算法的介绍设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。一趟快速排序的算法是： 1）设置两个变量i、j，排序开始的时候：i=0，j=N-1； 2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]； 3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换； 4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换； 5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。 排序演示假设用户输入了如下数组：6, 2, 7, 3, 8, 91.创建变量i=0（指向第一个数据）, j=5(指向最后一个数据), k=6(赋值为第一个数据的值)。我们要把所有比k小的数移动到k的左面，所以我们可以开始寻找比6小的数，从j开始，从右往左找，不断递减变量j的值，我们找到第一个下标3的数据比6小，于是把数据3移到下标0的位置，把下标0的数据6移到下标3，完成第一次比较：3, 2, 7, 6, 8, 9i=0 j=3 k=6接着，开始第二次比较，这次要变成找比k大的了，而且要从前往后找了。递加变量i，发现下标2的数据是第一个比k大的，于是用下标2的数据7和j指向的下标3的数据的6做交换，数据状态变成下表：3, 2, 6, 7, 8, 9i=2 j=3 k=6称上面两次比较为一个循环。接着，再递减变量j，不断重复进行上面的循环比较。在本例中，我们进行一次循环，就发现i和j“碰头”了：他们都指向了下标2。于是，第一遍比较结束。得到结果如下，凡是k(=6)左边的数都比它小，凡是k右边的数都比它大：3, 2, 6, 7, 8, 9如果i和j没有碰头的话，就递加i找大的，还没有，就再递减j找小的，如此反复，不断循环。注意判断和寻找是同时进行的。然后，对k两边的数据，再分组分别进行上述的过程，直到不能再分组为止。注意：第一遍快速排序不会直接得到最终结果，只会把比k大和比k小的数分到k的两边。为了得到最后结果，需要再次对下标2两边的数组分别执行此步骤，然后再分解数组，直到数组不能再分解为止（只有一个数据），才能得到正确结果。 代码实现前面讲了那么多了，简单就记住下面的步骤就好了。 1、找基准（一般是以当前数组的第一项的值）2、遍历数组，小于基准的放在left，大于基准的放在right3、递归（再分别对数组 left 和 right 1,2步骤，直到不能再分组为止） 123456789101112131415161718192021222324252627282930313233function quickSort(array)&#123; let arr = array.slice(); //如果数组&lt;=1,则直接返回 if(arr.length&lt;=1)&#123; return arr; &#125; //找基准，并把基准从原数组删除 var pivot=arr.splice(0,1)[0]; //定义左右数组 var left=[]; var right=[]; //比基准小的放在left，比基准大的放在right for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]&lt;=pivot)&#123; left.push(arr[i]); &#125; else&#123; right.push(arr[i]); &#125; &#125; //递归 return quickSort(left).concat([pivot],quickSort(right));&#125;let arr = [6, 2, 7, 3, 8, 9];let demo = quickSort(arr);console.log(arr); // [6, 2, 7, 3, 8, 9];console.log(demo); // [2, 3, 6, 7, 8, 9]; 时间复杂度：T(n) = O(n^2)空间复杂度：S(n) = O(logn)稳定性：不稳定是否为内排序：是 动图展示 图片来源网络，在次表示感谢 参考文档： JS实现快速排序 快速排序 十大经典排序算法]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法-归并算法]]></title>
    <url>%2F2017%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[归并排序（MERGE-SORT）基础定义：归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。实现过程：比较a[i]和b[j]的大小，若a[i]≤b[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素b[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。 归并操作归并排序：其基本思想是分治策略，先进行划分，然后再进行合并。 算法思路假设要对数组C进行归并排序，步骤是： let C = [10, 4, 6, 3, 8, 2, 5, 7]; 1.先将C划分为两个数组A和B（即把数组C从中间分开 n = Math.floor(C.length/2)） 2.再分别对数组A、B重复步骤1的操作，逐步划分，直到不能再划分为止(每个子数组只剩下一个元素)，这样，划分的过程就结束了。 3.然后从下层往上层不断合并数组，每一层合并相邻的两个子数组，合并的过程是每次从待合并的两个子数组中选取一个最小的元素，然后把这个元素放到合并后的数组中，不断重复直到把两个子数组的元素都放到合并后的数组为止。 4.依次类推，直到合并到最上层结束，这时数据的排序已经完成了。 算法划分和合并过程 先划分： [10, 4, 6, 3, 8, 2, 5, 7] 第一次划分：[10, 4, 6, 3] [8, 2, 5, 7] 第二次划分：[10, 4] [6, 3] [8, 2] [5, 7] 第三次划分：[10] [4] [6] [3] [8] [2] [5] [7] 再合并： 第一次合并：[4, 10] [3, 6] [2, 8] [5, 7] 第二次合并：[3, 4, 6, 10] [2, 5, 7, 8] 第三次合并：[2, 3, 4, 5, 6, 7, 8, 10] 代码实现123456789101112131415161718192021222324252627function merge(left, right)&#123; var result=[]; while(left.length &amp;&amp; right.length)&#123; if(left[0] &lt; right[0])&#123; /*shift()方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。*/ result.push(left.shift()); &#125;else&#123; result.push(right.shift()); &#125; &#125; return result.concat(left).concat(right);&#125;function mergeSort(items)&#123; if(items.length === 1)&#123; return items; &#125; let middle = Math.floor(items.length/2), left = items.slice(0, middle), //得到下标从0~index-1的数组 right = items.slice(middle); //得到下标从index开始到末尾的数组 return merge(mergeSort(left), mergeSort(right));&#125;let arr = [10, 4, 6, 3, 8, 2, 5, 7];let demo = mergeSort(arr)console.log(arr); // [10, 4, 6, 3, 8, 2, 5, 7]console.log(demo); // [2, 3, 4, 5, 6, 7, 8, 10] ps：使用递归的代码如下。优点是描述算法过程思路清晰，缺点是使用递归，mergeSort()函数频繁地自我调用。长度为n的数组最终会调用mergeSort()函数 2n-1次，这意味着一个长度超过1500的数组会在Firefox上发生栈溢出错误。可以考虑使用迭代来实现同样的功能。 时间复杂度：O(n log n) 空间复炸都：O（n) 稳定性：稳定 排序方式：外排序 动图展示 图片来源，在此表示感谢 参考文档： JS实现归并排序 js归并排序法 归并排序 十大经典排序算法]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法-希尔排序]]></title>
    <url>%2F2017%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[希尔排序（Shell Sort）的基础希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。 实现希尔排序（n为待排序arr.length）实现理论先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量 =1( &lt; …&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止。 该方法实质上是一种分组插入方法 比较相隔较远距离（称为增量）的数，使得数移动时能跨过多个元素，则进行一次比较就可能消除多个元素交换。D.L.shell于1959年在以他名字命名的排序算法中实现了这一思想。算法先将要排序的一组数按某个增量d分成若干组，每组中记录的下标相差d.对每组中全部元素进行排序，然后再用一个较小的增量对它进行，在每组中再进行排序。当增量减到1时，整个要排序的数被分成一组，排序完成。一般的初次取序列的一半为增量，以后每次减半，直到增量为1。 实现思路假设待排序文件有10个记录，其关键字分别是： 592,401,874,141,348,72,911,887,820,283。增量序列的取值依次为：n = 10, 则增量d1 = 10/2 = 5。 5，2，1 算法时间复杂度：T(n) = O(n*logn^2) 内排序(内存排序就够了) 不稳定(排序后原始顺序无法保证) 代码实现1234567891011121314151617181920function shellSort(array) &#123; let arr = array.slice(), len = arr.length; for(var fraction = Math.floor(len/2); fraction &gt; 0; fraction = Math.floor(fraction/2))&#123; // 这里实质上有进行了直接插入排序 for(var i = fraction; i &lt; len; i++)&#123; for(var j = i - fraction; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[fraction + j]; j -= fraction)&#123; var temp = arr[j]; arr[j] = arr[fraction + j]; arr[fraction + j] = temp; &#125; &#125; &#125; return arr;&#125;var arr1 = [592,401,874,141,348,72,911,887,820,283];let arr2 = shellSort(arr1);console.log(arr1); // [592, 401, 874, 141, 348, 72, 911, 887, 820, 283]console.log(arr2); // [72, 141, 283, 348, 401, 592, 820, 874, 887, 911] PS：首个增量一般取值为 Math.floor(arr.length/2),对每个分组进行直接插入排序。 重复上面过程，知道增量为1时，整个数组恰被分成一组，算法便终止。 参考文档： 十大经典排序算法 基本算法学习(一)之希尔排序(JS) 希尔排序]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Symbol总结]]></title>
    <url>%2F2017%2FSymbol%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[Symbol 基础Symbol 引入的原因ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。 特性语法：Symbol([description])参数：description – 可选的，字符串。symbol的description可以用于调试，但无法访问到symbol本身。 示例1234let s1 = Symbol();let s2 = Symbol();s1 === s2 // false 作为属性名的 Symbol1234567// 这里作为对象的属性使用，独一无二let s1 = Symbol();let a = &#123; [s1]: &apos;我是Symbol类型的&apos;&#125;;console.log(a[s1]); 属性名的遍历Symbol 作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。另一个新的API，Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。 Symbol.for(key)，Symbol.keyFor(key)Symbol.for(key)我们希望重新使用同一个 Symbol 值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。 1234let s1 = Symbol.for(&apos;foo&apos;);let s2 = Symbol.for(&apos;foo&apos;);s1 === s2 // true PS：上面代码中，s1和s2都是 Symbol 值，但是它们都是同样参数的Symbol.for方法生成的，所以实际上是同一个值。 Symbol.for(key)与Symbol(desc)这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。 Symbol.keyFor(key)Symbol.keyFor方法返回一个（全局）已登记的 Symbol 类型值的key。 12345let s1 = Symbol.for(&quot;foo&quot;);Symbol.keyFor(s1) // &quot;foo&quot;let s2 = Symbol(&quot;foo&quot;);Symbol.keyFor(s2) // undefined PS：上面代码中，变量s2属于未登记的 Symbol 值，所以返回undefined。 内置的Symbol值除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。 迭代 symbols Symbol.iterator 一个返回一个对象默认迭代器的方法。使用 for…of。 Symbol.asyncIterator（实验性API） 一个返回对象默认的异步迭代器的方法。使用 for await of。 正则表达式 symbols Symbol.match 一个用于对字符串进行匹配的方法，也用于确定一个对象是否可以作为正则表达式使用。使用 String.prototype.match(). Symbol.replace 一个替换匹配字符串的子串的方法. 使用 String.prototype.replace(). Symbol.search 一个返回一个字符串中与正则表达式相匹配的索引的方法。使用String.prototype.search(). Symbol.split 一个在匹配正则表达式的索引处拆分一个字符串的方法.。使用 String.prototype.split(). 其他 symbols Symbol.hasInstance 一个确定一个构造器对象识别的对象是否为它的实例的方法。使用 instanceof. Symbol.isConcatSpreadable 一个布尔值，表明一个对象是否应该flattened为它的数组元素。使用Array.prototype.concat(). Symbol.unscopables 拥有和继承属性名的一个对象的值被排除在与环境绑定的相关对象外。 Symbol.species 一个用于创建派生对象的构造器函数。 Symbol.toPrimitive 一个将对象转化为基本数据类型的方法。 Symbol.toStringTag 用于对象的默认描述的字符串值。使用Object.prototype.toString(). 参考文档： 阮一峰-Symbol MDN-Symbol]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Set和Map的用法]]></title>
    <url>%2F2017%2FSet%E5%92%8CMap%E7%9A%84%E7%94%A8%E6%B3%95.html</url>
    <content type="text"><![CDATA[Set 详解基础特性Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。语法：new Set([iterable]);参数：如果传递一个可迭代对象，它的所有元素将被添加到新的 Set中。如果不指定此参数或其值为null，则新的 Set为空。返回值：一个新的Set对象。 来个简单实例12let set = new Set([1, 2, 3, 3]);console.log(set) // Set(3) &#123;1, 2, 3&#125; Set 实例的属性和方法属性 Set.prototype表示Set构造器的原型，允许向所有Set对象添加新的属性。 Set.prototype.constructor返回实例的构造函数。默认情况下是Set。 Set.prototype.size返回Set对象的值的个数。 方法 Set.prototype.add(value)在Set对象尾部添加一个元素。返回该Set对象。 Set.prototype.clear()移除Set对象内的所有元素。 Set.prototype.delete(value)移除Set的中与这个值相等的元素，返回Set.prototype.has(value)在这个操作前会返回的值（即如果该元素存在，返回true，否则返回false）。Set.prototype.has(value)在此后会返回false。 Set.prototype.has(value)返回一个布尔值，表示该值在Set中存在与否。 Set.prototype.keys()与values()方法相同，返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。 Set.prototype.values()返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。 Set.prototype.entries()返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值的[value, value]数组。为了使这个方法和Map对象保持相似， 每个值的键和值相等。 Set.prototype.forEach(callbackFn[, thisArg])按照插入顺序，为Set对象中的每一个值调用一次callBackFn。如果提供了thisArg参数，回调中的this会是这个参数。 Set.prototype@@iterator返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值 WeakSetWeakSet 基础WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。 WeakSet 的成员只能是对象，而不能是其他类型的值。 WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。WeakSet 具有的方法WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 12345678910const ws = new WeakSet();const obj = &#123;&#125;;ws.add(window);ws.add(obj);ws.has(window); // truews.delete(window);ws.has(window); // false MapMap 出现的背景JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。 基础特性语法：new Map([iterable])参数：iterable Iterable 可以是一个数组或者其他 iterable 对象，其元素或为键值对，或为两个元素的数组。 每个键值对都会添加到新的 Map。null 会被当做 undefined。 简单的Map 实例123456789101112131415let map = new Map();map.set(-0, 123);map.get(+0) // 123map.set(true, 1);map.set(&apos;true&apos;, 2);map.get(true) // 1map.set(undefined, 3);map.set(null, 4);map.get(undefined) // 3map.set(NaN, 123);map.get(NaN) // 123 实例的属性和操作方法属性 Map.prototype表示 Map 构造器的原型。 允许添加属性从而应用于所有的 Map 对象。 Map.prototype.constructor返回一个函数，它创建了实例的原型。默认是Map函数。 Map.prototype.size返回Map对象的键/值对的数量。 方法 Map.prototype.clear()移除Map对象的所有键/值对 。 Map.prototype.delete(key)移除任何与键相关联的值，并且返回该值，该值在之前会被Map.prototype.has(key)返回为true。之后再调用Map.prototype.has(key)会返回false。 Map.prototype.has(key)返回一个布尔值，表示Map实例是否包含键对应的值。 Map.prototype.get(key)返回键对应的值，如果不存在，则返回undefined。 Map.prototype.set(key, value)设置Map对象中键的值。返回该Map对象。 Map.prototype.keys()返回一个新的 Iterator对象， 它按插入顺序包含了Map对象中每个元素的键 。 Map.prototype.values()返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的值 。 Map.prototype.entries()返回一个新的 Iterator 对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。 Map.prototype.forEach(callbackFn[, thisArg])按插入顺序，为 Map对象里的每一键值对调用一次callbackFn函数。如果为forEach提供了thisArg，它将在每次回调中作为this值。 Map.prototype@@iterator返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。 WeakMapWeakMap 的基础WeakMap结构与Map结构类似，也是用于生成键值对的集合。 WeakMap与Map的区别有两点： WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。 WeakMap的键名所指向的对象，不计入垃圾回收机制。 WeakMap 的方法 get() set() has() delete() WeakMap 的用途WeakMap 应用的典型场合就是 DOM 节点作为键名。 123456789let myElement = document.getElementById(&apos;logo&apos;);let myWeakmap = new WeakMap();myWeakmap.set(myElement, &#123;timesClicked: 0&#125;);myElement.addEventListener(&apos;click&apos;, function() &#123; let logoData = myWeakmap.get(myElement); logoData.timesClicked++;&#125;, false); PS：上面代码中，myElement是一个 DOM 节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是myElement。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。 参考文档： MDN-Set MDN-Map 阮一峰-Set和Map]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Proxy和Reflect的用法]]></title>
    <url>%2F2017%2FProxy%E5%92%8CReflect%E7%9A%84%E7%94%A8%E6%B3%95.html</url>
    <content type="text"><![CDATA[Proxy 详解Proxy 定义Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。 Proxy 语法12345678910111213// 目标对象，需要被拦截 或 处理的对象，数组，函数甚至是其他的代理器let target = &#123;&#125;;// 拦截器对象let handler = &#123; get(target, name)&#123; // 这里如果 target 没有name属性的话，就设定一个默认值 return name in target ? target[name] : 27; &#125;&#125;;var proxy = new Proxy(target, handler);console.log(target.name); // undefinedconsole.log(proxy.name); // 27 PS：Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。 Proxy 支持的拦截操作一览，一共13种 get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。 set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。 has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。 deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。 ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。 getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。 defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。 preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。 getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。 isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。 setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。 apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。 construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。 Proxy.revocable() 可撤销的代理Proxy.revocable方法返回一个可取消的 Proxy 实例。 12345678910let target = &#123;&#125;;let handler = &#123;&#125;;let &#123;proxy, revoke&#125; = Proxy.revocable(target, handler);proxy.foo = 123;console.log(proxy.foo);revoke(); // 取消Proxy实例console.log(proxy.foo); // TypeError: Revoked PS：Proxy.revocable方法返回一个对象，该对象的proxy属性是Proxy实例，revoke属性是一个函数，可以取消Proxy实例。上面代码中，当执行revoke函数之后，再访问Proxy实例，就会抛出一个错误。Proxy.revocable的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。 this 的问题虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。 1234567891011const target = &#123; m: function () &#123; console.log(this === proxy); &#125;&#125;;const handler = &#123;&#125;;const proxy = new Proxy(target, handler);target.m() // falseproxy.m() // true Proxy 的应用扩展数组的属性和方法需求：对于数组对象，有时候我们只想要得到数组中对象的某个键值内容。 123456789101112131415161718192021222324var AddSomeFunctionHandler=&#123; get:function(obj,prop)&#123; if(prop in obj)&#123; return obj[prop] // 按数组默认方式访问元素 &#125; if(prop === &apos;name&apos;)&#123; return obj.map(o=&gt;o.name) &#125; &#125;&#125;var PersonArray=[&#123; name:&quot;Alice&quot;,age:23&#125;,&#123; name:&quot;Bob&quot;,age:45&#125;,&#123; name:&quot;Mike&quot;,age:27&#125;]var p= new Proxy(PersonArray,AddSomeFunctionHandler)console.log(p.name) // [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Mike&quot;] Reflect 详解Reflect 定义Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个： 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。 Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。 Reflect 静态方法Reflect对象一共有13个静态方法。 Reflect.apply(target, thisArg, args) Reflect.construct(target, args) Reflect.get(target, name, receiver) Reflect.set(target, name, value, receiver) Reflect.defineProperty(target, name, desc) Reflect.deleteProperty(target, name) Reflect.has(target, name) Reflect.ownKeys(target) Reflect.isExtensible(target) Reflect.preventExtensions(target) Reflect.getOwnPropertyDescriptor(target, name) Reflect.getPrototypeOf(target) Reflect.setPrototypeOf(target, prototype)PS：上面这些方法的作用，大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的。 Reflect.get(target, name, receiver)Reflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined。 1234567891011var myObject = &#123; foo: 1, bar: 2, get baz() &#123; return this.foo + this.bar; &#125;,&#125;Reflect.get(myObject, &apos;foo&apos;) // 1Reflect.get(myObject, &apos;bar&apos;) // 2Reflect.get(myObject, &apos;baz&apos;) // 3 实例–使用 Proxy 实现观察者模式观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。如果你还不懂观察者模式 12345678910111213141516171819202122//添加观察者const queuedObservers = new Set();const observe = fn =&gt; queuedObservers.add(fn);//proxy 的set 方法function set(target, key, value, receiver) &#123; const result = Reflect.set(target, key, value, receiver); queuedObservers.forEach(observer =&gt; observer()); return result;&#125;//创建proxy代理const observable = obj =&gt; new Proxy(obj, &#123;set&#125;);//被观察的 对象const person = observable(&#123; name: &apos;张三&apos;, age: 20&#125;);observe(print);console.log(person.name); // 张三person.name = &apos;李四&apos;;console.log(person.name); // 李四 参考文档： 阮一峰-Reflect 用es6 （proxy 和 reflect）轻松实现 观察者模式]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Generator函数的用法]]></title>
    <url>%2F2017%2FGenerator%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95.html</url>
    <content type="text"><![CDATA[Generator函数的定义从语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。 Generator函数的简单示例1234567function* g() &#123; yield &apos;hello&apos;; yield &apos;world&apos;; return &apos;ending&apos;;&#125;var demo = g(); PS：上面代码定义了一个 Generator 函数g，它内部有两个yield表达式（hello和world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。返回的是，遍历器对象（Iterator Object）。例如这里，{ value: ‘hello’, done: false } yield 表达式由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。 （1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。 （2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。 （3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。 （4）如果该函数没有return语句，则返回的对象的value属性值为undefined。 for…of 循环可以遍历 数组 和 实现了 Symbol.iterator 方法的对象。 for…of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法。 12345678910111213function *foo() &#123; yield 1; yield 2; yield 3; yield 4; yield 5; return 6;&#125;for (let v of foo()) &#123; console.log(v);&#125;// 1 2 3 4 5 Generator.prototype.next()yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。next() 方法返回一个包含属性 done 和 value 的对象。该方法也可以通过接受一个参数用以向生成器传值。 1234567891011function* gen() &#123; yield 1; yield 2; yield 3;&#125;var g = gen(); // &quot;Generator &#123; &#125;&quot;g.next(); // &quot;Object &#123; value: 1, done: false &#125;&quot;g.next(); // &quot;Object &#123; value: 2, done: false &#125;&quot;g.next(); // &quot;Object &#123; value: 3, done: false &#125;&quot;g.next(); // &quot;Object &#123; value: undefined, done: true &#125;&quot; Generator.prototype.throw()Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。 Generator.prototype.return()Generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 Generator 函数。 1234567891011function* gen() &#123; yield 1; yield 2; yield 3;&#125;var g = gen();g.next() // &#123; value: 1, done: false &#125;g.return(&apos;foo&apos;) // &#123; value: &quot;foo&quot;, done: true &#125;g.next() // &#123; value: undefined, done: true &#125; PS：遍历器对象g调用return方法后，返回值的value属性就是return方法的参数foo。并且，Generator函数的遍历就终止了，返回值的done属性为true，以后再调用next方法，done属性总是返回true。如果return方法调用时，不提供参数，则返回值的value属性为undefined。 比较一下多个异步操作的编码step1完成才能做step2，step2完成才能做step3，step3完成才能做step4 回调函数(123456789step1(function (value1) &#123; step2(value1, function(value2) &#123; step3(value2, function(value3) &#123; step4(value3, function(value4) &#123; // Do something with value4 &#125;); &#125;); &#125;);&#125;); PS：层数多了就形成了回调地狱。 Promise 组织代码12345678910Q.fcall(step1) .then(step2) .then(step3) .then(step4) .then(function (value4) &#123; // Do something with value4 &#125;, function (error) &#123; // Handle any error from step1 through step4 &#125;) .done(); PS：是不是代码稍微要清晰一些了。 Generator 组织代码123456789101112131415161718192021222324function* longRunningTask() &#123; try &#123; var value1 = yield step1(); var value2 = yield step2(value1); var value3 = yield step3(value2); var value4 = yield step4(value3); // Do something with value4 &#125; catch (e) &#123; // Handle any error from step1 through step4 &#125;&#125;function scheduler(task) &#123; setTimeout(function() &#123; var taskObj = task.next(task.value); // 如果Generator函数未结束，就继续调用 if (!taskObj.done) &#123; task.value = taskObj.value scheduler(task); &#125; &#125;, 0);&#125;scheduler(longRunningTask()); 参考文档： Generator 函数的语法 MDN-Generator ES6 Generator 函数的使用]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise的用法]]></title>
    <url>%2F2017%2FPromise%E7%9A%84%E7%94%A8%E6%B3%95.html</url>
    <content type="text"><![CDATA[ES6出来了很久，Promise也一直在用，现在总结一下具体用法。 Promise 定义Promise 对象用于一个异步操作的最终完成（或失败）及其结果值的表示。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。 这里使用MDN的图片 基本方法创造了一个 Promise 实例123456789const promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); 对 Promise 实例成功 或 失败 做相应的处理12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); Promise.prototype.then()Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。 分为三种调用形式（注意最后面需要带着错误处理函数） promise.then((resolve) =&gt; { // 成功的处理函数 }, (reject) =&gt; { // 错误的处理函数 }) promise.then((resolve) =&gt; { // 成功的处理函数 }).then((resolve) =&gt; { // 成功的处理函数 }, (reject) =&gt; { // 错误的处理函数 }) promise.then(null, (reject) =&gt; { // 错误的处理函数 }) 返回值返回一个新的Promise 对象，从而达到链式调用。 Promise.prototype.catch()Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 12345promise.then(function(resolve) &#123; // 成功的处理函数&#125;).catch(function(error) &#123; console.log(error);&#125;); Promise.all()用法Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 1const p = Promise.all([p1, p2, p3]); PS：Promise.all方法接受一个数组或具有Iterator 接口的对象作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。 返回值（1）只有p1、p2、p3的状态都变成resolved，p的状态才会变成resolved，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 Promise.race()用法Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。 1const p = Promise.race([p1, p2, p3]); PS：Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。 返回值只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 Promise.resolve()有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。 1const jsPromise = Promise.resolve($.ajax(&apos;/whatever.json&apos;)); PS：将jQuery生成的deferred对象，转为一个新的Promise对象。 根据不同参数，返回结果情况 参数是一个Promise实例如果参数是Promise实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。 参数是一个thenable对象（thenable对象指的是具有then方法的对象）Promise.resolve方法会将这个对象转为Promise对象，然后就立即执行thenable对象的then方法。 参数不是具有then方法的对象，或根本就不是对象如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为resolved。 不带有任何参数Promise.resolve方法允许调用时不带参数，直接返回一个resolved状态的Promise对象。 Promise.reject()Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。下面两种形式一样： 12345678const p = Promise.reject(&apos;出错了&apos;);// 等同于const p = new Promise((resolve, reject) =&gt; reject(&apos;出错了&apos;))p.then(null, function (s) &#123; console.log(s)&#125;);// 出错了 自己部署有用的方法done()解决的问题Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。 部署 done 方法1234567Promise.prototype.done = function (onFulfilled, onRejected) &#123; this.then(onFulfilled, onRejected) .catch(function (reason) &#123; // 抛出一个全局错误 setTimeout(() =&gt; &#123; throw reason &#125;, 0); &#125;);&#125;; 使用12345asyncFunc() .then(f1) .catch(r1) .then(f2) .done(); finally()解决的问题finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。 部署finally方法1234567Promise.prototype.finally = function (callback) &#123; let P = this.constructor; return this.then( value =&gt; P.resolve(callback()).then(() =&gt; value), reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;) );&#125;; 使用下面是一个例子，服务器使用Promise处理请求，然后使用finally方法关掉服务器。 12345server.listen(0) .then(function () &#123; // run test &#125;) .finally(server.stop); Promise.try()目前还为提案，Promise 库Bluebird、Q和when，提供了这个方法。 使用场景实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误。 使用123Promise.try(f) // 这里不需要管 f 是同步还是异步函数。 .then(...) .catch(...) 应用我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。 123456789101112const preloadImage = function (path) &#123; return new Promise(function (resolve, reject) &#123; const image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; &#125;);&#125;;preloadImage .then((reslove) =&gt; &#123; console.log(&apos;图片加载成功了哦！&apos;) &#125;) .catch((reject) =&gt; &#123; console.log(&apos;图片加载失败了哦！&apos;) &#125;) 参考文档： MDN–Promiese 阮一峰–Promise]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法-插入排序]]></title>
    <url>%2F2017%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[插入排序算法定义（Insertion Sort）有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法——插入排序法,插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。 插入排序的基本思想是：每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。 插入排序的分类包括：直接插入排序，二分插入排序（又称折半插入排序），链表插入排序，希尔排序（又称缩小增量排序）。属于稳定排序的一种（通俗地讲，就是两个相等的数不会交换位置） 。 直接插入排序实现思路直接插入排序是一种简单的插入排序法，其基本思想是：把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列。例如,已知待排序的一组记录是：60,71,49,11,24,3,66假设在排序过程中，前3个记录已按关键码值递增的次序重新排列，构成一个有序序列：49,60,71将待排序记录中的第4个记录（即11）插入上述有序序列，以得到一个新的含4个记录的有序序列。首先，应找到11的插入位置，再进行插入。可以讲11放入数组的第一个单元r[0]中，这个单元称为监视哨，然后从71起从右到左查找，11小于71，将71右移一个位置，11小于60，又将60右移一个位置，11小于49，又再将49右移一个位置，这时再将11与r[0]的值比较，11≥r[0]，它的插入位置就是r[1]。假设11大于第一个值r[1]。它的插入位置应该在r[1]和r[2]之间，由于60已经右移了，留出来的位置正好留给11.后面的记录依照同样的方法逐个插入到该有序序列中。若记录数n,续进行n-1趟排序，才能完成。直接插入排序的算法思路：（1） 设置监视哨r[0]，将待插入记录的值赋值给r[0]；（2） 设置开始查找的位置j；（3） 在数组中进行搜索，搜索中将第j个记录后移，直至r[0].key≥r[j].key为止；（4） 将r[0]插入r[j+1]的位置上。 实现代码12345678910111213141516171819202122232425function insertSort(array)&#123; let i, j, temp, arr = array.slice(), // 这里对原数组拷贝 n = arr.length; for(i = 1;i &lt; n;i++)&#123; j = i-1; temp = arr[i]; // 第i项为待插入的项 while(j &lt; i &amp;&amp; arr[j] &gt; temp)&#123; arr[j+1] = arr[j]; j--; &#125; arr[j+1] = temp; &#125; return arr; &#125; var arrayA = [1 , 3, 2, 6, 4, 5]; let demo = insertSort(arrayA);console.log(arrayA); // [1, 3, 2, 6, 4, 5]console.log(demo); // [1, 2, 3, 4, 5, 6] 最佳情况：输入数组按升序排列。T(n) = O(n)最坏情况：输入数组按降序排列。T(n) = O(n2)平均情况：T(n) = O(n2) 折半插入排序（二分插入排序）定义将直接插入排序中寻找A[i]的插入位置的方法改为采用折半比较，即可得到折半插入排序算法。在处理A[i]时，A[0]……A[i-1]已经按关键码值排好序。所谓折半比较，就是在插入A[i]时，取A[i-1/2]的关键码值与A[i]的关键码值进行比较，如果A[i]的关键码值小于A[i-1/2]的关键码值，则说明A[i]只能插入A[0]到A[i-1/2]之间，故可以在A[0]到A[i-1/2-1]之间继续使用折半比较；否则只能插入A[i-1/2]到A[i-1]之间，故可以在A[i-1/2+1]到A[i-1]之间继续使用折半比较。如此担负，直到最后能够确定插入的位置为止。一般在A[k]和A[r]之间采用折半，其中间结点为A[k+r/2]，经过一次比较即可排除一半记录，把可能插入的区间减小了一半，故称为折半。执行折半插入排序的前提是文件记录必须按顺序存储。 实现思路（1）计算 0 ~ i-1 的中间点，用 i 索引处的元素与中间值进行比较，如果 i 索引处的元素大， 说明要插入的这个元素应该在中间值和刚加入i索引之间，反之，就是在刚开始的位置 到中间值的位置，这样很简单的完成了折半；（2）在相应的半个范围里面找插入的位置时，不断的用（1）步骤缩小范围，不停的折半， 范围依次缩小为 1/2 1/4 1/8 …….快速的确定出第 i 个元素要插在什么地方；（3）确定位置之后，将整个序列后移，并将元素插入到相应位置。 实现代码1234567891011121314151617181920212223242526272829303132function binaryInsertSort(array)&#123; let arr = array.slice(); for (let i = 1; i &lt; arr.length; i++) &#123; let key = arr[i], left = 0, right = i - 1; while (left &lt;= right) &#123; let middle = parseInt((left + right) / 2); if (key &lt; arr[middle]) &#123; right = middle - 1; &#125; else &#123; left = middle + 1; &#125; &#125; for (var j = i - 1; j &gt;= left; j--) &#123; arr[j + 1] = arr[j]; &#125; arr[left] = key; &#125; return arr;&#125;var arrayA = [1 , 3, 2, 6, 4, 5]; let demo = binaryInsertSort(arrayA);console.log(arrayA); // [1, 3, 2, 6, 4, 5]console.log(demo); // [1, 2, 3, 4, 5, 6] 最佳情况：T(n) = O(nlogn)最差情况：T(n) = O(n2)平均情况：T(n) = O(n2) 参考文档：数据结构复习：直接插入排序与二分插入排序的C++实现插入排序十大经典排序算法]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法-选择排序]]></title>
    <url>%2F2017%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[选择排序算法定义（Selection Sort）选择排序法 是对 定位比较交换法（也就是冒泡排序法） 的一种改进。选择排序的基本思想是：每一趟在n-i+1（i=1，2，…n-1）个记录中选取关键字最小的记录作为有序序列中第i个记录。基于此思想的算法主要有简单选择排序、树型选择排序和堆排序。 简单选择排序第1趟，在待排序记录r[0]~r[n-1]中选出最小的记录，将它与r[0]交换；第2趟，在待排序记录r[1]~r[n-1]中选出最小的记录，将它与r[1]交换；以此类推，第i趟，在待排序记录r[i-1]~r[n-1]中选出最小的记录，将它与r[i-1]交换，使有序序列不断增长直到全部排序完毕。 基本思想选择排序的基本思想每一趟在n-i+1（i=1，2，…n-1）个记录中选取关键字最小的记录作为有序序列中第i个记录。基于此思想的算法主要有简单选择排序、树型选择排序和堆排序。 简单选择排序的基本思想第1趟，在待排序记录r[0]~r[n-1]中选出最小的记录，将它与r[0]交换；第2趟，在待排序记录r[1]~r[n-1]中选出最小的记录，将它与r[1]交换；以此类推，第i趟，在待排序记录r[i-1]~r[n-1]中选出最小的记录，将它与r[i-1]交换，使有序序列不断增长直到全部排序完毕。 简单选择排序的存储状态初始序列：{49 27 65 97 76 12 38}第1趟：12与49交换：12{27 65 97 76 49 38}第2趟：27不动 ：12 27{65 97 76 49 38}第3趟：65与38交换：12 27 38{97 76 49 65}第4趟：97与49交换：12 27 38 49{76 97 65}第5趟：76与65交换：12 27 38 49 65{97 76}第6趟：97与76交换：12 27 38 49 65 76 97 完成 PS：其中大括号内为无序区，大括号外为有序序列 简单选择排序的算法分析在简单选择排序过程中，所需移动记录的次数比较少。最好情况下，即待排序记录初始状态就已经是正序排列了，则不需要移动记录。最坏情况下，需要移动记录的次数最多为3（n-1）（此情况中待排序记录并非完全逆序，给完全逆序记录排序的移动次数应为(n/2)*3，其中n/2向下取整）。简单选择排序过程中需要进行的比较次数与初始状态下待排序的记录序列的排列情况无关。当i=1时，需进行n-1次比较；当i=2时，需进行n-2次比较；依次类推，共需要进行的比较次数是∑ =(n-1)+(n-2)+…+2+1=n(n-1)/2，即进行比较操作的时间复杂度为O(n2)。 算法描述1234567891011121314151617181920212223function selectionSort(array) &#123; let arr = array.slice(), // 深拷贝一份原数组 len = arr.length, minIndex, temp; for (var i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; //寻找最小的数 minIndex = j; //将最小数的索引保存 &#125; &#125; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; return arr;&#125;var arr = [5, 4, 3, 2, 1];var demo = selectionSort(arr);console.log(arr); // [5, 4, 3, 2, 1]console.log(demo); // [1, 2, 3, 4, 5] PS：建议使用不可变对象的思想进行编程。 动态展示 图片来源，在此表示感谢！ 参考文档： 选择排序（Selection Sort） 选择排序法]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法--冒泡排序]]></title>
    <url>%2F2017%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[或许你需要对算法的基本概念进行了解，请访问该链接。 冒泡排序算法定义（Bubble Sort）它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名。 冒泡排序算法原理冒泡排序算法的运作如下： 比较相邻的元素。如果第一个比第二个大，就交换他们两个数的位置。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。一次比较后，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个（因为最后一个已经是最大的了，不需要参与比较）。 持续对剩余未排序的元素重复上面的步骤，直到没有任何一对数字需要比较。 冒泡排序算法分析时间复杂度若数组的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数 C 和记录移动次数 M 均达到最小值。 C=n-1；M=0； 所以，冒泡排序最好的时间复杂度为 O(n)。若初始数组是反序的，需要进行 n-1 趟排序。每趟排序要进行 n-i 次关键字的比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。 C=n(n-1)/2 = O(n^2)；M=3n(n-1)/2 = O(n^2)所以，冒泡排序最坏的时间复杂度为 O(n^2)。综上，因此冒泡排序总的平均时间复杂度为 O(n^2)。 冒泡排序算法的稳定性冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。 冒泡排序算法描述1234567891011121314151617181920function bubbleSort(array) &#123; let len = array.length, j, arr = array.slice(); let tempExchangeVal; while (len &gt; 0) &#123; for (j = 0; j &lt; len - 1; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; // 交换两个值 tempExchangeVal = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tempExchangeVal; &#125; &#125; len--; &#125; return arr;&#125;const arr = [5, 4, 3, 2, 1];let arrSorted = bubbleSort(arr);console.log(arrSorted); // [1, 2, 3, 4, 5]console.log(arr); // [5, 4, 3, 2, 1]; PS：这里在方法中新生成了一个数组，有不可变对象的思想。 动态展示 图片来源，在此表示感谢！ 参考文档：JS-排序详解-冒泡排序十大经典排序算法冒泡排序]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法基本概念]]></title>
    <url>%2F2017%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html</url>
    <content type="text"><![CDATA[对于评述算法优劣术语的说明 稳定：如果a原本在b的前面，若a=b，排序之后a仍然在b前面。 不稳定：如果a原本在b的前面，若a=b，排序之后a可能会在b的后面。 内排序：所有排序操作都在内存中完成。 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行。 时间复杂度：一个算法执行所消耗的时间。 空间复杂度：运行完一个程序所需内存的大小。 时间复杂度时间复杂度的定义 T(n)=O(f(n))一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示， 若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数， 则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称O(f(n))为算法的 渐进时间复杂度(O是数量级的符号 )，简称时间复杂度。 时间复杂度的计算步骤 计算出基本操作的执行次数T(n) 基本操作即算法中的每条语句（以;号作为分割），语句的执行次数也叫做语句的频度。 在做算法分析时，一般默认为考虑最坏的情况。 计算出T(n)的数量级 求T(n)的数量级，只要将T(n)进行如下一些操作，忽略常量、低次幂和最高次幂的系数。 令f(n)=T(n)的数量级。 用大O来表示时间复杂度 当n趋近于无穷大时，如果lim(T(n)/f(n))的值为不等于0的常数，则称f(n)是T(n)的同数量级函数。 记作T(n)=O(f(n))。 计算一下时间复杂度123for(i=1;i&lt;=n;i++) //循环了，当然是O(n^2) for(j=1;j&lt;=n;j++) s++; PS：这里的执行次数为 n*n 次 ，所以时间复杂度为O(n^2)。 123for(i=1;i&lt;=n;i++) for(j=1;j&lt;=i;j++) s++; PS：这里的执行次数为 (1+2+3+…+n)≈(n^2)/2次，所以时间复杂度为O(n^2)。 空间复杂度空间复杂度定义 S(n)=O(f(n))空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。 比如直接插入排序的时间复杂度是O(n^2),空间复杂度是O(1) 。 而一般的递归算法就要有O(n)的空间复杂度了，因为每次递归都要存储返回信息。 各种算法的总结 总结：接着我会使用 js 来做各种排序算法的分析。 参考文档： js十大排序算法 算法时间复杂度的计算 [整理] 如何计算时间复杂度]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式-享元模式]]></title>
    <url>%2F2017%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[享元模式的基础定义：享元模式是一种用于性能优化的模式，如果系统中因为创建了大量类似的对象而导致内存不足或占用过高这种模式就非常有用了。使用场景：第一种是应用在数据层上，主要是应用在内存里大量相似的对象上；第二种是应用在DOM层上，享元可以用在中央事件管理器上用来避免给父容器里的每个子元素都附加事件句柄。作用：Flyweight中有两个重要概念–内部状态intrinsic和外部状态extrinsic之分，内部状态就是在对象里通过内部方法管理，而外部信息可以在通过外部删除或者保存。 内衣厂展示许多商品需求：假设有个内衣工厂，目前的产品有50种男士内衣与50种女士内衣，为了推销产品，工厂决定生产一些塑料模特来穿上它们的内衣拍成内衣广告。这里很显然适合使用 享元模式 来组织代码。12345678910111213141516171819202122// 定义塑料模特的构造函数var Model = function (sex) &#123; this.sex = sex;&#125;// 为模特拍照Model.prototype.takePhoto = function () &#123; console.log(&apos;sex=&apos; + this.sex + &apos;underwear=&apos; + this.underwear )&#125;// 实例化一个男模特 和 一个女模特var maleModel = new Model(&apos;male&apos;), female = new Model(&apos;female&apos;); for (var i = 1; i &lt;=50; i++)&#123; // 分别为模特换上 50 件内衣 以及 照相 maleModel.underwear = &apos;underwear&apos; + i; maleModel.takePhoto();&#125;for (var i = 1; i &lt;=50; i++)&#123; // 分别为模特换上 50 件内衣 以及 照相 female.underwear = &apos;underwear&apos; + i; femaleModel.takePhoto();&#125; PS：很显然，这里只需要两个对象便完成这个需求。 地图应用（对象池）说明：对象池维护一个装载空闲对象的池子，如果需要对象的时候，不是直接new，而是转从对象池里获取对象。如果对象池里没有空闲对象则创建一个新的对象，当获取的对象完成他的职责之后，再进入池子等待被下次获取。需求：假设我们在开发一个地图应用，地图上经常会出现一些标志地名的小气泡，我们叫它toolTip 。当第一次搜索A地点时假设出现了2个小气泡，第二次搜索A附近的B地点的时候页面出现了6个小气泡，按照对象池的思想，在第二次搜索开始之前，并不会把第一次创建的2个小气泡删除掉，而是把它们放进对象池。这样第二次搜索结果页面里，我们只需要再创建4个小气泡而不是6个。 定义个气泡工厂1234567891011121314151617var toolTipFactory = (function () &#123; var toolTipPool = []; // toolTip 对象池 return &#123; create : function () &#123; if(toolTipPool.length === 0)&#123; var div = document.createElement(&apos;div&apos;); document.body.appendChild(div); return div; &#125; else&#123; return toolTipPool.shift(); //shift a dom &#125; &#125;, recover : function (tooltipDom) &#123; return toolTipPool.push(tooltipDom); &#125; &#125;;&#125;)(); PS：气泡工厂的对象池为数组是私有属性被包含在工厂闭包里，这个工厂又两个暴露对外的方法，create表示获取一个div节点，recover表示回收一个div节点。 第一次搜索（2个气泡）123456var ary = [];for(var i = 0, str; str = [&apos;A&apos;,&apos;B&apos;][i++])&#123; // get ary elem var toolTip = toolTipFactory.create(); toolTip.innerHTML = str; ary.push(toolTip)&#125;; PS：现在重新回到第一次搜索的时刻，目前需要创建2个小气泡节点，为了方便回收，用一个数组ary来记录它们。 现在开始回收节点123for(var i = 0 , toolTip ; toolTip = ary[i++])&#123; toolTip.recover(toolTip)&#125; 第二次搜索（6个气泡）1234for(var i =0 , str; str = [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;][i++]; )&#123; var toolTip = toolTipFactory.create(); toolTip.innerHTML(str);&#125; PS：现在页面中已经出现了6个节点，上一次创建好的节点被共享给了下一次操作。 参考文档：三分钟教会你JS设计模式之享元模式深入理解JavaScript系列（37）：设计模式之享元模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式-状态模式]]></title>
    <url>%2F2017%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[状态模式的基础定义：状态模式（State）定义一个对象，这个对象可以通过管理其状态从而使得应用程序作出相应的变化。状态模式是一个非常常用的设计模式，它主要有两个角色组成：（1）环境类：拥有一个状态成员，可以修改其状态并作出相应反应。（2）状态类：表示一种状态，包含其相应的处理方法作用：状态模式就是一种适合多种状态场景下的设计模式。使用状态模式可以让代码更加清晰，提高应用程序的维护性和扩展性。使用场景：文件下载（开始、暂停、完成、失败等）、红绿灯 红绿灯（红绿黄灯）说明：我们简单地通过一个红绿灯的例子来说明状态模式，红绿灯拥有一个状态：哪一种颜色的灯亮了，每一种颜色的灯亮了之后又各自的动作，一共有红绿黄三种颜色的灯，也就是有三种状态。 定义环境类（红绿灯对象）123456789var trafficLight = (function () &#123; var currentLight = null; return &#123; change: function (light) &#123; currentLight = light; currentLight.go(); &#125; &#125;&#125;)(); PS：上面的代码中，trafficLight是一个红绿灯对象，它有一个局部变量currentLight表示当前亮灯的对象，同时返回一个方法，这个方法用来改变红绿灯的状态，并触发相应的处理程序。 定义状态类（三种不同颜色的灯）123456789101112131415// 红灯function RedLight() &#123; &#125;RedLight.prototype.go = function () &#123; console.log(&quot;this is red light&quot;);&#125;// 绿灯function GreenLight() &#123; &#125;GreenLight.prototype.go = function () &#123; console.log(&quot;this is green light&quot;);&#125;// 黄灯function YellowLight() &#123; &#125;YellowLight.prototype.go = function () &#123; console.log(&quot;this is yellow light&quot;);&#125; PS：这段代码分别定义了红绿黄三种颜色的灯对象，每一个对象都包含一个go方法作为亮灯之后的处理程序。 客户端切换不同颜色的灯12trafficLight.change(new RedLight()); // this is red lighttrafficLight.change(new YellowLight()); // this is yellow light PS：通过传入灯对象到change方法中，从而改变红绿灯的状态，触发其相应的处理程序，这就是一个典型的状态模式的应用。 菜单组件（JS组件开发中的状态模式）说明：状态模式在开发JS组件时非常有用，我们平时开发组件时很多时候要切换组件的状态，每种状态有不同的处理方式，这个时候就可以使用状态模式进行开发。比如我们要开发一个菜单组件，菜单拥有最基本的两种状态：显示和隐藏，相应的显示或隐藏可能会有各自的其他操作。 定义一个环境类（菜单对象）1234function Menu() &#123; &#125;Menu.prototype.toggle = function (state) &#123; state();&#125; PS：这个菜单类有一个toggle方法用来切换状态，然后调用相应的处理方法。 定义状态类（切换菜单）12345678var menuStates = &#123; &quot;show&quot;: function () &#123; console.log(&quot;the menu is showing&quot;); &#125;, &quot;hide&quot;: function () &#123; console.log(&quot;the menu is hiding&quot;); &#125;&#125;; PS：通过一个对象menuStates来定义menu的状态，这里有两种状态show和hide，然后拥有相应的处理方法。 客户端切换菜单状态123var menu = new Menu();menu.toggle(menuStates.show);menu.toggle(menuStates.hide); PS：这段代码实例化了一个Menu对象，然后分别切换了显示和隐藏两种状态，如果有第三种状态，我们只需要menuStates添加相应的状态和处理程序即可。 参考文档：深入理解JavaScript系列（43）：设计模式之状态模式Javascript设计模式理论与实战：状态模式Javascript设计模式理论与实战：状态模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式-职责链模式]]></title>
    <url>%2F2017%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[职责链模式的基础定义：职责链模式（Chain of responsibility）是使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。职责链模式的名字非常形象，一系列可能会处理请求的对象被该连接成一条链，请求在这些对象之间依次传递，直到遇到一个可以处理它的对象，我们把这些对象成为链中的节点。优点：请求发送者只需要知道链中的第一个节点，从而弱化了发送者和一组接收者之间的强联系。使用场景：挤公交车递钱（只有售票员可以收钱）、交押金预定手机 交押金预定手机 假设一个电视购物网站对于某部新上市的手机经过了2轮缴纳500元定金与200元定金的预定，现在已经到了正式购买的阶段。支付了500元定金的用户在购买阶段可以使用100元优惠券，200元定金可以使用50元优惠券，普通用户没有优惠且当库存不足不一定能买到。约定：orderType: 表示订单类型(定金或者普通用户),code的值为1时候是500元定金用户，为2是200元定金用户，为3则是普通用户。pay : 表示用户是否支付定金，用户虽然下过500元定金的订单但是如果他一直没有支付定金，那么只能降级为普通用户。stock : 仅用户普通用户的库存数量，定金用户不受限制。首先定义三种预定的客户的订单并且让每种客户订单有满足当前预定条件和不满足当前预定条件（需后面继续处理）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 500 元客户订单var order500 = function (orderType,pay,stock) &#123; if(orderType === 1 &amp;&amp; pay)&#123; console.log(&apos;500 rmb deposit, get 100 coupon &apos;) &#125; else &#123; return &apos;nextSuccessor&apos; // unknow the next node but always pass to next. &#125;&#125;;// 200 元客户订单var order200 = function (orderType,pay,stock) &#123; if(orderType === 2 &amp;&amp; pay)&#123; console.log(&apos;200 rmb deposit , get 50 coupon&apos;) &#125; else&#123; return &apos;nextSuccessor&apos;; &#125;&#125;;// 无预约客户订单var orderNormal = function (orderType,pay,stock) &#123; if(stock &gt; 0)&#123; console.log(&apos;normal buy no coupon&apos;) &#125; else&#123; console.log(&apos;the stock lack&apos;) &#125;&#125;;// 定制职责链对象（作用是形成订单职责链）var Chain = function (fn) &#123; this.fn = fn; this.successor = null;&#125;;// 设置职责链Chain.prototype.setNextSuccessor = function (successor) &#123; return this.successor = successor;&#125;;// 设置每个节点的调用方式Chain.prototype.passRequest = function () &#123; var ret = this.fn.apply(this.arguments); if(ret === &apos;nextSuccessor&apos;)&#123; return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor,arguments) &#125; return ret;&#125;;// 现在我们把3个订单函数分别包装成职责链的节点var chainOrder500 = new Chain(order500);var chainOrder200 = new Chain(order200);var chainOrderNormal = new Chain(orderNormal);// 这里我们把上面封装的节点连成一条线，依次判断执行chainOrder500.setNextSuccessor(chainOrder200)chainOrder200.setNextSuccessor(chainOrderNormal)// 测试代码chainOrder500.passRequest(1,true,6); // 500 rmb deposit, get 100 couponchainOrder500.passRequest(2,true,4); // 200 rmb deposit , get 50 coupon 假如我们又想支持，300元定金购买，那我们就在改链中增加一个节点即可123456var order300 = function () &#123;// todo&#125;;chainOrder300 = new Chain(chainOrder300)chainOrder500.setNextSuccessor(chainOrder300)chainOrder300.setNextSuccessor(chainOrder200) 我们可以自由灵活的增加移除和链中的节点顺序，这样就很简单能满足瞬息万变的需求了。 参考文档： 三分钟教会你JS设计模式之职责链模式 深入理解JavaScript系列（38）：设计模式之职责链模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式-备忘录模式]]></title>
    <url>%2F2017%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[备忘录模式的基础定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态作用：在我们的开发中偶尔会遇到这样一种情况，需要对用户的行为进行撤销。要想实现撤销，首先需要保存软件系统的历史状态，当用户执行撤销时用之前的状态覆盖当前状态。本节介绍的备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便的回到一个特定的历史步骤。备忘录模式在js中经常用于数据缓存。使用场景：分页控件、撤销组件 分页控件12345678910111213141516var Page = function()&#123; let page = 1, cache = &#123;&#125;, data; return function( page )&#123; if ( cache[ page ] )&#123; data = cache[ page ]; render( data ); &#125;else&#123; Ajax.send( &apos;cgi.xx.com/xxx&apos;, function( data )&#123; cache[ page ] = data; render( data ); &#125;); &#125; &#125;&#125;(); PS：分页控件, 从服务器获得某一页的数据后可以存入缓存。以后再翻回这一页的时候，可以直接使用缓存里的数据而无需再次请求服务器。 参考文档：《javascript设计模式 – 备忘录模式》【Javascript设计模式14】-备忘录模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端同学需要了解的通信知识]]></title>
    <url>%2F2017%2F%E5%89%8D%E7%AB%AF%E5%90%8C%E5%AD%A6%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E9%80%9A%E4%BF%A1%E7%9F%A5%E8%AF%86.html</url>
    <content type="text"><![CDATA[head、options、get、put、post、delete含义与区别了解它们的区别，这对于 RESTful架构 来说非常有意义。 如果你还不知道什么叫 RESTful架构？ HEAD请求（判断资源是否存在）HEAD和GET本质是一样的，区别在于HEAD不含有呈现数据，而仅仅是HTTP头信息。 有的人可能觉得这个方法没什么用，其实不是这样的。想象一个业务情景：欲判断某个资源是否存在， 我们通常使用GET，但这里用HEAD则意义更加明确。 OPTIONS请求（获取当前URL支持的方法）这个方法很有趣，但极少使用。它用于获取当前URL所支持的方法。 若请求成功，则它会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”。 POST请求（相当于数据库操作–增）POST请求同PUT请求类似，都是向服务器端发送数据的，但是该请求会改变数据的种类等资源， 就像数据库的insert操作一样，会创建新的内容。几乎目前所有的提交操作都是用POST请求的。 DELETE请求（相当于数据库操作–删）DELETE请求顾名思义，就是用来删除某一个资源的，该请求就像数据库的delete操作。 PUT请求（相当于数据库操作–改）PUT请求是向服务器端发送数据的，从而改变信息，该请求就像数据库的update操作一样， 用来修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。 GET请求（相当于数据库操作–查）GET请求会向数据库发索取数据的请求，从而来获取信息，该请求就像数据库的select操作一样， 只是用来查询一下数据，不会修改、增加数据，不会影响资源的内容，即该请求不会产生副作用。 无论进行多少次操作，结果都是一样的。 常见的 GET 和 POST 的区别（浅比较） 这些都是比较常见的，我就直接借用下杨光的总结。 也许这才是面试官想要的上面我们的分析都是从TCP/IP五层网络架构中的 应用层 和 生产使用时做了区别，这里我们就进入更底层的 传输层 的分析吧！ GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 GET和POST还有一个重大区别，简单的说：GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）； 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。这里你只需要知道这个就好了，更详细请访问get与post的区别。 总结一下 http 状态码 看着这些是不是有些头大，下面我为大家总结一些通用的状态码。 100-199 用于指定客户端应相应的某些动作。 200-299 用于表示请求成功。 300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。 400-499 用于指出客户端的错误。 500-599 用于支持服务器错误。 1**100 (Continue/继续)如果服务器收到头信息中带有100-continue的请求，这是指客户端询问是否可以在后续的请求中发送附件。 在这种情况下，服务器用100(SC_CONTINUE)允许客户端继续或用417 (Expectation Failed)告诉客户端 不同意接受附件。这个状态码是 HTTP 1.1中新加入的。 101 (Switching Protocols/转换协议)指服务器将按照其上的头信息变为一个不同的协议。这是 HTTP 1.1中新加入的。 2**200 (OK/正常)200 (SC_OK)的意思是一切正常。一般用于相应GET和POST请求。这个状态码对servlet是缺省的； 如果没有调用setStatus方法的话，就会得到200。 201 (Created/已创建)201 (SC_CREATED)表示服务器在请求的响应中建立了新文档；应在定位头信息中给出它的URL。 202 (Accepted/接受)202 (SC_ACCEPTED)告诉客户端请求正在被执行，但还没有处理完。 203 (Non-Authoritative Information/非官方信息)状态码203 (SC_NON_AUTHORITATIVE_INFORMATION)是表示文档被正常的返回，但是由于正在使用的 是文档副本所以某些响应头信息可能不正确。这是 HTTP 1.1中新加入的。 204 (No Content/无内容)在并没有新文档的情况下，204 (SC_NO_CONTENT)确保浏览器继续显示先前的文档。这各状态码对于 用户周期性的重载某一页非常有用，并且你可以确定先前的页面是否已经更新。例如，某个servlet 可能作如下操作： 123456int pageVersion =Integer.parseInt(request.getParameter(&quot;pageVersion&quot;));if (pageVersion &gt;;= currentVersion) &#123; response.setStatus(response.SC_NO_CONTENT);&#125; else &#123; // Create regular page&#125; 205 (Reset Content/重置内容)重置内容205 (SC_RESET_CONTENT)的意思是虽然没有新文档但浏览器要重置文档显示。这个状态码用 于强迫浏览器清除表单域。这是 HTTP 1.1中新加入的。 206 (Partial Content/局部内容)206 (SC_PARTIAL_CONTENT)是在服务器完成了一个包含Range头信息的局部请求时被发送的。 这是 HTTP 1.1中新加入的。 3**300 (Multiple Choices/多重选择)300 (SC_MULTIPLE_CHOICES)表示被请求的文档可以在多个地方找到，并将在返回的文档中列出来。 如果服务器有首选设置，首选项将会被列于定位响应头信息中。 301 (Moved Permanently)永久性重定向。 302 (Move temporarily)临时性重定向。 303 (See Other/参见其他信息)与301类似，使用GET和POST请求查看 304 (Not Modified/未更改)当客户端有一个缓存的文档，通过提供一个 If-Modified-Since 头信息可指出客户端只希望文档在指定日期之后 有所修改时才会重载此文档，用这种方式可以进行有条件的请求。304 (SC_NOT_MODIFIED)是指缓冲的版本已经被 更新并且客户端应刷新文档。另外，服务器将返回请求的文档及状态码 200。servlet一般情况下不会直接设置这 个状态码。它们会实现getLastModified方法并根据修正日期让默认服务方法处理有条件的请求。这个方法的例程 已在2.8部分(An Example Using Servlet Initialization and Page Modification Dates/一个使用servlet初始化 和页面修正日期的例子)给出。 305 (Use Proxy/使用代理)305 (SC_USE_PROXY)表示所请求的文档要通过定位头信息中的代理服务器获得。这个状态码是新加入 HTTP 1.1中的。 307 (Temporary Redirect/临时重定向)与302类似，使用GET请求重定向。 4**400 (Bad Request/错误请求)400 (SC_BAD_REQUEST)指出客户端请求中的语法错误。 401 (Unauthorized/未授权)401 (SC_UNAUTHORIZED)表示客户端在授权头信息中没有有效的身份信息时访问受到密码保护的页面。 这个响应必须包含一个WWW-Authenticate的授权信息头。例如，在本书4.5部分中的“Restricting Access to Web Pages./限制访问Web页。” 403 (Forbidden/禁止)403 (SC_FORBIDDEN)的意思是除非拥有授权否则服务器拒绝提供所请求的资源。这个状态经常会由于 服务器上的损坏文件或目录许可而引起。 404 (Not Found/未找到)404 (SC_NOT_FOUND)状态每个网络程序员可能都遇到过，他告诉客户端所给的地址无法找到任何资源。 它是表示“没有所访问页面”的标准方式。这个状态码是常用的响应并且在HttpServletResponse类中有 专门的方法实现它：sendError(&quot;message&quot;)。相对于setStatus使用sendError得好处是：服务器会自动 生成一个错误页来显示错误信息。 405 (Method Not Allowed/方法未允许)405 (SC_METHOD_NOT_ALLOWED)指出请求方法(GET, POST, HEAD, PUT, DELETE, 等)对某些特定的资源 不允许使用。该状态码是新加入 HTTP 1.1中的。 406 (Not Acceptable/无法访问)406 (SC_NOT_ACCEPTABLE)表示请求资源的MIME类型与客户端中Accept头信息中指定的类型不一致。 406是新加入 HTTP 1.1中的。 407 (Proxy Authentication Required/代理服务器认证要求)407 (SC_PROXY_AUTHENTICATION_REQUIRED)与401状态有些相似，只是这个状态用于代理服务器。 该状态指出客户端必须通过代理服务器的认证。代理服务器返回一个Proxy-Authenticate响应头 信息给客户端，这会引起客户端使用带有Proxy-Authorization请求的头信息重新连接。 该状态码是新加入 HTTP 1.1中的。 408 (Request Timeout/请求超时)408 (SC_REQUEST_TIMEOUT)是指服务端等待客户端发送请求的时间过长。该状态码是新加入 HTTP 1.1中的。 409 (Conflict/冲突)该状态通常与PUT请求一同使用，409 (SC_CONFLICT)状态常被用于试图上传版本不正确的文件时。 该状态码是新加入 HTTP 1.1中的。 410 (Gone/已经不存在)410 (SC_GONE)告诉客户端所请求的文档已经不存在并且没有更新的地址。 410状态不同于404，410是在指导文档已被移走的情况下使用，而404则用于未知原因的无法访问。 该状态码是新加入 HTTP 1.1中的。 411 (Length Required/需要数据长度)411 (SC_LENGTH_REQUIRED)表示服务器不能处理请求（假设为带有附件的POST请求），除非客户端 发送Content-Length头信息指出发送给服务器的数据的大小。该状态是新加入 HTTP 1.1的。 412 (Precondition Failed/先决条件错误)412 (SC_PRECONDITION_FAILED)状态指出请求头信息中的某些先决条件是错误的。该状态是新加入 HTTP 1.1的。 413 (Request Entity Too Large/请求实体过大)413 (SC_REQUEST_ENTITY_TOO_LARGE)告诉客户端现在所请求的文档比服务器现在想要处理的要大。 如果服务器认为能够过一段时间处理，则会包含一个Retry-After的响应头信息。该状态是新加入 HTTP 1.1的。 414 (Request URI Too Long/请求URI过长)414 (SC_REQUEST_URI_TOO_LONG)状态用于在URI过长的情况时。这里所指的“URI”是指URL中主机、 域名及端口号之后的内容。例如：在URL--http://www.y2k-disaster.com:8080/we/look/silly/now/中URI是指/we/look/silly/now/。 该状态是新加入 HTTP 1.1的。 415 (Unsupported Media Type/不支持的媒体格式)415 (SC_UNSUPPORTED_MEDIA_TYPE)意味着请求所带的附件的格式类型服务器不知道如何处理。该状态是新加入 HTTP 1.1的。 416 (Requested Range Not Satisfiable/请求范围无法满足)416表示客户端包含了一个服务器无法满足的Range头信息的请求。该状态是新加入 HTTP 1.1的。 奇怪的是，在servlet 2.1版本API的HttpServletResponse中并没有相应的常量代表该状态。 417 (Expectation Failed/期望失败)如果服务器得到一个带有100-continue值的Expect请求头信息，这是指客户端正在询问是否可以在后面的 请求中发送附件。在这种情况下，服务器也会用该状态(417)告诉浏览器服务器不接收该附件或用100 (SC_CONTINUE)状态 告诉客户端可以继续发送附件。该状态是新加入 HTTP 1.1的。 5**500 (Internal Server Error/内部服务器错误)500 (SC_INTERNAL_SERVER_ERROR) 是常用的“服务器错误”状态。该状态经常由CGI程序引起也可能 （但愿不会如此！）由无法正常运行的或返回头信息格式不正确的servlet引起。 501 (Not Implemented/未实现)501 (SC_NOT_IMPLEMENTED)状态告诉客户端服务器不支持请求中要求的功能。例如，客户端执行了如PUT 这样的服务器并不支持的命令。 502 (Bad Gateway/错误的网关)502 (SC_BAD_GATEWAY)被用于充当代理或网关的服务器；该状态指出接收服务器接收到远端服务器的错误响应。 503 (Service Unavailable/服务无法获得)状态码503 (SC_SERVICE_UNAVAILABLE)表示服务器由于在维护或已经超载而无法响应。例如，如果某些线程 或数据库连接池已经没有空闲则servlet会返回这个头信息。服务器可提供一个Retry-After头信息告诉客户 端什么时候可以在试一次。 504 (Gateway Timeout/网关超时)该状态也用于充当代理或网关的服务器；它指出接收服务器没有从远端服务器得到及时的响应。 该状态是新加入 HTTP 1.1的。 505 (HTTP Version Not Supported/不支持的 HTTP 版本)505 (SC_HTTP_VERSION_NOT_SUPPORTED)状态码是说服务器并不支持在请求中所标明 HTTP 版本。 该状态是新加入 HTTP 1.1的。 http 缓存相关这里关于前端仔 http缓存相关的知识，我就不再总结了，有兴趣的同学可以访问我http缓存相关的知识。 参考文档： get、put、post、delete含义与区别 HTTP协议中GET和POST方法的区别 99%的人都理解错了HTTP中GET与POST的区别 有同学不好翻墙，就看百度的http状态码吧 HTTP状态码大全]]></content>
      <categories>
        <category>通信协议</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式-组合模式]]></title>
    <url>%2F2017%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[组合模式的基础定义：组合模式（Composite）将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。作用：组合模式让你可以优化处理递归或分级数据结构。使用场景：系统目录结构、网站导航结构、文件扫描、DOM的机制，一个DOM节点可以包含子节点，不管是父节点还是子节点都有添加、删除、遍历子节点的通用功能。该模式由两部分构成：1.子对象（Leaf）：组成组合对象的最基本对象。2.组合对象（Composite）：由子对象组合起来的复杂对象。 组合模式的例子文件扫描123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 定义组合对象（文件夹）let Folder = function( name )&#123; this.name = name; this.files = [];&#125;;Folder.prototype.add = function( file )&#123; this.files.push( file );&#125;;Folder.prototype.scan = function()&#123; console.log(&apos;开始文件扫描:&apos; + this.name); for( let i = 0, file, files = this.files; file = files[i++]; )&#123; file.scan(); &#125;&#125;;//定义叶子对象（文件）let File = function( name )&#123; this.name = name;&#125;;File.prototype.add = function()&#123; throw new Error(&apos;文件下面不能再添加文件&apos;);&#125;;File.prototype.scan = function()&#123; console.log(&apos;开始扫瞄：&apos; + this.name);&#125;;let folder = new Folder(&apos;前端学习&apos;);let folder1 = new Folder(&apos;JS学习&apos;);let folder2 = new Folder(&apos;JQ学习&apos;);let file1 = new File(&apos;JS设计模式&apos;);let file2 = new File(&apos;JQ实战&apos;);let file3 = new File(&apos;前端性能&apos;);folder1.add(file1);folder2.add(file2);folder.add(folder1);folder.add(folder2);folder.add(file3);folder.scan();// 输出开始文件扫描：前端学习开始文件扫描：JS学习开始扫瞄：JS设计模式开始文件扫描：JQ学习开始扫瞄：JQ实战开始扫瞄：前端性能 PS：父类和子类必须具有相同的接口（方法），只不过它们相同的方法具有的功能不相同，例如父类的实例具有 add 方法作用是，可以添加文件夹 或者 文件。子类的实例具有 add 方法则不能添加文件夹 或者 文件，却抛出一个错误（子类重写父类的方法）。 参考文档：0521组合模式深入理解JavaScript系列（40）：设计模式之组合模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式-模版方法模式]]></title>
    <url>%2F2017%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[模版方法模式定义：模板方法模式由二部分组成，第一部分是抽象父类，第二部分是具体实现的子类，一般的情况下是抽象父类封装了子类的算法框架，包括实现一些公共方法及封装子类中所有方法的执行顺序，子类可以继承这个父类，并且可以在子类中重写父类的方法，从而实现自己的业务逻辑。使用场景：（主要用于步骤相似的事情） 泡饮品（茶 和 coffee） 公司面试（百度面试 和 阿里面试） IT公司面试下面就以IT公司面试作为父类，百度面试作为子类来实现面试流程模版方法。（1.笔试 &gt;&gt; 2.技术面试 &gt;&gt; 3.领导面试 &gt;&gt; 4.等offer） 定义父类let ITInterview = function(){}; 笔试1234// 笔试ITInterview.prototype.writtenTest = function()&#123; console.log(&quot;某公司笔试测试&quot;);&#125;; 技术面试1234// 技术面试ITInterview.prototype.technicalInterview = function()&#123; console.log(&quot;某公司技术面试测试&quot;);&#125;; 领导面试1234// 领导面试ITInterview.prototype.leader = function()&#123; console.log(&quot;某公司leader来面试了&quot;);&#125;; 等offer1234// 等通知ITInterview.prototype.waitNotice = function()&#123; console.log(&quot;某公司的offer到了&quot;);&#125;; 定义模版方法作用：封装了子类的算法框架，包括实现一些公共方法及封装子类中所有方法的执行顺序。1234567// 当然，这是一切顺利的流程......ITInterview.prototype.init = function()&#123; this.writtenTest(); this.technicalInterview(); this.leader(); this.waitNotice();&#125;; 定义子类（百度面试）首先子类需要重父类哪里继承所有的方法12let BaiDuInterview = function()&#123;&#125;;BaiDuInterview.prototype = new ITInterview(); 百度笔试1234// 笔试BaiDuInterview.prototype.writtenTest = function()&#123; console.log(&quot;百度公司笔试测试&quot;); // 无非就是面试题不一样呗&#125;; 百度技术面试1234// 技术面试BaiDuInterview.prototype.technicalInterview = function()&#123; console.log(&quot;百度公司技术面试测试&quot;);&#125;; 百度领导面试1234// 领导面试BaiDuInterview.prototype.leader = function()&#123; console.log(&quot;百度公司leader来面试了&quot;);&#125;; 等offer1234// 等通知BaiDuInterview.prototype.waitNotice = function()&#123; console.log(&quot;百度公司的offer到了&quot;);&#125;; 测试执行let baiduInterview = new BaiDuInterview();baiduInterview.init(); // 子类还可以重写父类的init方法，这样各个公司面试的流程就不一样了。依次输出：百度公司笔试测试百度公司技术面试测试百度公司leader来面试了百度公司的offer到了 参考文档：JS设计模式之模板方法JavaScript：设计模式之模板方法javascript模板方法模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式-访问者模式]]></title>
    <url>%2F2017%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[在访问者模式中，主要包括以下几个角色 抽象访问者：抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是visit方法中的参数定义哪些对象是可以被访问的。 访问者：实现抽象访问者所声明的方法，它影响到访问者访问到一个类后该干什么，要做什么事情。 抽象元素类：接口或者抽象类，声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义的。抽象元素一般有两类方法，一部分是本身的业务逻辑，另外就是允许接收哪类访问者来访问。 元素类：实现抽象元素类所声明的accept方法，通常都是visitor.visit(this)，基本上已经形成一种定式了。 结构对象：一个元素的容器，一般包含一个容纳多个不同类、不同接口的容器，如List、Set、Map等，在项目中一般很少抽象出这个角色。 123456789101112131415161718192021// 访问者 function Visitor() &#123; this.visit = function( concreteElement ) &#123; concreteElement.doSomething(); &#125; &#125; // 元素类 function ConceteElement() &#123; this.doSomething = function() &#123; console.log(&quot;这是一个具体元素&quot;); &#125; this.accept = function( visitor ) &#123; visitor.visit(this); &#125; &#125; // Client var ele = new ConceteElement(); var v = new Visitor(); ele.accept( v ); 访问者模式的适用场景 假如一个对象中存在着一些与本对象不相干（或者关系较弱）的操作，为了避免这些操作污染这个对象，则可以使用访问者模式来把这些操作封装到访问者中去。 假如一组对象中，存在着相似的操作，为了避免出现大量重复的代码，也可以将这些重复的操作封装到访问者中去。 访问者模式的优点 符合单一职责原则：凡是适用访问者模式的场景中，元素类中需要封装在访问者中的操作必定是与元素类本身关系不大且是易变的操作，使用访问者模式一方面符合单一职责原则，另一方面，因为被封装的操作通常来说都是易变的，所以当发生变化时，就可以在不改变元素类本身的前提下，实现对变化部分的扩展。 扩展性良好：元素类可以通过接受不同的访问者来实现对不同操作的扩展。 参考文档： 【JS设计模式】访问者模式的代码示例]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux-API整理]]></title>
    <url>%2F2017%2FRedux-API%E6%95%B4%E7%90%86.html</url>
    <content type="text"><![CDATA[Redux 定义了一系列的约定（contract）来让你来实现（例如 reducers），同时提供少量辅助函数来把这些约定整合到一起。Redux 只关心如何管理 state。在实际的项目中，你还需要使用 UI 绑定库如 react-redux。 redux相关API创建 storecreateStore(reducers, [preloadedState], enhancer) 合并 reducers 函数该函数返回结果将作为 createStore 的第一个参数。随着应用变得越来越复杂，可以考虑将 reducer 函数 拆分成多个单独的函数，拆分后的每个函数负责独立管理 state 的一部分。combineReducers(reducers) 添加中间件该函数返回结果将作为 createStore 的第三个参数。我们可以在 action - reducer 中间加入，中间件如 redux-saga 等。applyMiddleware(…middlewares) otherbindActionCreators(actionCreators, dispatch)compose(…functions) Store APIgetState() // 返回应用当前的 state 树。dispatch(action) // 分发 action。这是触发 state 变化的惟一途径。subscribe(listener) // 添加一个变化监听器。每当 dispatch action 的时候就会执行，state 树中的一部分可能已经变化时触发监听函数。replaceReducer(nextReducer) // 替换 store 当前用来计算 state 的 reducer。 React-redux作用：Redux 官方提供的 React 绑定库。本库深受分离容器组件和展示组件思想启发。在应用中，只有最顶层组件是对 Redux 可知（例如路由处理）这是很好的。所有它们的子组件都应该是“笨拙”的，并且是通过 props 获取数据。对比 容器组件 和 展示组件 组件类型 容器组件 展示组件 位置 最顶层，路由处理 中间和子组件 使用 Redux 是 否 读取数据 从 Redux 获取 state 从 props 获取数据 修改数据 向 Redux 发起 actions 从 props 调用回调函数 Provider 组件作用：Provider 使组件层级中的 connect() 方法都能够获得 Redux store。正常情况下，你的根组件应该嵌套在 Provider 中才能使用 connect() 方法。属性：store (Redux Store): 应用程序中唯一的 Redux store 对象children (ReactElement) 组件层级的根组件。123456ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;Router history=&#123;history&#125;&gt;...&lt;/Router&gt; &lt;/Provider&gt;, targetEl); connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])作用： 连接 React 组件与 Redux store。 连接操作不会改变原来的组件类，反而返回一个新的已与 Redux store 连接的组件类。参数：1.[mapStateToProps(state, [ownProps]): stateProps] (Function): 如果定义该参数，组件将会监听 Redux store 的变化。2.[mapDispatchToProps(dispatch, [ownProps]): dispatchProps] (Object or Function): 如果传递的是一个对象，那么每个定义在该对象的函数都将被当作 Redux action creator， 而且这个对象会与 Redux store 绑定在一起，其中所定义的方法名将作为属性名，合并到组件的 props 中。3.[mergeProps(stateProps, dispatchProps, ownProps): props] (Function): 如果指定了这个参数，mapStateToProps() 与 mapDispatchToProps() 的执行结果和组件自身的 props 将传入到这个回调函数中。该回调函数返回的对象将作为 props 传递到被包装的组件中。4.[options] (Object) 如果指定这个参数，可以定制 connector 的行为。 返回值： 根据配置信息，返回一个注入了 state 和 action creator 的 React 组件。静态属性： WrappedComponent (Component): 传递到 connect() 函数的原始组件类。静态方法： 组件原来的静态方法都被提升到被包装的 React 组件。实例方法： getWrappedInstance(): ReactComponent 仅当 connect() 函数的第四个参数 options 设置了 { withRef: true } 才返回被包装的组件实例。 参考文档：redux 官方文档redux]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-routerV4总结]]></title>
    <url>%2F2017%2FReact-routerV4%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[BrowserRouter作用： &lt;Router&gt; 使用 HTML5 提供的 history API (pushState, replaceState 和 popstate 事件) 来保持 UI 和 URL 的同步。 属性： basename: string 当前位置的基准 URL。如果你的页面部署在服务器的二级（子）目录，你需要将 basename 设置到此子目录。 正确的 URL 格式是前面有一个前导斜杠，但不能有尾部斜杠。 getUserConfirmation: func 当导航需要确认时执行的函数。默认使用 window.confirm。 forceRefresh: bool 当设置为 true 时，在导航的过程中整个页面将会刷新。 只有当浏览器不支持 HTML5 的 history API 时，才设置为 true。 keyLength: number location.key 的长度。默认是 6。 children: node 渲染单一子组件（元素）。 12345678910import &#123; BrowserRouter &#125; from &apos;react-router-dom&apos;&lt;BrowserRouter basename=&quot;/calendar&quot; forceRefresh=&quot;false&quot; getUserConfirmation=&#123;optionalFunc&#125; keyLength=&quot;10&quot;&gt; &lt;Link to=&quot;/today&quot; /&gt; // 渲染为 &lt;a href=&quot;/calendar/today&quot;&gt;&lt;/BrowserRouter&gt; HashRouter作用： HashRouter 是一种特定的 &lt;Router&gt;， HashRouter 使用 URL 的 hash (例如：window.location.hash) 来保持 UI 和 URL 的同步。 属性： basename: string 当前位置的基准 URL。正确的 URL 格式是前面有一个前导斜杠，但不能有尾部斜杠。 getUserConfirmation: func 当导航需要确认时执行的函数。默认使用 window.confirm。 hashType: string window.location.hash 使用的 hash 类型。有如下几种： &quot;slash&quot; - 后面跟一个斜杠，例如 #/ 和 #/sunshine/lollipops &quot;noslash&quot; - 后面没有斜杠，例如 # 和 #sunshine/lollipops &quot;hashbang&quot; - Google 风格的 “ajax crawlable”，例如 #!/ 和 #!/sunshine/lollipops 默认为 &quot;slash&quot;。 children: node 渲染单一子组件（元素）。 12345import &#123; HashRouter &#125; from &apos;react-router-dom&apos;&lt;HashRouter&gt; &lt;App/&gt;&lt;/HashRouter&gt; Link作用： 为您的应用提供声明式的、无障碍导航。 属性： to: string/object 需要跳转到的路径(pathname)或地址（location）。 需要跳转到的地址（location）。 replace: bool 当设置为 true 时，点击链接后将使用新地址替换掉访问历史记录里面的原地址。 当设置为 false 时，点击链接后将在原有访问历史记录的基础上添加一个新的纪录。默认为 false。 &lt;Link to=&quot;/about&quot;&gt;关于&lt;/Link&gt; &lt;Link to={{ pathname: '/courses', search: '?sort=name', hash: '#the-hash', state: { fromDashboard: true } }}/&gt; NavLink作用： 为当前 URL 添加 class 和 style。 属性： activeClassName: string 选中 URL 是添加的class。 activeStyle：object 选中 URL 是添加的style。 exact: bool 如果为 true，path 为 &apos;/one&apos; 的路由将不能匹配 &apos;/one/two&apos;，反之，亦然。 strict: bool 对路径末尾斜杠的匹配。如果为 true。path 为 &apos;/one/&apos; 将不能匹配 &apos;/one&apos; 但可以匹配 &apos;/one/two&apos;。 isActive: func 为URL匹配添加更严谨的逻辑函数。 Prompt作用： 当用户离开当前页面前做出一些提示。 属性： message: string/func 当用户离开当前页面时，设置的提示信息。 当用户离开当前页面时，设置的回掉函数 when: bool 通过设置一定条件要决定是否启用 Prompt MemoryRouter作用： 无 DOM 的环境。 属性： initialEntries: array 一个 history 堆栈的数组。 initialIndex: number 在 initialEntries 数组中的初始index。 getUserConfirmation: func keyLength: number children: node Redirect作用： 重定向将替代当前的location 中的 history。 属性： to: string/object 重定向string 重定向object push: bool 当为 true 时，替换掉整个history，而不是当前这一条。 from: string 重定向的路径名。 Route作用： 它最基本的职责就是当页面的访问地址与 Route 上的 path 匹配时，就渲染出对应的 UI 界面。 属性： component: func 只有当访问地址和路由匹配时，一个 React component 才会被渲染，此时此组件接受 route props (match, location, history)。 render: func 此方法适用于内联渲染，而且不会产生上文说的重复装载问题。 children: func 有时候你可能只想知道访问地址是否被匹配，然后改变下别的东西，而不仅仅是对应的页面。 path: string exact: bool strict: bool Router作用：底层路由接口组件，使用封装后的组件代替。 &lt;BrowserRouter&gt; &lt;HashRouter&gt; &lt;MemoryRouter&gt; &lt;NativeRouter&gt; &lt;StaticRouter&gt; 属性： history：object 导航的history对象 children: node StaticRouter定义： 不会更改location的 &lt;Router&gt;，服务端渲染。 属性： basename: string location: string context: object children: node Switch定义： 只渲染出第一个与当前访问地址匹配的 &lt;Route&gt; 或 &lt;Redirect&gt;。 我们只想渲染出第一个匹配的路由就可以了，于是 &lt;Switch&gt; 应运而生！ 属性： children: node 对象和方法history路由分类1.browser history -- HTML5 history API 2.hash history -- 低版本浏览器 3.memory history -- 无DOM环境（RN 和 Node） histoty对象详解length -- number 浏览历史堆栈中的条目数。 action -- string 路由跳转到当前执行页面的动作，分为 PUSH、REPLACE、POP。 location -- object 当前访问地址信息组成的对象 （pathname、search、hash、state） push(path, [state]) 在历史堆栈信息里加入一个新条目。 replace(path, [state]) 在历史堆栈信息里替换掉当前的条目 go(n) 将 history 堆栈中的指针向前移动 n。 goBack() 等同于 go(-1) goForward 等同于 go(1) block(prompt) 阻止跳转 locationlocation 是指你当前的位置，将要去的位置，或是之前所在的位置 在以下情境中可以获取 location 对象: 1.在 Route component 中，以 this.props.location 获取 2.在 Route render 中，以 ({location}) =&gt; () 方式获取 3.在 Route children 中，以 ({location}) =&gt; () 方式获取 4.在 withRouter 中，以 this.props.location 的方式获取 可以在不同情境中使用 location： 1.&lt;Link to={location} /&gt; 2.&lt;NaviveLink to={location} /&gt; 3.&lt;Redirect to={location /&gt; 4.history.push(location) 5.history.replace(location) matchmatch 对象包含了 &lt;Route path&gt; 如何与 URL 匹配的信息，具有以下属性： 1.params: object 路径参数，通过解析 URL 中的动态部分获得键值对 2.isExact: bool 为 true 时，整个 URL 都需要匹配 3.path: string 用来匹配的路径模式，用于创建嵌套的 &lt;Route&gt; 4.url: string URL 匹配的部分，用于嵌套的 &lt;Link&gt; 在以下情境中可以获取 match 对象 1.在 Route component 中，以 this.props.match获取 2.在 Route render 中，以 ({match}) =&gt; () 方式获取 3.在 Route children 中，以 ({match}) =&gt; () 方式获取 4.在 withRouter 中，以 this.props.match的方式获取 5.matchPath 的返回值 注：当一个 Route 没有 path 时，它会匹配一切路径。 matchPathpathname props withRouter 参考文档： MDN-history 初探 React Router 4.0]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux总结]]></title>
    <url>%2F2017%2FRedux%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[Redux 三大原则单一数据源整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。 State 是只读的惟一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。 使用纯函数来执行修改为了描述 action 如何改变 state tree ，你需要编写 reducers。 Immutable 是一个可实现持久数据结构的 JavaScript 库。 Redux 基本概念ActionAction12345const ADD_TODO = &apos;ADD_TODO&apos;&#123; type: ADD_TODO, text: &apos;Build my first Redux app&apos;&#125; Action 是把数据从应用传到 store 的有效载荷。它是 store 数据的唯一来源。 一般来说你会通过 store.dispatch() 将 action 传到 store。 Action 本质上是 JavaScript 普通对象。 我们约定，action 内必须使用一个字符串类型的 type 字段来表示将要执行的动作。 Action 创建函数123456function addTodo(text) &#123; return &#123; type: ADD_TODO, text &#125;&#125; Action 创建函数 就是生成 action 的方法。“action” 和 “action 创建函数” 这两个概念很容易混在一起，使用时最好注意区分。 分发 Action（此时就新建了一条 todo）Redux 中只需把 action 创建函数的结果传给 dispatch() 方法即可发起一次 dispatch 过程。 1dispatch(addTodo(&apos;新建的todo&apos;)) ReducerAction 只是描述了有事情发生了这一事实，并没有指明应用如何更新 state。 而这正是 reducer 要做的事情。 设计 State 结构在 Redux 应用中，所有的 state 都被保存在一个单一对象中。 12345678910111213&#123; visibilityFilter: &apos;SHOW_ALL&apos;, todos: [ &#123; text: &apos;Consider using Redux&apos;, completed: true, &#125;, &#123; text: &apos;Keep all state in a single tree&apos;, completed: false &#125; ]&#125; Action 处理（reducer 纯函数）reducer 模版（不再reducer中执行有副作用的操作，如 API 请求和路由跳转） 1234567// 模版(previousState, action) =&gt; newStatefunction todoApp(state = initialState, action) &#123; // 这里暂不处理任何 action， // 仅返回传入的 state。 return state&#125; 处理多个 action1234567891011121314151617181920function todoApp(state = initialState, action) &#123; switch (action.type) &#123; case SET_VISIBILITY_FILTER: return Object.assign(&#123;&#125;, state, &#123; visibilityFilter: action.filter &#125;) case ADD_TODO: return Object.assign(&#123;&#125;, state, &#123; todos: [ ...state.todos, &#123; text: action.text, completed: false &#125; ] &#125;) default: return state &#125;&#125; 拆分 Reducer注意每个 reducer 只负责管理全局 state 中它负责的一部分。 每个 reducer 的 state 参数都不同，分别对应它管理的那部分 state 数据。 Store总结，action 和 reducers。 action 来描述“发生了什么”，和使用 reducers 来根据 action 更新 state 的用法。 Store的作用： 1.维持应用的 state 2.提供 getState() 方法获取 state 3.提供 dispatch(action) 方法更新 state 4.通过 subscribe(listener) 注册监听器 5.通过 subscribe(listener) 返回的函数注销监听器 发起 Actions1234567// 订阅 state 更改// 注意 subscribe() 返回一个函数用来注销监听器let unsubscribe = store.subscribe(() =&gt; console.log(store.getState()))// 发起 actionstore.dispatch(reducers) 数据流动Redux 应用中数据的生命周期 1.调用 store.dispatch(action) 你可以在任何地方调用 store.dispatch(action)，包括组件中、XHR 回调中、甚至定时器中。 2.Redux store 调用传入的 reducer 函数 Store 会把两个参数传入 reducer： 当前的 state 树和 action。 let nextState = todoApp(previousState, action); 3.根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树。 combineReducers() 来把根 reducer 拆分成多个函数，用于分别处理 state 树的一个分支。 4.Redux store 保存了根 reducer 返回的完整 state 树。 Redux 高级异步 ActionAction 每个 API 请求都需要 dispatch 至少三种 action： 1.一种通知 reducer 请求开始的 action。 2.一种通知 reducer 请求成功结束的 action。 3.一种通知 reducer 请求失败的 action。 同步 Action Creator 12345678export const SELECT_SUBREDDIT = &apos;SELECT_SUBREDDIT&apos;export function selectSubreddit(subreddit) &#123; return &#123; type: SELECT_SUBREDDIT, subreddit &#125;&#125; 设计 state 结构处理 Action（reducer）处理异步 action：redux-thunk、redux-promise、redux-promise-middleware 异步 Action CreatorMiddleware你可以利用 Redux middleware 来进行日志记录、创建崩溃报告、调用异步接口或者路由等等。 问题: 记录日志 问题: 崩溃报告 搭配 React RouterRedux 和 React Router 将分别成为你数据和 URL 的事实来源。 参考文档： Redux 中文文档]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-API]]></title>
    <url>%2F2017%2FReact-API.html</url>
    <content type="text"><![CDATA[React 高阶 APICreating React Elements 123推荐使用 JSXcreateElement() -- 根据给定的类型创建并返回新的 React element。createFactory() -- 根据给定的类型返回一个创建React元素的函数。 Transforming Elements 12345678cloneElement() -- 以 element 作为起点，克隆并返回一个新的 React Element。isValidElement() -- 验证对象是否是一个React元素。返回 true 或 false 。React.Children() -- React.Children 提供了处理 this.props.children 这个不透明数据结构的工具。 React.Children.map(children, function[(thisArg)]) -- 返回数组 React.Children.forEach(children, function[(thisArg)]) -- 对数组每项进行操作 React.Children.count(children) -- 返回组件总数 React.Children.only(children) -- 返回仅有的子级 React.Children.toArray(children) -- 返回扁平数组 ComponentsReact 组件可以让你把UI分割为独立、可复用的片段，并将每一片段视为相互独立的部分。 React组件可以通过继承 React.Component 或 React.PureComponent 来定义。 React.Component12345class Greeting extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125; 组件生命周期 装配 -- 这些方法会在组件实例被创建和插入DOM中时被调用 1234constructor()componentWillMount()render()componentDidMount() 更新 -- 属性或状态的改变会触发一次更新。当一个组件在被重渲时，这些方法将会被调用 12345componentWillReceiveProps()shouldComponentUpdate()componentWillUpdate()render()componentDidUpdate() 卸载 -- 当一个组件被从DOM中移除时，该方法被调用 1componentWillUnmount() 其他API 12setState() 参数为对象或函数forceUpdate() 类属性 1234defaultProps defaultProps可以被定义为组件类的一个属性，用以为类设置默认的属性。displayName displayName被用在调试信息中。 实例属性 1234props this.props包含了组件该调用者定义的属性。state 状态是该组件的特定数据，其可能改变多次。 参考 12345678910111213141516171819202122232425262728render() 可以返回：React元素、字符串和数字、Portals、null、布尔值（null和布尔值什么都不渲染）constructor(props) super(props) 有两个作用： this 指向（子类的实例） 在构造函数中使用 this.props componentWillMount() 在装配发生前被立刻调用。 其在render()之前被调用。componentDidMount() 在组件被装配后立即调用。 初始化使得DOM节点应该进行到这里。ajax 和 定时器componentWillReceiveProps(nextProps) 在装配了的组件接收到新属性前调用。shouldComponentUpdate(nextProps, nextState) 使用shouldComponentUpdate()以让React知道当前状态或属性的改变是否不影响组件的输出。componentWillUpdate(nextProps, nextState) 当接收到新属性或状态时，componentWillUpdate()为在渲染前被立即调用。componentDidUpdate(prevProps, prevState) 在更新发生后立即被调用。该方法并不会在初始化渲染时调用。componentWillUnmount() 在组件被卸载和销毁之前立刻调用。 可以在该方法里处理任何必要的清理工作，例如解绑定时器，取消网络请求，清理任何在componentDidMount环节创建的DOM元素。setState(updater, [callback]) 参数为对象 &#123;name: &apos;fanerge&apos;&#125; 参数为函数(prevState, props) =&gt; stateChangecomponent.forceUpdate(callback) 调用forceUpdate()将会导致组件的 render()方法被调用，并忽略shouldComponentUpdate()。 React.PureComponent浅对比继承该类来对 prop 和 state 进行比较，并调用 shouldComponentUpate()。 深对比使用 forceUpdate() 和 不可变对象 来促进嵌套数据的快速比较。 ReactDOM123react-dom这个软件包提供了针对DOM的方法，可以在你应用的顶级域中调用，也可以在有需要的情况下用作跳出React模型的出口。render() 渲染一个React元素，添加到位于提供的container里的DOM元素中，并返回这个组件的一个引用 (或者对于无状态组件返回null). ReactDOM.render( element, container, [callback] ) 123456ReactDOM.unmountComponentAtNode(container) 从DOM元素中移除已挂载的React组件，清除它的事件处理器和state。 有组件被卸载的时候返回true，没有组件可供卸载时返回 false。ReactDOM.findDOMNode(component) 如果这个组件已经被挂载到DOM中，函数会返回对应的浏览器中生成的DOM元素 。 大多数情况下，你可以添加一个指向DOM节点的引用，从而完全避免使用 findDOMNode 这个函数. ReactDOMServerReactDOMServer 类可以让你在服务端渲染你的组件。 ReactDOMServer.renderToString(element)把一个React元素渲染为原始的HTML。 你可以用这个方法在服务端生成HTML，并根据初始请求发送标记来加快页面的加载速度， 同时让搜索引擎可以抓取你的页面来达到优化SEO的目的。 ReactDOMServer.renderToStaticMarkup(element)类似 renderToString，但是不会创建额外的DOM属性，例如 data-reactid 这些仅在React内部使用的属性。 如果你希望把React当作一个简单的静态页面生成器来使用，这很有用，因为去掉 DOM ElementsReact实现了一套与浏览器无关的DOM系统，兼顾了性能和跨浏览器的兼容性。12345class -- classNamefor -- htmlFortabindex -- tabIndexaria-* （对于残障人士更易使用的各种机制）小写字母命名 data-* （自定义属性）小写字母命名 React和HTML DOM属性的区别123456789101112131415161718192021222324checked属性 受控组件 -- &lt;input&gt;标签type属性值为checkbox或radio时，支持checked属性。 非受控组件 -- defaultChecked这是非受控组件的属性类名属性 class -- classNamedangerouslySetInnerHTML函数 处理Cross-site scripting (XSS) dangerouslySetInnerHTML是React提供的替换浏览器DOM中的innerHTML接口的一个函数。htmlFor for -- htmlFor绑定事件 onchange -- onChangeselected 受控组件 -- 使用selected属性，设定组件是否选中的状态。style属性 &lt;Hello style=&#123;&#123;color: &apos;blue&apos;&#125;&#125; /&gt; 浏览器后缀除了ms以外，都应该以大写字母开头。 这就是为什么WebkitTransition有一个大写字母W。suppressContentEditableWarning contentEditable 该属性少使用。value 受控组件 -- &lt;input&gt; 和 &lt;textarea&gt; 组件都支持value属性。 非受控组件 -- defaultValue属性对应的是非受控组件的属性，用来设置组件第一次加载时的值。支持所有的HTMl属性 SyntheticEvent您的事件处理函数将会接收SyntheticEvent的实例，一个基于浏览器原生事件的跨浏览器实现。1234567891011121314boolean bubblesboolean cancelableDOMEventTarget currentTargetboolean defaultPreventednumber eventPhaseboolean isTrustedDOMEvent nativeEventvoid preventDefault()boolean isDefaultPrevented()void stopPropagation()boolean isPropagationStopped()DOMEventTarget targetnumber timeStampstring type 事件池SyntheticEvent是共享的。那就意味着在调用事件回调之后，SyntheticEvent对象将会被重用，并且所有属性会被置空。 支持的事件在事件名后面加Capture就能在事件捕获阶段注册事件处理函数。 你可以使用onClickCapture代替onClick在事件捕获阶段来处理点击事件。 [查看所有支持的事件](https://doc.react-china.org/docs/events.html) Test Utilities导入 -- import ReactTestUtils from &apos;react-dom/test-utils&apos;; [单元测试](https://doc.react-china.org/docs/test-utils.html) 浅层渲染[浅层渲染](https://doc.react-china.org/docs/shallow-renderer.html) Test Renderer[Test Renderer](https://doc.react-china.org/docs/test-renderer.html) 参考文档： React官方API]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web常见的安全问题及解决方法]]></title>
    <url>%2F2018%2Fweb%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[前端安全问题XSS 漏洞定义： 跨站脚本攻击(Cross Site Scripting)，为了不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。 恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。 举例： 1.HTML DOM 视图（textContent） &lt;a href=&quot;/user/1&quot;&gt;{{ user_name }}&lt;/a&gt; 数据 &lt;script&gt;alert(1)&lt;/script&gt; 结果 &lt;a href=&quot;/user/1&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;/a&gt; 最基本的例子，如果此处不对 user_name 中的特殊符号进行 escape，就会造成 XSS。 2.HTML Attribute 视图（attribute） &lt;img src=&quot;{{ image_url }}&quot;&gt; 数据 onerror=&quot;alert(1)&quot; 结果 &lt;img src=&quot;&quot; onerror=&quot;alert(1)&quot;&gt; 这个例子表明，如果只对尖括号进行 escape 是不够的，很多时候引号也需要被 escape。 简单来说，对不同输出场景，需要使用不同的 escape 规则。 3.Javascript &lt;script&gt;var user_data = {{ user_data|json_encode }};&lt;/script&gt; 数据 {&quot;exploit&quot;: &quot;&lt;/script&gt;&lt;script&gt;alert(1);//&quot;} 结果 &lt;script&gt;var user_data = {&quot;exploit&quot;: &quot;&lt;/script&gt;&lt;script&gt;alert(1);//&quot;};&lt;/script&gt; 这是一个特别的例子，大多数人觉得，对于输出在 &lt;script&gt; 中的内容，json_encode 一下就安全了，其实不然。在这个例子中，XSS 仍然发生了。 解决方案： 1.在不同上下文中，使用合适的 escape 方式 2.不要相信任何来自用户的输入，（不仅限于 POST Body，还包括 QueryString，甚至是 Headers） CSRF 漏洞定义： CSRF（Cross-site request forgery）跨站请求伪造通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。 它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。 与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。 理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。 CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账...... 造成的问题包括：个人隐私泄露以及财产安全。 CSRF攻击攻击原理及过程如下： 1. 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A； 2. 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A； 3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B； 4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A； 5. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。 网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 举例： 1.跨站转账 银行网站A，它以GET请求来完成银行转账的操作，如：http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000 危险网站B，它里面有一段HTML的代码如下： &lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt; 首先，你登录了银行网站A保存了cookie，然后访问危险网站B，噢，这时你会发现你的银行账户少了1000块...... 为什么会这样呢？原因是银行网站A违反了HTTP规范，使用GET请求更新资源。 在访问危险网站B的之前，你已经登录了银行网站A，而B中的&lt;img&gt;以GET的方式请求第三方资源（这里的第三方就是指银行网站了， 原本这是一个合法的请求，但这里被不法分子利用了），所以你的浏览器会带上你的银行网站A的Cookie发出Get请求， 去获取资源“http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000”，结果银行网站服务器收到请求后， 认为这是一个更新资源操作（转账操作），所以就立刻进行转账操作...... 解决方案：（让服务器分辨出是真实用户还是攻击者） 1.为请求带上 token 2.验证HTTP Referer字段 根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。 3.在HTTP头中自定义属性并验证 a链接的安全问题阐述问题：当a链接有target=”_blank”属性时，必须添加rel=”noreferrer noopener”，不然新产生的页面可以通过window.opener来获取到父窗口的window对象。1&lt;a href=&quot;www.baidu.com&quot; target=&quot;_blank&quot; rel=&quot;nofollow me noopener noreferrer&quot; &gt; 聊聊 rel=noopener关于a标签target=“_blank”使用rel=noopener 后端安全问题SQL 注入漏洞问题展示： &lt;?php $user = mysql_query(&apos;SELECT * FROM USERS WHERE UserName=&quot;&apos;.$_GET[&apos;user&apos;].&apos;&quot;&apos;); ?&gt; 那么当请求中 user 参数为 &quot;;DROP TABLE USERS;-- 时，合成的 SQL 语句是： SELECT * FROM USERS WHERE UserName=&quot;&quot;;DROP TABLE USERS;--&quot; // 这样将删除表 users 解决方案： 所有 SQL 语句都使用参数化查询（推荐）或对参数进行 escape（不推荐） 权限控制漏洞问题展示： 未经授权可以进行的操作都是权限控制漏洞。 例如，某些网站的后台操作就仗着「以为用户不知道入口地址」不进行任何权限检查， 又例如，某些操作可能出现不允许更改的字段被用户递交更改（往往是那些网页上标记为 disabled 或者 hidden 的字段）， 再例如，允许通过 ../ 访问到不应该被访问的文件等（一般存在于 include 中）。 解决方案： 所有地方都要进行权限检查（如是否已登录、当前用户是否有足够权限、该项是否可修改等）， 总之，不要相信任何来自用户的数据，URL 当然也是。 SESSION 与 COOKIE问题展示： Session 和 Cookie 是两种用于存储用户当前状态的工具。 某些开发者不了解 Session 与 Cookie 的区别，误用或者混用，导致敏感信息泄露或者信息篡改。 Cookie 存储在浏览器上，用户可以查看和修改 Cookie。 解决方案： Session 是存储在服务端的数据，一般来说安全可靠；大多数 Session 都是基于 Cookie 实现的 （在 Cookie 中存储一串 SESSION_ID，在服务器上存储该 SESSION_ID 对应的内容）。 IP 地址问题展示： 首先，用户的 IP 地址一般存储在 REMOTE_ADDR 中，这是唯一的可信的 IP 地址数据（视不同语言而定）。 然后某些代理服务器，会将用户的真实 IP 地址附加在 header 的 VIA 或 X_FORWARDED_FOR 中（因为REMOTE_ADDR 是代理服务器自身的 IP）。 所以，要获取用户 IP 地址，一般做法是，判断是否存在 VIA 或者 X_FORWARDED_FOR 头， 如果存在，则使用它们，如果不存在则使用 REMOTE_ADDR。 这就产生问题了，X_FORWARDED_FOR 或 VIA 是 HTTP Header，换句话说，它们是可以被伪造的。 例如，在投票中，如果采信了 X_FORWARDED_FOR，往往意味着被刷票。 解决方案： 只使用 REMOTE_ADDR 作为获取 IP 的手段。 验证码问题展示： 验证码里常见的问题有：非一次性、容易被识别。 解决方案： 非一次性指的是，同一个验证码可以一直被用下去。一般来说，每进行一次验证码校对（无论正确与否）， 都应该强制更换或清除 Session 中的验证码。 关于识别问题，在当前科技水平下，不加噪点不加扭曲的验证码几乎是 100% 可识别的。 其他nodeJs项目重新安装依赖包rm -rf node_modulesrm package-lock.jsonnpm cache clear –forcenpm install 参考文档： Web 开发常见安全问题 浅谈CSRF攻击方式 汇总网络安全demo]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-组件书写方式]]></title>
    <url>%2F2017%2FReact-%E7%BB%84%E4%BB%B6%E4%B9%A6%E5%86%99%E6%96%B9%E5%BC%8F.html</url>
    <content type="text"><![CDATA[createClassES5 定义组件只能使用 createClass 12345678910111213141516171819202122232425262728293031const React = require(react);const Greeting = React.createClass(&#123; // 属性校验 propTypes: &#123; name: React.PropTypes.string &#125;, // 默认属性 getDefaultProps: function() &#123; return &#123; name: &apos;fanerge&apos; &#125;; &#125;, // 初始化state getInitialState: function() &#123; return &#123; count: this.props.initialCount &#125;; &#125;, // 事件函数 handleClick: function() &#123; &#125;, render: function() &#123; return &lt;h1 onClick=&#123;this.handleClick&#125;&gt;&#123;&#123;this.props.name&#125;&#125;&lt;/h1&gt; &#125;;&#125;);module.exports = Greeting; PS：使用createClass，React对属性中的所有函数都进行了this绑定，也就是如上面的hanleClick其实相当于handleClick.bind(this) 。 componentES6 的类（语法糖）对原型继承机制进行了封装 12345678910111213141516171819202122232425262728293031323334353637383940import React from &apos;react&apos;;class Greeting extends React.Component &#123; constructor(props) &#123; super(props); // 设置初始值 this.state = &#123;count: props.initialCount&#125;; // 为函数绑定 this this.handleClick = this.handleClick.bind(this); &#125; // 定义props方式1 static defaultProps = &#123; name: &apos;Mary&apos; &#125; // props验证方式1 static propTypes = &#123; name: React.PropTypes.string &#125; // 事件函数 handleClick() &#123; &#125; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt; &#125;;&#125;;// props验证方式2Greeting.propTypes = &#123; name: React.PropTypes.string&#125;;// 定义props方式2Greeting.defaultProps = &#123; name: &apos;Mary&apos; &#125;;export default Greeting; PS：可以看到Greeting继承自React.component,在构造函数中，通过super()来调用父类的构造函数。 PureComponet作用：当组件更新时，如果组件的 props 和 state 都没发生改变， render 方法就不会触发，省去 Virtual DOM 的生成和比对过程，达到提升性能的目的。 123456789101112131415161718class CounterButton extends React.PureComponent &#123; constructor(props) &#123; super(props); this.state = &#123;count: 1&#125;; &#125; render() &#123; return( &lt;button color=&#123;this.props.color&#125; onClick=&#123;() =&gt; this.setState(state =&gt; (&#123;count: state.count + 1&#125;))&#125;&gt; Count: &#123;this.state.count&#125; &lt;/button&gt; ); &#125;&#125; PS：这种情况下，PureComponent只会对this.props.words进行一次浅比较，虽然数组里面新增了元素， 但是this.props.words与nextProps.words指向的仍是同一个数组，因此this.props.words !== nextProps.words 返回的便是flase，从而导致ListOfWords组件没有重新渲染。 最简单避免上述情况的方式，就是避免使用可变对象作为props和state，取而代之的是每次返回一个全新的对象,如下通过concat来返回新的数组： 12345handleClick() &#123; this.setState(prevState =&gt; (&#123; words: prevState.words.concat([&apos;marklar&apos;]) &#125;));&#125; 你还可以考虑使用Immutable.js来创建不可变对象，通过它来简化对象比较，提高性能。 Stateless Functional Component作用：数据都是通过props传入的时候，我们便可以使用Stateless Functional Component来快速创建组件。 12345678910111213141516import React from &apos;react&apos;;const Button = (&#123; day, increment&#125;) =&gt; &#123; return ( &lt;div&gt; &lt;button onClick=&#123;increment&#125;&gt;Today is &#123;day&#125;&lt;/button&gt; &lt;/div&gt; );&#125;;Button.propTypes = &#123; day: PropTypes.string.isRequired, increment: PropTypes.func.isRequired&#125;; ES7class IndexPage extends PureComponent { state = { stripeObj : { number: 6, color: &apos;rgba(16, 142, 233, 1)&apos;, show: true }, ellipsisObj: { fontSize : &apos;40px&apos;, color: &apos;red&apos;, show: true } } // 事件方法，自动绑定 this stripeColorChange = (e) =&gt; { alert(&apos;sds&apos;); } render (){ return (&lt;div onClick={this.stripeColorChange}&gt;&lt;/div&gt;); } } IndexPage.propTypes = { }; 如何选择（优先级降低） Stateless Functional Component（无状态、无生命周期） PureComponent （不可变对象，最好配合Immutable.js使用） Component createClass 参考文档： 谈一谈创建React Component的几种方式 React创建组件的三种方式及其区别]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式-外观模式]]></title>
    <url>%2F2017%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[外观模式基础定义：外观模式（Facade）为子系统中的一组接口提供了一个一致的界面，此模块定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式不仅简化类中的接口，而且对接口与调用者也进行了解耦。外观模式经常被认为开发者必备，它可以将一些复杂操作封装起来，并创建一个简单的接口用于调用。外观模式经常被用于JavaScript类库里，通过它封装一些接口用于兼容多浏览器，外观模式可以让我们间接调用子系统，从而避免因直接访问子系统而产生不必要的错误。外观模式的优势是易于使用，而且本身也比较轻量级。但也有缺点外观模式被开发者连续使用时会产生一定的性能问题，因为在每次调用时都要检测功能的可用性。 兼容浏览器事件绑定下面是一段未优化过的代码，我们使用了外观模式通过检测浏览器特性的方式来创建一个跨浏览器的使用方法。123456789const addEvent = function(el, ev, fn) &#123; if (el.addEventListener) &#123; el.addEventListener(ev, fn, false); &#125; else if (el.attachEvent) &#123; el.attachEvent(`on$&#123;ev&#125;`, fn); &#125; else &#123; el.[`on$&#123;ev&#125;`] = fn; &#125;&#125;; PS：这里有一个问题，我们每调用一次 addEvent 函数就是执行一次 if-else 判断。 兼容浏览器阻止冒泡、默认事件123456789101112131415161718192021let N = window.N || &#123;&#125;;N.tools = &#123; stopPropagation(e) &#123; if (e.stopPropagation) &#123; e.stopPropagation(); &#125; else &#123; e.cancelBubble = true; &#125; &#125;, preventDefault(e) &#123; if (e.preventDefault) &#123; e.preventDefault(); &#125; else &#123; e.returnValue = false; &#125; &#125;, stopEvent (e) &#123; this.stopPropagation(e); this.preventDefault(e); &#125;&#125;; 参考文档： 深入理解JavaScript系列（30）：设计模式之外观模式 javascript设计模式-外观模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式-桥接模式]]></title>
    <url>%2F2017%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[桥接模式基础定义：桥接模式（Bridge）将抽象部分与它的实现部分分离，使它们都可以独立地变化。使用场景：事件回调函数、请求接口之间进行桥接、用于连接公开的API代码和私用实现的代码根据javascript语言的特点，我们将其简化成2个角色：（1）扩充抽象类（2）具体实现类 最简单的桥接模式123456789101112var each = function (arr, fn) &#123; for (var i = 0; i &lt; arr.length; i++) &#123; var val = arr[i]; if (fn.call(val, i, val, arr)) &#123; return false; &#125; &#125;&#125;;var arr = [1, 2, 3, 4];each(arr, function (i, v) &#123; arr[i] = v * 2;&#125;); PS：在这个例子中，抽象部分是each函数，也就是上面说的扩充抽象类，实现部分是fn，即具体实现类。抽象部分和实现部分可以独立的进行变化。这个例子虽然简单，但就是一个典型的桥接模式的应用。 事件监控抽象类 click 事件12345678addEvent(element, &apos;click&apos;, getBeerByIdBridge);// 提供一个桥梁 将 抽象类和实现类链接起来// 作为桥梁function getBeerByIdBridge (e) &#123; getBeerById(this.id, function(beer) &#123; console.log(&apos;Requested Beer: &apos;+beer); &#125;);&#125; 实现类1234567function getBeerById(id, callback) &#123; // 通过ID发送请求，然后返回数据 asyncRequest(&apos;GET&apos;, &apos;beer.uri?id=&apos; + id, function(resp) &#123; // callback response callback(resp.responseText); &#125;);&#125; PS：这里的getBeerByIdBridge就是我们定义的桥，用于将抽象的click事件和getBeerById连接起来，同时将事件源的ID，以及自定义的call函数（console.log输出）作为参数传入到getBeerById函数里。 用于连接公开的API代码和私用实现的代码12345678910var Public=function()&#123; // 定义的私有变量 var secret = 3; // 该函数返回了私有变量，外界可以通过该方法访问该私有变量 this.privilegedGetter = function()&#123; return secret; &#125;&#125;var o = new Public();var data =o.privilegedGetter(); PS：如果一个公用的接口抽象了一些也许应该属于私用性的较复杂的任务，那么可以使用桥接模式来收集某些私用性的信息。可以用一些具有特殊权利的方法作为桥梁以便访问私用变量空间。这一特例中的桥接性函数又称特权函数。 用桥接模式联结多个类123456789101112var Class1 =function(a,b,c)&#123; this.a =a; this.b = b; this.c = c;&#125;var Class2 =function(d)&#123; this.d = d;&#125;var BridgeClass =function(a,b,c,d)&#123; this.one = new Class1(a,b,c); this.two = new Class2(d);&#125; PS：这看起来很像是—-适配器，的确如此。但要注意到本例中实际上并没有客户系统要求提供数据。它只不过是用来接纳大量数据并将其发送给责任方的一种辅助性手段。此外，BridgeClass也不是一个客户系统已经实现的现有接口。引入这个类的目的只不过是要桥接一些类而已。 参考文档： 深入理解JavaScript系列（44）：设计模式之桥接模式 Javascript设计模式理论与实战：桥接模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式-迭代器模式]]></title>
    <url>%2F2017%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[迭代器模式介绍定义：迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。使用的好处：迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。先看一个 jquery 迭代器123$.each(array, function (i, n) &#123; console.log(`当前为第$&#123;i&#125;项，值为$&#123;n&#125;`);&#125;); 封装迭代器内部迭代器定义：迭代函数内部已经定义好了迭代原则，它完全接手整个迭代过程，外部只需要一次初始调用。12345const each = function(array, callback) &#123; for (let i = 0, len = array.length; i &lt; len; i++) &#123; callback.call(array[i], array[i], i); &#125;&#125;; PS：这里设计each函数时参考了[].forEach函数，callback第一个参数为 value，第二个参数为 index。使用内部迭代器：123each([1,2,3,4], function (val, ind) &#123; console.log( val + &quot; - &quot; + ind ); // 输出数组值和下标&#125;); PS：现在 ES5 已经实现了内部迭代器 [].foreEach(callback(currentValue, index, array)[, this]);详细的使用说明请参考MDN-Array.prototype.forEach() 外部迭代器定义：外部迭代器必须显式地请求迭代下一个元素，外部迭代器增加了一些调用的复杂度，但相对的也增强了迭代器的灵活性，我们可以手工控制迭代的过程或者顺序。1234567891011121314151617181920212 var Iterator = function (obj) &#123; var current = 0; var next = function()&#123; current += 1; &#125;; var isDone = function()&#123; return current &gt;= obj.length; &#125;; var getCurrItem = function()&#123; return obj[ current ]; &#125;; return &#123; next: next, isDone: isDone, getCurrItem: getCurrItem &#125;&#125; 使用：判断两个数组是不是相等123456789101112131415var compare = function( iterator1, iterator2 )&#123; while( iterator1.isDone() &amp;&amp; iterator2.isDone() )&#123; if( iterator1.getCurrItem() !== iterator2.getCurrItem() )&#123; throw new Error( &quot;iterator1 和 iterator2不相等&quot; ); &#125; iterator1.next(); iterator2.next(); &#125; console.log( &quot;iterator1 和 iterator2相等&quot; );&#125;;var iterator1 = Iterator( [1,2,3,4] );var iterator2 = Iterator( [1,2,3,4] );compare(iterator1,iterator2); 中止迭代器定义：在迭代过程，通过判断是否退出迭代器。12345678var each = function( arry, callback )&#123; for( var i = 0, l = arry.length; i &lt; l; i++ )&#123; // callback 的执行结果返回false，提前中止迭代 if( callback( arry[i], i ) === false )&#123; break; &#125; &#125;&#125;; 使用：123456each( [1,2,3,4,5], function ( n, i ) &#123; if( n&gt;3 )&#123; // n 大于3的时候中止循环 return false; &#125; console.log(n); // 输出 1 2 3&#125;); 迭代器应用示例需求：根据不同的浏览器获取相应的上传组件对象，将不同的上传对象封装到各自的函数里; 如果函数可用，则返回该对象，否则返回false，提示迭代器继续向下迭代。定义上传组件方法：12345678910111213141516171819// 将不同的上传对象封装到各自的函数里; 如果函数可用，则返回该对象，否则返回false，提示迭代器继续var getActiveUploadObj = function()&#123; try&#123; return new ActiceXObject( &quot;TXFTNActiveX.FTNUpload&quot; ); // IE 上传控件 &#125;catch(e)&#123; return false; &#125;&#125;;var getFlashUploadObj = function()&#123; if( supportFlash() )&#123; var str = &quot;&lt;object type=&apos;application/x-shockwave-flash&apos;&gt;&lt;/object&gt;&quot;; return $( str).appendTo( $(&quot;body&quot;) ); &#125; return false;&#125;;var getFormUpl0adObj = function()&#123; var str = &quot;&lt;input type=&apos;file&apos; type=&apos;file&apos; class=&apos;ui-file&apos; /&gt;&quot;; // 表单上传 return $( str).appendTo( $(&quot;body&quot;) );&#125;; 实现迭代器：1234567891011//迭代器代码var iteratorUploadObj = function()&#123; for( var i = 0, fn; fn = arguments[ i++ ]; )&#123; var uploadObj = fn(); if( uploadObj !== false )&#123; return uploadObj; &#125; &#125;&#125;;var uploadObj = iteratorUploadObj( getActiveUploadObj, getFlashUploadObj, getFormUpl0adObj ); PS：这里说明一下，如果前面的上传方案可以使用就使用，否则就使用后面的上传方案（但是要保证至少一种方式所有浏览器都能实现）。 参考文档： 【Javascript设计模式12】-迭代器模式 JavaScript设计模式 - 迭代器模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式-适配器模式]]></title>
    <url>%2F2017%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[适配器模式介绍定义：适配器模式（Adapter）是将一个类（对象）的接口（方法或属性）转化成客户希望的另外一个接口（方法或属性）， 适配器模式使得原本由于接口不兼容而不能一起工作的那些类（对象）可以一些工作。速成包装器（wrapper）。使用场景：比如，当系统中某个接口的结构已经无法满足我们现在的业务需求，但又不能改动这个接口， 因为可能原来的系统很多功能都依赖于这个接口，改动接口会牵扯到太多文件。 因此应对这种场景，我们可以很快地想到可以用适配器模式来解决这个问题。 适配两个库 下面我们来实现从Prototype库的$函数到YUI的get方法的转换。这两个函数的功能比较相似，不过先看看她们在接口方面的差别：Prototype库的$函数 1234567891011121314function $()&#123; var elments = new Array(); for(var i=0; i&lt;arguments.length; i++)&#123; var element = arguments[i]; if(typeof element == &apos;string&apos;)&#123; element = document.getElementById(element); &#125; if(arguments.length == 1)&#123; return element; &#125; elments.push(element); &#125; return elements;&#125; YUI的get方法12345678910111213141516YAHOO.util.Dom.get = function(el)&#123; if(YAHOO.lang.isString(el))&#123; return document.getElementById(el); &#125; if(YAHOO.lang.isArray(el))&#123; var c = []; for(var i= 0, len=el.length; i&lt;len; i++)&#123; c[c.length] = YAHOO.util.Dom.get(el[i]); &#125; return c; &#125; if(el)&#123; return el; &#125; return null;&#125; 分析二者的区别：get具有一个参数，这个参数可以是一个HTML元素、字符串或者由字符串或HTML元素组成的数组，与此不同，$函数没有正式列出参数，而是允许客户传入任意数目的参数，不管是字符串还是HTML元素都行。 这里两种转换的适配器就应该这样写$ –&gt; get123456function $2getAdapter()&#123; return YAHOO.util.Dom.get(arguments);&#125;对于从Prototype改投YUI的人应该如下使用$ = $2getAdapter;这样就可以继续使用 $ 方法了。 get –&gt; $123456function get2$Adapter(el)&#123; return $.apply(window, el instanceof Array ?el: [el]);&#125;对于从YUI改投Prototype的人应该如下使用YAHOO.util.Dom.get = get2$Adapter;这样就可以继续使用 YAHOO.util.Dom.get 方法了。 总结 注意：适配器模式尽量少使用，就类似于在衣服上打补丁。特别是在接口还没有确定的时候使用，因为这样后期不利于维护，相反，这个时候我们应该重新思考我们的接口设计是否合理。 那合适使用适配器模式好呢？如果有以下情况出现时，建议使用： 使用一个已经存在的对象，但其方法或属性接口不符合你的要求； 你想创建一个可复用的对象，该对象可以与其它不相关的对象或不可见对象（即接口方法或属性不兼容的对象）协同工作； 想使用已经存在的对象，但是不能对每一个都进行原型继承以匹配它的接口。对象适配器可以适配它的父对象接口方法或属性。 另外，适配器模式和其它几个模式可能容易让人迷惑，这里说一下大概的区别： 适配器和桥接模式虽然类似，但桥接的出发点不同，桥接的目的是将接口部分和实现部分分离，从而对他们可以更为容易也相对独立的加以改变。而适配器则意味着改变一个已有对象的接口。 装饰者模式增强了其它对象的功能而同时又不改变它的接口，因此它对应程序的透明性比适配器要好，其结果是装饰者支持递归组合，而纯粹使用适配器则是不可能的。 代理模式在不改变它的接口的条件下，为另外一个对象定义了一个代理。 参考文档： 腾讯-曽探 深入理解JavaScript系列（39）：设计模式之适配器模式 JS设计模式——11.适配器模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue开发规范]]></title>
    <url>%2F2017%2Fvue%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83.html</url>
    <content type="text"><![CDATA[组件名为多个单词组件名应该始终是多个单词的，根组件 App 除外。 1234567Vue.component(&apos;todo-item&apos;, &#123; // 自动将组件的 name 设置为 todo-item // ...&#125;)export default &#123; name: &apos;TodoItem&apos;, // 最佳实践为组件带上 name 调试有好处 // ...&#125; 组件数据组件的 data 必须是一个函数。 每次返回一个新的纯对象。 Prop定义Prop 定义应该尽量详细（至少为其指定 type ）。 1234567891011121314props: &#123; status: &#123; type: String, required: true, validator: function (value) &#123; return [ &apos;syncing&apos;, &apos;synced&apos;, &apos;version-conflict&apos;, &apos;error&apos; ].indexOf(value) !== -1 &#125; &#125;&#125; 为 v-for 设置键值总是用 key 配合 v-for。 为组件样式设置作用域下面对于单文件组件。 对于应用来说，顶级 App 组件和布局组件中的样式可以是全局的， 但是其它所有组件都应该是有作用域的（3种方式）。 scoped css Modules 12345678910&lt;button :class=&quot;[$style.button]&quot;&gt;X&lt;/button&gt;&lt;style module&gt;.button &#123; border: none; border-radius: 2px;&#125;.buttonClose &#123; background-color: red;&#125;&lt;/style&gt; BEM 约定 1234567&lt;button class=&quot;c-Button c-Button--close&quot;&gt;X&lt;/button&gt;&lt;style&gt;.c-Button &#123; border: none; border-radius: 2px;&#125;&lt;/style&gt; 私有属性名 必要在插件、混入等扩展中始终为自定义的私有属性使用 $_ 前缀。并附带一个命名空间以回避和其它作者的冲突 (比如 $yourPluginName)。 12345678var myGreatMixin = &#123; // ... methods: &#123; $_myGreatMixin_update: function () &#123; // ... &#125; &#125;&#125; 组件文件只要有能够拼接文件的构建系统，就把每个组件单独分成文件。 components/ |- TodoList.vue |- TodoItem.vue 单文件组件文件的大小写（大驼峰）单文件组件的文件名应该要么始终是单词大写开头 (PascalCase)，要么始终是横线连接 (kebab-case)。 基础组件名应用特定样式和约定的基础组件 (也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头， 比如 Base、App 或 V。 components/ |- BaseButton.vue |- BaseTable.vue |- BaseIcon.vue 单例组件名只应该拥有单个活跃实例的组件应该以 The 前缀命名，以示其唯一性。 components/ |- TheHeading.vue |- TheSidebar.vue 紧密耦合的组件名和父组件紧密耦合的子组件应该以父组件名作为前缀命名。 components/ |- TodoList.vue |- TodoListItem.vue |- TodoListItemButton.vue 组件名中的单词顺序组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。 components/ |- SearchButtonClear.vue |- SearchButtonRun.vue |- SearchInputQuery.vue |- SearchInputExcludeGlob.vue |- SettingsCheckboxTerms.vue |- SettingsCheckboxLaunchOnStartup.vue 自闭合组件在单文件组件、字符串模板和 JSX 中没有内容的组件应该是自闭合的——但在 DOM 模板里永远不要这样做。 1234&lt;!-- 在单文件组件、字符串模板和 JSX 中 --&gt;&lt;MyComponent/&gt;&lt;!-- 在 DOM 模板中 --&gt;&lt;my-component&gt;&lt;/my-component&gt; 模板中的组件名大小写对于绝大多数项目来说，在单文件组件和字符串模板中组件名应该总是 PascalCase 的——但是在 DOM 模板中总是 kebab-case 的。 &lt;!-- 在所有地方 --&gt; &lt;my-component&gt;&lt;/my-component&gt; JS/JSX 中的组件名大小写JS/JSX 中的组件名应该始终是 PascalCase 的，尽管在较为简单的应用中只使用 Vue.component 进行全局组件注册时， 可以使用 kebab-case 字符串。 1234567891011Vue.component(&apos;MyComponent&apos;, &#123; // ...&#125;)Vue.component(&apos;my-component&apos;, &#123; // ...&#125;)import MyComponent from &apos;./MyComponent.vue&apos;export default &#123; name: &apos;MyComponent&apos;, // ...&#125; 完整单词的组件名组件名应该倾向于完整单词而不是缩写。 components/ |- StudentDashboardSettings.vue 学生面板设置 |- UserProfileOptions.vue Prop 名大小写在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板和 JSX 中应该始终使用 kebab-case。 12345props: &#123; greetingText: String&#125;// 在 html 中&lt;WelcomeMessage greeting-text=&quot;hi&quot;/&gt; 多个特性的元素多个特性的元素应该分多行撰写，每个特性一行。 1234&lt;img src=&quot;https://vuejs.org/images/logo.png&quot; alt=&quot;Vue Logo&quot;&gt; 模板中简单的表达式组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。 简单的计算属性应该把复杂计算属性分割为尽可能多的更简单的属性。 带引号的特性值（双引号）非空 HTML 特性值应该始终带引号 (单引号或双引号，选你 JS 里不用的那个)。 指令缩写指令缩写 (用 : 表示 v-bind: 和用 @ 表示 v-on:) 应该要么都用要么都不用。 组件/实例的选项的顺序组件/实例的选项应该有统一的顺序。 副作用 (触发组件外的影响) el 全局感知 (要求组件以外的知识) name parent 组件类型 (更改组件的类型) functional 模板修改器 (改变模板的编译方式) delimiters comments 模板依赖 (模板内使用的资源) components directives filters 组合 (向选项里合并属性) extends mixins 接口 (组件的接口) inheritAttrs model props/propsData 本地状态 (本地的响应式属性) data computed 事件 (通过响应式事件触发的回调) watch 生命周期钩子 (按照它们被调用的顺序) 非响应式的属性 (不依赖响应系统的实例属性) methods 渲染 (组件输出的声明式描述) template/render renderError 元素特性的顺序元素 (包括组件) 的特性应该有统一的顺序。 定义 (提供组件的选项) is 列表渲染 (创建多个变化的相同元素) v-for 条件渲染 (元素是否渲染/显示) v-if v-else-if v-else v-show v-cloak 渲染方式 (改变元素的渲染方式) v-pre v-once 全局感知 (需要超越组件的知识) id 唯一的特性 (需要唯一值的特性) ref key slot 双向绑定 (把绑定和事件结合起来) v-model 其它特性 (所有普通的绑定或未绑定的特性) 事件 (组件事件监听器) v-on 内容 (复写元素的内容) v-html v-text 组件/实例选项中的空行你可能想在多个属性之间增加一个空行，特别是在这些选项一屏放不下， 需要滚动才能都看到的时候。 单文件组件的顶级元素的顺序单文件组件应该总是让 template、script 和 style 标签的顺序保持一致。 且 &lt;style&gt; 要放在最后，因为另外两个标签至少要有一个。 &lt;template&gt;...&lt;/template&gt; &lt;script&gt;/* ... */&lt;/script&gt; &lt;style&gt;/* ... */&lt;/style&gt; 没有在 v-if/v-if-else/v-else 中使用 key 谨慎使用如果一组 v-if + v-else 的元素类型相同，最好使用 key (比如两个 &lt;div&gt; 元素)。 123456&lt;div v-if=&quot;error&quot; key=&quot;search-status&quot;&gt; 错误：&#123;&#123; error &#125;&#125;&lt;/div&gt;&lt;div v-else key=&quot;search-results&quot;&gt; &#123;&#123; results &#125;&#125;&lt;/div&gt; scoped 中的元素选择器 谨慎使用元素选择器应该避免在 scoped 中出现。 隐性的父子组件通信 谨慎使用应该优先通过 prop 和事件进行父子组件之间的通信，而不是 this.$parent 或改变 prop。 1234567891011121314Vue.component(&apos;TodoItem&apos;, &#123; props: &#123; todo: &#123; type: Object, required: true &#125; &#125;, template: ` &lt;input :value=&quot;todo.text&quot; @input=&quot;$emit(&apos;input&apos;, $event.target.value)&quot; &gt; `&#125;) 非 Flux 的全局状态管理 谨慎使用应该优先通过 Vuex 管理全局状态，而不是通过 this.$root 或一个全局事件总线。 参考文档： vue代码指南]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css实现水平和垂直居中方案总结]]></title>
    <url>%2F2017%2Fcss%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%92%8C%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[已知宽高元素水平和垂直居中position:absolute、top和left50%和margin:-height/2px 0 0 -width/2px;html 代码123&lt;div class=&quot;container&quot;&gt; 123&lt;/div&gt; css 代码1234567891011.container &#123; position:absolute; top:50%; left:50%; margin:-25px 0 0 -50px; width: 100px; height: 50px; font-size: 40px; color: #fff; background-color: rgba(0,0,0,.8) &#125; position:fixed、top和right和bottom和left0和margin:auto;html 代码123&lt;div class=&quot;container&quot;&gt; 123&lt;/div&gt; css代码12345678910111213.container &#123; position:fixed; top:0; right:0; bottom:0; left:0; margin:auto; width: 100px; height: 50px; font-size: 40px; color: #fff; background-color: rgba(0,0,0,.8) &#125; 未知宽高元素水平和垂直居中总结一些常用的不定高宽元素居中的方式，以备使用。 以下代码均不考虑兼容性，如需使用，请自行处理浏览器兼容性。 display 为 table 布局（父容器为display: table; 子元素为display: table-cell;）html 代码12345&lt;div id=&quot;container&quot;&gt; &lt;span id=&quot;inner&quot;&gt; 123123 &lt;/span&gt; &lt;/div&gt; css 代码1234567891011121314#container&#123; display: table; padding: 60% 30%; width: 100vw; height: 100vh; text-align: center; &#125; #inner&#123; display: table-cell; vertical-align: middle; font-size: 40px; color: #fff; background-color: rgba(0, 0, 0, .8); &#125; PS： 水平居中一般采用两种方式: 1.块级元素：定宽 + margin:0 auto;（由于是不定宽高，所以这里不适用）； 2.行内元素：作用于父级元素 text-algin：center；（可以内联化，视情况而定） 垂直方向居中： 使用display:table-cell;vertical-algin:middle; flex 布局实现注意：flex 方法兼容 IE10及以上版本 html 代码123&lt;div class=&quot;container&quot;&gt; &lt;span class=&quot;toast&quot;&gt;上传成功&lt;/span&gt;&lt;/div&gt; css 代码12345678910111213141516/*父容器*/.container &#123; position: fixed; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center;&#125; /*子项目*/.toast &#123; padding: 20px; font-size: 40px; color: #fff; background-color: rgba(0, 0, 0, .8);&#125; PS：display: flex; // 为父容器使用 flex 布局 justify-content: center; // 决定子项目在主轴的对齐方式 align-items: center; // 决定子项目在交叉轴轴的对齐方式 position + transform 方法实现注意：flex 方法兼容 IE9及以上版本 html 代码1&lt;span class=&quot;toast&quot;&gt;上传成功&lt;/span&gt; css 代码12345678910.toast &#123; position: fixed; top: 50%; // 50vh left: 50%; // 50vw transform: translate(-50%, -50%); padding: 20px; font-size: 40px; color: #fff; background-color: rgba(0, 0, 0, .8);&#125; PS：对于position: fixed; 之后的 top和left都为50%，这个50%为浏览器窗口宽高的50%， 对于transform中translate(-50%, -50%)，这个50%为自身元素的宽高的50%。 或许上面改写成top: 50vh; left: 50vw; 更容易理解。 参考文档： 不定元素宽高用css实现内容水平和垂直都居中 不定宽高div水平垂直居中 flex 布局 滴滴出行-再谈自适应垂直居中]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue官网-全局与实例解读]]></title>
    <url>%2F2017%2Fvue%E5%AE%98%E7%BD%91-%E5%85%A8%E5%B1%80%E4%B8%8E%E5%AE%9E%E4%BE%8B%E8%A7%A3%E8%AF%BB.html</url>
    <content type="text"><![CDATA[全局APIVue.extend( options )用法：使用基础 Vue 构造器，创建一个“子类”。 12345678910111213// 创建构造器var Profile = Vue.extend(&#123; template: &apos;&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;&apos;, data: function () &#123; return &#123; firstName: &apos;Walter&apos;, lastName: &apos;White&apos;, alias: &apos;Heisenberg&apos; &#125; &#125;&#125;);// 创建 Profile 实例，并挂载到一个元素上。new Profile().$mount(&apos;#mount-point&apos;) Vue.nextTick( [callback, context] )用法：在下次 DOM 更新循环结束之后执行延迟回调。 123456// 修改数据vm.msg = &apos;Hello&apos;// DOM 还没有更新Vue.nextTick(function () &#123; // DOM 更新之后进行相应的操作&#125;); Vue.set( target, key, value )用法：设置对象的属性。 Vue.delete( target, key )用法：删除对象的属性。 Vue.directive( id, [definition] )用法：注册或获取全局指令。 如自定义指令，v-focus Vue.filter( id, [definition] )用法：注册或获取全局过滤器。 Vue.component( id, [definition] )用法：注册或获取全局组件。 Vue.use( plugin )用法：安装 Vue.js 插件。 Vue.mixin( mixin )用法：全局注册一个混合，影响注册之后所有创建的每个 Vue 实例。 Vue.compile( template )用法：在 render 函数中编译模板字符串。 Vue.version用法：提供字符串形式的 Vue 安装版本号。 实例以下实例均为 vm。 123var vm = new (&#123; el: &apos;#app&apos;&#125;); 实例属性vm.$data作用：Vue 实例代理了对其 data 对象属性的访问。 vm.$props作用：Vue 实例代理了对其 props 对象属性的访问。 vm.$el（只读）作用：Vue 实例使用的根 DOM 元素。 vm.$options（只读）作用：用于当前 Vue 实例的初始化选项。需要在选项中包含自定义属性时会有用处。 vm.$parent（只读）作用：父实例，如果当前实例有的话。 vm.$root（只读）作用：当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自己。 vm.$children（只读）作用：当前实例的直接子组件。 vm.$slots（只读）作用：用来访问被插槽分发的内容。每个具名插槽 有其相应的属性 (例如：slot=&quot;foo&quot; 中的内容将会在 vm.$slots.foo 中被找到)。 vm.$scopedSlots（只读）作用：用来访问作用域插槽。 vm.$refs（只读）作用：一个对象，持有已注册过 ref 的所有子组件。 vm.$isServer（只读）作用：当前 Vue 实例是否运行于服务器。 vm.$attrs（只读）作用：包含了父作用域中不被认为 (且不预期为) props 的特性绑定 (class 和 style 除外)。 vm.$listeners作用：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。 实例方法/数据vm.$watch(expOrFn, callback, [options]);作用：观察 Vue 实例变化的一个表达式或计算属性函数。 返回值：{Function} unwatch vm.$watch 返回一个取消观察函数，用来停止触发回调： vm.$set( target, key, value )作用：这是全局 Vue.set 的别名。 vm.$delete( target, key )作用：这是全局 Vue.delete 的别名。 实例方法/事件vm.$on(event, callback);作用：监听当前实例上的自定义事件。 vm.$once(event, callback);作用：监听一个自定义事件，但是只触发一次，在第一次触发之后移除监听器。 vm.$off( [event, callback] )作用：移除自定义事件监听器。 vm.$emit(event, […args]);作用：触发当前实例上的事件。附加参数都会传给监听器回调。 实例方法/生命周期vm.$mount( [elementOrSelector] )作用：如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。 vm.$forceUpdate()作用：迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。 vm.$nextTick( [callback] )作用：将回调延迟到下次 DOM 更新循环之后执行。 vm.$destroy()作用：完全销毁一个实例。 指令（内置）v-text作用：更新元素的 textContent。 还可以使用 {{ Mustache }} v-html作用：更新元素的 innerHTML 。 v-show作用：根据表达式之真假值，切换元素的 display CSS 属性。 当条件变化时该指令触发过渡效果。 v-if作用：根据表达式的值的真假条件渲染元素。 在切换时元素及它的数据绑定 / 组件被销毁并重建。 v-else作用：否则，前一兄弟元素必须有 v-if 或 v-else-if。 v-else-if作用：表示 v-if 的 “else if 块”。 v-for作用：基于源数据多次渲染元素或模板块。 1234&lt;!--数组--&gt;&lt;div v-for=&quot;(item, index) in items&quot; :key=&quot;item.id&quot;&gt;&lt;/div&gt;&lt;!--对象--&gt;&lt;div v-for=&quot;(val, key, index) in object&quot; :key=&quot;item.id&quot;&gt;&lt;/div&gt; v-on（@）作用：绑定事件监听器。 事件修饰符：.stop, .prevent, .capture, .self, {keyCode | keyAlias} .native, .once, .left, .right, .middle, .passive v-bind（:）作用：绑定属性。 属性修饰符：.prop, .camel, .sync（会扩展成一个更新父组件绑定值的 v-on 侦听器） v-model作用：表单和数据的双向绑定。 表单修饰符：.lazy, .number, .trim v-pre作用：跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。 v-cloak作用：这个指令保持在元素上直到关联实例结束编译。 需配合 CSS 规则 [v-cloak] { display: none } 一起使用。 v-once作用：只渲染元素和组件一次。 特殊属性key作用：性能考虑。 使用场景：v-for, transition-group 过渡组件。 refsref 被用来给元素或子组件注册引用信息。 slot作用：用于标记往哪个具名插槽中插入子组件内容。 slot-scoped作用：用于将元素或组件表示为作用域插槽。 is作用：用于动态组件且基于 DOM 内模板的限制来工作。 1234567&lt;!-- component changes when currentView changes --&gt;&lt;component v-bind:is=&quot;currentView&quot;&gt;&lt;/component&gt;&lt;!-- necessary because `&lt;my-row&gt;` would be invalid inside --&gt;&lt;!-- a `&lt;table&gt;` element and so would be hoisted out --&gt;&lt;table&gt; &lt;tr is=&quot;my-row&quot;&gt;&lt;/tr&gt;&lt;/table&gt; 内置的组件component用法：渲染一个“元组件”为动态组件。依 is 的值，来决定哪个组件被渲染。 props: is, inline-template 1234&lt;!-- 动态组件由 vm 实例的属性值 `componentId` 控制 --&gt;&lt;component :is=&quot;componentId&quot;&gt;&lt;/component&gt;&lt;!-- 也能够渲染注册过的组件或 prop 传入的组件 --&gt;&lt;component :is=&quot;$options.components.child&quot;&gt;&lt;/component&gt; transition用法：&lt;transition&gt; 元素作为单个元素/组件的过渡效果。 props：... 事件：... transition-group用法：&lt;transition-group&gt; 元素作为多个元素/组件的过渡效果。 props: tag, move-class, mode 事件：... keep-aliveprops：include, exclude 用法：&lt;keep-alive&gt; 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。 slot用法：&lt;slot&gt; 元素作为组件模板之中的内容分发插槽。&lt;slot&gt; 元素自身将被替换。 props：name 参考文档： 官方api]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue官网-选项解读]]></title>
    <url>%2F2017%2Fvue%E5%AE%98%E7%BD%91-%E9%80%89%E9%A1%B9%E8%A7%A3%E8%AF%BB.html</url>
    <content type="text"><![CDATA[选项/数据12345678910var app = new Vue(&#123; data() &#123; // 声明所有的根级响应式属性 return &#123;&#125;; &#125;, props: &#123;&#125;, // 父组件传递过来的属性 propsData: &#123;&#125;, // 只能用于 new 创建的实例时传递 props。主要作用是方便测试 methods: &#123;&#125;, // 组件相关的方法 computed: &#123;&#125;, // 组件的计算属性 watch: &#123;&#125;, // 监听组件的 data 中数据变化执行对应函数 &#125;); data类型：Object | Function（对于组件只是使用这种方式，并且返回一个纯对象） 作用：Vue 实例的数据对象。 最佳实践：data中需要声明所有的根级响应式属性。 有些时候想为 data 添加新数据。Vue.set( target, key, value )；target 可以是Object 和 Array(多个VUE实例对象)， key 为对应数据的键，value 为对应数据的值。 对应还有 Vue.delete( target, key ) 移除VUE实例对象指定key的属性。 数据驱动的原理：Vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。 属性通过 Object.defineProperty(obj, prop, descriptor) 来实现数据驱动。 props类型：Array&lt;string&gt; | Object 作用：用于接收来自父组件的数据。对象允许配置高级选项，如是否必填（required）、 类型检测（type）、自定义校验（validator函数）和设置默认值（default）。 12345678910111213141516// 对象语法，提供校验Vue.component(&apos;props-demo-advanced&apos;, &#123; props: &#123; // 检测类型 height: Number, // 检测类型 + 其他验证 age: &#123; type: Number, default: 0, required: true, validator: function (value) &#123; return value &gt;= 0 &#125; &#125; &#125;&#125;); propsData类型：{ [key: string]: any } 作用：只能用于 new 创建的实例时传递 props。主要作用是方便测试。 12345var vm = new Vue(&#123; propsData: &#123; msg: &apos;hello&apos; &#125;&#125;); computed类型：{ [key: string]: Function | { get: Function, set: Function } } 作用：计算属性的结果会被缓存，除非依赖的响应式属性（data中的数据）变化才会重新计算。 1234567891011121314var vm = new Vue(&#123; data: &#123; a: 1 &#125;, computed: &#123; // 仅读取 aDouble: function () &#123; return this.a * 2 &#125;, &#125;,&#125;);// 组件类使用this.aDouble// 组件外使用vm.aDouble methods类型：{ [key: string]: Function } 作用：为组件定义方法 12345678910111213var vm = new Vue(&#123; data: &#123; a: 1 &#125;, methods: &#123; plus: function () &#123; this.a++ &#125; &#125;&#125;);// 组件内使用this.plus()// 组件外使用vm.plus() watch类型：{ [key: string]: string | Function | Object } 作用：键是需要观察的表达式data中的属性，值是对应回调函数。值也可以是方法名，或者包含选项的对象 12345678910111213141516171819var vm = new Vue(&#123; data: &#123; a: 1, b: 2, c: 3 &#125;, watch: &#123; a: function (val, oldVal) &#123; console.log(&apos;new: %s, old: %s&apos;, val, oldVal) &#125;, // 方法名 b: &apos;someMethod&apos;, // 深度 watcher c: &#123; handler: function (val, oldVal) &#123; /* ... */ &#125;, deep: true &#125; &#125;&#125;); 选项/DOM12345678910new Vue(&#123; el: &apos;#app&apos;, template: &apos;&lt;div&gt;我是模板&lt;/div&gt;&apos;, render (h) &#123; throw new Error(&apos;oops&apos;) &#125;, renderError (h, err) &#123; return h(&apos;pre&apos;, &#123; style: &#123; color: &apos;red&apos; &#125;&#125;, err.stack) &#125;&#125;); el类型：string | HTMLElement 作用：提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标（只在由 new 创建的实例中遵守）。 template类型：string 作用：一个字符串模板作为 Vue 实例的标识使用。 render类型：(createElement: () =&gt; VNode) =&gt; VNode 作用：字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力。 renderError类型：(createElement: () =&gt; VNode, error: Error) =&gt; VNode 作用：当 render 函数遭遇错误时，提供另外一种渲染输出。 选项/生命周期钩子（函数）在组件的具体某个过程触发相应的函数 可以理解为：创建 -&gt; 挂载 -&gt; 更新 -&gt; 激活 -&gt; 销毁 123456789101112new Vue(&#123; beforeCreate() &#123;&#125;, // 实例初始化之后 created() &#123;&#125;, // 在实例创建完成后被立即调用 beforeMount() &#123;&#125;, // 在挂载开始之前被调用 mounted() &#123;&#125;, // 实例挂载到 DOM 节点 beforeUpdate() &#123;&#125;, // 数据更新时调用 updated() &#123;&#125;, // 数据更新完成后调用 activated() &#123;&#125;, // keep-alive 组件激活时调用 deactivated() &#123;&#125;, // keep-alive 组件停用时调用 beforeDestory() &#123;&#125;,// 实例销毁之前调用 destoryed() &#123;&#125; // 实例销毁后调用。&#125;); 详细信息请看官网-生命周期图示 beforeCreate执行时机：在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。 created执行时机：在实例创建完成后被立即调用。完成以下任务：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调，但实例并没有挂载到真实节点。 beforeMount执行时机：在挂载开始之前被调用：相关的 render 函数首次被调用。 mounted执行时机：当实例挂载到文档 DOM 元素时触发。 注意 mounted 不会保证所有的子组件也都一起被挂载，下面可以保证所有子组件都一起被挂起。 12345mounted: function () &#123; this.$nextTick(function () &#123; // 整个视图页面全部渲染时触发，类似于jquery的ready方法。 &#125;);&#125; beforeUpdate执行时机：数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 updated执行时机：由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。 此时可以进行 DOM 操作。 activated执行时机：keep-alive 组件激活时调用。 deactivated执行时机：keep-alive 组件停用时调用。 beforeDestory执行时机：实例销毁之前调用。在这一步，实例仍然完全可用。 destoryed执行时机：Vue 实例销毁后调用。 选项/资源123456var vm = new Vue(&#123; el: &apos;#app&apos;, directives: &#123;&#125;, // 注册局部指令 filters: &#123;&#125;, // 注册局部过滤器 compoents: &#123;&#125; // 注册局部组件 &#125;); directives类型：Object 1.注册自定义指令（全局） 1234567891011Vue.directive(&apos;focus&apos;, &#123; // 当绑定元素插入到 DOM 中。 inserted: function (el) &#123; // 聚焦元素 el.focus() &#125;&#125;);var vm = new Vue(&#123; el: &apos;#app&apos;, // directives: &#123;&#125; 注册局部指令&#125;); 这里指令的钩子函数：bind、inserted、update、componentUpdated、unbind 每个钩子函数的参数：(包括 el，binding，vnode，oldVnode)。 2.使用自定义指令 123&lt;div id=&quot;app&quot;&gt; &lt;input v-focus&gt;&lt;/div&gt; filter类型：Object 1.注册全局过滤器 12345678910111213Vue.filter(&apos;add4&apos;, function (value) &#123;return value + 4; // 返回处理后的值&#125;);var vm = new Vue(&#123; el: &apos;#app&apos;, data() &#123; return &#123; num: 10 &#125;; &#125;, // filters: &#123;&#125; 注册局部过滤器&#125;); 2.使用过滤器 123&lt;div id=&quot;app&quot;&gt; &lt;p&gt;10 + 4 = &#123;&#123;num | add4&#125;&#125;&lt;/p&gt; // 14&lt;/div&gt; compoents（局部组件的注册）类型：Object 1.注册全局组件 123456789101112Vue.component(&apos;my-component&apos;, &#123; // 选项&#125;);var vm = new Vue(&#123; el: &apos;#app&apos;, data() &#123; return &#123; num: 10 &#125;; &#125;, // components: &#123;&#125; 注册局部组件&#125;); 2.使用组件 123&lt;div id=&quot;app&quot;&gt; &lt;my-component /&gt;&lt;/div&gt; 选项/组合1234567import parentComponent from &apos;./path&apos;;var vm = new Vue(&#123; el: &apos;#app&apos;, parent: parentComponent, // 定义当前组件的父组件 minxins: [mixin], // 定义局部混合逻辑（引入的先触发） extends: CompA // 定义局部继承（自身的先触发）&#125;); parent类型：Vue instance 作用：指定已创建的实例的父实例，在两者之间建立父子关系。 子实例可以用 this.$parent 访问父实例，子实例被推入父实例的 $children 数组中。 minxins类型：Array&lt;Object&gt; 作用：混合 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。 混合对象可以包含任意组件选项。以组件使用混合对象时，所有混合对象的选项将被 混入该组件本身的选项。 1.创建局部混合 12345var mixin = &#123; created: function () &#123; console.log(&apos;混合对象的钩子被调用&apos;) &#125;&#125;; 2.使用混合 123456new Vue(&#123; mixins: [mixin], // 这里使用 created: function () &#123; console.log(&apos;组件钩子被调用&apos;) &#125;&#125;); 这里需要说明：混合对象的 钩子将在组件自身钩子 之前 调用。 extends类型：Object | Function 作用：允许声明扩展另一个组件(可以是一个简单的选项对象或构造函数)，而无需使用 Vue.extend。这主要是为了便于扩展单文件组件。 这和 mixins 类似，区别在于，组件自身的选项会比要扩展的源组件具有更高的优先级。 123456var CompA = &#123; ... &#125;// 在没有调用 `Vue.extend` 时候继承 CompAvar CompB = &#123; extends: CompA, ...&#125; provide/injectprovide：Object | () =&gt; Object inject：Array&lt;string&gt; | { [key: string]: string | Symbol } 说明：provide 和 inject 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中。 选项/其它name类型：string 作用：只有作为组件选项时起作用，并为组件命名。 最佳实践：为每个组件命名，利于 vue-devtools 调试。 delimiters类型：Array&lt;string&gt; 作用：改变纯文本插入分隔符。 1234new Vue(&#123; delimiters: [&apos;$&#123;&apos;, &apos;&#125;&apos;]&#125;);// 分隔符变成了 ES6 模板字符串的风格 functional类型：boolean 作用：使组件无状态 (没有 data ) 和无实例 (没有 this 上下文)。 model类型：{ prop?: string, event?: string } 作用：允许一个自定义组件在使用 v-model 时定制 prop 和 event。 inheritAttrs类型：boolean 作用：默认情况下父作用域的不被认作 props 的特性绑定 (attribute bindings) 将会“回退”且作为普通的 HTML 特性应用在子组件的根元素上。 comments类型：boolean 作用：当设为 true 时，将会保留且渲染模板中的 HTML 注释。默认行为是舍弃它们。 参考文档： 官方api]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件开发方法总结]]></title>
    <url>%2F2017%2Fvue%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[VUE 组件的三种开发方式 开发组件大致分为3个步骤： 组件声明-组件注册（全局和局部）-组件使用 使用 script 标签1.组件声明 123456789&lt;!-- 注意：使用&lt;script&gt;标签时，type指定为text/x-template，意在告诉浏览器这不是一段js脚本，浏览器在解析HTML文档时会忽略&lt;script&gt;标签内定义的内容。--&gt; &lt;!-- type 和 id 必须要填写 --&gt;&lt;script type=&quot;text/x-template&quot; id=&quot;myComponent&quot;&gt; &lt;!--只能有一个根节点，下面两种方式同样遵循--&gt; &lt;div class=&quot;root&quot;&gt; &lt;p&gt;我是p1&lt;/p&gt; &lt;p&gt;我是p2&lt;/p&gt; &lt;/div&gt; &lt;/script&gt; 2.组件注册（分为全局注册和局部注册） 1234567全局注册：需要确保在根实例初始化之前注册，这样才能使组件在任意实例中都可以使用。 Vue.component(&apos;my-component&apos;,MyComponent);//此句一定要放在new Vue(&#123;...&#125;);之前局部注册：限定了组件只能在被注册的组件中使用，而无法在其他组件中使用。//全局注册组件Vue.component(&apos;my-component&apos;,&#123; template: &apos;#myComponent&apos;&#125;); 3.组件使用 123&lt;div id=&quot;app&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;/div&gt; 本例全部代码 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--3.组件使用--&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;/div&gt; &lt;!--1.组件声明--&gt; &lt;script type=&quot;text/x-template&quot; id=&quot;myComponent&quot;&gt; &lt;div&gt;This is a component!&lt;/div&gt; &lt;/script&gt; &lt;/body&gt; &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; &lt;!--2.组件注册--&gt; Vue.component(&apos;my-component&apos;,&#123; template: &apos;#myComponent&apos; &#125;); new Vue(&#123; el: &apos;#app&apos; &#125;); &lt;/script&gt;&lt;/html&gt; 使用 template 标签1.组件声明 123&lt;template id=&quot;myComponent&quot;&gt; &lt;div&gt;This is a component!&lt;/div&gt; &lt;/template&gt; 2.组件注册 123Vue.component(&apos;my-component&apos;,&#123; template: &apos;#myComponent&apos;&#125;); 3.使用组件 123&lt;div id=&quot;app&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;/div&gt; 本例全部代码 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--3.组件使用--&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;/div&gt; &lt;!--1.组件声明--&gt; &lt;template id=&quot;myComponent&quot;&gt; &lt;div&gt;This is a component!&lt;/div&gt; &lt;/template&gt; &lt;/body&gt; &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; &lt;!--2.组件注册--&gt; Vue.component(&apos;my-component&apos;,&#123; template: &apos;#myComponent&apos; &#125;); new Vue(&#123; el: &apos;#app&apos; &#125;); &lt;/script&gt;&lt;/html&gt; 单文件组件注：这种方法常用在vue单页应用中。 1.创建组件（hello.vue） 12345678910111213141516&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;hello&apos;, data () &#123; return &#123; msg: &apos;欢迎！&apos; &#125; &#125;&#125;&lt;/script&gt; 父组件代码（app.vue，这里app.vue为hello.vue的父组件） 1234567891011121314151617181920&lt;!-- 展示模板 --&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 3.使用组件 --&gt; &lt;hello&gt;&lt;/hello&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 导入组件import Hello from &apos;./components/hello&apos;export default &#123; name: &apos;app&apos;, // 2.这里进行组件局部注册 components: &#123; Hello &#125;&#125;&lt;/script&gt; 参考文档： vue官网 vue组件的3种书写形式 vue.js中组件的创建和使用方法]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件通信的方式总结]]></title>
    <url>%2F2017%2Fvue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[父子组件通信父组件通过 props 向子组件传递数据，子组件通过执行父组件的方法，通知父组件子组件所发生的变化。 123456789101112131415// 父组件&lt;one-address :addressitems=&quot;addressitems&quot; @edit-address=&quot;editAddress&quot;&gt;&lt;/one-address&gt;// 子组件&lt;div&gt;&#123;&#123; addressitems.partment &#125;&#125;&#123;&#123; addressitems.address &#125;&#125;&lt;/div&gt;export default &#123; props: &#123; addressitems: Object &#125;, methods: &#123; editAddress () &#123; this.$emit(&apos;edit-address&apos;, false) &#125; &#125;&#125; 非父子组件通信非父子组件通信同样也可以用Vue.$emit自定义事件来解决 1234567var bus = new Vue();// 组件Abus.$emit(&apos;id-selected&apos;, 1);// 组件Bbus.$on(&apos;id-selected&apos;, function (id) &#123; console.log(id)&#125;); vue跨组件跨模块通信使用 vuex vuex有四个核心概念，其中state和getters主要是用于数据的存储与输出， 而mutations和actions是用于提交事件并修改state中的数据。 这里盗取vuex官网图，需要详细了解请访问[vuex](https://vuex.vuejs.org) 参考文档： vue组件之间的多种通信方法 vue组件之间的通信（一）]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式-发布订阅模式]]></title>
    <url>%2F2017%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[发布-订阅模式（观察者模式）定义：对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。 现实生活中的发布-订阅模式比如小红最近在淘宝网上看上一双鞋子，但是呢 联系到卖家后，才发现这双鞋卖光了，但是小红对这双鞋又非常喜欢，所以呢联系卖家，问卖家什么时候有货，卖家告诉她，要等一个星期后才有货，卖家告诉小红，要是你喜欢的话，你可以收藏我们的店铺，等有货的时候再通知你，所以小红收藏了此店铺，但与此同时，小明，小花等也喜欢这双鞋，也收藏了该店铺；等来货的时候就依次会通知他们。在上面的故事中，可以看出是一个典型的发布订阅模式，卖家是属于发布者，小红，小明等属于订阅者，订阅该店铺，卖家作为发布者，当鞋子到了的时候，会依次通知小明，小红等，依次使用旺旺等工具给他们发布消息。 实现发布-订阅模式的步骤1.首先要想好谁是发布者(比如上面的卖家)。2.然后给发布者添加一个缓存列表，用于存放回调函数来通知订阅者(比如上面的买家收藏了卖家的店铺，卖家通过收藏了该店铺的一个列表名单)。3.最后就是发布消息，发布者遍历这个缓存列表，依次触发里面存放的订阅者回调函数。 发布-订阅模式的代码封装1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var Event = (function()&#123; var list = &#123;&#125;, // 缓存列表 listen, // 监听函数 trigger, // 触发监听 remove; // 移除监听函数 listen = function(key,fn)&#123; if(!list[key]) &#123; list[key] = []; &#125; list[key].push(fn); &#125;; trigger = function()&#123; var key = Array.prototype.shift.call(arguments), fns = list[key]; if(!fns || fns.length === 0) &#123; return false; &#125; for(var i = 0, fn; fn = fns[i++];) &#123; fn.apply(this,arguments); &#125; &#125;; remove = function(key,fn)&#123; var fns = list[key]; if(!fns) &#123; return false; &#125; if(!fn) &#123; fns &amp;&amp; (fns.length = 0); &#125;else &#123; for(var i = fns.length - 1; i &gt;= 0; i--)&#123; var _fn = fns[i]; if(_fn === fn) &#123; fns.splice(i,1); &#125; &#125; &#125; &#125;; return &#123; listen: listen, trigger: trigger, remove: remove &#125;&#125;)();// 测试代码function d1() &#123; console.log(&apos;我是第二个color监听的函数!&apos;); &#125;function d2() &#123; console.log(&apos;我是第二个color监听的函数!&apos;);&#125;// 测试代码Event.listen(&quot;color&quot;, d1); // 在 list[&apos;color&apos;] 中绑定 d1 函数Event.listen(&quot;color&quot;, d2); // 在 list[&apos;color&apos;] 中绑定 d2 函数Event.remove(&apos;color&apos;, d1); // 在 list[&apos;color&apos;] 中移除 d1 函数Event.trigger(&quot;color&quot;); // 我是第二个color监听的函数! PS：此处代码来源于网络。 参考文档： Javascript中理解发布–订阅模式 学习笔记-js发布/订阅模式的简单实现]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js函数传参方式--按值传递]]></title>
    <url>%2F2017%2Fjs%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F.html</url>
    <content type="text"><![CDATA[一直以为js函数传参方式–按引用传递，原来我一直错了。通过查阅资料彻底了解js函数传参是按值传递的。要搞清楚js函数传参方式，我们先需要具备一些基础知识。 数据类型基本类型值: Undefined,Null,Boolean,Number,String。 引用类型值: Object,Array,Function,Date等。 变量的复制基本类型的复制 众所周知，js中变量的基本类型和引用类型保存方式是不同的，这也就导致变量复制时也就不同了。 如果从一个变量向另一个变量复制基本类型的值时，会将前者的值克隆一个，然后将克隆的值赋值到后者， 因此这两个值是完全独立的，只是他们的value相同而已。 123var num1 = 10;var num2 = num1;console.log(num2);//10 上面的num1中被保存的值为10，当把num1的值赋值给num2时，num2的值也为10。 但是这两个10是完全独立的，num2中的10只是被克隆出来的，相当于我写了一个word文档， 把它放到了num1的文件夹中，然后我再复制这个word文档，就叫word副本吧，然后把这个副本放到num2的文件夹下， 这两个word文档是完全一样的，修改任何一个都不会影响另一个。 123num2 += 1;console.log(num1); //10console.log(num2); //11 引用类型的复制1234567var obj1 = &#123; name : &quot;111&quot;&#125;;var obj2 = obj1;console.log(obj2.name); //111obj2.name = &quot;222&quot;;console.log(obj1.name); //222 第一次打印出的结果为“111”，这个我们很容易理解，但是第二次打印出来的是“222”，有点莫名其妙了。 这就是引用类型和基本类型的不同之处了。复制对象时并不会在堆内存中新生成一个一模一样的对象， 只是多了一个保存指向这个对象指针的变量罢了。将obj1的值复制给obj2，而这个值的副本实际上是一个指针， 这个指针指向存储在堆中的一个对象，也就是说创建了一个新的内存地址传给了obj2，obj1和obj2两个变量同时指向了同一个Object， 当去改变这个对象时，他们的值都会改变，也就是说他们中任何一个作出的改变都会反映在另一个身上。 下面的简易图可能更明了些。 函数参数的传递（按值传递）基本类型传递参数（）12345678var count = 10;function num(num1)&#123; num1 = 1; return num1;&#125;var result = num(count);console.log(result); //1console.log(count); //10，并未变成1 这个例子很容易理解，实际就是创建了一个count的副本，然后把count的副本的值传入参数中， 因为函数中定义了参数的值，所以1就将10覆盖了，最后的result返回1，而count并未发生变化。 引用类型传递参数（按值传递）1234567891011var person = &#123; name : &quot;Tom&quot;&#125;;function obj(peo)&#123; // PS：这里 peo 对象和 person 对象的内存地址一模一样，所以后面两个才会同时改变 peo.name = &quot;Jerry&quot;; return peo;&#125;var result = obj(person);console.log(result.name); // Jerryconsole.log(person.name); // Jerry 在上面的例子中，把person复制传入obj()中，peo和person指向了同一个对象，而在peo中修改了name属性， 其实修改了它们共同指向的对象的name属性，相对应的外部person所引用的name属性也就改变了， 所以打印出来的为Jerry。其实这个乍一看，感觉引用类型的参数是按照引用传递的， 这就是我最初犯得错误。 再来看一个例子。 12345678910111213var person = &#123; name : &quot;Tom&quot;&#125;; function obj(peo)&#123; // PS：这里在函数里面新建了一个对象 peo，其内存地址和 person 对象内存地址不一样，所以两个对象不相干涉 peo = &#123; name : &quot;Jerry&quot; &#125;; return peo;&#125;var result = obj(person);console.log(result.name);// Jerryconsole.log(person.name);// Tom 上面的例子中，在函数中重新定义了一个对象，也就是现在堆内存中有两个对象， 外部的person指向的是老的对象，被传入参数后指向的是新定义的对象，所以调用后返回的值是新定义的对象的值。 如果是参数是按引用传递的，那么person.name打印出来的结果为Jerry，从这点可以得出参数是按值传递的（有的地方叫做按共享传递）。 总结JavaScript中的函数不存在按引用传递，所有参数都是按值传递！ 引用类型的变量本就是一个引用，它的值是堆内存中Object的地址， 当使用按值传递时传递的值本就是一个地址，所以在函数中对参数进行操作会影响到函数外对应的变量。 参考文档： JavaScript中函数参数的按值传递与按引用传递（即按地址传递） JS函数参数都是按值传递的！ js函数中参数的传递]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式-装饰者模式]]></title>
    <url>%2F2017%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[装饰者模式定义：装饰者(decorator)模式能够在不改变对象自身的基础上，在程序运行期间给对象动态的添加职责。 装饰者用于通过重载方法的形式添加新功能，该模式可以在被装饰者前面或者后面加上自己的行为以达到特定的目的。 与继承相比，装饰者是一种更轻便灵活的做法。普通对象被装饰者包裹起来，就形成了装饰者模式。举例： 雷霆战机（吃道具的例子） 雷霆战机（吃道具的例子）介绍：现在我们假设正在开发一个小游戏–雷霆战机， 最开始我们使用最渣的飞机，只能发射普通子弹； 吃一颗星，可以发射普通子弹和发射散弹 ； 再吃一颗，可以发射普通子弹和散弹和跟踪导弹。// 一级飞机123456var plane = &#123; fire: function()&#123; console.log(&apos;发射普通子弹&apos;); &#125;&#125;plane.fire(); // &apos;发射普通子弹&apos; // 二级飞机123456789var fire1 = plane.fire;var shot = function() &#123; console.log(&apos;发射散弹&apos;);&#125;;plane.fire = function () &#123; fire1(); shot();&#125;;plane.fire(); // &apos;发射普通子弹&apos; &apos;发射散弹&apos; // 三级飞机123456789var fire2 = plane.fire;var track = function() &#123; console.log(&apos;发射跟踪导弹&apos;);&#125;;plane.fire = function () &#123; fire2(); track();&#125;;plane.fire(); // &apos;发射普通子弹&apos; &apos;发射散弹&apos; &apos;发射跟踪导弹&apos; PS：这样给对象动态的增加职责的方式就没有改变对象自身，一个对象放入另一个对象就形成了一条装饰链（一个聚合对象）， 而上面的shot和track也就是装饰者、装饰函数 ，当函数执行时，会把请求转给链中的下一个对象。 在 FUNCTION 原型上封装通用的装饰函数// 在原函数之前执行1234567Function.prototype.before=function(beforefn) &#123; var _this = this; // 保存旧函数的引用 return function() &#123; // 返回包含旧函数和新函数的“代理”函数 beforefn.apply(this,arguments); // 执行新函数,且保证this不被劫持,新函数接受的参数 return _this.apply(this,arguments); // 也会被原封不动的传入旧函数,新函数在旧函数之前执行 &#125;;&#125;; // 在原函数之后执行12345678Function.prototype.after = function(afterfn) &#123; var _this = this; return function() &#123; var ret = _this.apply(this,arguments); afterfn.apply(this,arguments); return ret; &#125;;&#125;; 封装成单独函数（不污染原型）// 在原函数之前执行123456789var before = function(fn, before) &#123; return function() &#123; before.apply(this, arguments); return fn.apply(this, arguments); &#125;;&#125;; // 使用before(func1, func2); // 在原函数之后执行12345678910var after = function(fn, after) &#123; return function() &#123; var ret = fn.apply(this,arguments); after.apply(this,arguments); return ret; &#125;;&#125;; // 使用after(func1, func2); PS：代码来源于–腾讯.曾探《JavaScript设计模式与开发实践》，但能很好的说明装饰者模式在js实际项目中的应用。上面封装的函数可以直接在项目中使用。 参考文档：JavaScript设计模式—-装饰者模式深入理解JavaScript系列（29）：设计模式之装饰者模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式-中介者模式]]></title>
    <url>%2F2017%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[中介者模式定义：中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者模式使网状的多对多关系变成了相对简单的一对多关系。举例： 手机购买页面（颜色、数量、内存、价格） MVC模式（控制层便是位于表现层与模型层之间的中介者。） MVC 模式我们应该很熟悉 MVC 三层模型实体模型（Model）、视图表现层（View）还有控制层（Control/Mediator）。1234567891011121314/** 模擬 Model, View, Controller */var M = &#123;&#125;, V = &#123;&#125;, C = &#123;&#125;;/** Model 負責存放資料 */M.data = &quot;hello world&quot;;/** View 負責將資料輸出到螢幕上 */V.render = (M) =&gt; &#123; alert(M.data); &#125;/** Controller 作為一個 M 和 V 的橋樑 */C.handleOnload = () =&gt; &#123; V.render(M); &#125;/** 在網頁讀取的時候呼叫 Controller */window.onload = C.handleOnload; MVC 模式中的Control/Mediator 层，就是本设计模式的中介者 (它必须拿到 View 和 Model 的引用)。 手机购买页面HTML 部分123456789101112131415161718192021&lt;body&gt; 选择颜色: &lt;select id=&quot;colorSelect&quot;&gt; &lt;option value=&quot;&quot;&gt;请选择&lt;/option&gt; &lt;option value=&quot;red&quot;&gt;红色&lt;/option&gt; &lt;option value=&quot;blue&quot;&gt;蓝色&lt;/option&gt; &lt;/select&gt; 选择内存: &lt;select id=&quot;memorySelect&quot;&gt; &lt;option value=&quot;&quot;&gt;请选择&lt;/option&gt; &lt;option value=&quot;32G&quot;&gt;32G&lt;/option&gt; &lt;option value=&quot;16G&quot;&gt;16G&lt;/option&gt; &lt;/select&gt; 输入购买数量: &lt;input type=&quot;text&quot; id=&quot;numberInput&quot;/&gt;&lt;br/&gt; &lt;!--输入部分结束--&gt; 您选择了颜色: &lt;div id=&quot;colorInfo&quot;&gt;&lt;/div&gt;&lt;br/&gt; 您选择了内存: &lt;div id=&quot;memoryInfo&quot;&gt;&lt;/div&gt;&lt;br/&gt; 您输入了数量: &lt;div id=&quot;numberInfo&quot;&gt;&lt;/div&gt;&lt;br/&gt; &lt;button id=&quot;nextBtn&quot; disabled=&quot;true&quot;&gt;请选择手机颜色和购买数量&lt;/button&gt;&lt;body&gt; JS部分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 各种手机库存（通常来自于后端，这里前端进行模拟）var goods = &#123; &quot;red|32G&quot;: 3, &quot;red|16G&quot;: 0, &quot;blue|32G&quot;: 1, &quot;blue|16G&quot;: 6&#125;;// 中介者var mediator = (function()&#123; // 获得所有节点的引用，以便对其进行操作（中介者必许获得对其他对象的引用） var colorSelect = document.getElementById( &apos;colorSelect&apos; ), memorySelect = document.getElementById( &apos;memorySelect&apos; ), numberInput = document.getElementById( &apos;numberInput&apos; ), colorInfo = document.getElementById( &apos;colorInfo&apos; ), memoryInfo = document.getElementById( &apos;memoryInfo&apos; ), numberInfo = document.getElementById( &apos;numberInfo&apos; ), nextBtn = document.getElementById( &apos;nextBtn&apos; ); return &#123; changed( obj )&#123; var color = colorSelect.value, // 颜色 memory = memorySelect.value,// 内存 number = numberInput.value, // 数量 stock = goods[ color + &apos;|&apos; + memory ]; // 颜色和内存对应的手机库存数量 if ( obj === colorSelect )&#123; // 如果改变的是选择颜色下拉框 colorInfo.innerHTML = color; &#125;else if ( obj === memorySelect )&#123; memoryInfo.innerHTML = memory; &#125;else if ( obj === numberInput )&#123; numberInfo.innerHTML = number; &#125; if ( !color )&#123; nextBtn.disabled = true; nextBtn.innerHTML = &apos;请选择手机颜色&apos;; return; &#125; if ( !memory )&#123; nextBtn.disabled = true; nextBtn.innerHTML = &apos;请选择内存大小&apos;; return; &#125; if ( ( ( number - 0 ) | 0 ) !== number - 0 )&#123; // 输入购买数量是否为正整数 nextBtn.disabled = true; nextBtn.innerHTML = &apos;请输入正确的购买数量&apos;; return; &#125; nextBtn.disabled = false; nextBtn.innerHTML = &apos;放入购物车&apos;; &#125; &#125;&#125;)();// 与中介者联系起来，事件函数colorSelect.onchange = function()&#123; mediator.changed( this );&#125;;memorySelect.onchange = function()&#123; mediator.changed( this );&#125;;numberInput.oninput = function()&#123; mediator.changed( this );&#125;; PS：代码来源于–腾讯.曾探《JavaScript设计模式与开发实践》，但能很好的说明中介者模式在js实际项目中的应用。PS：这里共有手机颜色、手机内存、手机数量的选择和展示共6个对象，和一个中介者对象。 中介者必须获得这6个对象的应用，当每个对象发生变化时都需要通知中介者，中介者再来执行具体操作。 参考文档： js之中介模式 wiki-MVC]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式-代理模式]]></title>
    <url>%2F2017%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[代理模式定义：为一个对象提供一个代用品或占位符，以便控制对它的访问。 代理对象和本体对象实现了同样的接口，并且会把任何方法调用传递给本体对象；举例： 图片预加载、图片懒加载、 合并HTTP请求（代理收集一定时间内的所有HTTP请求，然后一次性发给服务器）、 惰性加载（通过代理处理和收集一些基本操作，然后仅在真正需要本体的时候才加载本体）、 缓存代理（缓存请求结果、计算结果） 缓存代理1234567891011121314151617181920212223242526272829303132333435// 先实现具体的两个算法const mult = function() &#123; let a = 1; for (let i = 0; i &lt; arguments.length; i++) &#123; a *= arguments[i]; &#125; return a;&#125;;const plus = function() &#123; let a = 0; for (let i = 0; i &lt; arguments.length; i++) &#123; a += arguments[i]; &#125; return a;&#125;;// 创建缓存代理const createProxyFactory = function(fn) &#123; let cache = &#123;&#125;; // 保存计算的结果 // 使用闭包在内存中保留对cache的引用 return function() &#123; let args = Array.from(arguments).join(&apos;,&apos;); // 将所有参数转化为字符串作为缓存的 key if (args in cache) &#123; return cache[args]; &#125; else &#123; return cache[args] = fn.apply(this, arguments); &#125; &#125;;&#125;;// 使用代理对象const proxyMult = createProxyFactory(mult);const proxyPlus = createProxyFactory(plus);console.log(proxyMult(1,2,3,4)); // 24console.log(proxyPlus(1,2,3,4)); // 10 PS：这里每次进行同类的计算时（乘法和加法两类），先判断缓存对象cache中是否存在该参数连接成的字符串作为key的属性。如果有，则直接从cache中读取，否则就进行计算并保存其结果。 虚拟代理虚拟代理：某一个花销很大的操作，可以通过虚拟代理的方式延迟到这种需要它的时候才去创建例：使用虚拟代理实现图片懒加载下面以虚拟代理来说明：123456789101112131415161718192021222324252627// 本体对象const imgFunc = (function() &#123; const imgNode = document.createElement(&apos;img&apos;); document.body.appendChild(imgNode); return &#123; setSrc(src)&#123; imgNode.src = src; &#125; &#125;&#125;)();// 代理对象const proxyImage = (function() &#123; const img = new Image(); img.onload = function() &#123; imgFunc.setSrc(this.src); &#125;; return &#123; setSrc(src)&#123; imgFunc.setSrc(&apos;./loading.gif&apos;); img.src = src; &#125; &#125;;&#125;)();// 使用代理对象proxyImage.setSrc(&apos;./reality.png&apos;); PS：图片懒加载的方式：先通过一张loading图占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到img标签里面。这里讲述一下代理对象做了那些事：1.创建了一个 Image 对象，并为其绑定了 onload 事件。2.将 imgNode 先设置为 ‘./loading.gif’ 加载的菊花图。3.当 Image 对象加载完真实的图片，也就是上文的 ‘./reality.png’ ,将 imgNode 设置为 ‘./reality.png’。 参考文档： js设计模式（9）—代理模式 JavaScript设计模式 js用高阶函数动态创建缓存代理]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式-策略模式]]></title>
    <url>%2F2017%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[策略模式定义：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。举例：表单效验（是否为空、长度、手机号、邮箱等等） 计算年终奖（工资、效绩）下面以年终将做说明：比如公司的年终奖是根据员工的工资和绩效来考核的，绩效为A的人，年终奖为工资的4倍，绩效为B的人，年终奖为工资的3倍，绩效为C的人，年终奖为工资的2倍；12345678910111213141516171819202122232425262728// 一组策略类封装具体的算法const Bouns = &#123; A (salary)&#123; return salary * 4; &#125;, B (salary)&#123; return salary * 3; &#125;, C (salary)&#123; return salary * 2; &#125;&#125;;Object.freeze(Bouns);/** 计算年终奖 环境类Context* @param &#123;String&#125; A 效绩等级* @param &#123;Number&#125; 10000 每月工资* @returns &#123;Number&#125; 40000 年终奖*/const calculateBouns = function (type, salary)&#123; return Bouns[type](salary);&#125;;// 测试年终奖计算方式const demo1 = calculateBouns(&apos;A&apos;, 10000);const demo2 = calculateBouns(&apos;B&apos;, 80000);console.log(demo1, demo2); // 40000, 240000 PS：策略模式指的是定义一系列的算法，把它们一个个封装起来，将不变的部分和变化的部分隔开，实际就是将算法的使用和实现分离出来；算法的使用方式是不变的，都是根据某个算法取得计算后的奖金数，而算法的实现是根据绩效对应不同的绩效规则；一个基于策略模式的程序至少由2部分组成，第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类Context，该Context接收客户端的请求，随后把请求委托给某一个策略类。复合开放-封闭原则，可变的部分为策略类（一组算法），不变的部分为执行具体算法的方式。 表单验证123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 这里我们实现一组策略类封装具体的验证规则const strategy = &#123; // 是否为空 isNotEmpty (value, errorMsg)&#123; if (value === &apos;&apos;) &#123; return errorMsg; &#125; &#125;, // 最小长度 minLength (value, errorMsg, length)&#123; if (value.length &lt; length) &#123; return errorMsg; &#125; &#125;, // 手机号码格式 mobileFormat (value,errorMsg)&#123; if(!/(^1[3|5|8][0-9]&#123;9&#125;$)/.test(value)) &#123; return errorMsg; &#125; &#125;&#125;;Object.freeze(strategy);var Validator = function()&#123; this.cache = []; // 保存效验规则&#125;;Validator.prototype.add = function(dom,rules) &#123; var self = this; for(var i = 0, rule; rule = rules[i++]; )&#123; (function(rule)&#123; var strategyAry = rule.strategy.split(&quot;:&quot;); var errorMsg = rule.errorMsg; self.cache.push(function()&#123; var strategy = strategyAry.shift(); strategyAry.unshift(dom.value); strategyAry.push(errorMsg); return strategys[strategy].apply(dom,strategyAry); &#125;); &#125;)(rule); &#125;&#125;;Validator.prototype.start = function()&#123; for(var i = 0, validatorFunc; validatorFunc = this.cache[i++]; ) &#123; var msg = validatorFunc(); // 开始效验 并取得效验后的返回信息 if(msg) &#123; return msg; &#125; &#125;&#125;;// 代码调用var registerForm = document.getElementById(&quot;registerForm&quot;);var validateFunc = function()&#123; var validator = new Validator(); // 创建一个Validator对象 /* 添加一些效验规则 */ validator.add(registerForm.userName,[ &#123;strategy: &apos;isNotEmpty&apos;,errorMsg:&apos;用户名不能为空&apos;&#125;, &#123;strategy: &apos;minLength:6&apos;,errorMsg:&apos;用户名长度不能小于6位&apos;&#125; ]); validator.add(registerForm.password,[ &#123;strategy: &apos;minLength:6&apos;,errorMsg:&apos;密码长度不能小于6位&apos;&#125;, ]); validator.add(registerForm.phoneNumber,[ &#123;strategy: &apos;mobileFormat&apos;,errorMsg:&apos;手机号格式不正确&apos;&#125;, ]); var errorMsg = validator.start(); // 获得效验结果 return errorMsg; // 返回效验结果&#125;;// 点击确定提交registerForm.onsubmit = function()&#123; var errorMsg = validateFunc(); if(errorMsg)&#123; alert(errorMsg); return false; &#125;&#125; PS：此处代码来源于–腾讯.曾探的《javascript设计模式》，这能很好的说明策略模式的用途。 参考文档： 理解javascript中的策略模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式-单例模式]]></title>
    <url>%2F2017%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[单例模式定义：单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。 在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。举例：模态框、登录控件、注销控件下面均以登录模态框做说明 引入代理实现单例模式12345678910111213141516171819202122232425var CreateDiv = function(html) &#123; this.html = html; this.init();&#125;;CreateDiv.prototype.init = function() &#123; var div = document.createElement(&apos;div&apos;); div.innerHTML = this.html; document.body.appendChild(div);&#125;var ProxySingletonCreateDiv = (function() &#123; var instance; return function(html) &#123; if (!instance) &#123; instance = new CreateDiv(html); &#125; return instance; &#125;&#125;)();var a = new ProxySingletonCreateDiv(&apos;seven1&apos;);var b = new ProxySingletonCreateDiv(&apos;seven2&apos;);console.log(a === b); // true PS：我们负责管理单例的逻辑移到了代理类ProxySingletonCreateDiv中。这样一来，CreateDiv就变成了一个普通的类，他跟ProxySingletonCreateDiv组合起来可以达到单例模式的效果。 通用的单例模式12345678910111213141516171819202122// 通用的单例验证方法const getSingle = function (fn)&#123; let result; return function ()&#123; return result || (result = fn.apply(this, arguments)); &#125;;&#125;;// 创建登录模态框const createLoginLayer = function ()&#123; const div = document.createElement(&apos;div&apos;); div.innerHTML = &apos;我是登录模态框&apos;; document.body.appendChild(div); return div;&#125;;// 为登录模态框使用单例模式const createSingleLoginLoyer = getSingle(createLoginLayer);const loginLayer1 = createSingleLoginLoyer(); // 第一个登录模态框const loginLayer2 = createSingleLoginLoyer(); // 还是第一个登录模态框console.log(loginLayer1 === loginLayer2); // true 这时不管你执行多少次 createSingleLoginLoyer() 方法，都只会生产一个 div 节点。我们的通用单例模式就完成了。 惰性单例定义：惰性单例指的是在需要的时候才创建对象的实例。以创建登录模态框为例12345678910111213141516const createLoginLayer = (function ()&#123; let div; return function ()&#123; if (!div) &#123; div = document.createElement(&apos;div&apos;); div.innerHTML = &apos;我是登录模态框&apos;; &#125; return div; &#125;;&#125;)();// 在点击按钮时才创建节点（惰性）document.getElementById(&apos;login-btn&apos;).onclick = function ()&#123; var loginLayer = createLoginLayer(); loginLayer.style.display = &apos;block&apos;;&#125;; 这里的对惰性单例的实现主要是只有单例了网页上的登录按钮，才会去创建，登录框的dom节点，并且只是创建一次。 参考文档： JavaScript设计模式—-单例模式 设计模式之单例模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js设计模式-工厂模式]]></title>
    <url>%2F2017%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[从事前端开发已经有几年了，也经常使用一些设计模式，但是对一些设计模式并不能很好的说出名字以及使用场景。现利用周末闲暇时间来好好整理一下JS中常用的设计模式,如有不正确的地方，还望指出，谢谢！ 简单工厂定义：简单工厂模式是由一个方法来决定到底要创建哪个类的实例, 而这些类通常都拥有相同的接口（属性和方法）。举例：计算器（加、减、乘、除） 自行车售卖（山地、公路） 饮料机（咖啡、牛奶、水） RPG中职业（战士、法师、射手）这里就以RPG中职业（战士、法师、射手）来做说明： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 先创建各个角色的构造函数function Warrior() &#123; this.skill = &apos;回血&apos;; this.blood = 150; // 初始化生命值 this.hit = 8; // 普通攻击伤害 // 其他特有属性和方法比如生命值 console.log(this);&#125;function Mage() &#123; this.skill = &apos;冰冻&apos;; this.blood = 120; // 初始化生命值 this.hit = 3; // 普通攻击伤害 // 其他特有属性和方法 console.log(this);&#125;function Archer() &#123; this.skill = &apos;消耗&apos;; this.blood = 110; // 初始化生命值 this.hit = 10; // 普通攻击伤害 // 其他特有属性和方法 console.log(this);&#125;// 工厂对象 可以是普通对象是的方法 和 构造函数，这里使用前者const RoleFactory = &#123; createRole (role) &#123; let roler; switch (role) &#123; case &apos;战士&apos;: roler = new Warrior(); break; case &apos;法师&apos;: roler = new Mage(); break; case &apos;射手&apos;: roler = new Archer(); break; // 后续扩展角色直接追加选择语句和添加角色构造函数 defaulr: roler = new Warrior(); &#125; &#125;&#125;;Object.freeze(RoleFactory); // 冻结该对象，防止他人操作// 创建各个角色的实例var warrior1 = RoleFactory.createRole(&apos;战士&apos;); // 创建一个战士var mage1 = RoleFactory.createRole(&apos;法师&apos;); // 创建一个法师var arche1 = RoleFactory.createRole(&apos;射手&apos;); // 创建一个射手 其实我们还可以这样设计工厂处理函数1234567const RoleFactory = function (role) &#123; return new role ();&#125;var warrior1 = RoleFactory(Warrior); // 创建一个战士var mage1 = RoleFactory(Mage); // 创建一个法师var arche1 = RoleFactory(Archer); // 创建一个射手 上面输出的结果 什么时候使用工厂模式 对象的构建十分复杂 需要依赖具体环境创建不同实例 处理大量具有相同属性的小对象 参考文档：JS设计模式之工厂模式js之简单工厂模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSI七层与TCP/IP五层网络架构]]></title>
    <url>%2F2017%2FOSI%E4%B8%83%E5%B1%82%E4%B8%8ETCP-IP%E4%BA%94%E5%B1%82%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84.html</url>
    <content type="text"><![CDATA[还记得大学时学习了通信相关的底层知识，只是当时并没有特别在意，从参加工作一直做的WEB前端开发，对这方面知识也不是太需要。但是为了自己更好的发展，需要了解一些底层的东西重新拾起通信相关的知识。 名词解释 OSI：开放系统互连参考模型 (Open System Interconnect 简称OSI）。 TCP：TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。 IP：网络之间互连的协议（IP）是Internet Protocol的外语缩写，中文缩写为“网协”。 HTTP：超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。 HTTPS：HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。 OSI七层模型OSI七层结构--每层的解释 OSI七层结构–每层结构的功能 TCP/IP五层模型OSI七层模型与TCP/IP五层模型的关系 OSI七层模型–每层的设备 对各层的详细说明 第一层是物理层（PhysicalLayer)，规定通信设备的机械的、电气的、功能的和过程的特性，用以建立、维护和拆除物理链路连接。具体地讲，机械 特性规定了网络连接时所需接插件的规格尺寸、引脚数量和排列情况等；电气特性规定了在物理连接上传输bit流时线路上信号电平的大小、阻抗匹配、传输速率 距离限制等；功能特性是指对各个信号先分配确切的信号含义，即定义了DTE和DCE之间各个线路的功能；规程特性定义了利用信号线进行bit流传输的一组 操作规程，是指在物理连接的建立、维护、交换信息是，DTE和DCE双放在各电路上的动作系列。在这一层，数据的单位称为比特（bit）。属于物理层定义的典型规范代表包括：EIA/TIA RS-232、EIA/TIA RS-449、V.35、RJ-45等。 第二层是数据链路层在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧（Frame）在信道上无差错的传输，并进行各电路上的动作系列。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。在这一层，数据的单位称为帧（frame）。数据链路层协议的代表包括：SDLC、HDLC、PPP、STP、帧中继等。 第三层是网络层在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。网络层将数据链路层提供的帧组成数据包，包中封装有网络层包头，其中含有逻辑地址信息- -源站点和目的站点地址的网络地址。如果你在谈论一个IP地址，那么你是在处理第3层的问题，这是“数据包”问题，而不是第2层的“帧”。IP是第3层问题的一部分，此外还有一些路由协议和地 址解析协议（ARP）。有关路由的一切事情都在这第3层处理。地址解析和路由是3层的重要目的。网络层还可以实现拥塞控制、网际互连等功能。在这一层，数据的单位称为数据包（packet）。网络层协议的代表包括：IP、IPX、RIP、OSPF等。 第四层是处理信息的传输层第4层的数据单元也称作数据包（packets）。但是，当你谈论TCP等具体的协议时又有特殊的叫法，TCP的数据单元称为段 （segments）而UDP协议的数据单元称为“数据报（datagrams）”。这个层负责获取全部信息，因此，它必须跟踪数据单元碎片、乱序到达的 数据包和其它在传输过程中可能发生的危险。第4层为上层提供端到端（最终用户到最终用户）的透明的、可靠的数据传输服务。所为透明的传输是指在通信过程中 传输层对上层屏蔽了通信传输系统的具体细节。传输层协议的代表包括：TCP、UDP、SPX等。 第五层是会话层这一层也可以称为会晤层或对话层，在会话层及以上的高层次中，数据传送的单位不再另外命名，而是统称为报文。会话层不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。如服务器验证用户登录便是由会话层完成的。 第六层是表示层这一层主要解决拥护信息的语法表示问题。它将欲交换的数据从适合于某一用户的抽象语法，转换为适合于OSI系统内部使用的传送语法。即提供格式化的表示和转换数据服务。数据的压缩和解压缩， 加密和解密等工作都由表示层负责。 第七层应用层应用层为操作系统或网络应用程序提供访问网络服务的接口。应用层协议的代表包括：Telnet、FTP、HTTP、SNMP等。 参考文档 OSI七层与TCP/IP五层网络架构详解 OSI七层模型与TCP/IP五层模型]]></content>
      <categories>
        <category>通信协议</category>
      </categories>
      <tags>
        <tag>OSI</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RESTful API 设计指南]]></title>
    <url>%2F2017%2FRESTful-API-%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97.html</url>
    <content type="text"><![CDATA[RESTful API 的产生当前的发展趋势，就是前端设备层出不穷（手机、平板、桌面电脑、其他专用设备......）。 因此，必须有一种统一的机制，方便不同的前端设备与后端进行通信，在这种情况下RESTful API产生了。 协议HTTP、HTTPS 应用层协议。 联网的设备 和 服务器之前的通信。 域名 API专用域名https://api.example.com API放在主域名https://example.org/api/ 版本（Versioning）将API的版本放入URL中。 https://api.example.com/v1 路径（Endpoint） 路径又称”终点”（endpoint），表示API的具体网址。 在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。 举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。 123https://api.example.com/v1/zooshttps://api.example.com/v1/animalshttps://api.example.com/v1/employees HTTP 动词对于资源的具体操作类型，由HTTP动词表示。 常用的HTTP动词有下面五个（括号里是对应的SQL命令）。 GET（SELECT）：从服务器取出资源（一项或多项）。 POST（CREATE）：在服务器新建一个资源。 PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。 PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。 DELETE（DELETE）:从服务器删除资源。不常用的两个动词 HEAD：获取资源的元数据。 OPTIONS：获取信息，关于资源的那些属性是客户端可以改变的。动物园管理系统举例：12345678GET /zoos: 列出所有动物园。POST /zoos: 新建一个动物园（动物园的信息的请求体中）。GET /zoos/ID: 获取某个动物园的信息。PUT /zoos/ID: 更新某个指定动物园的信息（提供该动物园的全部信息）。PATCH /zoos/ID: 更新某个动物园的信息（提供该动物园的部分信息）。DELETE /zoos/ID: 删除某个动物园。GET /zoos/ID/animals: 列出某个指定动物园的所有动物。DELETE /zoos/ID/animals/ID: 删除某个动物园的指定动物。 过滤信息（Filtering）如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。 12345?limit=10：指定返回记录的数量?offset=10：指定返回记录的开始位置。?page=2&amp;per_page=100：指定第几页，以及每页的记录数。?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。?animal_type_id=1：指定筛选条件 参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。 比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。 状态码（Status Codes） 服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。 123456789101112200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）204 NO CONTENT - [DELETE]：用户删除数据成功。400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。 状态码的完全列表参见[w3c](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)。 错误处理（Error handling）如果状态码是4xx，就应该向用户返回出错信息。 一般来说，返回的信息中将error作为键名，出错信息作为键值即可。 123&#123; error: &quot;Invalid API key&quot;&#125; 返回结果 针对不同操作，服务器向用户返回的结果应该符合以下规范。 123456GET /collection：返回资源对象的列表（数组）GET /collection/resource：返回单个资源对象POST /collection：返回新生成的资源对象PUT /collection/resource：返回完整的资源对象PATCH /collection/resource：返回完整的资源对象DELETE /collection/resource：返回一个空文档 注意事项（1）API的身份认证应该使用OAuth 2.0框架。 （2）服务器返回的数据格式，应该尽量使用JSON，避免使用XML。 参考文档： RESTful API 设计]]></content>
      <categories>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>服务端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js代码规范]]></title>
    <url>%2F2017%2Fjs%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83.html</url>
    <content type="text"><![CDATA[Airbnb JavaScript Style Guide，这是业界中比较权威的js编码规范，先学习这个规范，后期项目配合ESLint指定良好的代码规范。 类型 基本类型：直接存取基本类型。String 字符串Number 数值Boolean 布尔类型nullundefined 复制类型：通过引用的方式存取复杂类型。Object 对象Array 数组Function 函数引用 对不可变的引用使用 const 避免使用 var。 const 声明的变量不可以重新赋值，而 var 可以。 对可变的引用使用 let 避免使用 var。 注意 let 和 const 都是块级作用域。对象 使用字面值创建对象。 如果你的代码在浏览器环境下执行，别使用 保留字 作为键值。这样的话在 IE8 不会运行。 使用同义词替换需要使用的保留字。 创建有动态属性名的对象时，使用可被计算的属性名称。 12345678function getKey(k) &#123; return `a key named $&#123;k&#125;`;&#125;const obj = &#123; id: 5, name: &apos;San Francisco&apos;, [getKey(&apos;enabled&apos;)]: true,&#125;; 使用对象方法的简写。 1234567const atom = &#123; value: 1, // 方法简写 addValue(value) &#123; return atom.value + value; &#125;&#125;; 使用对象属性值的简写。 123456const lukeSkywalker = &apos;Luke Skywalker111&apos;;const obj = &#123; lukeSkywalker,&#125;;console.log(obj.lukeSkywalker); // &apos;Luke Skywalker111&apos; 在对象属性声明前把简写的属性分组（也就是说把简写属性放在一起）。 数组 使用字面值创建数组。 向数组添加元素时使用 Arrary#push 替代直接赋值。 123456789 const someStack = []; // bad someStack[someStack.length] = &apos;abracadabra&apos;; // good someStack.push(&apos;abracadabra&apos;); ``` 3. 使用拓展运算符 ... 复制数组。 let array = [‘1’,’2’];console.log([…array]); 14. 使用 Array#from 把一个类数组对象转换成数组。 const foo = document.querySelectorAll(‘.foo’);const nodes = Array.from(foo); 12## 解构1. 使用解构存取和使用多属性对象。 // goodfunction getFullName(obj) { const { firstName, lastName } = obj; return ${firstName} ${lastName};} // best function getFullName({ firstName, lastName }) { return ${firstName} ${lastName};} 12. 对数组使用解构赋值。 const arr = [1, 2, 3, 4];const [first, second] = arr;console.log(first, second); // 1, 2 13. 需要回传多个值时，使用对象解构，而不是数组解构。 function processInput(input) { // then a miracle occurs return { left, right, top, bottom };} // 调用时只选择需要的数据const { left, right } = processInput(input); 字符串 字符串使用单引号 ‘’。 字符串超过 80 个字节应该使用字符串连接号换行。\ 过度使用字串连接符号可能会对性能造成影响。可换用 + 程序化生成字符串时，使用模板字符串代替字符串连接。函数 使用函数声明代替函数表达式。 立即调用的函数表达式 (IIFE) 123(() =&gt; &#123; console.log(&apos;Welcome to the Internet. Please follow me.&apos;);&#125;)(); 永远不要在一个非函数代码块（if、while 等）中声明一个函数，把那个函数赋给一个变量。浏览器允许你这么做，但它们的解析表现不一致。可以这样 123456let test;if (currentUser) &#123; test = () =&gt; &#123; console.log(&apos;Yup.&apos;); &#125;;&#125; 永远不要把参数命名为 arguments。这将取代原来函数作用域内的 arguments 对象。 不要使用 arguments。可以选择 rest 语法 … 替代。 直接给函数的参数指定默认值，不要使用一个变化的函数参数。 123function handleThings(opts = &#123;&#125;) &#123; // ...&#125; 直接给函数参数赋值时需要避免副作用。 箭头函数 当你必须使用函数表达式（或传递一个匿名函数）时，使用箭头函数符号。 123[1, 2, 3].map((x) =&gt; &#123; return x * x;&#125;); 如果一个函数适合用一行写出并且只有一个参数，那就把花括号、圆括号和 return 都省略掉。如果不是，那就不要省略。 Classes 和 Constructors 总是使用 class。避免直接操作 prototype 。 12345678910111213// goodclass Queue &#123; constructor(contents = []) &#123; this._queue = [...contents]; &#125; pop() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value; &#125;&#125;var demo = new Queue([1, 2, 3]);console.log(demo.pop()); // 1 使用 extends 继承。 12345678class PeekableQueue extends Queue &#123; constructor (args) &#123; super(args); &#125; peek() &#123; return this._queue[0]; &#125;&#125; 方法可以返回 this 来帮助链式调用。 123456789101112131415class Jedi &#123; jump() &#123; this.jumping = true; return this; &#125; setHeight(height) &#123; this.height = height; return this; &#125;&#125;const luke = new Jedi();luke.jump() .setHeight(20); 可以写一个自定义的 toString() 方法，但要确保它能正常运行并且不会引起副作用。 12345678910111213class Jedi &#123; constructor(options = &#123;&#125;) &#123; this.name = options.name || &apos;no name&apos;; &#125; getName() &#123; return this.name; &#125; toString() &#123; return `Jedi - $&#123;this.getName()&#125;`; &#125;&#125; 模块 总是使用模组 (import/export) 而不是其他非标准模块系统。 1234567// okimport AirbnbStyleGuide from &apos;./AirbnbStyleGuide&apos;;export default AirbnbStyleGuide.es6;// bestimport &#123; es6 &#125; from &apos;./AirbnbStyleGuide&apos;;export default es6; 不要使用通配符 import。 12345// badimport * as AirbnbStyleGuide from &apos;./AirbnbStyleGuide&apos;;// goodimport AirbnbStyleGuide from &apos;./AirbnbStyleGuide&apos;; 不要从 import 中直接 export。 12import &#123; es6 &#125; from &apos;./AirbnbStyleGuide&apos;;export default es6; Iterators &amp; Generators 不要使用 iterators。使用高阶函数例如 map() 和 reduce() 替代 for-of。12345678const numbers = [1, 2, 3, 4, 5];// goodlet sum = 0;numbers.forEach((num) =&gt; sum += num);// best (use the functional force)const sum = numbers.reduce((total, num) =&gt; total + num, 0); 属性 普通属性使用 . 来访问对象的属性。 当通过变量访问属性时使用中括号 []。变量 一直使用 const 来声明变量，如果不这样做就会产生全局变量。我们需要避免全局命名空间的污染。 单独声明每一个变量。 123const items = getItems();const goSportsTeam = true;const dragonball = &apos;z&apos;; 将所有的 const 和 let 分组。 在你需要的地方给变量赋值，但请把它们放在一个合理的位置。提升 var 声明会被提升至该作用域的顶部，但它们赋值不会提升。let 和 const 被赋予了一种称为「暂时性死区（Temporal Dead Zones, TDZ）」的概念。 匿名函数表达式的变量名会被提升，但函数内容并不会。 命名的函数表达式的变量名会被提升，但函数名和函数函数内容并不会。 函数声明的名称和函数体都会被提升。比较运算符 &amp; 等号 优先使用 === 和 !== 而不是 == 和 !=。 条件表达式例如 if 语句通过抽象方法 ToBoolean 强制计算它们的表达式并且总是遵守下面的规则对象 被计算为 trueUndefined 被计算为 falseNull 被计算为 false布尔值 被计算为 布尔的值数字 如果是 +0、-0、或 NaN 被计算为 false, 否则为 true字符串 如果是空字符串 ‘’ 被计算为 false，否则为 true 使用简写。代码块 使用大括号包裹所有的多行代码块。 如果通过 if 和 else 使用多行代码块，把 else 放在 if 代码块关闭括号的同一行。注释 使用 /* … / 作为多行注释。包含描述、指定所有参数和返回值的类型和值。配合 JSDoc 完美 使用 // 作为单行注释。在评论对象上面另起一行使用单行注释。在注释前插入空行。 给注释增加 FIXME 或 TODO 的前缀可以帮助其他开发者快速了解这是一个需要复查的问题，或是给需要实现的功能提供一个解决方式。这将有别于常见的注释，因为它们是可操作的。使用FIXME – need to figure this out 或者 TODO – need to implement。 使用 // FIXME: 标注问题。 123456class Calculator &#123; constructor() &#123; // FIXME: shouldn&apos;t use a global here total = 0; &#125;&#125; 使用 // TODO: 标注问题的解决方式。 123456class Calculator &#123; constructor() &#123; // TODO: total should be configurable by an options param this.total = 0; &#125;&#125; 空白 使用 2 个空格作为缩进。 在花括号前放一个空格。 在控制语句（if、while 等）的小括号前放一个空格。在函数调用及声明中，不在函数的参数列表前加空格。 使用空格把运算符隔开。 在文件末尾插入一个空行。 在使用长方法链时进行缩进。使用前面的点 . 强调这是方法调用而不是新语句。 在块末和新语句前插入空行。逗号 行首不要加逗号。 增加结尾的逗号: 需要。分号 每个语句都使用分号。 IIFE 函数前添加分号。12345// good (防止函数在两个 IIFE 合并时被当成一个参数);(() =&gt; &#123; const name = &apos;Skywalker&apos;; return name;&#125;)(); 类型转换 在语句开始时执行类型转换。 显式转换字符串。const reviewScore = 9;const totalScore = String(reviewScore); 对数字使用 parseInt 转换，并带上类型转换的基数。 123const val = Number(inputValue);const val = parseInt(inputValue, 10); 如果因为某些原因 parseInt 成为你所做的事的瓶颈而需要使用位操作解决性能问题时，留个注释说清楚原因和你的目的。 小心使用位操作运算符。数字会被当成 64 位值，但是位操作运算符总是返回 32 位的整数。位操作处理大于 32 位的整数值时还会导致意料之外的行为。 转换为buer。123const age = 0;const hasAge = Boolean(age);const hasAge = !!age; 命名规则 避免单字母命名。命名应具备描述性。 使用驼峰式命名对象、函数和实例。 使用帕斯卡（大驼峰）式命名构造函数或类。 使用下划线 _ 开头命名私有属性。 别保存 this 的引用。使用箭头函数或 Function#bind。 1234567891011function foo() &#123; return () =&gt; &#123; console.log(this); &#125;;&#125;function foo() &#123; return function() &#123; console.log(this); &#125;.bind(this)&#125; 如果你的文件只输出一个类，那你的文件名必须和类名完全保持一致。 1234567// file contentsclass CheckBox &#123; // ...&#125;export default CheckBox;import CheckBox from &apos;./CheckBox&apos;; 当你导出默认的函数时使用驼峰式命名。你的文件名必须和函数名完全保持一致。 当你导出单例、函数库、空对象时使用帕斯卡式命名。123456const AirbnbStyleGuide = &#123; es6: &#123; &#125;&#125;;export default AirbnbStyleGuide; 存取器 属性的存取函数不是必须的。 如果你需要存取函数时使用 getVal() 和 setVal(‘hello’)。 12dragon.getAge();dragon.setAge(25); 如果属性是布尔值，使用 isVal() 或 hasVal()。 创建 get() 和 set() 函数是可以的，但要保持一致。1234567891011121314class Jedi &#123; constructor(options = &#123;&#125;) &#123; const lightsaber = options.lightsaber || &apos;blue&apos;; this.set(&apos;lightsaber&apos;, lightsaber); &#125; set(key, val) &#123; this[key] = val; &#125; get(key) &#123; return this[key]; &#125;&#125; 事件 当给事件附加数据时（无论是 DOM 事件还是私有事件），传入一个哈希而不是原始值。这样可以让后面的贡献者增加更多数据到事件数据而无需找出并更新事件的每一个处理器。12345$(this).trigger(&apos;listingUpdated&apos;, &#123; listingId : listing.id &#125;);$(this).on(&apos;listingUpdated&apos;, function(e, data) &#123; // do something with data.listingId&#125;); Jquery 使用 $ 作为存储 jQuery 对象的变量名前缀。const $sidebar = $(‘.sidebar’); 缓存 jQuery 查询。 12345678function setSidebar() &#123; const $sidebar = $(&apos;.sidebar&apos;); $sidebar.hide(); $sidebar.css(&#123; &apos;background-color&apos;: &apos;pink&apos; &#125;);&#125; 对 DOM 查询使用层叠 $(‘.sidebar ul’) 或 父元素 &gt; 子元素 $(‘.sidebar &gt; ul’)。 对有作用域的 jQuery 对象查询使用 find。 参考文档：Airbnb JavaScript 代码规范（ES6）Airbnb JavaScript Style Guide]]></content>
      <categories>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Node.js-读书笔记]]></title>
    <url>%2F2017%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode-js-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8B%EF%BC%89.html</url>
    <content type="text"><![CDATA[构建Web应用基础功能常见的需求： 请求方法的判断（保存在报文）常见的方法有：GET(查看)\POST(更新)\DELETE(删除)\PUT(新建)\CONNECT\HEAD通过req.method 来判断 URL的路径解析（保存在报文）http://localhost:8080/a.html通过req.url 来查找 URL中查询字符串解析（保存在报文）?foo=bar&amp;baz=val使用Node提供的querystring 模块处理 Cookie的解析（保存在报文）网站为了辨别用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。http 为无状态协议。数据保存在客户端。 Session（会话）的需求（保存在报文）数据保存在服务器端。1.基于Cookie 来实现用户和数据的映射。 原理：在客户端只保存口令，发送请求是通过该口令再去查找对应的数据2.通过查询字符串来实现浏览器端和服务器端数据的对应。 不推荐使用，风险大。两种存储方式：1.内存2.数据工具 Redis是一个支持网络、基于内存、可选持久性的键值对存储数据库。 Basic认证（保存在报文）当客户端与服务端进行请求时，允许通过用户名和密码实现的一种身份认证方式。 数据上传思路：先判断数据的格式，再通过对应的解析方法解析。1.表单数据的解析先判断req.headers[‘content-type’] === ‘application/x-www-formurlencoded’ querystring.parse(req.rawBody);2.其他格式 json – application/json xml – application/xml 任意格式文件的上传处理此时需要 缓存YSlow中提出的缓存规则：1.添加Expires 和 Cache-Control 到报文头中。2.配置ETags。3.让Ajax 可缓存。数据上传与安全1.内存限制（提交数据占用了所有内存） 限制上传内容的大小，一旦超过限制，停止接收数据，并响应400状态码。 通过流式解析，将数据导向到磁盘中，Node只保留文件路径等小数据。2.CSRF Cross-Site Request Forgery（跨站点请求伪造） 路由解析文件路径型 静态文件：URL 的路径与网站目录的路径一致，无须转换。 动态文件：在 MVC 模式流行起来之前，根据文件路径执行动态脚本也是基本的路由方式， 它的处理原理是Web服务器根据URL路径找到对应的文件，如/index.asp或/index.php。 MVC MVC 模型的主要思想是将业务逻辑按职责分离。 控制器（Controller），一组行为的集合。 模型（Model），数据相关的操作和封装。 视图（View），视图的渲染。 1.路由解析，根据URL寻找到对应的控制器和行为。 2.行为调用相关的模型，进行数据操作。 3.数据操作结束后，调用视图和相关数据进行页面渲染，输出到客户端。 路由映射 1.手工映射 正则匹配 参数解析 2.自然映射 RESTful REST Representational State Transfer （表现层状态转化） POST /user/fanerge 修改用户信息 DELETE /user/fanerge 删除用户 PUT /user/fanerge 新建用户 GET /user/fanerge 查询用户信息 请求方法 中间件作用：middleware 来简化和隔离这些基础设施与业务逻辑之间的细节，使开发者更加关注在业务的开发。 中间件设计格式（connect的设计） 1234var querystring = function (req, res, next) &#123; // TODO next();&#125; 使用中间件（串联多个中间件） 123app.use(&apos;/user/:username&apos;, querystring, cookie, session, function (req, res) &#123; // 这里处理具体的业务逻辑&#125;); 异常处理 同步异常 -- try {} catch (err) {throw err} 异步异常 需要把异常传递出来 domain 模块 页面渲染内容响应 Content-Encoding: gzip Content-Length: 21170 Content-Type: text/javascript; charset=utf-8 MIME : Multipurpose Internet Mail Extensions 附件下载：有些MIME类的资源不需要在客户端中打开它，只需要弹出并下载它即可。 Content-Disposition: inline(查看)/attachment(附件下载); 例如：Content-Disposition: attachment; filename=&apos;filename.ext&apos;; // 下载附件并为其命名 响应JSON 响应跳转 视图渲染 模板 如EJS、Pug等 模板引擎 语法分解。 处理表达式。 生成待执行的语句。 与数据一起执行，生成最终字符串。 with的应用 模板安全 XSS 解决方案 转义用户的输入 模板逻辑 集成文件系统 子模板 布局视图 模板性能 Bigpipe BigPipe是一个重新设计的基础动态网页服务体系。 前端加载技术，它的提出主要是为了解决重数据页面的加载问题。 Bigpipe 的解决思路则是将页面分割成多个部分（pagelet）， 先向用户输出没有数据（框架），将每个部分逐步输出到前端， 再最终渲染填充框架，完成整个网页的渲染。 这个过程中需要前端js的参与，它负责将后续输出的数据渲染到页面上。 1.页面布局框架（无数据的）。 2.后端持续性的数据输出。 3.前端渲染。 bigpipe.ready() -- 以一个key注册一个事件。 bigpipe.set() -- 触发一个事件，进行页面渲染。 玩转进程多进程架构child_process 模块 创建子进程 1.spawn(): 启动一个子进程来执行命令。 2.exec(): 启动一个子进程来执行命令，与spawn()不同的是其接口不同， 它有一个回调函数获知子进程的状况。 3.execFile(): 启动一个子进程来执行可执行文件。 4.fork(): 与spawn()类似，不同点在于它创建Node的子进程只需指定要执行的Javascript文件模块即可。 spawn()与exec()、execFile()不同的是，后两者创建时可以指定timeout属性设置超时时间， 一旦创建的进程运行超过设定的时间将会被杀死。 exec()与execFile()不同的是，exec()适合执行已有的命令，execFile()适合执行文件。 进程间通信 message事件 绑定发送事件 send()方法 触发发送消息 句柄传递 child_process.send(message, [sendHandle]); 句柄是一种可以用来标识资源的引用，它的内部包含了指向对象的文件描述符。 比如句柄可以用来标识一个服务器端socket对象、客户端socket对象、UDP套接字、一个管道等。 集群稳定之路进程事件 message error exit close disconnect 自动重启 自杀信号 负载均衡（轮叫调度） 由主进程接受链接，将其依次分发给工作进程。 cluster 模块 状态共享 第三方数据存储 通过轮询 主动通知 当数据更新时，主动通知子进程。 Cluster 模块解决多核CPU的利用率问题。 Cluster 工作原理 该模块是 child_process 和 net 模块的组合应用。 Cluster 事件 fork online listening disconnect exit setup 测试测试驱动开发 单元测试测试代码编写的原则 1.单一职责 2.接口抽象 3.层次分离 单元测试介绍 1.断言 assert 模块 单元测试中用来保证最小单元是否正常的检测方法。 用于检查程序在运行时是否满足期望。 ok(): 判断结果是否为真。 equal(): 判断实际值余期望值是否相等。 notEqual(): 判断实际值与期望值是否不相等。 deepEqual(): 判断实际值余期望值是否深度相等（对象和数组的元素是否相等）。 notDeepEqual(): 判断实际值与期望值是否不深度相等。 strictEqual(): 判断实际值与期望值是否严格相等（===）。 notStrictEqual(): 判断实际值与期望值是否不严格相等（!==）。 throws(): 判断代码块是否抛出异常。 doesNotThrow(): 判断代码块是否没有抛出异常。 ifError(): 判断实际值是否为一个假值（null、undefined、0、&apos;&apos;、false），若实际值为真值，将抛出异常。 2.测试框架 用于管理测试用例和生成测试报告。 mocha 模块 测试风格 TDD 测试驱动开发 BDD 行为驱动开发 测试报告 mocha --reporters 测试代码的文件组织 测试用例 异步测试 测试覆盖率 mock 或者 muk 私有方法的测试 var lib = rewire(&apos;../lib/index.js&apos;); // 需要测试方法所在的文件 var litmit = lib.__get__(&apos;limit&apos;); // 需要测试的方法 3.工程化与自动化 工程化 -- Makefile 持续集成 -- travis-ci 性能测试负载测试、压力测试和基准测试。 基准测试：（对基本的方法如Array.protoryp.map 和 for循环的比较） benchmark 模块 压力测试：（网络接口进行压力测试） 常用的工具：ab、siege、http_load 基准测试驱动开发 1.写基准测试 2.写/改代码 3.收集数据 4.找出问题 5.回到第（2）步 测试数据余业务数据的转换 PV访问量（Page View），即页面访问量，每打开一次页面PV计数+1，刷新页面也是。 UV访问数（Unique Visitor）指独立访客访问数，一台电脑终端为一个访客。 TPS 是每秒内的事务数，比如执行了dml操作，那么相应的tps会增加； QPS 是指每秒内查询次数，比如执行了select操作，相应的qps会增加。 QPS = PV/H (H为访问量集中的时间单位小时)。 产品化包括：工程化、架构、容灾备份、部署和运维。 项目工程化1.目录结构 Web框架：Express、Koa、Egg 2.构建工具 合并静态文件、压缩文件大小、打包应用、编译模块。 Makefile 一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中， makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译， 哪些文件需要重新编译，甚至于进行更复杂的功能操作， 因为 makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。 Grunt 3.编码规范 JSLint JSHint ESLint 4.代码审查 部署流程部署环境 部署操作 性能动静分离 静态请求用 Nginx 和 CDN 来保存 启用缓存 Redis 和 Memcached 多进程架构 读写分离 日志访问日志 异常日志 日志与数据库 分割日志 监控报警业务逻辑型监控 和 硬件型监控 监控 日志监控 响应时间 进程监控 磁盘监控 内存监控 CPU占用监控 CPU load监控 I/O负载 网络监控 应用状态监控 DNS 监控 -- 免费DNS监控服务 DNSPod 报警的实现 邮件报警 -- nodemailer 模块 短信或电话报警 监控系统的稳定性 稳定性多机器 多机房 容灾备份 异构共存调试NodeDebugger 1.在代码中插入 debugger 2.运行 node debug demo.js Node Inspector 1.安装 npm install -g node-inspector 2.错误堆栈 Node 编码规范编码规范1.空格与格式 -- 采用2个空格缩进，而不是tab缩进。 2.变量声明 -- 每个变量声明都应该带var。 3.空格 -- 操作符前后加空格，如+、-、*、%、/、=等 4.单双引号的问题 -- 只在html标签的属性中使用双引号，其余使用单引号。 但在JSON中，严格的规范是要求使用字符串使用双引号，内容中出现双引号时需要转义。 5.大括号的位置 -- 不需要另起一行 6.逗号 -- 若逗号不在行结尾，前面需要一个空格。 7.分号 -- 给表达式结尾添加分号。 命名规范1.变量命名 -- 小驼峰式命名。 2.方法命名 -- 小驼峰式命名，尽量采用动词或判断词汇。 12var getUser = () =&gt; &#123;&#125;;var isAdmin = () =&gt; &#123;&#125;; 3.类命名（构造函数和Class） -- 大驼峰式命名。 4.常量命名 -- 全大写字母和下划线。 1var PINK_COLOR = &apos;pink&apos;; 5.文件命名 -- 全小写字母和下划线。 12child_process.js // 普通文件_linklist.js // 私有文件 6.包名 -- 不要包含 js 或 node 的字样，它们是重复的。 比较操作1.使用 === 替代 == 2.当遇到 0、undefined、null、false、&apos;&apos;假值时，不需要使用 === 或 ==。 字面量尽量使用 {}、[]，不要使用 new Object() 和 new Array() 作用域1.慎用with 1234with (obj) &#123; foo = bar;&#125;// 出现4中结果：obj.foo = obj.bar; obj.foo = bar; foo = obj.bar; foo = bar; 2.慎用eval() 数组与对象1.字面量格式 -- 结尾用逗号分隔，若分行，一行只能一个元素。 2.for in 循环 -- 只能对对象使用，不能对数组使用。 for in语句以任意顺序遍历一个对象的可枚举属性（包括原型上的属性）。 3.不要把数组当对象使用 异步1.异步回调函数的第一个参数应该是错误指示 2.执行传入的回调函数 类与模块1.类继承（Node推荐的类继承方式） 1234function Socket (options) &#123; stream.Stream.call(this);&#125;util.inherits(Socket, stream.Stream); 2.导出 -- 所有供外部调用的方法或变量均需要挂载在exports变量上。 当需要将文件当做一个类导出时，需要通过如下方式挂载。 1module.exports = Class; 注解规范采用 JSDoc 最佳实践1.冲突的解决原则 -- 入乡随俗 2.给编辑器设置检测工具 3.版本控制中的hook 4.持续集成 搭建局域NPM仓库 参考文档 朴灵-深入浅出Node]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object的扩展、密密封、冻结]]></title>
    <url>%2F2017%2FObject%E7%9A%84%E6%89%A9%E5%B1%95%E3%80%81%E5%AF%86%E5%AF%86%E5%B0%81%E3%80%81%E5%86%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[扩展特性Object.isExtensible(obj) 判断一个对象是可扩展(是否能有新的属性添加到它)。 Object.preventExtensions(obj) 可以对对象的属性进行修改和删除，不能向自身添加属性但可以向其原型添加属性。 示例： 123456789101112// Object.create(proto[, propertiesObject]);var obj = &#123; a: 1, b: 2&#125;;console.log(Object.isExtensible(obj)); // trueObject.preventExtensions(obj);console.log(Object.isExtensible(obj)); // false// obj.a = 3; // 可以修改原有属性// delete obj.a; // 可以删除原有属性// obj.c = 3; // 不能自身添加属性 console.log(obj); 密封特性Object.isSealed() 判断一个对象是密封的。 Object.seal() 密封对象是指那些不能添加新的属性，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性，但可能可以修改已有属性的值的对象。 属性不可配置的效果就是属性变的不可删除，以及一个数据属性不能被重新定义成为访问器属性。 将所有现有的属性标记为不可配置。现在的属性的值仍然可以改变,只要它们是可写的。 示例： 12345678910111213141516171819202122232425var obj = &#123; prop: function() &#123;&#125;, foo: &apos;bar&apos;&#125;;var o = Object.seal(obj);console.log(o === obj); // trueObject.isSealed(obj); // === trueobj.foo = &apos;quux&apos;; // 可以改变属性// 不能改变属性访问器，会抛出错误Object.defineProperty(obj, &apos;foo&apos;, &#123; get: function() &#123; return &apos;g&apos;; &#125;&#125;); // throws a TypeError// 不能添加新属性obj.quaxxor = &apos;the friendly duck&apos;;// 不能删除原有属性delete obj.foo;// 可以更改属性，只要它是可写的Object.defineProperty(obj, &apos;foo&apos;, &#123; value: &apos;eit&apos;&#125;); 冻结特性Object.isFrozen() Object.freeze() 防止新的属性被添加到它;防止现有的属性被移除; 和防止现有的属性,或他们的可数性,可配置性,或可写性,被改变了,它还可以防止原型被改变了。 该方法返回对象处于冻结状态。 示例： 1234567891011121314151617181920212223242526var obj = &#123; prop: function() &#123;&#125;, foo: &apos;bar&apos;&#125;;// 返回已被冻结的对象var o = Object.freeze(obj);// o === obj; // trueObject.isFrozen(obj); // === true// 改变原有属性失败obj.foo = &apos;quux&apos;; // silently does nothing// 添加属性失败obj.quaxxor = &apos;the friendly duck&apos;;// 删除原有属性失败delete obj.foo; // throws a TypeErrorconsole.log(obj);// 重新配置原有属性失败Object.defineProperty(obj, &apos;ohai&apos;, &#123; value: 17 &#125;);Object.defineProperty(obj, &apos;foo&apos;, &#123; value: &apos;eit&apos; &#125;);// 向原型中添加属性失败Object.setPrototypeOf(obj, &#123; x: 20 &#125;)obj.__proto__ = &#123; x: 20 &#125; 浅冻结与深冻结如该方法 MDN 的描述所述，倘若一个对象的属性是一个对象， 那么对这个外部对象进行冻结，内部对象的属性是依旧可以改变的，这就叫浅冻结， 若把外部对象冻结的同时把其所有内部对象甚至是内部的内部无限延伸的对象属性也冻结了，这就叫深冻结。 12345678910111213141516171819202122232425(function () &#123; obj = &#123; internal :&#123;&#125; &#125;; Object.freeze(obj);//浅冻结 obj.internal.a = &quot;aValue&quot;; console.log(obj.internal.a);//&quot;aValue&quot; //想让一个对象变得完全冻结,冻结所有对象中的对象,可以使用下面的函数. function deepFreeze(o)&#123; var prop,propKey; Object.freeze(o);//首先冻结第一层对象 for(propKey in o)&#123; prop = o[propKey]; if(!o.hasOwnProperty(propKey) || !(typeof prop === &quot;object&quot;) || Object.isFrozen(prop))&#123; continue; &#125; deepFreeze(prop);//递归 &#125; &#125; deepFreeze(obj); obj.internal.b = &quot;bValue&quot;;//静默失败 console.log(obj.internal.b);//undefined&#125;)(); 参考文档： 浅谈 JS 对象之扩展、密封及冻结三大特性 MDN]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Node.js-读书笔记]]></title>
    <url>%2F2017%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode-js-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8A%EF%BC%89.html</url>
    <content type="text"><![CDATA[最近在研究node.js,正赶上国庆长假，回趟老家。在网上找了一本电子书籍《深入浅出Node.js》，利用这个假期学习一下。 Node.js 基础知识chrome 与 Node 工作原理chrome：HTML + JavaScript + WebKit + V8 &gt;&gt; 中间层 &gt;&gt; 网卡 + 硬盘 + 显卡 + ... Node：JavaScript + V8 &gt;&gt; 中间层（libuv）&gt;&gt; 网卡 + 硬盘 + 显卡 + ... 说明：libuv 是 Node 的新跨平台抽象层，用于抽象 Windows 的 IOCP 及 Unix 的 libev。 作者打算在这个库的包含所有平台的差异性。 异步I/O123$.get(&apos;url&apos;, (data) =&gt; &#123; console.log(data);&#125;); 异步是并行的基础。 单线程，不适合大量计算占用 CPU 导致无法继续调用异步I/O。 模块机制CommonJS 规范模块引用： var math = require(&apos;math&apos;); 模块定义： exports.add = () =&gt; { var a = 1, b = 3; return a + b; } exports 是 module 的属性。 Node 引入模块的步骤： 路径分析 文件定位 编译执行 核心模块文件模块 &gt;&gt; 核心模块（JavaScript） &gt;&gt; 内建模块（C/C++） 异步I/ONode 的异步I/ONode 自身的执行模型 -- 事件循环。 单线程、事件循环、观察者和I/O线程池 非I/O的异步API定时器：setTimeout()\setInterval() process.nextTick() 在事件循环的下一次循环中调用 callback 回调函数。 效果是将一个函数推迟到代码书写的下一个同步方法执行完毕时或异步方法的事件回调函数开始执行时； 与setTimeout(fn, 0) 函数的功能类似，但它的效率高多了。 setImmediate() nextTick()的回调函数执行的优先级要高于setImmediate(); process.nextTick()属于idle观察者,setImmediate()属于check观察者.在每一轮循环检查中,idle观察者先于I/O观察者, I/O观察者先于check观察者. 异步编程函数式编程高阶函数：以函数作为参数或返回值。 偏函数用法：通过指定部分参数来产生一个新的定制函数的形式就是偏函数。 123456const isType = function (type)&#123; return function (obj) &#123; return Object.prototype.toString.call(obj) == &apos;[object &apos; + type + &apos;]&apos;; &#125;; &#125;var isString = isType(&apos;String&apos;); 异步编程解决方案事件发布/订阅模式（事件绑定） promise generator async-await 并发方案eventproxy [async](https://github.com/caolan/async) 内存控制理解BufferBuffer 是一个像Array的对象，但它主要用于操作字节。 Buffer 对象 var buf = new Buffer(&apos;string&apos;, &apos;utf-8&apos;); Buffer 的转换 支持的字符串编码类型： ASCII\UTF-8\UTF-16LE/UCS-2\Base64\Binary\Hex 字符串转 Buffer 12var buf = new Buffer(str, [encoding]);buf.write(string, [offset], [length], [encoding]); Buffer 转字符串 buf.toString([encoding], [start], [end]); 网络编程TCP 和 UDP 属于网络传输层协议，HTTP 属于应用层协议。 TCP（传输控制协议）创建TCP 服务器端 net 模块 TCP 服务的事件 构建UDP 服务（用户数据包协议）创建UDP套接字 dgram模块 创建UDP 服务器端 创建UDP 客户端 UDP 套接字事件 构建HTTP 服务HTTP 超文本传输协议。 http 模块 HTTP 客户端 构建WebSocket 服务以前的方案：Comet（彗星）技术细节为：长轮询（long-polling）或iframe流（streaming）。 长轮询原理：客户端向服务器断发送请求，服务端只在超时或有数据响应时断开连接（res.end()）， 客户端在接收到数据或者超时后重新发送请求。 iframe流原理：iframe 是很早就存在的一种 HTML 标记， 通过在 HTML 页面里嵌入一个隐蔵帧， 然后将这个隐蔵帧的 SRC 属性设为对一个长连接的请求，服务器端就能源源不断地往客户端输入数据。 通过iframe里的内容进行长时间的请求，当需要传输内容时通过调用父页面js方法来实现页面展示，以此达到comet所需要的效果。 WebSocket原理：WebSocket是一种在单个TCP连接上进行全双工通讯的协议。 WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中， 浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 网络服务与安全Node在网络安全上提供了3个模块 crypto – 主要用于加密和解密，SHA1、MD5。 tls – 类似于net模块，它是建立在TLS/SSL加密的TCP连接上。 https – 类似于http模块，他它是建立于安全的连接之上。TLS/SSLTLS/SSL是一个公钥/私钥的结构，它是一个非对称的结构。每个服务器断和客户端都有自己的公私钥。公钥要来加密要传输的数据，私钥用来解密接收到的数据。Node在底层采用的是openssl实现TLS/SSL。数字证书：CA（Certificate Authority，数字证书认证中心）HTTPS服务HTTPS服务就是工作在TLS/SSL上的HTTP。 参考文档朴灵-深入浅出Node]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa学习-总结]]></title>
    <url>%2F2017%2Fkoa%E5%AD%A6%E4%B9%A0-%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[一个koa示例123456789const koa = require(&apos;koa&apos;);const app = new koa();// 使用中间件app.use(); // @param function// 监听端口，开启服务app.listen(1314, () =&gt; &#123; console.log(&apos;success&apos;);&#125;); Context 对象Koa 提供一个 Context 对象，表示一次对话的上下文（包括 HTTP 请求和 HTTP 回复）。 koa 通过 ctx.request.accepts 设置期望返回的类型内容，默认为 text/plain。 koa 通过 ctx.response.type 指定返回类型。 示例：常用的格式xml、json、html、text等。 123456789101112 app.use((ctx) =&gt; &#123; if (ctx.request.accepts(&apos;xml&apos;)) &#123; ctx.response.type = &apos;xml&apos;; ctx.response.body = &apos;&lt;data&gt;我是xml&lt;/data&gt;&apos;; &#125; else &#123; ctx.response.type = &apos;text&apos;; ctx.response.body = &apos;我是text&apos;; &#125; &#125;); ``` 示例：实际开发（网页模板） 直接返回template.html app.use(ctx =&gt; { ctx.response.type = &apos;html&apos;; ctx.response.body = fs.createReadStream(&apos;./views/template.html&apos;); }); 123## 路由 通过ctx.request.path可以获取用户请求的路径，由此实现简单的路由。### 原生路由 const main = ctx =&gt; { ctx.response.type = &apos;html&apos;; if (ctx.request.path === &apos;/&apos;) { ctx.response.body = &apos;&lt;a href=&quot;/&quot;&gt;Index Page&lt;/a&gt;&apos;; } else if (ctx.request.path === &apos;/get&apos;) { ctx.response.body = &apos;&lt;a href=&quot;/&quot;&gt;Get Page&lt;/a&gt;&apos;; } else { ctx.response.body = &apos;&lt;a href=&quot;/&quot;&gt;other Page&lt;/a&gt;&apos;; } }; 1### koa-route 模块 const Koa = require(&apos;koa&apos;); const route = require(&apos;koa-route&apos;); const app = new Koa(); const about = ctx =&gt; { ctx.response.type = &apos;html&apos;; ctx.response.body = &apos;&lt;p&gt;about page&lt;/p&gt;&apos; }; const user = ctx =&gt; { ctx.response.type = &apos;html&apos;; ctx.response.body = &apos;&lt;p&gt;user page&lt;/p&gt;&apos; }; const main = ctx =&gt; { ctx.response.type = &apos;html&apos;; ctx.response.body = &apos;hello world&apos; }; app.use(route.get(&apos;/&apos;, main)); // 主页 app.use(route.get(&apos;/about&apos;, about)); // about页面 app.use(route.get(&apos;/user&apos;, user)); // user页面 // app.use(main); app.listen(3000); 12345## 静态资源 和 重定向### 静态资源 如果网站提供静态资源（图片、字体、样式表、脚本......）。 koa-static 模块封装了这部分的请求。 示例：请求本地12.js const Koa = require(&apos;koa&apos;); const app = new Koa(); const path = require(&apos;path&apos;); const serve = require(&apos;koa-static&apos;); const main = serve(path.join(__dirname)); app.use(main); app.listen(3000); 123456 说明：__dirname 表示 node.js 执行环境路径。 请求资源： http://127.0.0.1:3000/12.js### 重定向 有些场合，服务器需要重定向（redirect）访问请求。 比如，用户登陆以后，将他重定向到登陆前的页面。 ctx.response.redirect()方法可以发出一个302跳转，将用户导向另一个路由。 const redirect = ctx =&gt; { ctx.response.redirect(&apos;/&apos;); }; const main = ctx =&gt; { ctx.response.body = &apos;Hello World&apos;; }; app.use(route.get(&apos;/&apos;, main)); app.use(route.get(&apos;/redirect&apos;, redirect)); // 当请求路径为 /redirect 时，执行 redirect 方法，进行重定向 12345 访问 http://127.0.0.1:3000/redirect ，浏览器会将用户导向根路由。## 中间件### 设计中间件 Koa 的最大特色，也是最重要的一个设计，就是中间件（middleware）。 示例：自己设计一个logger中间件。 /** * 定义日志中间件 logger * @param ctx {object} 上下文对象 * @param next {function} 下一个中间件执行权 */ const logger = (ctx, next) =&gt; { console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`); next(); // 只要调用next函数，就可以把执行权转交给下一个中间件。 }; // 使用中间件 app.use(logger); 12### 中间件特性 多个中间件会形成一个栈结构（middle stack），以&quot;先进后出&quot;（first-in-last-out）的顺序执行。 const one = (ctx, next) =&gt; { console.log(&apos;&gt;&gt; one&apos;); next(); console.log(&apos;&lt;&lt; one&apos;); } const two = (ctx, next) =&gt; { console.log(&apos;&gt;&gt; two&apos;); next(); console.log(&apos;&lt;&lt; two&apos;); } const three = (ctx, next) =&gt; { console.log(&apos;&gt;&gt; three&apos;); next(); console.log(&apos;&lt;&lt; three&apos;); } app.use(one); app.use(two); app.use(three); 12345678910 输出： &gt;&gt; one // one中间件进栈 &gt;&gt; two // two中间件进栈 &gt;&gt; three // three中间件进栈 &lt;&lt; three // three中间件 出栈 &lt;&lt; two // two中间件 出栈 &lt;&lt; one // one中间件 出栈 ### 异步中间件 如果有异步操作（比如读取数据库），中间件就必须写成 async 函数。 实例：异步 main 中间件 const fs = require(&apos;fs.promised&apos;); const main = async function (ctx, next) { ctx.response.type = &apos;html&apos;; ctx.response.body = await fs.readFile(&apos;./demos/template.html&apos;, &apos;utf8&apos;); }; 123 fs.readFile是一个异步操作，必须写成异步中间件。### koa-compose模块可以将多个中间件合成为一个。 示例：合并 logger 和 main 中间件。 const compose = require(&apos;koa-compose&apos;); const middlewares = compose([logger, main]); app.use(middlewares); 12345## 错误处理 如果代码运行过程中发生错误，我们需要把错误信息返回给用户。### 500错误 HTTP 协定约定这时要返回500状态码。 Koa 提供了ctx.throw()方法，用来抛出错误，ctx.throw(500)就是抛出500错误。 const main = ctx =&gt; { ctx.throw(500); }; 12### 404错误 如果将ctx.response.status设置成404，就相当于ctx.throw(404)，返回404错误。 const main = ctx =&gt; { ctx.response.status = 404; // ctx.throw(404); ctx.response.body = &apos;Page Not Found&apos;; }; 123### 处理错误的中间件 为了方便处理错误，最好使用try...catch将其捕获。 但是，为每个中间件都写try...catch太麻烦，我们可以让最外层的中间件，负责所有中间件的错误处理。 // 最外层中间件 const handler = async (ctx, next) =&gt; { try { await next(); } catch (err) { ctx.response.status = err.statusCode || err.status || 500; ctx.response.body = { message: err.message }; } }; // 内层中间件 const main = ctx =&gt; { ctx.throw(404); }; 123### error 事件的监听 运行过程中一旦出错，Koa 会触发一个error事件。 监听这个事件，也可以处理错误。 const main = ctx =&gt; { ctx.throw(500); // 直接触发错误 }; // 监听错误 app.on(&apos;error&apos;, (err, ctx) =&gt; { console.error(&apos;server error&apos;, err); }); 123### 释放 error 事件 需要注意的是，如果错误被try...catch捕获，就不会触发error事件。 这时，必须调用ctx.app.emit()，手动释放error事件，才能让监听函数生效。 const handler = async (ctx, next) =&gt; { try { await next(); } catch (err) { ctx.response.status = err.statusCode || err.status || 500; ctx.response.type = &apos;html&apos;; ctx.response.body = &apos;&lt;p&gt;Something wrong, please contact administrator.&lt;/p&gt;&apos;; ctx.app.emit(&apos;error&apos;, err, ctx); } }; const main = ctx =&gt; { ctx.throw(500); }; app.on(&apos;error&apos;, function(err) { console.log(&apos;logging error &apos;, err.message); console.log(err); }); 12345 main函数抛出错误，被handler函数捕获。 catch代码块里面使用ctx.app.emit()手动释放error事件，才能让监听函数监听到。## Web App 的功能### Cookies ctx.cookies 用来读写 Cookie。 const main = function(ctx) { const n = Number(ctx.cookies.get(&apos;view&apos;) || 0) + 1; ctx.cookies.set(&apos;view&apos;, n); ctx.response.body = n + &apos; views&apos;; } 1234### 表单 Web 应用离不开处理表单。 表单就是 POST 方法发送到服务器的键值对。 koa-body模块可以用来从 POST 请求的数据体里面提取键值对。 const koaBody = require(&apos;koa-body&apos;); const main = async function (ctx) { const body = ctx.request.body; if (!body.name) ctx.throw(400, &apos;.name required&apos;); ctx.body = { name: body.name }; }; app.use(koaBody()); 12### 文件上传 koa-body模块还可以用来处理文件上传。 const os = require(&apos;os&apos;); const path = require(&apos;path&apos;); const koaBody = require(&apos;koa-body&apos;); const main = async function(ctx) { const tmpdir = os.tmpdir(); const filePaths = []; const files = ctx.request.body.files || {}; for (let key in files) { const file = files[key]; const filePath = path.join(tmpdir, file.name); const reader = fs.createReadStream(file.path); const writer = fs.createWriteStream(filePath); reader.pipe(writer); filePaths.push(filePath); } ctx.body = filePaths; }; app.use(koaBody({ multipart: true })); ``` 参考文档： 阮一峰老师的koa教程 koa-router官方文档]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsDoc学习-标签总结]]></title>
    <url>%2F2017%2FjsDoc%E5%AD%A6%E4%B9%A0-5.html</url>
    <content type="text"><![CDATA[类和构造函数@class -- 此函数旨在需要使用”new”关键字调用（构造函数）或ES6中class。 @constructor @classdesc -- 使用的后面的蚊子来描述整个类。 @abstract -- 这个成员必须在继承的子类中重写。 @virtual @static -- 记录一个静态成员。 @access -- 指定该成员的访问级别（私有private、保护protected、公共public）。 @access private 等价于 @private @access protected 等价于 @protected @access public 等价于 @public @alias -- 标记成员有一个别名。 @extends -- 指名这个子类继承至哪个父类，后面需要加父类名。 @augments @instance -- 记录一个实例成员。 @interface -- 这是别人可以实现的一个接口。 对象@borrows -- 这个对象使用另一个对象的某些东西。 @lends -- 将一个字面量对象的所有属性标记为某个标识符（类或模块）的成员。 @mixes -- 此对象混入了另一个对象中的所有成员。 @mixin -- 记录一个mixin（混入）对象。 @name -- 记录一个对象的名称。 @namespace -- 记录一个命名空间对象。 @property -- 记录一个对象的属性。 @prop @typedef -- 记录一个自定义的类型。 @type -- 记录一个对象的类型。 @variation -- 区分具有相同名称的不同的对象。 方法@callback -- 描述一个回调函数。 @function -- 描述一个函数或方法。 @func @method @returns -- 记录一个函数的返回值。 @return @this -- this关键字的指向。 说明@author -- 指定项目的作者。 @constant -- 记录一个对象作为一个常量。 @const @default -- 记录默认值。 @defaultvalue @copyright -- 描述一些版权信息。 @since -- 该方法添加于该版本，建议使用。 @deprecated -- 该方法已弃用，不建议使用。 @description -- 描述一个标识。 @desc @enum -- 描述一个相关属性的集合。 @example -- 提供一个如何使用描述项的例子。 @external -- 标识一个外部的类，命名空间，或模块。 @file -- 描述一个文件。 @fileoverview @overview @global -- 记录一个全局对象。 @ignore -- 忽略文档中的一个标识。 @implements -- 这个表示实现一个接口。 @inheritdoc -- 指明这个标识应继承其父类的文档。 @inner -- 描述一个内部对象。 @kind -- 表示的类型。 @license -- 表示你的代码采用何种软件许可协议。 @member -- 记录一个成员。 @var @memberof -- 标明这个标识属于哪个父级标识。 @override -- 指明一个标识符覆盖其父类同名的标识符。 @param -- 记录传递给一个函数的参数。 @arg @argument @readonly -- 标记为只读的。 @see -- 更多详细参阅其他一些文档。 @summary -- 完整描述的一个简写版本。 @throws -- 说明可能会被抛出什么样的错误。 @todo -- 记录一个将要完成的任务。 @tutorial -- 插入一个连接到包含教程文件。 @version -- 记录版本信息。 事件@event -- 描述一个事件。 @listens -- 列出一个标识的监听事件。 @fires -- 描述事件这个方法可能会触发。 @emits 模块@exports -- 表示一个由javascript模块导出的成员。 @module -- 记录一个javascript模块。 @requires -- 这个文件需要一个javascript模块。 内联标签@link -- 连接到文档中的另一个项目。 @linkcode @linkplain @tutorial -- 链接到一个教程。 使用 安装jsdoc3npm install -g jsdoc 在cmd 中 (此时会在test.js的同级目录产出out目录，存放生成的API文档)jsdoc test.js 默认配置情况下out目录中产出：fonts、scripts、styles目录顾名思义。 index.html -- API文档首页 global.html -- 全局的（成员和方法） index.js.html -- 源代码页面 相关配置启用jsdoc有两种方式：命令行参数 和 conf.json配置JSDoc命令行参数 JSDoc命令行几个常用参数有以下几个： -c, –configure 指定configuration file -d, –destination 指定输出路径，默认./out -e, –encoding 设定encoding，默认utf8 -p, –private 将private注释输出到文档，默认不输出 -P, –package 指定package.json file -r, –recurse 查询子目录 -t, –template 指定输出文档template -u, –tutorials 指定教程路径，默认无 例如：jsdoc -T –match tag –verboseJSDoc配置文件 默认的配置文件：conf.json.EXAMPLE 123456789101112131415&#123; &quot;tags&quot;: &#123; &quot;allowUnknownTags&quot;: true, // 允许使用自定义tag &quot;dictionaries&quot;: [&quot;jsdoc&quot;,&quot;closure&quot;] // 定义tag集 &#125;, &quot;source&quot;: &#123; &quot;includePattern&quot;: &quot;.+\\.js(doc)?$&quot;, // 将以.js, .jsdoc结尾的文件作为源文件 &quot;excludePattern&quot;: &quot;(^|\\/|\\\\)_&quot; // 忽略以_开头的文件夹及文件 &#125;, &quot;plugins&quot;: [], &quot;templates&quot;: &#123; &quot;cleverLinks&quot;: false, &quot;monospaceLinks&quot;: false &#125;&#125; 例如：jsdoc -c /path/to/conf.json 参考文档： jsdoc jsdoc3 使用 JSDoc 3 自动生成 JavaScript API 文档]]></content>
      <categories>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsDoc学习-标签3]]></title>
    <url>%2F2017%2FjsDoc%E5%AD%A6%E4%B9%A0-4.html</url>
    <content type="text"><![CDATA[@override@override标签指明一个标识符覆盖其父类同名的标识符。 下面的例子说明一个方法如何重写父类的方法。 12345678910111213141516171819202122232425262728/** * @classdesc Abstract class representing a network connection. * @class */function Connection() &#123;&#125;/** * Open the connection. */Connection.prototype.open = function() &#123; // ...&#125;;/** * @classdesc Class representing a socket connection. * @class * @augments Connection */function Socket() &#123;&#125;/** * Open the socket. * @override */Socket.prototype.open = function() &#123; // ...&#125;; @param@param标签提供了对某个函数的参数的各项说明，包括参数名、参数数据类型、描述等。 别名：@arg @argument 下面的示例演示如何在 @param标签中包含名称，类型，和说明。 123456/** * @param somebody */function sayHello(somebody) &#123; alert(&apos;Hello &apos; + somebody);&#125; @private@private标签标记标识符为私有，或者不做一般用途使用。 私有成员不会在生成文档中输出任何内容，除非JSDoc使用 -p/--private 命令行选项运行。 语法：@private 在下面的例子中，Documents和Documents.Newspaper会被输出到生成的文档中，但是Documents.Diary不会。 123456789101112/** @namespace */var Documents = &#123; /** * An ordinary newspaper. */ Newspaper: 1, /** * My diary. * @private */ Diary: 2&#125;; @property@property标签很容易描述类，命名空间或其它对象的静态属性列表。 别名：@prop 例如，描述命名空间的默认属性及嵌套属性： 1234567891011121314151617/** * @namespace * @property &#123;object&#125; defaults - The default values for parties. * @property &#123;number&#125; defaults.players - The default number of players. * @property &#123;string&#125; defaults.level - The default level for the party. * @property &#123;object&#125; defaults.treasure - The default treasure. * @property &#123;number&#125; defaults.treasure.gold - How much gold the party starts with. */var config = &#123; defaults: &#123; players: 1, level: &apos;beginner&apos;, treasure: &#123; gold: 0 &#125; &#125;&#125;; @protected@protected标签标记标识符为受保护的，通常情况下，受保护的成员只能在被继承的子类中或在模块内部可以访问。 语法：@protected [{typeExpression}] 在下面的例子中，该实例成员Thingy#_bar会被导出到生成的文档中，但使用注释说明它是被保护的。 12345/** @constructor */function Thingy() &#123; /** @protected */ this._bar = 1;&#125; @public@public标签标记标识符为公开的。 12345678910111213/** * The Thingy class is available to all. * @public * @class */function Thingy() &#123; /** * The Thingy~foo member. Note that &apos;foo&apos; is still an inner member * of &apos;Thingy&apos;, in spite of the @public tag. * @public */ var foo = 0;&#125; @readonly标记一个标识符为只读。jsdoc不会检查某个代码是否真是只读的，只要标上@readonly，在文档中就体现为只读的。 例如，给getter标记为只读 12345678910111213/** * Options for ordering a delicious slice of pie. * @namespace */var pieOptions = &#123; /** * A la mode. * @readonly */ get aLaMode() &#123; return this.plain + &apos; with ice cream&apos;; &#125;&#125;; @requires@requires标签可以记录一个模块需要的依赖项。一个JSDoc注释块可以有多个@require标签。 模块名可以被指定为 &quot;moduleName&quot; 或者 &quot;module:moduleName&quot;;这两种形式将被解析为模块。 语法：@requires &lt;someModuleName&gt; 例如，使用@requires 标签 12345678/** * This class requires the modules &#123;@link module:xyzcorp/helper&#125; and * &#123;@link module:xyzcorp/helper.ShinyWidget#polish&#125;. * @class * @requires module:xyzcorp/helper * @requires xyzcorp/helper.ShinyWidget#polish */function Widgetizer() &#123;&#125; @returns@returns 标签描述一个函数的返回值。语法和@param类似。 别名：@return 返回值的类型 123456789/** * Returns the sum of a and b * @param &#123;Number&#125; a * @param &#123;Number&#125; b * @returns &#123;Number&#125; */function sum(a, b) &#123; return a + b;&#125; @see@see标签表示可以参考另一个标识符的说明文档，或者一个外部资源。 语法：@see &lt;namepath&gt; @see &lt;text&gt; 123456/** * Both of these will link to the bar function. * @see &#123;@link bar&#125; * @see bar */function foo() &#123;&#125; @since@since标签标明一个类，方法，或其它标识符是在哪个特定版本开始添加进来的。 语法：@since &lt;versionDescription&gt; 例如，使用@since标签： 12345/** * Provides access to user information. * @since 1.0.1 */function UserRecord() &#123;&#125; @static@static标签标明一个在父类中的标识符不需实例即可使用。 例如，在一个虚拟注释中使用@static 123456/** @namespace MyNamespace *//** * @function myFunction * @memberof MyNamespace * @static */ @summary@summary标签是完整描述的一个简写版本。它可以被添加到任何的doclet。 语法：@summary Summary goes here. 1234567/** * A very long, verbose, wordy, long-winded, tedious, verbacious, tautological, * profuse, expansive, enthusiastic, redundant, flowery, eloquent, articulate, * loquacious, garrulous, chatty, extended, babbling description. * @summary A concise summary. */function bloviate() &#123;&#125; @this@this标签指明this关键字的指向。 语法：@this &lt;namePath&gt; 在下面的例子中，@this标签迫使&quot;this.name&quot;被描述为&quot;Greeter#name&quot;，而不是全局变量&quot;name&quot;。 12345678910/** @constructor */function Greeter(name) &#123; setName.apply(this, name);&#125;/** @this Greeter */function setName(name) &#123; /** document me */ this.name = name;&#125; @throws@throws标签可以让你描述函数可能会抛出的错误。在一个JSDoc注释块中您可以包含多个@throws标签。 语法：@throws free-form description @throws {&lt;type&gt;} @throws {&lt;type&gt;} free-form description 例如，在type中使用@throws标签: 1234/** * @throws &#123;InvalidArgumentException&#125; */function foo(x) &#123;&#125; @todo@todo标签可以让你记录要完成的任务。在一个JSDoc注释块中您可以包含多个@todo标签。 语法：@todo text describing thing to do. 1234567/** * @todo Write the documentation. * @todo Implement this function. */function foo() &#123; // write me&#125; @tutorial@tutorial 标签插入一个指向向导教程的链接，作为文档的一部分。 语法：@tutorial &lt;tutorialID&gt; 在下面的例子中，MyClass的文档将链接到tutorial-1 和 tutorial-2标识符的教程。 1234567/** * Description * @class * @tutorial tutorial-1 * @tutorial tutorial-2 */function MyClass() &#123;&#125; @type@type标签允许你提供一个表达式，用于标识一个标识符可能包含的值的类型，或由函数返回值的类型。 语法：@type {typeName1 | typeName2} 1234/** @type &#123;(string|Array.&lt;string&gt;)&#125; */var foo;/** @type &#123;number&#125; */var bar = 1; @typedef@typedef标签在描述自定义类型时是很有用的，特别是如果你要反复引用它们的时候。 语法：@typedef [&lt;type&gt;] &lt;namepath&gt; 这个例子定义了一个联合类型的参数，表示可以包含数字或字符串。 1234/** * A number, or a string containing a number. * @typedef &#123;(number|string)&#125; NumberLike */ @variation描述: 区分具有相同名称的不同的对象。 语法：@variation &lt;variationNumber&gt; @version@version标签后面的文本将被用于表示该项的版本。 1234567/** * @version 1.2.3 * @tutorial solver */function solver(a, b) &#123; return b / a;&#125; 内联标签（inline Tags）{@link}内联标签创建一个链接到您指定的namepath或URL。当您使用{@link}标签，还可以提供几种不同的格式的链接文本。 如果你不提供任何链接文本，JSDoc使用namepath或URL作为链接文字。 别名：@linkcode @linkplain 语法：{@link namepathOrURL} [link text]{@link namepathOrURL} {@link namepathOrURL|link text} {@link namepathOrURL link text (after the first space)} 下面的例子显示了提供给{@link} 标签链接文本的所有方式 123456/** * See &#123;@link MyClass&#125; and [MyClass&apos;s foo property]&#123;@link MyClass#foo&#125;. * Also, check out &#123;@link http://www.google.com|Google&#125; and * &#123;@link https://github.com GitHub&#125;. */function myFunction() &#123;&#125; @tutorial{@tutorial}行内标签创建一个链接到您指定的教程标识符。当您使用{@tutorial}标签，您也可以提供几种不同的格式的链接文本。 如果你不提供任何链接文本，JSDoc使用本教程的标题作为链接文字。 语法：{@tutorial tutorialID} [link text]{@tutorial tutorialID} {@tutorial tutorialID|link text} {@tutorial tutorialID link text (after the first space)} 下面的例子显示了提供给{@tutorial}标签链接文本的所有方式 123456/** * See &#123;@tutorial gettingstarted&#125; and [Configuring the Dashboard]&#123;@tutorial dashboard&#125;. * For more information, see &#123;@tutorial create|Creating a Widget&#125; and * &#123;@tutorial destroy Destroying a Widget&#125;. */function myFunction() &#123;&#125; 参考文档： jsDoc文档]]></content>
      <categories>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsDoc学习-标签2]]></title>
    <url>%2F2017%2FjsDoc%E5%AD%A6%E4%B9%A0-3.html</url>
    <content type="text"><![CDATA[@file@file标签提供文件的说明。在文件开头的JSDoc注释部分使用该标签。 别名：@fileoverview @overview 例如，文件描述 1234/** * @file 这是正则js文件 * @author fanerge &lt;fanerge@example.com&gt; */ @fires@fires标签标明当一个方法被调用时将触发一个指定类型的事件，使用@event 标签来描述事件的内容。 别名：@emits 语法：@fires &lt;className&gt;#[event:]&lt;eventName&gt; 例如，方法将触发&quot;drain&quot;事件 1234567/** * Drink the milkshake. * @fires Milkshake#drain */Milkshake.prototype.drink = function() &#123; // ...&#125;; @function标记一个对象作为一个函数，即使它可能不会出现在解析器中。它设置doclet的@kind为&apos;function&apos;。 别名：@func @method 语法：@function [&lt;FunctionName&gt;] 例如，使用@function标记为一个函数 12/** @function */var paginate = paginateFactory(pages); global@global标签指定一个在文档的标识是为全局性的标识。 JSDoc忽略这个标识在源文件中的实际作用范围。这个标记是在本地所定义标识时特别有用。 例如，文档中的内部变量作为一个全局变量 123456(function() &#123; /** @global */ var foo = &apos;hello foo&apos;; this.foo = foo;&#125;).apply(window); @ignore@ignore标签表示在你的代码中的注释不应该出现在文档中，注释会被直接忽略。这个标签优先于所有其他标签。 在下面的例子中，@ignore标签， Jacket 和 Jacket#color 将不会出现在文档中 12345678/** * @class * @ignore */function Jacket() &#123; /** The jacket&apos;s color. */ this.color = null;&#125; @implements@implements标签指示一个标识实现一个接口。 语法：@implements {typeExpression} 在下面的例子中，TransparentColor类实现Color接口，并添加了TransparentColor#rgba方法。 @inheritdoc@inheritdoc标签指示该标识应继承其父类的文档。在你的JSDoc注释中的任何其它标签都将被忽略。 下面的例子显示了一个类的描述如何从它的父类继承文档。 12345678910111213141516171819202122232425/** * @classdesc Abstract class representing a network connection. * @class */function Connection() &#123;&#125;/** * Open the connection. */Connection.prototype.open = function() &#123; // ...&#125;;/** * @classdesc Class representing a socket connection. * @class * @augments Connection */function Socket() &#123;&#125;/** @inheritdoc */Socket.prototype.open = function() &#123; // ...&#125;; @inner使用@inner标签将标明该标识符作为它父标识符的内部成员。这意味着它可以通过 &quot;Parent~Child&quot; 被引用。 在下面的例子中，我们使用@inner迫使一个命名空间的成员被描述作为内部成员（默认情况下，这是一个静态成员）。 这意味着，foo现在有了MyNamespace~foo新名字，而不是MyNamespace.foo。 12345678/** @namespace */var MyNamespace = &#123; /** * foo is now MyNamespace~foo rather than MyNamespace.foo. * @inner */ foo: 1&#125;; @instance使用@instance标签标明该标识符作为它父标识符的实例成员。 这意味着它可以通过&quot;Parent#Child&quot;被引用。 例如，使用@instance确定一个实例成员 1234567891011121314/** @namespace */var BaseObject = &#123; /** * foo is now BaseObject#foo rather than BaseObject.foo. * @instance */ foo: null&#125;;/** Generates BaseObject instances. */function fooFactory(fooValue) &#123; var props = &#123; foo: fooValue &#125;; return Object.create(BaseObject, props);&#125; @interface@interface标签使一个标识符作为其他标识符的一个实现接口。 例如，你的代码可能定义一个父类，它的方法和属性被去掉。 您可以将@interface标签添加到父类，以指明子类必须实现父类的方法和属性。 语法：@interface [&lt;name&gt;] 在下面的例子中，Color函数表示其它类可以实现的接口。 1234567891011121314/** * Interface for classes that represent a color. * @interface */function Color() &#123;&#125;/** * Get the color as an array of red, green, and blue values, represented as * decimal numbers between 0 and 1. * @returns &#123;Array&amp;lt;number&gt;&#125; An array containing the red, green, and blue values, * in that order. */Color.prototype.rgb = function() &#123; throw new Error(&apos;not implemented&apos;);&#125;; @kind@kind标签是用来指明什么样的标识符被描述（例如，一类或模块）。标识符kind 不同于标识符type（例如，字符串或布尔）。 语法：@kind &lt;kindName&gt; kindName取值：class constant event external file function member mixin module namespace typedef 12345/** * A constant. * @kind constant */const asdf = 1; @lends@lends标签允许你将一个字面量对象的所有成员标记为某个标识符（类或模块）的成员，就像他们是给定名称的标识符成员。 你可能想这样做，如果你传递一个对象字面量给一个函数，创建一个成员为对象字面量的命名类。 语法：@lends &lt;namepath&gt; 实例，@lends标签告诉JSDoc，这一对象字面量的所有成员都会被“借”给&quot;Person&quot;类。 123456789101112/** @class */var Person = makeClass( /** @lends Person */ &#123; initialize: function(name) &#123; this.name = name; &#125;, say: function(message) &#123; return this.name + &quot; says: &quot; + message; &#125; &#125;); @license@license标签标识你的代码采用何种软件许可协议。 语法：@license &lt;identifier&gt; 例如，这是在Apache 2.0 许可下分发的模块 12345/** * Utility functions for the foo package. * @module foo/util * @license Apache-2.0 */ @listens@listens 标签指示一个标识监听指定的事件。使用@event 标签来记录事件的内容。 语法：@listens &lt;eventName&gt; 下面的示例演示了如何记录名为module:hurler~event:snowball的事件，还有一个方法命名为module:playground/monitor.reportThrowage来监听事件。 @member@member标签记录成员基本种类（kind），比如&quot;class&quot;, &quot;function&quot;, 或者 &quot;constant&quot;。 一个成员可以任选地具有一个类型以及名称。 别名：@var 语法：@member [&lt;type&gt;] [&lt;name&gt;] 例如，Data#point上使用@member： 12345/** @class */function Data() &#123; /** @member &#123;Object&#125; */ this.point = &#123;&#125;;&#125; @memberof@memberof标签标明成员隶属于哪一个父级标识符。 语法：@memberof &lt;parentNamepath&gt; @memberof! &lt;parentNamepath&gt; 事实上，它就是一个全局性的函数，但同事它也是Tools命名空间的一个成员，而这才是你想描述的。 12345678/** @namespace */var Tools = &#123;&#125;;/** @memberof Tools */var hammer = function() &#123;&#125;;Tools.hammer = hammer; @mixes@mixes标签指示当前对象混入了OtherObjectPath对象的所有成员,被混入的对象就是一个@mixin。 语法：@mixes &lt;OtherObjectPath&gt; @mixin您可以使用@mixin标签标识该对象是一个mixin（混入），旨在表明该对象的属性和方法混入到其他对象。 然后，可以将@mixes标签 添加到使用了该 mixin（混入）的对象上。 语法：@mixin [&lt;MixinName&gt;] @module@module可以将当前文件标注为一个模块，默认情况下文件内的所有标识符都隶属于此模块，除非文档另有说明。 @module [[{&lt;type&gt;}] &lt;moduleName&gt;] 下面的示例演示了在一个模块中用于标识的namepaths。第一个标识符是模块私有的，或“内部”变量 - 它只能在模块内访问。第二个标识符是由模块导出一个静态函数。 1234567/** @module myModule *//** will be module:myModule~foo */var foo = 1;/** will be module:myModule.bar */var bar = function() &#123;&#125;; @name@name标签强制JSDoc使用这个给定的名称，而忽略实际代码里的名称。 这个标签最好用于&quot;虚拟注释&quot;，而不是在代码中随时可见的标签，如在运行时期间产生的方法。 语法：@name &lt;namePath&gt; 下面的例子演示了如何使用@name标签描述一个函数，JSDoc通常不会识别。 1234567/** * @name highlightSearchTerm * @function * @global * @param &#123;string&#125; term - The search term to highlight. */eval(&quot;window.highlightSearchTerm = function(term) &#123;&#125;;&quot;) @namespace@namespace标签指明对象是一个命名空间。你也可以书写一个虚拟JSDoc注释，通过使用代码来定义命名空间。 语法：@namespace [{&lt;type&gt;}] &lt;SomeName&gt;] 例如，对象上使用 @namespace 标签： 12345678910/** * My namespace. * @namespace */var MyNamespace = &#123; /** documented as MyNamespace.foo */ foo: function() &#123;&#125;, /** documented as MyNamespace.bar */ bar: 1&#125;; 参考文档： jsDoc文档]]></content>
      <categories>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[postman]]></title>
    <url>%2F2017%2Fpostman.html</url>
    <content type="text"><![CDATA[虽然一直使用postman进行http相关的调试，但一直都停留在简单使用，并没有对其的深入学习。 现在比较全面的学习下post相关功能。 postman仪表盘布局分为左右两栏（sidebar + main） siderbar：Search + History + Collections main： 第一行：请求方式 + URL + Params + Send(Send and Download) + Save(Save as) 第二行(request)：Authorization + Headers + Body + Pre-request Script(请求发送前运行的脚本) + Tests + Code(转化为相应的语言请求代码) 第三行(response)：Body + Cookies + Headers + Tests + Status(响应状态) + Time(响应等待时间) 请求HTTP请求的4部分:URL，method，headers，body。 对于body说明： 1.mutipart/form-data：是网页表单用来传输数据的默认格式。（提交表单上传文件） 2.x-www-form-urlencoded：同前面一样，注意,你不能上传文件通过这个编码模式。 3.raw：raw request可以包含任何东西。所有填写的text都会随着请求发送。 4.binary：image, audio or video files.text files 。 也不能保存历史，每次选择文件，提交。 身份验证Authentication： 1.Basic Auth：填写用户名和密码，点击Refresh headers 2.Digest Auth：要比Basic Auth复杂的多。使用当前填写的值生成authorization header。 所以在生成header之前要确保设置的正确性。 如果当前的header已经存在，postman会移除之前的header。 3.OAuth 1.0a：postman的OAuth helper让你签署支持OAuth 1.0基于身份验证的请求。 OAuth不用获取access token,你需要去API提供者获取的。 OAuth 1.0可以在header或者查询参数中设置value。 4.OAuth 2.0：postman支持获得OAuth 2.0 token并添加到requests中。 响应对于body说明： 1.Pretty：格式化了JSON和XML，方便查看。 2.Raw：是text文本。 3.Preview：返回html页面。 cookies：可以显示browser cookies，需要开启Interceptor。 Writting Test暂不涉及！！！ Postman的Tests标签可以用来写测试 运行CollectionsPostman测试管理的单位是测试集（Collections），测试集内可以创建文件夹(Folder)和具体的请求(Requests)。 postman允许你运行collection，你可以运行任意的次数。 最后会给出一个整体运行的结果。 会保存每一次运行的结果，提供给你比较每一次运行结果的不同。 Postman开发者模式使用环境变量可以方便的在开发和测试环境进行切换。 1.点击环境管理按钮添加环境。 2.通常会有开发和测试两个环境，分别添加相应的环境变量。 环境一：ev_develop url：127.0.0.1.8081 环境二：ev_test url：10.1.1.133.8080 3.使用环境变量 {{url}}/api/v1/currentUser.json No Environment选择对应的环境即可 4.查看和编辑环境变量 下拉select和眼睛图标 Postman接口测试1.对于同一接口的多个测试请求，可统一使用后缀命名 在Collections中 如测试登录的不同情况： login_normal login_bad_username login_bad_password login_miss_username login_miss_password 2.对于关键字搜索测试，可使用关键字作为后缀，以保持与开发关键字一致 如测试评分资料内容列表展示 评分资料内容列表_pageNum 评分资料内容列表_numPerPage 评分资料内容列表_docName 3.对于需要额外说明的测试请求，需要在描述里增加注释 点击edit添加Description Postman接口测试进阶1.全局变量的创建方式与环境变量相同 2.使用方式也是相同的，不同的是全局变量可以在不同环境下共用 参考文档： postman 使用详解 postmen 使用入门]]></content>
      <categories>
        <category>调试</category>
      </categories>
      <tags>
        <tag>调试</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsDoc学习-标签1]]></title>
    <url>%2F2017%2FjsDoc%E5%AD%A6%E4%B9%A0-2.html</url>
    <content type="text"><![CDATA[块标签（Block Tags） @abstract该成员（一般指父类的方法）必须在继承的子类中实现（或重写）。 别名：@virtual 1234567891011121314151617181920212223242526/** * 奶制品 * @constructor */function DairyProduct () &#123;&#125;/** * 检查奶制品的状态 * @abstract * @return &#123;boolean&#125; */DairyProduct.prototype.isSolid = function () &#123; throw new Error(&apos;must be implemented by subclass!&apos;);&#125;;/** * 牛奶 * @constructor */function Milk () &#123;&#125;Milk.prototype = new DairyProduct();// 这里重写了父类的isSolid方法Milk.prototype.isSolid = function () &#123; return false;&#125;;var dd = new Milk();console.log(dd.isSolid()); // false @access指定该成员的访问级别（私有 private，公共 public，或保护 protected） 语法：@access &lt;private|protected|public&gt; @access private 等价于 @private; @access protected 等价于 @protected; @access public 等价于 @public; 1234567891011121314151617181920212223/** * @constructor */function Thingy () &#123; /** @access private */ var foo = 0; /** @access protected */ this._bar = 1; /** @access public */ this.pez = 2;&#125;OR/** * @constructor */function Thingy () &#123; /** @private */ var foo = 0; /** @protected */ this._bar = 1; /** @public */ this.pez = 2;&#125; alias标记成员有一个别名 语法：@alias &lt;aliasNamepath&gt; 例如，匿名的构造函数使用@alias。 1234567891011Klass(&apos;trackr.CookieManager&apos;, /** * 匿名函数 * @alias trackr.CookieManager * @param kv */ function (kv) &#123; /** trackr.CookieManager＃value */ this.value = kv; &#125;) 您也可以在一个立即调用的函数表达式（IIFE）中创建的成员中使用@alias标签。 @alias标签告诉JSDoc，这些成员都暴露在IIFE作用域之外的。 例如，命名空间的静态方法使用@alias。 123456789101112/** @namespace */var Apple = &#123;&#125;;(function (ns) &#123; /** * @namespace * @alias Apple.Core */ var core = &#123;&#125;; /** Documented as Apple.Core.seed */ core.speed = function () &#123;&#125;; ns.Core = core;&#125;)(Apple); 对于那些对象字面量中定义的成员，可以使用@alias标签替代的@lends标记。 例如，对象常量使用@alias。 123456789101112131415161718// Documenting objectA with @aliasvar objectA = (function() &#123; /** * Documented as objectA * @alias objectA * @namespace */ /** @lends objectA */ var x = &#123; /** * Documented as objectA.myProperty * @member */ myProperty: &apos;foo&apos; &#125;; return x;&#125;)(); @auguments@augments or@extends标签指明标识符继承自哪个父类，后面需要加父类名。 你可以使用这个标签来记录基于类和并基于原型的继承。 别名：@extends 语法：@auguments &lt;namepath&gt; 12345678910111213141516171819202122/** * 动物 * @constructor */function Animal () &#123; this.alive = true;&#125;/** * 鸭子 * @constructor * @auguments Animal */function Duck () &#123;&#125;Duck.prototype = new Animal();Duck.prototype.speak = function () &#123; if (this.alive) &#123; alert(&apos;Quack!&apos;); &#125;&#125;;var d = new Duck();d.speak(); @author@author标签标识一个项目的作者。 语法：@author &lt;name&gt; [&lt;emailAddress&gt;] 1234/*** @author fanerge &lt;fanerge@qq.com&gt;*/function MyClass () &#123;&#125;; @borrows@borrows标签允许您将另一个标识符的描述添加到你的当前描述。 语法：@borrows &lt;that namepath&gt; as &lt;this namepath&gt; 在这个例子中，&quot;trstr&quot;函数存在文档，但&quot;util.trim&quot;只是使用不同的名称引用相同的功能。 例如，复制trstr的文档描述给util.trim。 1234567891011121314/** * @namespace * @borrows trstr as trim */var util = &#123; trim: trstr&#125;;/** * Remove whitespace from around a string. * @param &#123;string&#125; str */function trstr(str) &#123;&#125; @callback描述一个回调函数。@Callback标签提供回调函数（可传递给其他函数）的描述，包括回调的参数和返回值。 你可以包涵任何一个你能提供给@method标签。 语法：@callback &lt;namepath&gt; 例如,描述一个指定类回调。 12345678910111213141516171819/** * @class */function Requester() &#123;&#125;/** * Send a request. * @param &#123;Requester~requestCallback&#125; cb - The callback that handles the response. */Requester.prototype.send = function(cb) &#123; // code&#125;;/** * This callback is displayed as part of the Requester class. * @callback Requester~requestCallback * @param &#123;number&#125; responseCode * @param &#123;string&#125; responseMessage */ @class@class标签标明函数是一个构造器函数，意味着需要使用 new 关键字来返回一个实例，即使用 new 关键字实例化。 别名：@constructor 语法：@class [&lt;type&gt; &lt;name&gt;] 例如，一个函数构建一个Person实例 123456/** * 创建一个人 * @class */function Person () &#123;&#125;var p = new Person(); @classdesc@classdesc标签用于为类提供一个描述，这样和构造函数的描述区分开来。 @classdesc标签应该与 @class (或 @constructor)标签结合使用。 语法：@classdesc &lt;some description&gt; 如下所示，一个类有两个添加描述的地方，一个适用于函数本身，而另一个一般适用于类。 1234567/** * This is a description of the MyClass constructor function. * @class * @classdesc This is a description of the MyClass class. */function MyClass() &#123;&#125; @constant@constant 标签指明这个对象是一个常量。 语法：@constant [&lt;type&gt; &lt;name&gt;] 例如，一个字符串常量表示红色。 12345/** @constant @type &#123;string&#125; @default*/const RED = &apos;FF0000&apos;; @constructs当使用对象字面量形式定义类（例如使用@lends标签）时，可使用@constructs标签标明这个函数用来作为类的构造实例。 语法：＠constructs [name] 例如， @constructs 和 @lends 结合使用 123456789101112131415161718var Person = makeClass( /** @lends Person.prototype */ &#123; /** * @constructs * @param name */ initialize: function (name) &#123; this.name = name; &#125;, /** * @param msg * @returns &#123;*&#125; */ say: function (msg) &#123; return `$&#123;this.name&#125;says:$&#123;msg&#125;`; &#125; &#125;); @copyright@copyright标签是用来描述一个文件的版权信息。一般和@file 标签结合使用。 语法：@copyright &lt;some copyright text&gt; 1234/*** @file this is javascript* @copyright fanerge 2017*/ @default@default标签可以让你记录标识的赋值。 可以在标签后面跟上他的值，或者当值是一个唯一被分配的简单值(可以是：一个字符串，数字，布尔值或null)的时候，你可以让JSDoc从源代码中获取值，自动记录 。 别名：defaultvalue 语法：@default [&lt;some value&gt;] 在本实例中,一个常量被记录。该常数的值为0xff0000。通过添加@default标签，这个值将自动添加到文档。 12345/*** @constant* @default*/const RED = &apos;0xff0000&apos;; @deprecated@deprecated 标签指明一个标识在你代码中已经被弃用。 语法：@deprecated [&lt;some text&gt;] 例如，描述一个old函数从2.0版本开始已经被弃用 1234/*** @deprecated since version 2.0*/function old () &#123;&#125; @description@description标签允许您提供一般描述。 该说明可能包括HTML标签。如果Markdown 插件启用的话，它也可包括Markdown格式。 别名：@desc 语法：@description &lt;some description&gt; 例如，不用@description标签描述一个标识 123456789/** * Add two numbers. * @param &#123;number&#125; a * @param &#123;number&#125; b * @returns &#123;number&#125; */function add(a, b) &#123; return a + b;&#125; 例如，用@description标签描述一个标识 123456789/** * @param &#123;number&#125; a * @param &#123;number&#125; b * @returns &#123;number&#125; * @description Add two numbers. */function add(a, b) &#123; return a + b;&#125; @enum@enum标签描述一个静态属性值的全部相同的集合。 枚举类似一个属性的集合，除了枚举自己的描述注释之外，属性都记录在容器内部的注释中。 通常这种标签是与@ReadOnly结合使用，作为一个枚举通常表示常量的集合。 语法：@enum [&lt;type&gt;] 例如，一个数字枚举，表示的3种状态 123456789101112/** * Enum for tri-state values. * @readonly * @enum &#123;number&#125; */var triState = &#123; /** The true value */ TRUE: 1, FALSE: -1, /** @type &#123;boolean&#125; */ MAYBE: true&#125;; @event描述一个事件。@event标签允许您描述一个可触发的事件，一个典型的事件是由对象定义的一组属性来表示。 标签来定义事件的具体类型，您可以使用@fires标记，以表明这个种方法可以触发该事件。 你还可以使用@listens标签，以指示表明用这个表示来侦听该事件。 语法：@event &lt;className&gt;#[event:]&lt;eventName&gt; 例如，描述一个作为事件的行数 1234567891011121314151617/** * Throw a snowball. * * @fires Hurl#snowball */Hurl.prototype.snowball = function() &#123; /** * Snowball event. * * @event Hurl#snowball * @type &#123;object&#125; * @property &#123;boolean&#125; isPacked - Indicates whether the snowball is tightly packed. */ this.emit(&apos;snowball&apos;, &#123; isPacked: this._snowball.isPacked &#125;);&#125;; @example提供一个如何使用描述项的例子。跟随此标签的文字将显示为高亮代码。 12345678910111213/** * Solves equations of the form a * x = b * @example * // returns 2 * globalNS.method1(5, 10); * @example * // returns 3 * globalNS.method(5, 15); * @returns &#123;Number&#125; Returns the value of x for the equation. */globalNS.method1 = function (a, b) &#123; return b / a;&#125;; @exports@exports标签描述由JavaScript模块的exports或module.exports属性导出的任何内容。 语法：@exports &lt;moduleName&gt; 123456789/** * A module that says hello! * @module hello/world *//** Say hello. */exports.sayHello = function() &#123; return &apos;Hello world&apos;;&#125;; @external@external标签用来标识一个在当前包外部定义的类，命名空间，或模块。 通过使用这个标签，你可以描述你的包的外部标识的扩展，或者您也可以提供关于 外部标识的相关信息给你的包的使用者。 你也可以在任何其他JSDoc标签中引用外部标识的namepath（名称路径）。 外部标识引用的路径名 始终需要使用external:前缀：（例如{@link external:Foo}或@augments external:Foo）。 但是，你可以省略@external标记的这个前缀。 别名：@host 下面的示例演示如何描述内置的String对象作为external，新的实例方法external:String#rot13 12345678910111213/** * The built in string object. * @external String * @see &#123;@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String|String&#125; *//** * Create a ROT13-encoded version of the string. Added by the `foo` package. * @function external:String#rot13 * @example * var greeting = new String(&apos;hello world&apos;); * console.log( greeting.rot13() ); // uryyb jbeyq */ 参考文档： jsDoc文档]]></content>
      <categories>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsDoc学习-常用示例]]></title>
    <url>%2F2017%2FjsDoc%E5%AD%A6%E4%B9%A0-1.html</url>
    <content type="text"><![CDATA[jsDoc 示例ES 2015 ClassesDocumenting a simple class（文档化一个简单的类） 演示了如何通过一个构造函数，两个实例方法和一个静态方法文档化一个简单的类 12345678910111213141516171819202122232425262728293031323334353637class Point &#123; /** * 构造函数 * @param x * @param y */ constructor (x, y) &#123; this.x = x; this.y = y; &#125; /** * 实例方法 * @returns &#123;*&#125; */ getX () &#123; return this.x; &#125; /** * 实例方法 * @returns &#123;*&#125; */ getY () &#123; return this.y; &#125; /** * 静态方法 * @param str */ static fromString (str) &#123; // ... &#125;&#125;var de = new Point(&apos;1&apos;,&apos;2&apos;);console.log(de.getX()); // &apos;1&apos; Extending classes（扩展类） 当您使用 extends关键字来扩展一个现有的类的时候，你还需要告诉JSDoc哪个类是你要扩展的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** Class representing a point. */class Point &#123; /** * 构造函数 * @param x * @param y */ constructor (x, y) &#123; this.x = x; this.y = y; &#125; /** * 实例方法 * @returns &#123;*&#125; */ getX () &#123; return this.x; &#125; /** * 实例方法 * @returns &#123;*&#125; */ getY () &#123; return this.y; &#125; /** * 静态方法 * @param str */ static fromString (str) &#123; // ... &#125;&#125;/** Class representing a point * @extends Point */class Dot extends Point &#123; /** * 构造函数 * @param x * @param y * @param width */ constructor (x, y, width) &#123; super(x,y); this.width = width; &#125; /** * 实例方法 * @returns &#123;*&#125; */ getWidth () &#123; return this.width; &#125;&#125;var dd = new Dot(1, 2, 3);console.log(dd.getX()); // 1 ES 2015 ModulesModule identifiers（模块标识符） 当你描述一个 ES 2015 module（模块）时，您将使用@module 标签来描述模块的标识符。 1234/** * @module my/shirt */import * as myShirt from &apos;my/shirt&apos;; 当您使用一个 JSDoc namepath（名称路径）从另一个JSDoc注释中引用一个模块，您必须添加前缀module:。 例如，如果你想模块my/pants的文档 连接到模块my/shirt，您可以使用@see 标签来描述my/pants。 12345/** * Pants module. * @module my/pants * @see module:my/shirt */ 同样，模块中每个成员的namepath （名称路径）将以module: 开始，后面跟模块名字。 例如，如果你的my/pants模块输出一个Jeans类，并且Jeans 有一个名为hem的实例方法， 那么这个实例方法longname（长名称）是module:my/pants.Jeans#hem。 Exported values （导出值） 123456789101112131415161718192021222324252627/** The name of the module. */export const name = &apos;mixer&apos;;/** The most recent blended color. */export var lastColor = null;/** * Blend two colors together. * @param &#123;string&#125; color1 - The first color, in hexidecimal format. * @param &#123;string&#125; color2 - The second color, in hexidecimal format. * @return &#123;string&#125; The blended color. */export function blend(color1, color2) &#123;&#125;// convert color to array of RGB values (0-255)function rgbify(color) &#123;&#125;export &#123; /** * Get the red, green, and blue values of a color. * @function * @param &#123;string&#125; color - A color, in hexidecimal format. * @returns &#123;Array.&lt;number&gt;&#125; An array of the red, green, and blue values, * each ranging from 0 to 255. */ rgbify as toRgb&#125; CommonJS ModulesModule identifiers（模块标识符） 例如，如果你想模块my/pants的文档 连接到模块my/shirt，您可以使用@see 标签来描述my/pants。 12345/** * Pants module. * @module my/pants * @see module:my/shirt */ Properties of the &apos;exports&apos; object（&apos;exports&apos;对象的属性） 例如，方法添加到导出对象。 1234567891011121314/** * Shirt module. * @module my/shirt *//** Button the shirt. */exports.button = function() &#123; // ...&#125;;/** Unbutton the shirt. */exports.unbutton = function() &#123; // ...&#125;; Values assigned to local variables （值分配给局部变量） 例如，longname（长名称）定义在 @alias 标签中。 123456789101112/** * Shirt module. * @module my/shirt *//** * Wash the shirt. * @alias module:my/shirt.wash */var wash = exports.wash = function() &#123; // ...&#125;; 例如，JSDoc注释放在exports.wash之前。 12345678910/** * Shirt module. * @module my/shirt */var wash =/** Wash the shirt. */exports.wash = function() &#123; // ...&#125;; Values assigned to &apos;module.exports&apos; （值分配给&apos;module.exports&apos;） Object literal assigned to &apos;module.exports&apos;（对象字面量分配给&apos;module.exports&apos;） 例如：对象字面量分配给&apos;module.exports&apos;。 12345678910111213141516/** * Color mixer. * @module color/mixer */module.exports = &#123; /** Blend two colors together. */ blend: function(color1, color2) &#123; // ... &#125;, /** Darken a color by the given percentage. */ darken: function(color, percent) &#123; // .. &#125;&#125;; 例如，通过属性定义，分配给module.exports。 12345678910111213141516/** * Color mixer. * @module color/mixer */module.exports = &#123; /** Blend two colors together. */ blend: function(color1, color2) &#123; // ... &#125;&#125;;/** Darken a color by the given percentage. */module.exports.darken = function(color, percent) &#123; // ..&#125;; Function assigned to &apos;module.exports&apos;（函数分配给&apos;module.exports&apos;） 例如，函数分配给&apos;module.exports&apos;。 123456789/** * Color mixer. * @module color/mixer *//** Blend two colors together. */module.exports = function(color1, color2) &#123; // ...&#125;; 例如，构造函数分配给&apos;module.exports&apos;。 123456789/** * Color mixer. * @module color/mixer *//** Create a color mixer. */module.exports = function ColorMixer() &#123; // ...&#125;; String, number, or boolean assigned to &apos;module.exports&apos;（字符串，数字，或布尔值分配给&apos;module.exports&apos;） 例如，字符串分配给&apos;module.exports&apos;。 1234567/** * Module representing the word of the day. * @module wotd * @type &#123;string&#125; */module.exports = &apos;perniciousness&apos;; Values assigned to &apos;module.exports&apos; and local variables （值分配给&apos;module.exports&apos;和局部变量） 例如，对象字面量分配给一个局部变量和module.export。 12345678910/** * Color mixer. * @exports color/mixer */var mixer = module.exports = &#123; /** Blend two colors together. */ blend: function(color1, color2) &#123; // ... &#125;&#125;; Properties added to &apos;this&apos;（属性添加到&apos;this&apos;） 例如，属性添加到一个模块的&apos;this&apos;对象。 1234567/** @module bookshelf *//** @class */this.Book = function(title) &#123; /** The title of the book. */ this.title = title;&#125; AMD ModulesModule identifiers（模块标识符） 12345/** * Pants module. * @module my/pants * @see module:my/shirt */ Function that returns an object literal（函数返回一个对象字面量） 例如，函数返回一个对象字面量。 123456789101112131415161718define(&apos;my/shirt&apos;, function() &#123; /** * A module representing a shirt. * @exports my/shirt */ var shirt = &#123; /** The module&apos;s `color` property. */ color: &apos;black&apos;, /** @constructor */ Turtleneck: function(size) &#123; /** The class&apos; `size` property. */ this.size = size; &#125; &#125;; return shirt;&#125;); Function that returns another function（函数返回另一个函数） 例如，函数返回另一个函数。 1234567891011121314151617181920/** * A module representing a jacket. * @module my/jacket */define(&apos;my/jacket&apos;, function() &#123; /** * @constructor * @alias module:my/jacket */ var Jacket = function() &#123; // ... &#125;; /** Zip up the jacket. */ Jacket.prototype.zip = function() &#123; // ... &#125;; return Jacket;&#125;); Module declared in a return statement （模块声明在return语句中） 例如，模块声明在return语句中。 123456789101112131415/** * Module representing a shirt. * @module my/shirt */define(&apos;my/shirt&apos;, function() &#123; // Do setup work here. return /** @alias module:my/shirt */ &#123; /** Color. */ color: &apos;black&apos;, /** Size. */ size: &apos;unisize&apos; &#125;;&#125;); Module object passed to a function（模块对象传递给一个函数） 例如，模块对象传递给一个函数。 123456789101112131415define(&apos;my/jacket&apos;, function( /** * Utility functions for jackets. * @exports my/jacket */ module) &#123; /** * Zip up a jacket. * @param &#123;Jacket&#125; jacket - The jacket to zip up. */ module.zip = function(jacket) &#123; // ... &#125;;&#125;); Multiple modules defined in one file（多模块定义在一个文件中） 例如，多模块定义在一个文件中。 ``` // one module define(&apos;html/utils&apos;, function() { /** * Utility functions to ease working with DOM elements. * @exports html/utils */ var utils = { /** Get the value of a property on an element. */ getStyleProperty: function(element, propertyName) { } }; /** Determine if an element is in the document head. */ utils.isInHead = function(element) { } return utils; } ); // another module define(&apos;tag&apos;, function() { /** @exports tag */ var tag = { /** @class */ Tag: function(tagName) { // ... } }; return tag; }); ``` 参考文档： jsDoc文档]]></content>
      <categories>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsDoc学习-入门知识]]></title>
    <url>%2F2017%2FjsDoc%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[jsDoc介绍定义：JSDoc是一个根据javascript文件中注释信息，生成JavaScript应用程序或库、模块的API文档 的工具。jsDoc注释：是以 /** 来作为jsDoc注释的开始，其它如 /* 和 /*** 的注释都会被jsDoc解析器忽略。 在webstorm中自动生成jsDoc注释 示例： 123456789101112131415161718192021222324252627282930313233343536/** * Book类，代表一本书 * @param title * @param anthor * @param pageNum * @constructor */function Book (title, anthor, pageNum ) &#123; // 实例属性 this.title = title; this.anthor = anthor; this.pageNum = pageNum || 0;&#125;Book.prototype = &#123; /** * 获取书本的标题 * @returns &#123;*&#125; */ getTitle : function () &#123; return this.title; &#125;, /** * 获取书本的作者 * @returns &#123;*&#125; */ getAnthor: function () &#123; return this.anthor; &#125;, /** * 设置书本的页码 * @param pageNum */ setPageNum: function (pageNum) &#123; this.pageNum = pageNum; &#125;&#125;; 入门Namepaths in JSDoc 3（JSDoc 3中的名称路径）如果涉及到一个JavaScript变量，这个变量在文档中的其他地方，你必须提供一个唯一标识符映射到该变量。 名称路径提供了一种这样做的方法，并且消除实例成员，静态成员和内部变量之间的歧义。 jsDoc中名称路径的基本语法示例： myFunction MyConstructor MyConstructor#instanceMember（实例成员） MyConstructor.staticMember（静态成员） MyConstructor~innerMember（内部成员）示例： 123456789101112131415161718192021222324252627282930313233343536373839/** * Person类，一个人 * @param name * @constructor */const Person = function (name) &#123; this.name = name; /** * 这是一个实例成员 * @returns &#123;string&#125; */ this.say = () =&gt; &#123; return &apos;I\&apos;am an instance.&apos;; &#125;; /** * 这是一个内部成员 * @returns &#123;string&#125; */ function say () &#123; return &apos;I\&apos; am an inner.&apos;; &#125;;&#125;;/** * 这是一个静态成员 * @returns &#123;string&#125; */Person.say = function () &#123; return &apos;I\&apos;am an static.&apos;;&#125;;/** * 实例化一个人 * @type &#123;Person&#125; */const person1 = new Person(&apos;fanerge&apos;);// Person#say 使用实例方法person1.say();// Person.say 使用静态方法Person.say();// Person~say 使用内部方法，但这里不能访问到 使用名称路径也有一些特殊的情况：@module名称由”module:”前缀，@external 名称由”external:”前缀，@event名称由”event:”前缀。 JSDoc中的命令行参数使用JSDoc最基本的，像这样使用：/path/to/jsdoc yourSourceCodeFile.js anotherSourceCodeFile.js ...其中…是生成文档文件的路径。JSDoc支持大量的命令行选项，其中许多选项有长和短两种形式。选项 描述-a , –access 只显示特定access方法属性的标识符： private, protected, public, or undefined, 或者 all（表示所有的访问级别）。默认情况下， 显示除private标识符以外的所有标识符。-c , –configure JSDoc配置文件的路径。默认为安装JSDoc目录下的conf.json或conf.json.EXAMPLE。-d , –destination 输出生成文档的文件夹路径。JSDoc内置的Haruki模板，使用console 将数据转储到控制台。默认为./out。–debug 打印日志信息，可以帮助调试JSDoc本身的问题。-e , –encoding 当JSDoc阅读源代码时假定使用这个编码，默认为 utf8。-h, –help 显示JSDoc的命令行选项的信息，然后退出。–match 只有运行测试，其名称中包含value。–nocolor 当运行测试时，在控制台输出信息不要使用的颜色。在Windows中，这个选项是默认启用的。-p, –private 将标记有[@private 标签][tags-private.md]的标识符也生成到文档中。默认情况下，不包括私有标识符。-P, –package 包含项目名称，版本，和其他细节的package.json文件。默认为在源路径中找到的第一个package.json文件。–pedantic 将错误视为致命错误，将警告视为错误。默认为false。-q , –query 一个查询字符串用来解析和存储到全局变量env.opts.query中。示例：foo=bar&amp;baz=true。-r, –recurse 扫描源文件和导览时递归到子目录。-R, –readme 用来包含到生成文档的README.md文件。默认为在源路径中找到的第一README.md 文件。-t , –template 用于生成输出文档的模板的路径。默认为templates/default，JSDoc内置的默认模板。-T, –test 运行JSDoc的测试套件，并把结果打印到控制台。-u , –tutorials 导览路径，JSDoc要搜索的目录。如果省略，将不生成导览页。查看导览说明，以了解更多信息。-v, –version 显示JSDoc的版本号，然后退出。–verbose 日志的详细信息到控制台JSDoc运行。默认为false。-X, –explain 以JSON格式转储所有的doclet到控制台，然后退出。 示例：使用配置文件/path/to/my/conf.json，为./src目录的中文件生成文档，并保存输出到./docs目录中： /path/to/jsdoc src -r -c /path/to/my/conf.json -d docs运行所有JSDoc的测试，其名称包含 tag，并记录每个测试信息： /path/to/jsdoc -T –match tag –verbose 用conf.json配置JSDocConfiguration File(配置文件) 要自定义JSDoc的行为，可以使用JSON格式的配置文件格式化JSDoc，使用-c选项，例如： jsdoc -c /path/to/conf.json。 默认的jsDoc配置文件conf.json.EXAMPLE 123456789101112131415&#123; &quot;tags&quot;: &#123; &quot;allowUnknownTags&quot;: true, &quot;dictionaries&quot;: [&quot;jsdoc&quot;,&quot;closure&quot;] &#125;, &quot;source&quot;: &#123; &quot;includePattern&quot;: &quot;.+\\.js(doc)?$&quot;, &quot;excludePattern&quot;: &quot;(^|\\/|\\\\)_&quot; &#125;, &quot;plugins&quot;: [], &quot;templates&quot;: &#123; &quot;cleverLinks&quot;: false, &quot;monospaceLinks&quot;: false &#125;&#125; Specifying input files(指定输入文件) source选项组，结合给JSDoc命令行的路径，确定哪些文件要用JSDoc生成文档。 123456&quot;source&quot;: &#123; &quot;include&quot;: [ /* array of paths to files to generate documentation for */ ], &quot;exclude&quot;: [ /* array of paths to exclude */ ], &quot;includePattern&quot;: &quot;.+\\.js(doc)?$&quot;, &quot;excludePattern&quot;: &quot;(^|\\/|\\\\)_&quot;&#125; Incorporating command-line options into the configuration file(合并命令行选项到配置文件) 它有可能把许多JSDoc的命令行选项放到配置文件，而不用在命令行中指定它们。 要做到这一点，只要在conf.json的opts部分中使用的相关选项的longnames,值是该选项的值。 1234567&quot;opts&quot;: &#123; &quot;template&quot;: &quot;templates/default&quot;, // same as -t templates/default &quot;encoding&quot;: &quot;utf8&quot;, // same as -e utf8 &quot;destination&quot;: &quot;./out/&quot;, // same as -d ./out/ &quot;recurse&quot;: true, // same as -r &quot;tutorials&quot;: &quot;path/to/tutorials&quot;, // same as -u path/to/tutorials&#125; Plugins（插件） 要启用插件，只要添加它们的路径（相对于JSDoc文件夹）到plugins数组中就可以了。 示例： 例如，以下将包括 markdown 插件，它转换 markdown格式的文本为HTML，和“summarize”插件，该自动生成的每个的doclet的摘要： 1234&quot;plugins&quot;: [ &quot;plugins/markdown&quot;, &quot;plugins/summarize&quot;] Tags and tag dictionaries(标签和标签字典) tags选项控制哪些JSDoc标签允许被使用和解析。 1234&quot;tags&quot;: &#123; &quot;allowUnknownTags&quot;: true, &quot;dictionaries&quot;: [&quot;jsdoc&quot;,&quot;closure&quot;]&#125; 配置JSDoc的默认模板JSDoc的默认模板中提供了几个选项，您可以使用自定义外观和内容来生成文档。 要使用这些选项，您必须为JSDoc创建一个配置文件，并在配置文件中设置相应的选项。 Generating pretty-printed source files（生成适合打印的文档） 默认情况下，JSDoc的默认模板为你的源文件生成适合打印的文档。在文档中，它还链接到那些适合的打印文件。 要禁用适合打印的文件，设置选项templates.default.outputSourceFiles为false。 使用该选项也将删除文档中链接到源文件的连接。此选项在JSDoc3.3.0及更高版本上是可用的。 Copying static files to the output directory(复制静态文件到输出目录) SDoc的默认模板会自动复制一些静态文件，如CSS样式表，到输出目录。 在JSDoc3.3.0或更高版本，你可以告诉默认模板复制附加静态文件到输出目录。 例如，您可能希望复制一个图像的目录到输出目录，所以你可以在你的文档中显示这些图像。 Showing the current date in the page footer（在页脚显示当前日期） 默认情况下，JSDoc的默认模板总是在生成文档的页脚显示当前日期。 在JSDoc3.3.0或更高版本，可以通过设置选项templates.default.includeDate为false来忽略当前日期。 Showing longnames in the navigation column（在导航栏中显示长文件名） 默认情况下，JSDoc的默认模板在导航列中显示每个标识符缩写的名字。 例如，标识符my.namespace.MyClass将简单地称为显示MyClass。相反,要显示完整的长名称，设置选项templates.default.useLongnameInNav为true。 此选项在JSDoc3.4.0及更高版本中可用。 Overriding the default template&apos;s layout file（重写默认模板的布局文件） 默认的模板使用名为 layout.tmpl 的文件 指定每个生成文档的页面中的页眉和页脚。 特别是，每个生产的文档页面会加载该文件定义了CSS和JavaScript文件。在JSDoc3.3.0或更高版本，可以指定使用自己的layout.tmpl文件，它允许你加载自己的自定义CSS和JavaScript文件，去除或替代，标准的文件。 要使用此功能，设置选项templates.default.layoutFile的路径到你的自定义布局文件。 路径是相对于config.json文件，当前的工作目录，和JSDoc目录的相对路径，按照这个顺序。 块标签和内联标签JSDoc支持两种不同类型的标签： 块标签, 这是在一个JSDoc注释的最高级别。 内联标签, 块标签文本中的标签或说明。块标签通常会提供有关您的代码的详细信息，如一个函数接受的参数。块标签总是以 at 符号（@）开头。除了JSDoc注释中最后一个块标记，每个块标签后面必须跟一个换行符。内联标签通常链接到文件的其他部分，类似于HTML中的锚标记（）。内联标签也以 at 符号（@）开。然而，内联标签及其文本必须用花括号（{ and }）括起来。 { 表示行内联标签的开始，而}表示内联标签的结束。如果你的标签文本中包含右花括号（}），则必须用反斜线（ \ ）进行转义。在内联标签后,你并不需要使用一个换行符。示例：123456789101112131415161718192021222324252627282930313233/** * Shoe类，一双鞋子 * @param color * @param size * @constructor */const Shoe = function (color, size)&#123; this.color = color; this.size = size;&#125;;/** * Set shoe&apos;s color. Use &#123;@link Shoe#setSize&#125; to set the shoe size * @param color */Shoe.prototype.setColor = function (color) &#123; this.color = color;&#125;;/** * 设置鞋子的尺寸 * @param size */Shoe.prototype.setSize = function (size) &#123; this.size = size;&#125;;/** * 设置花边的颜色和样式 * @param color * @param type */Shoe.prototype.setLaceType = function (color, type) &#123; // ...&#125;;var shoe1 = new Shoe(&apos;red&apos;, 12); 关于JSDoc插件Creating and Enabling a Plugin（创建并启用插件） 创建并启用新JSDoc插件,需要两个步骤： 创建一个包含你的插件代码的JavaScript模块. 将该模块添加到JSDoc配置文件的plugins数组中。你可以指定一个绝对或相对路径。 如果使用相对路径，JSDoc按照相对于配置文件所在的目录，当前的工作目录和JSDoc安装目录的顺序搜索插件。 Authoring JSDoc 3 Plugins（创建JSDoc3插件） JSDoc 3的插件系统广泛的控制着解析过程。一个插件可以通过执行以下任何一项操作，影响解析结果： 定义事件处理程序 定义标签 定义一个抽象语法树节点的访问者Event Handlers（事件处理程序）事件: parseBegin – JSDoc开始加载和解析源文件之前，parseBegin事件被触发。事件: fileBegin – 当解析器即将解析一个文件fileBegin事件触发。事件: beforeParse – beforeParse事件在解析开始之前被触发。事件: jsdocCommentFound – 每当JSDoc注释被发现,jsdocCommentFound事件就会被触发。事件: symbolFound – 当解析器在代码中遇到一个可能需要被文档化的标识符时，symbolFound 事件就会被触发。事件: newDoclet – newDoclet事件是最高级别的事件。新的doclet已被创建时，它就会被触发。事件: fileComplete – 当解析器解析完一个文件时，fileComplete 事件就会被触发。事件: parseComplete – JSDoc解析所有指定的源文件之后，parseComplete事件就会被触发。事件: processingComplete – JSDoc更新反映继承和借来的标识符的解析结果后，processingComplete事件被触发。Tag Definitions （标签定义）添加标签到标签字典是影响文档生成的一个中级方式。在一个newDoclet事件被触发前，JSDoc注释块被解析以确定可能存在的说明和任何JSDoc标签。当一个标签被发现，如果它已在标签字典被定义，它就会被赋予一个修改doclet的机会。The Dictionary（字典）Node Visitors（节点访问者）Reporting Errors(报告错误) 使用Markdown插件Enabling the Markdown plugin(启用markdown插件)要启用markdown插件，只要将字符串plugins/markdown添加到JSDoc配置文件的plugins数组中即可。Converting Markdown in additional JSDoc tags（在额外的JSDoc标签中转换Markdown）默认情况下，markdown插件只处理特定JSDoc标签的markdown文本。您可以通过添加一个 markdown.tags属性到你的JSDoc配置文件中，来处理的其他标签中的markdown文本。Excluding the default tags from Markdown processing（剔除markdown默认处理的标签）为了防止Markdown插件处理任何默认JSDoc标签，添加一个markdown.excludeTags属性到您的JSDoc配置文件。Hard-wrapping text at line breaks （用换行符换行文本）默认情况下，Markdown插件不处理换行符换行的文本。Adding ID attributes to headings（添加ID属性到标题标签）默认情况下，Markdown插件不会给每个HTML标题标签添加id 属性。 Tutorials 教程JSDoc允许你的API文档的页面旁边包含教程。您可以使用此功能来为您的API提供详细的使用说明，如“入门”指南或实现一个功能的一步一步的过程。 Adding tutorials（添加教程）添加教程到您的API文档，可以通过–tutorials 或 -u 选项运行JSDoc，并提供JSDoc要搜索的教程目录。 1jsdoc -u path/to/tutorials path/to/js/files Configuring titles, order, and hierarchy （配置标题，顺序和层次结构）默认情况下，JSDoc使用的文件名作为教程标题，并且所有的教程都在同一层次。您可以使用JSON文件为每个教程提供标题并指示文档中的教程应如何排序和分组。Linking to tutorials from API documentation（从API文档链接到教程）@tutorial 块标签{@tutorial} 内联标签 包含Package（包）文件包文件包含的信息对你的项目文档是很有用的，比如该项目的名称和版本号。当JSDoc生成的文档的时候,可以自动使用项目中package.json文件中的信息。示例，默认的模板在文档中显示项目的名称和版本号。在源路径中包含一个包文件: jsdoc path/to/js path/to/package/package.json使用 -P/–package 选项： jsdoc –package path/to/package/package-docs.json path/to/js 包含 README 文件有两种方法可以将 README 文件中的信息合并到您的文档：在源路径中包含一个 README 文件:jsdoc path/to/js path/to/readme/README.md使用 -R/–readme 选项：jsdoc –readme path/to/readme/README path/to/js 参考文档：jsDoc文档]]></content>
      <categories>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC学习]]></title>
    <url>%2F2017%2FMVC%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[名词解释MVC的全名是Model View Controller，是模型（model）--视图（view）--控制器（controller）的缩写，是一种软件设计典范。 M（数据模型）：比如你设计一个User对象，包含username和password属性，它就是一个简单的M。 M是指业务模型，V是指用户界面，C则是控制器。 在web开发中V--即View视图是指用户看到并与之交互的界面。比如由html元素组成的网页界面，或者软件的客户端界面。 MVC的好处之一在于它能为应用程序处理很多不同的视图。 在视图中其实没有真正的处理发生，它只是作为一种输出数据并允许用户操纵的方式。 M--即Model模型是指模型表示业务规则。在MVC的三个部件中，模型拥有最多的处理任务。 被模型返回的数据是中立的，模型与数据格式无关，这样一个模型能为多个视图提供数据， 由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。 C--即Controller控制器是指控制器接受用户的输入并调用模型和视图去完成用户的需求， 控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求， 然后再确定用哪个视图来显示返回的数据。 它们三者的关系 用户首先在界面中进行人机交互，然后请求发送到控制器，控制器根据请求类型和请求的指令发送到相应的模型， 模型可以与数据库进行交互，进行增删改查操作，完成之后，根据业务的逻辑选择相应的视图进行显示，此时用户获得此次交互的反馈信息， 用户可以进行下一步交互，如此循环。 每层主要的功能视图（View）：用户界面 控制器（Controller）：业务逻辑 模型（Model）：数据保存 wiki控制器（Controller）- 负责转发请求，对请求进行处理。 视图（View） - 界面设计人员进行图形界面设计。 模型（Model） - 程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)。 将应用程序划分为三种组件，模型 - 视图 - 控制器（MVC）设计定义它们之间的相互作用。 模型（Model） 用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法。“ Model ”有对数据直接访问的权力，例如对数据库的访问。 “Model”不依赖“View”和“Controller”，也就是说， Model 不关心它会被如何显示或是如何被操作。 但是 Model 中数据的变化一般会通过一种刷新机制被公布。 为了实现这种机制，那些用于监视此 Model 的 View 必须事先在此 Model 上注册，从而，View 可以了解在数据 Model 上发生的改变。（比较：观察者模式（软件设计模式）） 视图（View）能够实现数据有目的的显示（理论上，这不是必需的）。在 View 中一般没有程序上的逻辑。 为了实现 View 上的刷新功能，View 需要访问它监视的数据模型（Model），因此应该事先在被它监视的数据那里注册。 控制器（Controller）起到不同层面间的组织作用，用于控制应用程序的流程。它处理事件并作出响应。 “事件”包括用户的行为和数据 Model 上的改变。 javscript的一个MVC示例1234567891011121314/** 模擬 Model, View, Controller */var M = &#123;&#125;, V = &#123;&#125;, C = &#123;&#125;;/** Model 負責存放資料 */M.data = &quot;hello world&quot;;/** View 負責將資料輸出到螢幕上 */V.render = (M) =&gt; &#123; alert(M.data); &#125;/** Controller 作為一個 M 和 V 的橋樑 */C.handleOnload = () =&gt; &#123; V.render(M); &#125;/** 在網頁讀取的時候呼叫 Controller */window.onload = C.handleOnload; 参考文档： MVC简介 阮一峰 wiki-MVC]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sass学习]]></title>
    <url>%2F2017%2FSass%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[Sass是在CSS语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。 常用的指令在命令行中运行 Sass sass input.scss output.css 监视单个 Sass 文件，每次修改并保存时自动编译 sass --watch input.scss:output.css 监视整个文件夹 sass --watch app/scss:public/stylesheets 开启debug信息 sass --watch input.scss:output.css --debug-info 选择编译格式并添加调试map sass --watch input.scss:output.css --style expanded --sourcemap 编译添加调试map sass --watch input.scss:output.css --sourcemap 编译格式 sass --watch input.scss:output.css --style compact 使用变量sass让人们受益的一个重要特性就是它为css引入了变量。你可以把反复使用的css属性值 定义成变量，然后通过变量名来引用它们，而无需重复书写这一属性值。或者，对于仅使用过一 次的属性值，你可以赋予其一个易懂的变量名，让人一眼就知道这个属性值的用途。 sass使用$符号来标识变量，如比如$highlight-color和$sidebar-width。 变量声明 声明单个属性值$higlight-color: #f90; 声明多个属性值$basic-border: 1px solid black; 逗号分割多个属性值$plain-font: “Myriad Pro”,Myriad,”Helvetica Neue”,Helvetica,”Liberation Sans”,Arial,sans-serif,sans-serif; 变量的作用域当变量定义在css规则块内，那么该变量只能在此规则块内使用。如果它们出现在任何形式的{…}块中（如@media或者@font-face块） 1234567$nav-color: #F90; // 全局声明nav &#123; $width: 100px; // 局部声明 width: $width; // 100px color: $nav-color; // #f90&#125;// 这意味着是你可以在样式表的其他地方定义和使用$width变量，不会对这里造成影响。 在声明变量时，变量值也可以引用其他变量。$highlight-color: #F90;$highlight-border: 1px solid $highlight-color; 变量引用如果你需要一个不同的值，只需要改变这个变量的值，则所有引用此变量的地方生成的值都会随之改变。 123456// 声明变量$highlight-color: #F90;$highlight-border: 1px solid $highlight-color;.selected &#123; border: $highlight-border; // 引用变量&#125; 变量命名 变量名用中划线还是下划线分隔用中划线声明的变量可以使用下划线的方式引用，反之亦然。1234$link-color: blue; // 中划线声明a &#123; color: $link_color; // 下划线引用&#125; 将局部变量升级为全局变量编译前 1234567#main &#123; $width: 5em !global; width: $width;&#125;#sidebar &#123; width: $width;&#125; 编译后 123456#main &#123; width: 5em; &#125;#sidebar &#123; width: 5em; &#125; 数据类型 (Data Types)Interactive Shell color: #777 + #777; // color: #eeeeee; 如果需要使用变量，同时又要确保 / 不做除法运算而是完整地编译到 CSS 文件中，只需要用 #{} 插值语句将变量包裹。 12345p &#123; $font-size: 12px; $line-height: 30px; font: #&#123;$font-size&#125;/#&#123;$line-height&#125;;&#125; 数字，1, 2, 13, 10px 字符串，有引号字符串与无引号字符串，&quot;foo&quot;, &apos;bar&apos;, baz 颜色，blue, #04a3f9, rgba(255,0,0,0.5) 布尔型，true, false 空值，null 数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif maps, 相当于 JavaScript 的 object，(key1: value1, key2: value2) 嵌套CSS 规则123456789101112// 编译前#content &#123; article &#123; h1 &#123; color: #333 &#125; p &#123; margin-bottom: 1.4em &#125; &#125; aside &#123; background-color: #EEE &#125;&#125;// 编译后#content article h1 &#123; color: #333 &#125;#content article p &#123; margin-bottom: 1.4em &#125;#content aside &#123; background-color: #EEE &#125; 当你同时要为一个容器元素及其子元素编写特定样式时，这种能力就非常有用了。 12345678// 编译前#content &#123; background-color: #f5f5f5; aside &#123; background-color: #eee &#125;&#125;// 编译后#content &#123; background-color: #f5f5f5 &#125;#content aside &#123; background-color: #eee &#125; 父选择器的标识符&amp;作用于伪类:hover、:after等等 12345678// 编译前article a &#123; color: blue; &amp;:hover &#123; color: red &#125;&#125;// 编译后article a &#123; color: blue &#125;article a:hover &#123; color: red &#125; 父选择器标识符还有另外一种用法，你可以在父选择器之前添加选择器。 举例来说，当用户在使用IE浏览器时，你会通过JavaScript在&lt;body&gt;标签上添加一个ie的类名，为这种情况编写特殊的样式如下 12345678// 编译前#content aside &#123; color: red; body.ie &amp; &#123; color: green &#125;&#125;// 编译后#content aside &#123;color: red&#125;;body.ie #content aside &#123; color: green &#125; 群组选择器的嵌套123456789// 编译前nav, aside &#123; a &#123;color: blue&#125;&#125;// 编译后nav a, aside a &#123; color: blue&#125; 子组合选择器和同层组合选择器：&gt;、+和~上边这三个组合选择器必须和其他选择器配合使用，以指定浏览器仅选择某种特定上下文中的元素。 可以把它们放在外层选择器后边，或里层选择器前边。 &gt; 直接后代选择器 + 紧接的相邻兄弟选择器 ~ 同层全体组合选择器 嵌套属性除了CSS选择器，属性也可以进行嵌套。 嵌套属性的规则是这样的：把属性名从中划线-的地方断开，在根属性后边添加一个冒号:，紧跟一个{ }块，把子属性部分写在这个{ }块中。 属性的嵌套 1234567891011121314// 编译前nav &#123; border: &#123; style: solid; width: 1px; color: #ccc; &#125;&#125;// 编译后nav &#123; border-style: solid; border-width: 1px; border-color: #ccc;&#125; 对于属性的缩写形式 12345678910111213// 编译前nav &#123; border: 1px solid #ccc &#123; left: 0px; right: 0px; &#125;&#125;// 编译后nav &#123; border: 1px solid #ccc; border-left: 0px; border-right: 0px;&#125; 导入SASS文件css有一个特别不常用的特性，即@import规则，它允许在一个css文件中导入其他css文件。 使用sass的@import规则并不需要指明被导入文件的全名。你可以省略.sass或.scss文件后缀。 @import &quot;sidebar&quot;;这条命令将把sidebar.scss文件中所有样式添加到当前样式表中。 使用SASS部分文件sass局部文件的文件名以下划线开头。这样，sass就不会在编译时单独编译这个文件输出css，而只把这个文件用作导入。 12你想导入themes/_night-sky.scss这个局部文件里的变量，你只需在样式表中写@import &quot;themes/night-sky&quot;;。 默认变量值你反复声明一个变量，只有最后一处声明有效且它会覆盖前边的值。 如果这个变量被声明赋值了，那就用它声明的值，否则就用这个默认值。 使用sass的!default标签可以实现这个目的。 对于通过@import导入的sass库文件，你可能希望导入者可以定制修改sass库文件中的某些值，非常有用。 1234$fancybox-width: 400px !default;.fancybox &#123; width: $fancybox-width; // 400px&#125; 嵌套导入跟原生的css不同，sass允许@import命令写在css规则内。 12345678910111213141516171819// _blue-theme.scssaside &#123; background: blue; color: white;&#125;// 在主scss文件中index.scss.blue-theme &#123;@import &quot;blue-theme&quot;&#125; // 类似于编译前.blue-theme &#123; aside &#123; background: blue; color: #fff; &#125;&#125;// 编译后.blue-theme aside &#123; background: blue; color: #fff;&#125; 原生的CSS导入下列3种情况使用原生CSS@import，浏览器解析css时的额外下载。 123被导入文件的名字以.css结尾；被导入文件的名字是一个URL地址（比如http://www.sass.hk/css/css.css），由此可用谷歌字体API提供的相应服务；被导入文件的名字是CSS的url()值。 静默注释sass另外提供了一种不同于css标准注释格式/* ... */的注释语法， 即静默注释，其内容不会出现在生成的css文件中。 将 ! 作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。 1234body &#123; color: #333; // 这种注释内容不会出现在生成的css文件中(静默注释) padding: 0; /* 这种注释内容会出现在生成的css文件中 */&#125; 当注释出现在原生css不允许的地方，如在css属性或选择器中，sass将不知如何将其生成到对应css文件中的相应位置，于是这些注释被抹掉。 1234body &#123; color /* 这块注释内容不会出现在生成的css中 */: #333; padding: 1; /* 这块注释内容也不会出现在生成的css中 */ 0;&#125; 混合器混合器允许用户编写语义化样式的同时避免视觉层面上样式的重复。 你可以通过sass的混合器实现大段样式的重用。 混合器使用@mixin标识符定义。这个标识符给一大段样式赋予一个名字，这样你就可以轻易地通过引用这个名字重用这段样式。 1234567891011// 声明混合器@mixin rounded-corners &#123; -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px;&#125;// 使用混合器div p &#123; color: red; @include rounded-corners;&#125; 何时使用混合器一条经验法则就是你能否为这个混合器想出一个好的名字。如果你能找到一个很好的短名字来描述这些属性修饰的样式，比如rounded-cornersfancy-font或者no-bullets，那么往往能够构造一个合适的混合器。 如果你找不到，这时候构造一个混合器可能并不合适。 混合器中的CSS规则混合器中不仅可以包含属性，也可以包含css规则，包含选择器和选择器中的属性。 1234567891011121314// 定义一个嵌套css混合@mixin no-bullets &#123; list-style: none; li &#123; list-style-image: none; list-style-type: none; margin-left: 0px; &#125;&#125;// 使用混合ul.plain &#123; color: #444; @include no-bullets;&#125; 编译后 123456789ul.plain &#123; color: #444; list-style: none;&#125;ul.plain li &#123; list-style-image: none; list-style-type: none; margin-left: 0px;&#125; 给混合器传参可以通过在@include混合器时给混合器传参，来定制混合器生成的精确样式。 // 声明带参数的混合 12345@mixin link-colors($normal, $hover, $visited) &#123; color: $normal; &amp;:hover &#123; color: $hover; &#125; &amp;:visited &#123; color: $visited; &#125;&#125; // 使用带参数的混合 123456789101112// 使用1p a &#123; @include link-colors(red, blue, white);&#125;// 使用2（好处是表明每个参数的意思和顺序）a &#123; @include link-colors( $normal: blue, $visited: green, $hover: red );&#125; 编译后 123p a &#123; color: blue; &#125;p a:hover &#123; color: red; &#125;p a:visited &#123; color: green; &#125; 默认参数值1234567891011// 默认都使用$normal的值@mixin link-colors( $normal, $hover: $normal, $visited: $normal )&#123; color: $normal; &amp;:hover &#123; color: $hover; &#125; &amp;:visited &#123; color: $visited; &#125;&#125; 使用混合 1234567891011@include link-colors(red)编译后p a &#123; color: red; &#125;p a:hover &#123; color: red; &#125;p a:visited &#123; color: red; &#125; 使用混合 1234567891011@include link-colors(red, blue, white)编译后p a &#123; color: red; &#125;p a:hover &#123; color: blue; &#125;p a:visited &#123; color: white; &#125; 使用选择器继承来精简CSS继承允许你声明类之间语义化的关系，通过这些关系可以保持你的css的整洁和可维护性。 选择器继承是说一个选择器可以继承为另一个选择器定义的所有样式。这个通过@extend语法实现。编译前 123456789//通过选择器继承继承样式.error &#123; border: 1px solid red; background-color: #fdd;&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125; 编译后 1234567.error, .seriousError &#123; border: 1px solid red; background-color: #fdd; &#125;.seriousError &#123; border-width: 3px; &#125; .seriousError不仅会继承.error自身的所有样式，任何跟.error有关的组合选择器样式也会被.seriousError以组合选择器的形式继承 12345678//.seriousError从.error继承样式.error a&#123; //应用到.seriousError a color: red; font-weight: 100;&#125;h1.error &#123; //应用到hl.seriousError font-size: 1.2rem;&#125; 何时使用继承混合器主要用于展示性样式的重用，而类名用于语义化样式的重用。 当一个元素拥有的类（比如说.seriousError）表明它属于另一个类（比如说.error），这时使用继承再合适不过了。 综上所述你应该使用@extend。让.seriousError从.error继承样式，使两者之间的关系非常清晰。 更重要的是无论你在样式表的哪里使用.error.seriousError都会继承其中的样式。 继承的高级用法接下来的这段代码定义了一个名为disabled的类，样式修饰使它看上去像一个灰掉的超链接。通过继承a这一超链接元素来实现 编译前 1234567a &#123; background: #fff;&#125;.disabled &#123; color: gray; @extend a;&#125; 编译后 1234567a, .disabled &#123; background: #fff; &#125;.disabled &#123; color: gray; &#125; 继承的工作细节@extend背后最基本的想法是，如果.seriousError @extend .error， 那么样式表中的任何一处.error都用.error.seriousError这一选择器组进行替换。 @extend的优点 跟混合器相比，继承生成的css代码相对更少。因为继承仅仅是重复选择器，而不会重复属性，所以使用继承往往比混合器生成的css体积更小。如果你非常关心你站点的速度，请牢记这一点。 继承遵从css层叠的规则。当两个不同的css规则应用到同一个html元素上时，并且这两个不同的css规则对同一属性的修饰存在不同的值，css层叠规则会决定应用哪个样式。相当直观：通常权重更高的选择器胜出，如果权重相同，定义在后边的规则胜出。 使用继承的最佳实践通常使用继承会让你的css美观、整洁。因为继承只会在生成css时复制选择器，而不会复制大段的css属性。 避免这种情况出现的最好方法就是不要在css规则中使用后代选择器（比如.foo .bar）去继承css规则。 小知识点 占位符选择器 %foo (Placeholder Selectors: %foo) 字符串 (Strings) 有引号字符串 与 无引号字符串 (unquoted strings) 数组 (Lists) nth 函数可以直接访问数组中的某一项； join 函数可以将多个数组连接在一起； append 函数可以在数组中添加新值； @each 指令能够遍历数组中的每一项。 Maps $map: (key1: value1, key2: value2, key3: value3); 颜色 (Colors) 运算 (Operations)所有数据类型均支持相等运算 == 或 !=，此外，每种数据类型也有其各自支持的运算方式。SassScript 支持数字的加减乘除、取整等运算 (+, -, *, /, %)，如果必要会在不同单位间转换值。字符串运算 (String Operations) 123p &#123; cursor: e + -resize;&#125; 布尔运算 (Boolean Operations)SassScript 支持布尔型的 and or 以及 not 运算。 圆括号 (Parentheses) width: 1em + (2em * 3); 插值语句 #{} (Interpolation: #{}) $attr: border; #{$attr}-color: blue; &amp; in SassScript 父选择器标识符 变量定义 !default (Variable Defaults: !default) @import 并可以嵌套 导入其他scss文件 @extend 控制指令 (Control Directives)@if 声明后面可以跟多个 @else if 声明，或者一个 @else 声明。 @if 1 + 1 == 2 { border: 1px solid; } @if 5 &lt; 3 { border: 2px dotted; }@for 123@for $i from 1 through 3 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;&#125; @each 12345@each $animal in puma, sea-slug, egret, salamander &#123; .#&#123;$animal&#125;-icon &#123; background-image: url(&apos;/images/#&#123;$animal&#125;.png&apos;); &#125;&#125; @while 12345$i: 6;@while $i &gt; 0 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125; $i: $i - 2;&#125; 总结变量（声明及使用）： 可以声明全局和局部变量。声明方法：$var-name 嵌套CSS规则： article a { color: blue; &amp;:hover { color: red } // 父选择器的标识符&amp;，此时代表 a 元素 } 导入SASS文件： 在一个scss文件同导入其他scss文件。导入方法：@import &quot;sidebar&quot;; 静默注释： 在scss文件中有注释，编译之后注释被抹掉。注释方法为：// 混合器： 混合器允许用户编写语义化样式的同时避免视觉层面上样式的重复。 定义混合器使用@mixin标识符。 使用混合器@include。 使用选择器继承来精简CSS： 继承允许你声明类之间语义化的关系，通过这些关系可以保持你的css的整洁和可维护性。 这个通过@extend语法实现。 参考文档： Sass中文网]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>Sass</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa学习-搭建项目]]></title>
    <url>%2F2017%2Fkoa%E5%AD%A6%E4%B9%A0-%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE.html</url>
    <content type="text"><![CDATA[参考文档： koa-note cookies]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa学习-debug]]></title>
    <url>%2F2017%2Fkoa%E5%AD%A6%E4%B9%A0-debug.html</url>
    <content type="text"><![CDATA[环境node环境 8.x + chrome 60+ index.js 12345678910const Koa = require(&apos;koa&apos;)const app = new Koa()app.use( async ( ctx ) =&gt; &#123; ctx.body = &apos;hello koa2&apos;&#125;)app.listen(3000, () =&gt; &#123; console.log(&apos;[demo] start-quick is starting at port 3000&apos;)&#125;) 进行调试node --inspect index.js 在控制台上点击node调试，会弹出新窗口，此时就可以进入调试--如打断点。 参考文档： debug]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa学习-测试]]></title>
    <url>%2F2017%2Fkoa%E5%AD%A6%E4%B9%A0-%E6%B5%8B%E8%AF%95.html</url>
    <content type="text"><![CDATA[mocha 模块是测试框架chai 模块是用来进行测试结果断言库，比如一个判断 1 + 1 是否等于 2supertest 模块是http请求测试库，用来请求API接口 单元测试所需测试demo 123456789101112131415161718192021222324252627282930313233343536373839const koa = require(&apos;koa&apos;);const app = new koa();const server = async (ctx, next) =&gt; &#123; let result = &#123; success: true, data: null &#125;; if (ctx.method === &apos;GET&apos;) &#123; if (ctx.url === &apos;/getString.json&apos;) &#123; result.data = &apos;this is string data&apos;; &#125; else if (ctx.url === &apos;/getNumber.json&apos;)&#123; result.data = 123456; &#125; else &#123; result.success = false; &#125; ctx.body = result; next &amp;&amp; next(); &#125; else if (ctx.method === &apos;POST&apos;) &#123; if (ctx.url === &apos;/postData.json&apos;) &#123; result.data = &apos;ok&apos;; &#125; else &#123; result.success = false; &#125; ctx.body = result; next &amp;&amp; next(); &#125; else &#123; ctx.body = &apos;hello world&apos;; next &amp;&amp; next(); &#125;&#125;;app.use(server);module.exports = app;app.listen(3004, () =&gt; &#123; console.log(&apos;[demo] test-unit is starting at port 3004&apos;)&#125;); 测试代码123456789101112131415161718192021222324const supertest = require(&apos;supertest&apos;)const chai = require(&apos;chai&apos;)const app = require(&apos;./../index&apos;)const expect = chai.expectconst request = supertest( app.listen() )// 测试套件/组describe( &apos;开始测试demo的GET请求&apos;, ( ) =&gt; &#123; // 测试用例 it(&apos;测试/getString.json请求&apos;, ( done ) =&gt; &#123; request .get(&apos;/getString.json&apos;) .expect(200) .end(( err, res ) =&gt; &#123; // 断言判断结果是否为object类型 expect(res.body).to.be.an(&apos;object&apos;) expect(res.body.success).to.be.an(&apos;boolean&apos;) expect(res.body.data).to.be.an(&apos;string&apos;) done() &#125;) &#125;)&#125;) 参考文档： koa-note koa-jsonp]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa学习-jsonp实现]]></title>
    <url>%2F2017%2Fkoa%E5%AD%A6%E4%B9%A0-jsonp%E5%AE%9E%E7%8E%B0.html</url>
    <content type="text"><![CDATA[原生koa2实现jsonp123456789101112131415161718192021222324252627282930const koa = require(&apos;koa&apos;);const app = new koa();app.use(async (ctx) =&gt; &#123; // 判断是否为jsonp的请求 if (ctx.method === &apos;GET&apos; &amp;&amp; ctx.url.split(&apos;?&apos;)[0] === &apos;/getData.jsonp&apos;) &#123; // 获取jsonp的callback let callbackName = ctx.query.callback || &apos;callback&apos;; let returnData = &#123; success: true, data: &#123; text: &apos;this is a jsonp api&apos;, time: new Date().getTime() &#125; &#125; // jsonp的script字符串 let jsonpStr = `;$&#123;callbackName&#125;($&#123;JSON.stringify(returnData)&#125;)`; // 用text/javascript，让请求支持跨域获取 ctx.type = &apos;text/javascript&apos;; // 输出jsonp字符串 ctx.body = jsonpStr &#125; else &#123; ctx.body = &apos;hello jsonp&apos;; &#125;&#125;);app.listen(3004, () =&gt; &#123; console.log(&apos;[demo] jsonp is starting at port 3004&apos;)&#125;); koa-jsonp中间件实现12345678910111213141516171819202122const koa = require(&apos;koa&apos;);const jsonp = require(&apos;koa-jsonp&apos;);const app = new koa();app.use(jsonp());app.use(async (ctx) =&gt; &#123; let returnData = &#123; success: true, data: &#123; text: &apos;this is a jsonp api&apos;, time: new Date().getTime(), &#125; &#125;; // 直接输出json ctx.body = returnData;&#125;);app.listen(3004, () =&gt; &#123; console.log(&apos;[demo] jsonp is starting at port 3004&apos;)&#125;); 参考文档： koa-note koa-jsonp]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa学习-数据库mysql]]></title>
    <url>%2F2017%2Fkoa%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E5%BA%93mysql.html</url>
    <content type="text"><![CDATA[模块介绍123456789101112131415161718const mysql = require(&apos;mysql&apos;);// 数据库的配置信息const connection = mysql.createConnection(&#123; host: &apos;localhost&apos;, port: 3306, user: &apos;root&apos;, password: &apos;root&apos;, database: &apos;sql&apos;&#125;);// 连接数据库connection.connect();// 进行数据库操作connection.query(&apos;SELECT * FROM apps&apos;, (err, result) =&gt; &#123; if (err) throw err; console.log(result);&#125;);// 关闭连接connection.end(); 创建数据连接池一般情况下操作数据库是很复杂的读写过程，不只是一个会话，如果直接用会话操作，就需要每次会话都要配置连接参数。 所以这时候就需要连接池管理会话。 123456789101112131415161718const mysql = require(&apos;mysql&apos;);const pool = mysql.createPool(&#123; host: &apos;localhost&apos;, port: 3306, user: &apos;root&apos;, password: &apos;root&apos;, database: &apos;sql&apos;&#125;);// 在数据池中进行会话操作pool.getConnection((err, connection) =&gt; &#123; connection.query(&apos;SELECT * FROM apps&apos;, (err, result) =&gt; &#123; console.log(result); // 连接完成，连接将返回连接池 connection.release(); if (err) throw err; &#125;)&#125;); 使用promise和async-await来封装12345678910111213141516171819202122232425262728293031323334353637383940// promise.jsconst mysql = require(&apos;mysql&apos;);const pool = mysql.createPool(&#123; host : &apos;127.0.0.1&apos;, user : &apos;root&apos;, password : &apos;root&apos;, database : &apos;sql&apos;&#125;);let query = function (sql) &#123; return new Promise((resolve, reject) =&gt; &#123; pool.getConnection((err, connection) =&gt; &#123; if (err) &#123; reject(err); &#125; else &#123; connection.query(sql, (err, rows) =&gt; &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(rows); &#125; connection.release(); &#125;); &#125; &#125;); &#125;);&#125;module.exports = query;// async.jsconst query = require(&apos;./promise&apos;);async function getData (sql) &#123; let dataList = await query(sql); console.log(dataList);&#125;getData(&apos;SELECT * FROM sql&apos;); 建表初始化+----------+ 遍历sql +---+ 解析所有sql +---+ 执行sql +------------&gt; | | 目录下的 | | 文件脚本 | | 脚本 | | +----------+ sql文件 +---+ 内容 +---+ +------------&gt; [详细代码见]() 参考文档： koa-note cookies]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa学习-文件上传]]></title>
    <url>%2F2017%2Fkoa%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0.html</url>
    <content type="text"><![CDATA[busboy模块模块是用来解析POST请求，node原生req中的文件流。 busboy 是用来解析出请求中文件流。 封装上传文件到写入服务的方法创建上传模块upload.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101const inspect = require(&apos;util&apos;).inspect;const path = require(&apos;path&apos;);const os = require(&apos;os&apos;);const fs = require(&apos;fs&apos;);const Busboy = require(&apos;busboy&apos;);/** 同步创建文件目录* @param &#123;string&#125; dirname 目录绝对地址* @return &#123;boolean&#125; 创建目录结果*/function mkdirsSync (dirname) &#123; if (fs.existsSync(dirname)) &#123; return true; &#125; else &#123; if (mkdirsSync(path.dirname(dirname))) &#123; fs.mkdirSync(dirname); return true; &#125; &#125;&#125;/** 获取上传文件的后缀名* @param &#123;string&#125; fileName 获取上传文件的后缀名* @return &#123;string&#125; 文件后缀名*/function getSuffixName (fileName) &#123; /*let nameList = fileName.split(&apos;.&apos;); return nameList[nameList.length-1]*/ return path.extname(fileName);&#125;/** 上传文件* @param &#123;object&#125; ctx koa上下文* @param &#123;object&#125; options 文件上传参数 fileType文件类型， path文件存放路径* @return &#123;promise&#125;*/function uploadFile (ctx, options) &#123; let req = ctx.req; let res = ctx.res; let busboy = new Busboy(&#123;headers: req.headers&#125;); // 获取类型 let fileType = options.fileType || &apos;common&apos;; let filePath = path.join(options.path, fileType); let mkdirResult = mkdirsSync(filePath); return new Promise((resolve, reject) =&gt; &#123; console.log(&apos;文件上传中...&apos;); let result = &#123; success: false, formData: &#123;&#125;, &#125;; // 解析请求文件事件 busboy.on(&apos;file&apos;, function(fieldname, file, filename, encoding, mimetype) &#123; let fileName = Math.random().toString(16).substr(2) + &apos;.&apos; + getSuffixName(filename) let _uploadFilePath = path.join( filePath, fileName ) let saveTo = path.join(_uploadFilePath) // 文件保存到制定路径 file.pipe(fs.createWriteStream(saveTo)) // 文件写入事件结束 file.on(&apos;end&apos;, function() &#123; result.success = true result.message = &apos;文件上传成功&apos; console.log(&apos;文件上传成功！&apos;) resolve(result) &#125;) &#125;) // 解析表单中其他字段信息 busboy.on(&apos;field&apos;, function(fieldname, val, fieldnameTruncated, valTruncated, encoding, mimetype) &#123; console.log(&apos;表单字段数据 [&apos; + fieldname + &apos;]: value: &apos; + inspect(val)); result.formData[fieldname] = inspect(val); &#125;); // 解析结束事件 busboy.on(&apos;finish&apos;, function( ) &#123; console.log(&apos;文件上结束&apos;) resolve(result) &#125;) // 解析错误事件 busboy.on(&apos;error&apos;, function(err) &#123; console.log(&apos;文件上出错&apos;) reject(result) &#125;) req.pipe(busboy) &#125;);&#125;module.exports = &#123; uploadFile&#125; 入口文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445const Koa = require(&apos;koa&apos;)const path = require(&apos;path&apos;)const app = new Koa()// const bodyParser = require(&apos;koa-bodyparser&apos;)const &#123; uploadFile &#125; = require(&apos;./util/upload&apos;)// app.use(bodyParser())app.use( async ( ctx ) =&gt; &#123; if ( ctx.url === &apos;/&apos; &amp;&amp; ctx.method === &apos;GET&apos; ) &#123; // 当GET请求时候返回表单页面 let html = ` &lt;h1&gt;koa2 upload demo&lt;/h1&gt; &lt;form method=&quot;POST&quot; action=&quot;/upload.json&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;p&gt;file upload&lt;/p&gt; &lt;span&gt;picName:&lt;/span&gt;&lt;input name=&quot;picName&quot; type=&quot;text&quot; /&gt;&lt;br/&gt; &lt;input name=&quot;file&quot; type=&quot;file&quot; /&gt;&lt;br/&gt;&lt;br/&gt; &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt; &lt;/form&gt; ` ctx.body = html &#125; else if ( ctx.url === &apos;/upload.json&apos; &amp;&amp; ctx.method === &apos;POST&apos; ) &#123; // 上传文件请求处理 let result = &#123; success: false &#125; let serverFilePath = path.join( __dirname, &apos;upload-files&apos; ) // 上传文件事件 result = await uploadFile( ctx, &#123; fileType: &apos;album&apos;, // common or album path: serverFilePath &#125;) ctx.body = result &#125; else &#123; // 其他请求显示404 ctx.body = &apos;&lt;h1&gt;404！！！ o(╯□╰)o&lt;/h1&gt;&apos; &#125;&#125;)app.listen(3004, () =&gt; &#123; console.log(&apos;[demo] upload-simple is starting at port 3000&apos;)&#125;) 参考文档： koa-note cookies]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa学习-模版引擎]]></title>
    <url>%2F2017%2Fkoa%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E.html</url>
    <content type="text"><![CDATA[koa2加载模板引擎koa-views - 为koa模版渲染中间件 ejs - 模版引擎 关键代码： 1234567891011121314151617181920const views = require(&apos;koa-views&apos;)const path = require(&apos;path&apos;)app.use(views(path.join(__dirname, &apos;./view&apos;), &#123; extension: &apos;ejs&apos;&#125;));app.use(async (ctx) =&gt; &#123; if (ctx.url === &apos;/&apos;) &#123; let title = &apos;hello koa2&apos;; await ctx.render(&apos;index&apos;, &#123; title, &#125;); &#125; else &#123; let title = &apos;other&apos;; await ctx.render(&apos;index&apos;, &#123; title, &#125;); &#125; &#125;); ejs模板引擎1 参考文档： koa-note koa-views ejs]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa学习-cookie/session]]></title>
    <url>%2F2017%2Fkoa%E5%AD%A6%E4%B9%A0-cookie-session.html</url>
    <content type="text"><![CDATA[koa2使用cookiekoa提供了从上下文直接读取、写入cookie的方法 ctx.cookies.get(name, [options]) 读取上下文请求中的cookie ctx.cookies.set(name, value, [options]) 在上下文写入cookie关键代码：12345678910111213141516171819const cookies = require(&apos;cookies&apos;);app.use(async (ctx) =&gt; &#123; if (ctx.url === &apos;/&apos;) &#123; // 设置cookies ctx.cookies.set(&apos;username&apos;, &apos;fanerge222&apos;, &#123; domain: &apos;localhost&apos;, // 写cookie所在的域名 path: &apos;/&apos;, // 写cookie所在的路径 maxAge: 10 * 60 * 1000, // cookie有效时长 expires: new Date(&apos;2017-08-18&apos;), // cookie失效时间 httpOnly: false, // 是否只用于http请求中获取 overwrite: false // 是否允许重写 &#125;); ctx.body = &apos;cookies写入成功&apos; &#125; else &#123; // 获取cookie const cookie = ctx.cookies.get(&apos;username&apos;); // &apos;fanerge222&apos; ctx.body = cookie &#125;&#125;) koa2实现sessionkoa2原生功能只提供了cookie的操作，但是没有提供session操作。session就只用自己实现或者通过第三方中间件实现。 在koa2中实现session的方案有以下几种 如果session数据量很小，可以直接存在内存中 如果session数据量很大，则需要存储介质存放session数据数据库存储方案 将session存放在MySQL数据库中 需要用到中间件koa-session-minimal 适用于koa2 的session中间件，提供存储介质的读写接口 。koa-mysql-session 为koa-session-minimal中间件提供MySQL数据库的session数据读写操作。 将sessionId和对应的数据存到数据库 将数据库的存储的sessionId存到页面的cookie中 根据cookie的sessionId去获取对于的session信息关键代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const session = require(&apos;koa-session-minimal&apos;)const MysqlSession = require(&apos;koa-mysql-session&apos;)// 配置存储session信息的mysqllet store = new MysqlSession(&#123; user: &apos;root&apos;, password: &apos;root&apos;, database: &apos;koa_demo&apos;, host: &apos;127.0.0.1&apos;,&#125;)// 存放SESSION_ID的cookie配置let cookie = &#123; maxAge: &apos;&apos;, // cookie有效时长 expires: &apos;&apos;, // cookie失效时间 path: &apos;&apos;, // 写cookie所在的路径 domain: &apos;&apos;, // 写cookie所在的域名 httpOnly: &apos;&apos;, // 是否只用于http请求中获取 overwrite: &apos;&apos;, // 是否允许重写 secure: &apos;&apos;, sameSite: &apos;&apos;, signed: &apos;&apos;,&#125;// 使用session中间件app.use(session(&#123; key: &apos;SESSION_ID&apos;, store: store, // 使用数据库来存储 cookie: cookie // 将SESSION_ID存在cookie中&#125;))app.use( async ( ctx ) =&gt; &#123; // 设置session if ( ctx.url === &apos;/set&apos; ) &#123; ctx.session = &#123; user_id: Math.random().toString(36).substr(2), count: 0 &#125; ctx.body = ctx.session &#125; else if ( ctx.url === &apos;/&apos; ) &#123; // 读取session信息 ctx.session.count = ctx.session.count + 1 ctx.body = ctx.session &#125; &#125;) 参考文档： koa-note koa-static koa-session-minimal koa-mysql-session]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa学习-静态资源加载]]></title>
    <url>%2F2017%2Fkoa%E5%AD%A6%E4%B9%A0-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD.html</url>
    <content type="text"><![CDATA[原生koa2实现静态资源服务器一个http请求访问web服务静态资源，一般响应结果有三种情况 访问文本，例如html，js，css，png，jpg，gif 访问静态目录 找不到资源，抛出404错误这里由于代码量过多，请查看源代码这里由于代码量过多，请查看源代码koa-static中间件使用koa-static作为koaweb框架的静态服务器中间件使用关键代码:// 导入koa-static模块 const static = require(&apos;koa-static&apos;); // 设置静态资源的更目录 const staticPath = &apos;./static&apos;; // 使用静态资源中间件 app.use(static(path.join(__dirname, staticPath))); 参考文档：koa-notecookies]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa学习-请求数据获取]]></title>
    <url>%2F2017%2Fkoa%E5%AD%A6%E4%B9%A0-%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96.html</url>
    <content type="text"><![CDATA[GET请求数据获取获取GET请求数据源头是koa中request对象中的query方法或querystring方法， query返回是格式化好的参数对象，querystring返回的是请求字符串。 由于ctx对request的API有直接引用的方式，所以获取GET请求数据有两个途径。 是从上下文中直接获取 请求对象ctx.query，返回如 { a:1, b:2 } 请求字符串 ctx.querystring，返回如 a=1&amp;b=2 是从上下文的request对象中获取 请求对象ctx.request.query，返回如 { a:1, b:2 } 请求字符串 ctx.request.querystring，返回如 a=1&amp;b=2关键代码： 1234567891011121314151617app.use(async (ctx) =&gt; &#123; let url = ctx.url; let request = ctx.request; // 使用ctx.request对象获取 let req_query = request.query; let req_querystring = request.querystring; // 使用ctx对其request属性的引用获取 let ctx_query = ctx.query; let ctx_querystring = ctx.querystring; ctx.body = &#123; url, req_query, req_querystring, ctx_query, ctx_querystring &#125;;&#125;); 输出：测试url：http://localhost:3000/?name=fanerge&amp;age=323 12345678910111213&#123; url: &quot;/?name=fanerge&amp;age=323&quot;, req_query: &#123; name: &quot;fanerge&quot;, age: &quot;323&quot; &#125;, req_querystring: &quot;name=fanerge&amp;age=323&quot;, ctx_query: &#123; name: &quot;fanerge&quot;, age: &quot;323&quot; &#125;, ctx_querystring: &quot;name=fanerge&amp;age=323&quot;&#125; POST请求参数获取解析出POST请求上下文中的表单数据 新建一个工具函数库：./util/index.js 1234567891011121314151617181920212223242526272829303132function parseQueryStr (queryStr) &#123; let queryData = &#123;&#125;; let queryStrList = queryStr.split(&apos;&amp;&apos;); console.log(queryStrList); for (let [index, queryStr] of queryStrList.entries()) &#123; let itemList = queryStr.split(&apos;=&apos;); queryData[itemList[0]] = decodeURIComponent(itemList[1]); &#125; return queryData;&#125;function parsePostData (ctx) &#123; return new Promise((resolve, reject) =&gt; &#123; try &#123; let postData = &quot;&quot;; ctx.req.addListener(&apos;data&apos;, (data) =&gt; &#123; postData += data; &#125;); ctx.req.addListener(&apos;end&apos;, ()=&gt; &#123; let parseData = parseQueryStr(postData); resolve(parseData); &#125;); &#125; catch (e) &#123; conole.error(e); reject(e); &#125; &#125;);&#125;module.exports= &#123; parsePostData,&#125;; post.js关键代码 12345678910111213141516171819202122232425const &#123;parsePostData&#125; = require(&apos;./util/index&apos;);app.use(async (ctx) =&gt; &#123; if (ctx.url === &apos;/&apos; &amp;&amp; ctx.method === &apos;GET&apos;) &#123; // 当get请求是返回表单页面 let html = ` &lt;h1&gt;koa2 request post demo&lt;/h1&gt; &lt;form method=&quot;POST&quot; action=&quot;/&quot;&gt; &lt;p&gt;userName&lt;/p&gt; &lt;input name=&quot;userName&quot; /&gt;&lt;br/&gt; &lt;p&gt;nickName&lt;/p&gt; &lt;input name=&quot;nickName&quot; /&gt;&lt;br/&gt; &lt;p&gt;email&lt;/p&gt; &lt;input name=&quot;email&quot; /&gt;&lt;br/&gt; &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt; &lt;/form&gt; `; ctx.body = html; &#125; else if (ctx.url === &apos;/&apos; &amp;&amp; ctx.method === &apos;POST&apos;) &#123; let postData = await parsePostData(ctx); ctx.body = postData; &#125; else &#123; ctx.body = &apos;没找到&apos; &#125;&#125;); 提交表单的数据 12345&#123; userName: &quot;67&quot;, nickName: &quot;89&quot;, email: &quot;0&quot;&#125; koa-bodyparser中间件对于POST请求的处理，koa-bodyparser中间件可以把koa2上下文的formData数据解析到ctx.request.body中 关键代码： 1234567891011121314151617181920212223242526const bodyParser = require(&apos;koa-bodyparser&apos;); // 引入该模块app.use(bodyParser()); // 使用ctx.body解析中间件app.use(async (ctx) =&gt; &#123; if (ctx.url === &apos;/&apos; &amp;&amp; ctx.method === &apos;GET&apos;) &#123; // 当GET请求时候返回表单页面 let html = ` &lt;h1&gt;koa2 request post demo&lt;/h1&gt; &lt;form method=&quot;POST&quot; action=&quot;/&quot;&gt; &lt;p&gt;userName&lt;/p&gt; &lt;input name=&quot;userName&quot; /&gt;&lt;br/&gt; &lt;p&gt;nickName&lt;/p&gt; &lt;input name=&quot;nickName&quot; /&gt;&lt;br/&gt; &lt;p&gt;email&lt;/p&gt; &lt;input name=&quot;email&quot; /&gt;&lt;br/&gt; &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt; &lt;/form&gt; ` ctx.body = html &#125; else if (ctx.url === &apos;/&apos; &amp;&amp; ctx.method === &apos;POST&apos;) &#123; // 当POST请求的时候，中间件koa-bodyparser解析POST表单里的数据，并显示出来 let postData = ctx.request.body; ctx.body = postData; &#125; else &#123; ctx.body = &apos;没找到404&apos;; &#125;&#125;); 参考文档： koa-note koa-bodyparser]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa学习-中间件和路由]]></title>
    <url>%2F2017%2Fkoa%E5%AD%A6%E4%B9%A0-%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%92%8C%E8%B7%AF%E7%94%B1.html</url>
    <content type="text"><![CDATA[koa中间件的制作和使用koa模版1234567var koa = require(&apos;koa&apos;);const app = new koa();// 中间件app.use(async (ctx) =&gt; &#123; ctx.body = &apos;hello koa2&apos;;&#125;);app.listen(3000); async/await123456789101112131415161718192021function getSyncTime () &#123; return new Promise((resolve, reject) =&gt; &#123; try &#123; let startTime = new Date().getTime(); setTimeout(() =&gt; &#123; let endTime = new Date().getTime(); let data = endTime - startTime; resolve(data); &#125;, 500); &#125; catch (e) &#123; reject(e); &#125; &#125;);&#125;async function getSyncData () &#123; let time = await getSyncTime(); let data = `endTime - startTime = $&#123;time&#125;`; console.log(data);&#125;getSyncData(); koa2简析结构源码文件： ├── lib │ ├── application.js │ ├── context.js │ ├── request.js │ └── response.js └── package.json 文件说明： application.js 是整个koa2 的入口文件，封装了context，request，response，以及最核心的中间件处理流程。 context.js 处理应用上下文，里面直接封装部分request.js和response.js的方法 request.js 处理http请求 response.js 处理http响应 koa中间件开发和使用以日志中间件为例 middleware/logger-async.js 12345678910function log (ctx) &#123; console.log(`请求方法：$&#123;ctx.method&#125;, host：$&#123;ctx.header.host&#125;, url：$&#123;ctx.url&#125;`);&#125;module.exports = function () &#123; return async function (ctx, next)&#123; log(ctx); await next(); &#125;;&#125;; 使用该中间件logger 123const loggerAsync = require(&apos;./middleware/logger-async&apos;);// 使用日志中间件app.use(loggerAsync()); koa路由中间件koa2原生路由实现获取url：ctx.request.url 后端路由：根据前端get请求的url地址，后端返回对应的view页面达到。 koa-router中间件安装koa-router中间件 npm install --save koa-router 使用koa-router 123456789101112131415161718192021222324252627282930313233343536373839404142// 子路由1let home = new Router();home.get(&apos;/&apos;, async (ctx) =&gt; &#123; let html = ` &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;/&quot;&gt;/&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/page&quot;&gt;/page&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/page/helloword&quot;&gt;/page/helloword&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/page/chengdu&quot;&gt;/page/chengdu&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/page/ss&quot;&gt;not found&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; `; ctx.body = html;&#125;);// 子路由2let page = new Router();page.get(&apos;/&apos;, async (ctx) =&gt; &#123; ctx.body = &apos;page主页&apos;;&#125;).get(&apos;/chengdu&apos;, async (ctx) =&gt; &#123; ctx.body = &apos;欢迎来到成都&apos;;&#125;).get(&apos;/helloword&apos;, (ctx) =&gt; &#123; ctx.body = &apos;helloword page&apos;;&#125;);// 子路由3-Not foundlet notFound = new Router();notFound.get(&apos;*&apos;, async (ctx) =&gt; &#123; ctx.body = &apos;没有找到！&apos;;&#125;);// 装载所有的子路由let router = new Router();router.use(&apos;/&apos;, home.routes(), home.allowedMethods());router.use(&apos;/page&apos;, page.routes(), page.allowedMethods());router.use(&apos;*&apos;, notFound.routes(), notFound.allowedMethods());// 加载路由中间件app.use(router.routes()).use(router.allowedMethods()); 参考文档： koa2-note koa-router官方文档]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP模块]]></title>
    <url>%2F2017%2Fnodejs%E8%87%AA%E5%B8%A6%E6%A8%A1%E5%9D%97-HTTP.html</url>
    <content type="text"><![CDATA[要使用 HTTP 服务器与客户端，需要 require(‘http’)。Node.js 中的 HTTP 接口被设计成支持协议的许多特性。 比如，大块编码的消息。 这些接口不缓冲完整的请求或响应，用户能够以流的形式处理数据。 http.Agent 类Agent 负责为 HTTP 客户端管理连接的持续与复用。 它为一个给定的主机与端口维护着一个等待请求的队列，且为每个请求重复使用一个单一的 socket 连接直到队列为空，此时 socket 会被销毁或被放入一个连接池中，在连接池中等待被有着相同主机与端口的请求再次使用。 是否被销毁或被放入连接池取决于 keepAlive 选项。 new Agent([options]) 作用：实例化一个代理 代理的配置选项。 var agent = new Agent([options]); agent.createConnection(options[, callback]) 作用：创建一个用于 HTTP 请求的 socket 或流。 agent.keepSocketAlive(socket) 作用：在 socket 被请求分离的时候调用, 可能被代理持续使用。 agent.reuseSocket(socket, request) 作用：由于 keep-alive 选项被保持持久化, 在 socket 附加到 request 时调用。 agent.destroy() 作用：销毁当前正被代理使用的任何 socket。 agent.freeSockets 作用：返回一个对象，包含当前正在等待被启用了 keepAlive 的代理使用的 socket 数组。 不要修改该属性。 agent.getName(options) 作用：为请求选项的集合获取一个唯一的名称，用来判断一个连接是否可以被复用。 agent.maxFreeSockets 作用：默认为 256。 对于已启用 keepAlive 的代理，该属性可设置要保留的空闲 socket 的最大数量。 agent.maxSockets 作用：默认为不限制。 该属性可设置代理为每个来源打开的并发 socket 的最大数量。 agent.requests 作用：返回一个对象，包含还未被分配到 socket 的请求队列。 不要修改。 agent.sockets 作用：返回一个对象，包含当前正被代理使用的 socket 数组。 不要修改。http.ClientRequest 类该对象在 http.request() 内部被创建并返回。 它表示着一个正在处理的请求，其请求头已进入队列。 请求头仍可使用 setHeader(name, value)、getHeader(name) 和 removeHeader(name) API 进行修改。 abort事件当请求已被客户端终止时触发。 该事件仅在首次调用 abort() 时触发。 aborted事件当请求已被服务器终止且网络 socket 已关闭时触发。 connect事件每当服务器响应 CONNECT 请求时触发。 continue事件当服务器发送了一个 100 Continue 的 HTTP 响应时触发，通常是因为请求包含 Expect: 100-continue。 这是客户端将要发送请求主体的指令。 response事件当请求的响应被接收到时触发。 该事件只触发一次。 socket事件当 socket 被分配到请求后触发。 upgrade事件每当服务器响应 upgrade 请求时触发。 request.abort()标记请求为终止。 调用该方法将使响应中剩余的数据被丢弃且 socket 被销毁。 request.aborted如果请求已被终止，则该属性的值为请求被终止的时间，从 1 January 1970 00:00:00 UTC 到现在的毫秒数。 request.connection request.end([data[, encoding]][, callback])结束发送请求。 request.flushHeaders()刷新请求头。 request.setNoDelay([noDelay])一旦 socket 被分配给请求且已连接，socket.setNoDelay() 会被调用。 request.setSocketKeepAlive([enable][, initialDelay])一旦 socket 被分配给请求且已连接，socket.setKeepAlive() 会被调用。 request.setTimeout(timeout[, callback])一旦 socket 被分配给请求且已连接，socket.setTimeout() 会被调用。 request.socket引用底层socket。 request.write(chunk[, encoding][, callback])发送请求主体的一个数据块。http.Server 类该类继承自 net.Server，且具有以下额外的事件 checkContinue 事件每当接收到一个带有 HTTP Expect: 100-continue 请求头的请求时触发。 checkExpectation 事件每当接收到一个带有 HTTP Expect 请求头（值不为 100-continue）的请求时触发。 clientError 事件如果客户端触发了一个 ‘error’ 事件，则它会被传递到这里。 close事件当服务器关闭时触发。 connect事件每当客户端发送 HTTP CONNECT 请求时触发。 connection事件当一个新的 TCP 流被建立时触发。 request事件每次接收到一个请求时触发。 upgrade事件每当客户端发送 HTTP upgrade 请求时触发。 server.close([callback])停止服务端接收新的连接。 server.listen(handle[, callback])handle 对象可以被设为一个服务器或 socket（任何带有一个 _handle 成员的对象）、或一个 {fd: } 对象。 server.listen(path[, callback])启动一个 UNIX socket 服务器，并在给定的 path 上监听连接。 server.listen([port][, hostname][, backlog][, callback])开始在指定的 port 和 hostname 上接受连接。 server.listening返回一个布尔值，表示服务器是否正在监听连接。 server.maxHeadersCount限制请求头的最大数量，默认为 2000。 如果设为 0，则没有限制。 server.setTimeout([msecs][, callback])设置 socket 的超时时间。 server.timeoutsocket 被认定为超时的空闲毫秒数。 server.keepAliveTimeout服务器完成最后的响应之后需要等待的额外的传入数据的活跃毫秒数, socket 才能被销毁。http.ServerResponse 类该对象在 HTTP 服务器内部被创建。 它作为第二个参数被传入 ‘request’ 事件。 close事件当底层连接在 response.end() 被调用或能够刷新之前被终止时触发。 finish事件当响应已被发送时触发。 response.addTrailers(headers)该方法会添加 HTTP 尾部响应头（一种在消息尾部的响应头）到响应。 response.connection response.end([data][, encoding][, callback])该方法会通知服务器，所有响应头和响应主体都已被发送，即服务器将其视为已完成。 response.finished返回一个布尔值，表示响应是否已完成。 response.getHeader(name)读取一个已入队列但尚未发送到客户端的响应头。 response.getHeaderNames()返回一个包含当前响应唯一名称的 http 头信息名称数组. 名称均为小写。 response.getHeaders()返回当前响应头文件的浅拷贝。 response.hasHeader(name)如果响应头当前有设置 name 头部，返回 true。 response.headersSent返回一个布尔值（只读）。 response.removeHeader(name)从隐式发送的队列中移除一个响应头。 response.sendDate当为 true 时，如果响应头里没有日期响应头，则日期响应头会被自动生成并发送。 response.setHeader(name, value)为一个隐式的响应头设置值。 response.setTimeout(msecs[, callback])设置 socket 的超时时间为 msecs。 response.socket引用底层socket。 response.statusCode当使用隐式的响应头时（没有显式地调用 response.writeHead()），该属性控制响应头刷新时将被发送到客户端的状态码。 response.statusMessage使用隐式的响应头时（没有显式地调用 response.writeHead()），该属性控制响应头刷新时将被发送到客户端的状态信息。 response.write(chunk[, encoding][, callback])如果该方法被调用且 response.writeHead() 没有被调用，则它会切换到隐式响应头模式并刷新隐式响应头。 response.writeContinue()发送一个 HTTP/1.1 100 Continue 消息到客户端，表示请求主体可以开始发送。 参阅 Server 的 ‘checkContinue’ 事件。 response.writeHead(statusCode[, statusMessage][, headers])发送一个响应头给请求。 http.IncomingMessage 类IncomingMessage 对象由 http.Server 或 http.ClientRequest 创建，并作为第一个参数分别递给 ‘request’ 和 ‘response’ 事件。 它可以用来访问响应状态、消息头、以及数据。 参考文档：HTTP参考-api]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[url模块-网址]]></title>
    <url>%2F2017%2Fnodejs%E8%87%AA%E5%B8%A6%E6%A8%A1%E5%9D%97-url.html</url>
    <content type="text"><![CDATA[url 模块提供了一些实用函数，用于 URL 处理与解析。URL 字符串与 URL 对象一个 URL 字符串是一个结构化的字符串，它包含多个有意义的组成部分。 当被解析时，会返回一个 URL 对象，它包含每个组成部分作为属性。 ┌─────────────────────────────────────────────────────────────────────────────────────────────┐ &quot; https: // user : pass @ sub.host.com : 8080 /p/a/t/h ? query=string #hash &quot; │ │ │ │ │ hostname │ port │ │ │ │ │ │ │ │ ├──────── ──────┴──────┤ │ │ │ │ protocol │ │ username │ password │ host │ │ │ │ ├──────────┴──┼──────────┴──────────┼─────────────────────┤ │ │ │ │ origin │ │ origin │ pathname │ search │ hash │ ├─────────────┴─────────────────────┴─────────────────────┴──────────┴────────────────┴───────┤ │ href │ └─────────────────────────────────────────────────────────────────────────────────────────────┘ Constructor: new URL(input[, base])123const &#123; URL &#125; = require(&apos;url&apos;);const myURL = new URL(&apos;/foo&apos;, &apos;https://example.org/&apos;);// https://example.org/foo 一下实例均以：var myURL = new URL(‘https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash‘); url.hash作用：获取及设置URL的分段(hash)部分。 myURL.hash; // #hash url.host作用：获取及设置URL的主机(host)部分。 myURL.host; // user:pass@sub.host.com:8080 url.hostname作用：获取及设置URL的主机名(hostname)部分。 url.host和url.hostname之间的区别是url.hostname不 包含端口。 myURL.hostname; // user:pass@sub.host.com url.href作用：获取及设置序列化的URL。 myURL.href; // https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash url.origin作用：获取只读序列化的URL orgin部分。 myURL.origin; // https://user:pass@sub.host.com:8080 url.password作用：获取及设置URL的密码(password)部分。 myURL.password; // pass url.pathname作用：获取及设置URL的路径(path)部分。 myURL.pathname; // /p/a/t/h url.port作用：获取及设置URL的端口(port)部分。 myURL.port; 8080 url.protocol作用：获取及设置URL的协议(protocol)部分。 myURL.protocol; // https url.search作用：获取及设置URL的序列化查询(query)部分部分。 myURL.search; // ?query=string url.searchParams作用：获取表示URL查询参数的URLSearchParams对象。该属性是只读的； myURL.searchParams; // url.username作用：获取及设置URL的用户名(username)部分。 myURL.username; // user url.toString()作用：在URL对象上调用toString()方法将返回序列化的URL。返回值与url.href和url.toJSON()的相同。 如果需要更大灵活性，require(&apos;url&apos;).format()可能更合适。 url.toJSON()在URL对象上调用toJSON()方法将返回序列化的URL。 Constructor: new URLSearchParams(obj)通过使用查询哈希映射实例化一个新的URLSearchParams对象，obj的每一个属性的键和值将被强制转换为字符串。 urlSearchParams.append(name, value) 在查询字符串中附加一个新的键值对。 urlSearchParams.entries() 返回: &lt;Iterator&gt; 在查询中的每个键值对上返回一个ES6迭代器。 urlSearchParams.forEach(fn[, thisArg]) 在查询字符串中迭代每个键值对，并调用给定的函数。 urlSearchParams.get(name) 返回键是name的第一个键值对的值。如果没有对应的键值对，则返回null。 urlSearchParams.getAll(name) 返回键是name的所有键值对的值，如果没有满足条件的键值对，则返回一个空的数组。 urlSearchParams.has(name) 如果存在至少一对键是name的键值对则返回 true。 urlSearchParams.keys() 在每一个键值对上返回一个键的ES6迭代器。 urlSearchParams.set(name, value) 将URLSearchParams对象中与name相对应的值设置为value。 urlSearchParams.sort() 按现有名称就地排列所有的名称-值对。 urlSearchParams.toString() 返回查询参数序列化后的字符串，必要时存在百分号编码字符。 urlSearchParams.values() 在每一个键值对上返回一个值的ES6迭代器。 urlSearchParams[@@iterator]() 返回在查询字符串中每一个键值对的ES6迭代器。 url.domainToASCII(domain) 返回Punycode ASCII序列化的domain. 如果domain是无效域名，将返回空字符串。 url.domainToUnicode(domain) 返回Unicode序列化的domain. 如果domain是无效域名，将返回空字符串。 url.format(URL[, options]) 返回一个WHATWG URL对象的可自定义序列化的URL字符串表达。 参考文档： url参考-api]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全局变量-global]]></title>
    <url>%2F2017%2Fnodejs%E8%87%AA%E5%B8%A6%E6%A8%A1%E5%9D%97-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F.html</url>
    <content type="text"><![CDATA[global - 全局变量global - 全局变量，相当于浏览器环境下的window对象。 __dirname作用：当前模块的文件夹名称。等同于 __filename 的 path.dirname() 的值。 __filename作用：当前模块的文件名称---解析后的绝对路径。 module作用：导出一个对象。 module.exports 用于指定一个模块所导出的内容，即可以通过 require() 访问的内容。 exports作用：导出一个方法，为module.exports的简写形式。 PS: module.exports和exports的区别 每一个node.js执行文件，都自动创建一个module对象，同时，module对象会创建一个叫exports的属性，初始化的值是 {} module.exports本身不具备任何属性和方法。如果，Module.exports已经具备一些属性和方法，那么exports收集来的信息将被忽略。 require(path)作用：引入模块。 PS：module导入查找顺序。核心模块 -》 否则将执行下列查找如果按确切的文件名没有找到模块，则 Node.js 会尝试带上 .js、.json 或 .node 拓展名再加载。.js 文件会被解析为 JavaScript 文本文件，.json 文件会被解析为 JSON 文本文件。 .node 文件会被解析为通过 dlopen 加载的编译后的插件模块。以 ‘/‘ 为前缀的模块是文件的绝对路径。 例如，require(‘/home/marco/foo.js’) 会加载 /home/marco/foo.js 文件。以 ‘./‘ 为前缀的模块是相对于调用 require() 的文件的。 也就是说，circle.js 必须和 foo.js 在同一目录下以便于 require(‘./circle’) 找到它。当没有以 ‘/‘、’./‘ 或 ‘../‘ 开头来表示文件时，这个模块必须是一个核心模块或加载自 node_modules 目录。如果给定的路径不存在，则 require() 会抛出一个 code 属性为 ‘MODULE_NOT_FOUND’ 的 Error。 timer（定时器）setImmediate(callback[, …args])作用：创建 Immediate 对象。 clearImmediate(immediateObject)作用：取消一个由 setImmediate() 创建的 Immediate 对象。 setInterval(callback, delay[, …args])作用：创建 Timeout 对象。 clearInterval(timeoutObject)作用：取消一个由 setInterval() 创建的 Timeout 对象。 setTimeout(callback, delay[, …args])作用：创建 Timeout 对象。 clearTimeout(timeoutObject)作用：取消一个由 setTimeout() 创建的 Timeout 对象。 events（事件）包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。 绑定监听事件emitter.addListener(eventName, listener)emitter.on(eventName, listener)emitter.once(eventName, listener)emitter.prependListener(eventName, listener)emitter.prependOnceListener(eventName, listener)PS：添加一个单次 listener 函数到名为 eventName 的事件的监听器数组的开头。 下次触发 eventName 事件时，监听器会被移除，然后调用。 触发事件emitter.emit(eventName[, …args])PS：如果事件有注册监听返回 true，否则返回 false。 移除监听事件emitter.removeListener(eventName, listener)emitter.removeAllListeners([eventName])其他‘newListener’ 事件‘removeListener’ 事件PS：当新的监听器被添加时，所有的 EventEmitter 会触发 ‘newListener’ 事件；当移除已存在的监听器时，则触发 ‘removeListener’。 ‘error’ 事件PS：当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。 EventEmitter.defaultMaxListenersemitter.setMaxListeners(n)emitter.getMaxListeners()emitter.listenerCount(eventName)PS：返回正在监听名为 eventName 的事件的监听器的数量。 emitter.listeners(eventName)PS：返回名为 eventName 的事件的监听器数组的副本。 emitter.eventNames()PS：返回一个列出触发器已注册监听器的事件的数组。 数组中的值为string或symbol。 assert（断言）assert模块是Node的内置模块，主要用于断言。如果表达式不符合预期，就抛出一个错误,可用于测试模块功能，有少数几个是常用的。 console控制台console.assert(value[, message][, …args])PS：一个简单的断言测试，验证 value 是否为真。 如果不为真，则抛出 AssertionError。 如果提供了 message，则使用 util.format() 格式化并作为错误信息使用。 console.clear()PS：当 stdout 是一个 TTY 时，调用 console.clear() 将尝试清除 TTY。 当 stdout 不是一个TTY时，该方法什么都不做。 console.count([label])PS：维护一个指定 label 的内部计数器并且输出到 stdout 指定 label 调用 console.count() 的次数。 console.countReset([label=’default’])PS：重置指定 label 的内部计数器。 console.log([data][, …args])console.info([data][, …args])console.debug(data[, …args]) console.error([data][, …args])console.warn([data][, …args])PS：打印到 stderr，并带上换行符。 console.group([…label])console.groupCollapsed()PS：将后续行的缩进增加两个空格。console.groupEnd()PS：将后续行的缩进减少两个空格。PS：打印到 stdout，并带上换行符。 console.time(label)console.timeEnd(label)PS：启动一个定时器，用以计算一个操作的持续时间。 console.trace([message][, …args])PS：打印字符串 ‘Trace :’ 到 stderr ，并通过 util.format() 格式化消息与堆栈跟踪在代码中的当前位置。 console.dir(obj[, options])PS：在 obj 上使用 util.inspect() 并打印结果字符串到 stdout。 process - 进程process 对象是一个全局变量，它提供当前 Node.js 进程的有关信息，以及控制当前 Node.js 进程。 process 事件beforeExit 事件当 Node.js 的事件循环数组已经为空，并且没有额外的工作被添加进来，事件 ‘beforeExit’ 会被触发。 disconnect 事件如果 Node.js 进程是由 IPC 通道的方式创建的，当 IPC 通道关闭时，会触发’disconnect’事件。 exit 事件两种情况触发：显式调用 process.exit() 方法，使得 Node.js 进程即将结束；Node.js 事件循环数组中不再有额外的工作，使得 Node.js 进程即将结束。 message 事件如果 Node.js 进程是由 IPC 通道的方式创建的，当子进程收到父进程发送的消息时(消息通过 childprocess.send() 发送），会触发 ‘message’ 事件。 rejectionHandled 事件如果有 Promise 被 rejected，并且此 Promise在 Nodje.js 事件循环的下次轮询及之后期间，被绑定了一个错误处理器（例如使用 promise.catch()），会触发 ‘rejectionHandled’ 事件。 uncaughtException 事件如果 Javascript 未捕获的异常，沿着代码调用路径反向传递回事件循环，会触发 ‘uncaughtException’ 事件。 Node.js 默认情况下会将这些异常堆栈打印到 stderr 然后进程退出。 为 ‘uncaughtException’ 事件增加监听器会覆盖上述默认行为。 unhandledRejection 事件如果在事件循环的一次轮询中，一个 Promise 被 rejected，并且此 Promise 没有绑定错误处理器，’unhandledRejection 事件会被触发。 warning 事件任何时候Node.js发出进程告警，都会触发’warning’事件。 信号事件SIGUSR1、SIGTERM 、SIGINT、SIGPIPE等等 IPC（Inter-Process Communication，进程间通信）方法process.channel如果Node.js进程是由IPC channel方式创建的，process.channel属性保存IPC channel的引用。 如果IPC channel不存在，此属性值为undefined。 process.connected如果Node.js进程是由IPC channel方式创建的， 只要IPC channel保持连接，process.connected属性就会返回true。 process.disconnect()被调用后，此属性会返回false。 process.disconnect()如果 Node.js 进程是从IPC频道派生出来的, process.disconnect()函数会关闭到父进程的IPC频道，以允许子进程一旦没有其他链接来保持活跃就优雅地关闭。 process.pid返回进程的PID。 process.ppid返回父进程的id。 process.send(message[, sendHandle[, options]][, callback])如果Node.js进程是通过进程间通信产生的，那么，process.send()方法可以用来给父进程发送消息。 接收到的消息被视为父进程的ChildProcess对象上的一个’message’事件。 process.abort()使Node.js进程立即结束，并生成一个core文件。 process.arch返回CPU体系机构字符串（arm、arm64）。 process.execPathNode.js执行的路径。 process.argv返回一个数组。[process.execPath, 当前执行js文件路径, 剩余的元素为其他命令行参数。] process.argv0保存Node.js启动时传入的argv[0]参数值的一份只读副本。 process.chdir(directory)变更Node.js进程的当前工作目录，如果变更目录失败会抛出异常(例如，如果指定的目录不存在)。 process.config（可读可写）返回一个Javascript对象。此对象描述了用于编译当前Node.js执行程序时涉及的配置项信息。 process.cpuUsage([previousValue])返回包含当前进程的用户CPU时间和系统CPU时间的对象。 process.cwd()返回 Node.js 进程当前工作的目录。 process.emitWarning(warning[, options])process.emitWarning()方法可用于发出定制的或应用特定的进程警告。process.emitWarning(warning[, type[, code]][, ctor]) process.env返回一个包含用户环境信息的对象。 process.execArgv返回当Node.js进程被启动时，Node.js特定的命令行选项。如：–harmony process.execPathprocess.execPath 属性，返回启动Node.js进程的可执行文件所在的绝对路径。 process.exit([code])process.exit()方法以结束状态码code指示Node.js同步终止进程。 process.exitCode当进程正常结束，或通过process.exit()结束但未传递参数时，此数值标识进程结束的状态码。 process.getegid()返回Node.js进程的有效数字标记的组身份(See getegid(2))。 process.geteuid()返回Node.js进程的有效数字标记的用户身份(See geteuid(2))。 process.getgid()返回Node.js进程的数字标记的组身份(See getgid(2))。 process.getgroups()返回数组，其中包含了补充的组ID。 process.getuid()返回Node.js进程的数字标记的用户身份(See getuid(2))。 process.hrtime([time])返回当前时间以[seconds, nanoseconds] tuple Array表示的高精度解析值， nanoseconds是当前时间无法使用秒的精度表示的剩余部分。 process.initgroups(user, extra_group)读取/etc/group文件，并且初始化组访问列表，该列表包括了用户所在的所有组。 process.kill(pid[, signal])将signal发送给pid标识的进程。 process.mainModule提供了一种获取require.main的替代方式。 process.memoryUsage()返回Node.js进程的内存使用情况的对象，该对象每个属性值的单位为字节。 process.nextTick(callback[, …args])将 callback 添加到”next tick 队列”。 每次事件轮询后，在额外的I/O执行前，next tick队列都会优先执行。 process.noDeprecationprocess.platform返回字符串，标识Node.js进程运行其上的操作系统平台。 process.release返回与当前发布相关的元数据对象，包括源代码和源代码头文件 tarball的URLs。 process.setegid(id)为进程设置有效的用户组ID。 process.seteuid(id)process.seteuid()方法为进程设置有效的用户ID。 process.setgid(id)process.setgid() 为进程方法设置组ID。 process.setgroups(groups)process.setuid(id)设置进程的用户ID。 process.stderr返回连接到stderr(fd 2)的流。 process.stdin返回连接到 stdin (fd 0)的流。 process.stdout返回连接到 stdout (fd 1)的流。 process.throwDeprecationprocess.title用于获取或设置当前进程在 ps 命令中显示的进程名字。 process.traceDeprecationprocess.umask([mask])用于返回或设置Node.js进程的默认创建文件的权限掩码。 process.uptime()返回当前 Node.js 进程运行时间秒长。 process.version返回Node.js的版本信息。 process.versions返回一个对象，此对象列出了Node.js和其依赖的版本信息。 path（路径）path 模块提供了一些工具函数，用于处理文件与目录的路径。path 模块的默认操作会根据 Node.js 应用程序运行的操作系统的不同而变化（Windows与POSIX）。要想在任何操作系统上处理 Windows 文件路径时获得一致的结果，可以使用 path.win32，如path.win32.basename(‘C:\temp\myfile.html’);要想在任何操作系统上处理 POSIX 文件路径时获得一致的结果，可以使用 path.posix，如path.posix.basename(‘/tmp/myfile.html’); path.basename(path[, ext])返回一个 path 的最后一部分，类似于 Unix 中的 basename 命令。 path.delimiter提供平台特定的路径分隔符：Windows 上是 ;POSIX 上是 : path.dirname(path)返回一个 path 的目录名，类似于 Unix 中的 dirname 命令。 path.extname(path)返回 path 的扩展名，即从 path 的最后一部分中的最后一个 .（句号）字符到字符串结束。 path.format(pathObject)会从一个对象返回一个路径字符串。 与 path.parse() 相反。PS：如果提供了 pathObject.dir，则 pathObject.root 会被忽略如果提供了 pathObject.base 存在，则 pathObject.ext 和 pathObject.name 会被忽略 path.parse(path)返回一个对象，对象的属性表示 path 的元素。 path.isAbsolute(path)会判定 path 是否为一个绝对路径。 path.join([…paths])使用平台特定的分隔符把全部给定的 path 片段连接到一起，并规范化生成的路径。 path.normalize(path)会规范化给定的 path，并解析 ‘..’ 和 ‘.’ 片段。 path.relative(from, to)返回从 from 到 to 的相对路径（基于当前工作目录）。 path.resolve([…paths])会把一个路径或路径片段的序列解析为一个绝对路径。 path.sep提供了平台特定的路径片段分隔符：Windows 上是 \POSIX 上是 / urlurl 模块提供了一些实用函数，用于 URL 处理与解析。 querystring（查询字符串）querystring 模块提供了一些实用函数，用于解析与格式化 URL 查询字符串。 querystring.parse(str[, sep[, eq[, options]]])该方法会把一个 URL 查询字符串 str 解析成一个键值对的集合。 querystring.unescape(str)该方法是提供给 querystring.parse() 使用的，通常不直接使用。 querystring.stringify(obj[, sep[, eq[, options]]])该方法通过遍历给定的 obj 对象的自身属性，生成 URL 查询字符串。 querystring.escape(str)该方法是提供给 querystring.stringify() 使用的，通常不直接使用。 Buffer（缓冲器）在 ECMAScript 2015 (ES6) 引入 TypedArray 之前，JavaScript 语言没有读取或操作二进制数据流的机制。 Buffer 类被引入作为 Node.js API 的一部分，使其可以在 TCP 流或文件系统操作等场景中处理二进制数据流。 string_decoder（字符串解码器）string_decoder 模块提供了一个 API，用于把 Buffer 对象解码成字符串，但会保留编码过的多字节 UTF-8 与 UTF-16 字符。 child_process（子进程）child_process 模块提供了衍生子进程的功能，它与 popen(3) 类似，但不完全相同。 这个功能主要由 child_process.spawn() 函数提供。 cluster (集群)Node.js在单个线程中运行单个实例。 用户(开发者)为了使用现在的多核系统，有时候,用户(开发者)会用一串Node.js进程去处理负载任务。 crypto (加密)crypto 模块提供了加密功能，包含对 OpenSSL 的哈希、HMAC、加密、解密、签名、以及验证功能的一整套封装。 dgram (数据报)dgram模块提供了 UDP 数据包 socket 的实现。 net (网络)net 模块提供了创建基于流的 TCP 或 IPC 服务器(net.createServer())和客户端(net.createConnection()) 的异步网络 API。 dns (域名服务器)1.使用底层操作系统工具进行域名解析，且无需进行网络通信。2.连接到一个真实的 DNS 服务器进行域名解析，且始终使用网络进行 DNS 查询。 http客户端与服务端通信。Node.js 中的 HTTP 接口被设计成支持协议的许多特性。 比如，大块编码的消息。 这些接口不缓冲完整的请求或响应，用户能够以流的形式处理数据。 tls (安全传输层)tls 模块是对安全传输层（TLS）及安全套接层（SSL）协议的实现，建立在OpenSSL的基础上。 httpsHTTPS 是 HTTP 基于 TLS/SSL 的版本。在 Node.js 中，它被实现为一个独立的模块。 Error (错误)所有由 Node.js 引起的 JavaScript 错误与系统错误都继承自或实例化自标准的 JavaScript 类，且保证至少提供类中的属性。 fs (文件系统)文件 I/O 是对标准 POSIX 函数的简单封装。 通过 require(‘fs’) 使用该模块。 所有的方法都有异步和同步的形式。 os (操作系统)os 模块提供了一些操作系统相关的实用方法。 readline (逐行读取)用于从可读流（如 process.stdin）读取数据，每次读取一行。 repl (交互式解释器)repl 模块提供了一种“读取-求值-输出”循环（REPL）的实现，它可作为一个独立的程序或嵌入到其他应用中。 stream (流)流（stream）在 Node.js 中是处理流数据的抽象接口（abstract interface）。 stream 模块提供了基础的 API 。使用这些 API 可以很容易地来构建实现流接口的对象。 tty（终端）util (实用工具)util 模块主要用于支持 Node.js 内部 API 的需求。 大部分实用工具也可用于应用程序与模块开发者。 V8（引擎）v8 模块暴露了特定于V8版本内置到 Node.js 二进制文件中的API。 vm (虚拟机)vm 模块提供了一系列 API 用于在 V8 虚拟机环境中编译和运行代码。 Zlib（压缩）zlib模块提供通过 Gzip 和 Deflate/Inflate 实现的压缩功能。]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fs模块-文件]]></title>
    <url>%2F2017%2Fnodejs%E8%87%AA%E5%B8%A6%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0-fs.html</url>
    <content type="text"><![CDATA[fs模块-文件系统以下方法均有同步和异步版本 说明：文件 I/O 是对标准 POSIX 函数的简单封装。 通过 require(&apos;fs&apos;) 使用该模块。 所有的方法都有异步和同步的形式。 异步方法的最后一个参数都是一个回调函数。 传给回调函数的参数取决于具体方法，但回调函数的第一个参数都会保留给异常。 如果操作成功完成，则第一个参数会是 null 或 undefined。 步方法时，任何异常都会被立即抛出。 可以使用 try/catch 来处理异常，或让异常向上冒泡。 异步的删除文件1234fs.unlink(&apos;tmp/hello&apos;, function (err) &#123; if (err) throw err; console.log(&apos;删除成功&apos;);&#125;); 同步的删除文件123456try &#123; fs.unlinkSync(&apos;tmp/hello&apos;);&#125;catch (e) &#123; console.error(e);&#125;console.log(&apos;删除成功&apos;); fs.contants作用：返回一个包含常用文件系统操作的常量的对象。FRWX（可见、读、写、执行） fs.FSWatcher 类作用：从 fs.watch() 返回的对象是该类型。 方法：change、error、close分别代表监视目录或文件的改变和出错和关闭监视。 fs.watch(&apos;./tmp&apos;, (eventType, filename) =&gt; { if (filename) { console.log(filename); } }); fs.ReadStream 类作用：ReadStream 是一个可读流。 属性： readStream.bytesRead - 已读取的字节数。 readStream.path - 流正在读取的文件的路径，指定在 fs.createReadStream() 的第一个参数 方法：open、close分别对应ReadStream文件fs.open()被打开和fs.close()被关闭时触发。 fs.Stats 类从 fs.stat()、fs.lstat() 和 fs.fstat() 及其同步版本返回的对象都是该类型。 stats.isFile() stats.isDirectory() stats.isBlockDevice() stats.isCharacterDevice() stats.isSymbolicLink() (仅对 fs.lstat() 有效) stats.isFIFO() stats.isSocket() Stat 时间值atime &quot;访问时间&quot; - 文件数据最近被访问的时间。 mtime &quot;修改时间&quot; - 文件数据最近被修改的时间。 ctime &quot;变化时间&quot; - 文件状态最近更改的时间。 birthtime &quot;创建时间&quot; - 文件创建的时间。 fs.WriteStream类作用：WriteStream 一个可写流。 属性： writeStream.bytesWritten - 已写入的字节数。 不包括仍在排队等待写入的数据。 writeStream.path - 流正在写入的文件的路径，指定在 fs.createWriteStream() 的第一个参数。 方法： open() - 当 WriteStream 文件被打开时触发。 close() - 当 WriteStream 底层的文件描述符已被使用 fs.close() 方法关闭时触发。 fs.access(path[, mode], callback);作用：判断用户是否有权限操作给定的目录或者是文件。 如果要检查一个文件是否存在且不操作它。 mode参数的可选项： fs.constants.F_OK - path 文件对调用进程可见（默认）。 fs.constants.R_OK - path 文件可被调用进程读取。 fs.constants.W_OK - path 文件可被调用进程写入。 fs.constants.X_OK - path 文件可被调用进程执行。 fs.accessSync(path[, mode]);fs.access() 的同步版本。 fs.appendFile(file, data[, options], callback);作用：异步地追加数据到一个文件，如果文件不存在则创建文件。 fs.appendFile(&apos;filename.txt&apos;, &apos;data to append&apos; , (err) =&gt; { if (err) throw err; console.log(&apos;添加成功&apos;); }); fs.chmod(path, mode, callback);作用： 更改文件属性（存取模式）(mode)。 fs.chown(path, uid, gid, callback);作用：修改文件目录属主。用户ID，群体身份（共享资源系统使用者的身份） fs.close(fd, callback);作用：关闭已打开的文件。 fs.createReadStream(path[, options]);作用：返回一个新建的ReadStream对象。 fs.createWriteStream(path[, options]);作用：返回一个新建的WriteStream对象。 fs.existsSync(path);作用： 判断文件是否存在的同步版，异步已经废弃了。 fs.fchmod(fd, mode, callback);作用：更改文件权限（文件描述符）。 fs.fchown(fd, uid, gid, callback);作用：更改文件所有权(文件描述符)。 fs.fdatasync(fd, callback);作用：刷新数据到磁盘。 fs.fstat(fd, callback);作用：返回文件的详细信息。 fs.fsync(fd, callback);作用：同步缓存数据到磁盘。 fs.ftruncate(fd, len, callback);作用：截取文件内容。 fs.futimes(fd, atime, mtime, callback);作用：更改一个文件所提供的文件描述符引用的文件的时间戳。 fs.lchmod(path, mode, callback);作用：更改文件权限(不解析符号链接)。 fs.lchown(path, uid, gid, callback)作用：更改文件所有权（不解析符号链接）。 fs.link(existingPath, newPath, callback);作用：创建硬链接(只能在本券中)。 fs.lstat(path, callback);作用：获取文件信息(不解析符号链接)。 fs.mkdir(path[, mode], callback);作用：创建文件目录，如果目录已存在，将抛出异常。 fs.mkdtemp(prefix[, options], callback);作用：创建临时目录。 fs.open(path, flags[, mode], callback);作用：打开文件。 fs.read(fd, buffer, offset, length, position, callback);作用：读取文件内容。 fs.readdir(path[, options], callback);作用：读取文件目录。 fs.readFile(path[, options], callback);作用：读取文件。 fs.readlink(path[, options], callback);作用：读取软连接信息。 fs.readSync(fd, buffer, offset, length, position);作用：读取文件内容，返回字节数。 fs.realpath(path[, options], callback);作用：获取真实路径。 fs.rename(oldPath, newPath, callback);作用：重命名路径。 fs.rmdir(path, callback);作用：删除文件目录。 fs.stat(path, callback);作用：获取文件信息。 fs.symlink(target, path[, type], callback);作用：创建符号链接。 fs.truncate(path[, len], callback);作用：文件内容截取操作。 fs.unlink(path, callback);作用：删除文件操作。 fs.unwatchFile(filename[, listener]);作用：解除文件监听。 fs.utimes(path, atime, mtime, callback);作用：修改文件时间戳。 fs.watch(filename[, options][, listener]);作用：监控文件。 fs.watchFile(filename[, options], listener);作用：监控文件。 fs.write(fd, buffer[, offset[, length[, position]]], callback);作用：向文件写数据。 fs.writeFile(file, data[, options], callback);作用：向文件写数据。 参考文档： fs参考-api fs模块]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[util模块-工具]]></title>
    <url>%2F2017%2Fnodejs%E8%87%AA%E5%B8%A6%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0-util.html</url>
    <content type="text"><![CDATA[util模块说明：util 模块主要用于支持 Node.js 内部 API 的需求。 大部分实用工具也可用于应用程序与模块开发者。 util.callbackify(original)util.debuglog(section)作用：util.debuglog() 方法用于创建一个函数，基于 NODE_DEBUG 环境变量的存在与否有条件地写入调试信息到 stderr。 const debuglog = util.debuglog(&apos;foo&apos;); debuglog(&apos;hello from foo [%d]&apos;, 123); 若程序的环境运行是带上NODE_DEBUG=foo,则FOO 3245: hello from foo [123] 3234是进程id util.deprecate(function, string)作用：util.deprecate() 方法会包装给定的 function 或类，并标记为废弃的。 // 在util模块中 exports.puts = util.deprecate(function() { for (let i = 0, len = arguments.length; i &lt; len; ++i) { process.stdout.write(arguments[i] + &apos;\n&apos;); } }, &apos;util.puts: 使用 console.log 代替&apos;); util.format(format[, …args])作用：返回一个格式化后的字符串，使用第一个参数作为一个类似 printf 的格式。 对应的占位符： %s - 字符串 %d - 数值 %i - Integer %f - Float %j - JSON %o - Object %% - 单个百分号（&apos;%&apos;）。不消耗参数。 util.format(&apos;%s:%d&apos;, &apos;fan&apos;, 100); // &apos;fan:100&apos; util.inherits(constructor, superConstructor)注意，不建议使用 util.inherits()。 请使用 ES6 的 class 和 extends 关键词获得语言层面的继承支持。 作用：从一个构造函数中继承原型方法到另一个。 constructor 的原型会被设置到一个从 superConstructor 创建的新对象上。 util.inherits(MyStream, EventEmitter); util.inspect(object[, options])作用：返回 object 的字符串表示，主要用于调试。 附加的 options 可用于改变格式化字符串的某些方面。 自定义 util.inspect 颜色作用：可以通过 util.inspect.styles 和 util.inspect.colors 属性全局地自定义 util.inspect 的颜色输出（如果已启用）。 util.inspect.custom作用：可被用于声明自定义的查看函数。 util.inspect.defaultOptions作用：defaultOptions 值允许对被 util.inspect 使用的默认选项进行自定义。 util.promisify(original)作用：让一个遵循通常的让一个遵循通常的 Node.js 回调风格的函数， 即 (err, value) =&gt; ... 回调函数是最后一个参数, 返回一个返回值是一个 promise 版本的函数。 参考文档： util参考-api]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[path模块-路径]]></title>
    <url>%2F2017%2Fnodejs%E8%87%AA%E5%B8%A6%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0-path.html</url>
    <content type="text"><![CDATA[path模块-路径在不同系统中，路径分隔符显示不同。POSIX 上的 / 与 Windows 上的 \ 说明：path 模块提供了一些工具函数，用于处理文件与目录的路径。 path.sep作用：提供了平台特定的路径片段分隔符。 windows上是 \ POSIX上是 / path.win32 和 path.posix要想在任何操作系统上处理 Windows 文件路径时获得一致的结果，可以使用 path.win32 path.win32.basename(&apos;c:\\temp\\myfile.html&apos;); // myfile.html 要想在任何操作系统上处理 POSIX 文件路径时获得一致的结果，可以使用 path.posix path.posix.basename(&apos;/temp/myfile.html&apos;); // myfile.html path.delimiter作用：提供平台特定的路径分隔符。 windows是; POSIX是: process.env.PATH; // &apos;/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin&apos; process.env.PATH.split(path.delimiter); // [&apos;/usr/bin&apos;, &apos;/bin&apos;, &apos;/usr/sbin&apos;, &apos;/sbin&apos;, &apos;/usr/local/bin&apos;] path.basename(path[, ext]);作用：返回一个 path 的最后一部分。 path.basename(&apos;/foo/bar/myfile.html&apos;); // &apos;myfile.html&apos; patn.basename(&apos;/foo/bar/myfile.html&apos;, &apos;.html&apos;); // &apos;myfile&apos; path.dirname(path);作用：返回一个path的目录名。 path.dirname(&apos;/foo/bar/myfile&apos;); // foo/bar path.extname(path)作用：返回 path 的扩展名，即从 path 的最后一部分中的最后一个 .（句号）字符到字符串结束。 path.extname(&apos;index.coffee.md&apos;); // &apos;.md&apos; path.format(pathObject);作用：会从一个对象返回一个路径字符串。 与 path.parse() 相反。 参数：Object { dir: &apos;&apos;, root: &apos;&apos;, base: &apos;&apos;, name: &apos;&apos;, ext: &apos;&apos; } 在windows中 path.format({ root: &apos;ignored&apos;, dir: &apos;\home\user&apos;, base: &apos;file.txt&apos; }); // &apos;\home\user\file.txt&apos; path.parse(path);作用：返回一个对象，对象的属性表示 path 的元素。 path.parse(&apos;/home/user/file.txt&apos;); // { root: &apos;/&apos;, base: &apos;/home/user&apos;, ext: &apos;.txt&apos;. name: &apos;file&apos; } path.isAbsolute(path);作用：会判定 path 是否为一个绝对路径。 path.isAbsolute(&apos;bar\baz&apos;); // true path.join([…path]);作用：使用平台特定的分隔符把全部给定的 path 片段连接到一起，并规范化生成的路径。 path.join(&apos;/foo&apos;, &apos;bar&apos;, &apos;baz/asdf&apos;, &apos;quux&apos;, &apos;..&apos;); // 返回: &apos;/foo/bar/baz/asdf&apos; path.normalize(path);作用：规范化给定的 path，并解析 &apos;..&apos; 和 &apos;.&apos; 片段。 path.normalize(&apos;/foo/bar/baz/asdf/quux/..&apos;); // &apos;/foo/bar/baz/asdf&apos; path.relative(from, to);作用：返回从 from 到 to 的相对路径（基于当前工作目录）。 path.relative(&apos;/data/orandea/test/aaa&apos;, &apos;/data/orandea/impl/bbb&apos;); // &apos;../../impl/bbb&apos; path.resolve([…paths]);作用：把一个路径或路径片段的序列解析为一个绝对路径。 path.resolve(&apos;/foo/bar&apos;, &apos;./baz&apos;); // &apos;/foo/bar/baz&apos; 参考文档： path参考-api]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql参考手册]]></title>
    <url>%2F2017%2Fsql%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C.html</url>
    <content type="text"><![CDATA[AND / ORAND &amp; OR 运算符用于基于一个以上的条件对记录进行过滤。 语法：SELECT column_name(s) FROM table_name WHERE condition AND|OR condition; 选择count大于10 且 count小于230 SELECT * FROM access_log WHERE count &gt; 10 AND count &lt; 230 选择count小于10 或 count大于230 SELECT * FROM access_log WHERE count &lt; 10 OR count &gt; 230 ALTER TABLEALTER TABLE 语句用于在已有的表中添加、删除或修改列。 语法： // 添加一列 ALTER TABLE table_name ADD column_name datatype // 删除一列 ALTER TABLE table_name DROP COLUMN column_name // 更改一列字段类型 ALTER TABLE table_name MODIFY COLUMN column_name VARCHAR(10) // 更改一列 ALTER TABLE table_name CHANGE COLUMN column_name re_name AS (alias)SELECT column_name AS column_alias FROM table_name OR SELECT column_name FROM table_name AS table_alias 对url改名为ii SELECT url AS ii FROM websites BETWEEN语法： SELECT column_name(s) FROM table_name WHERE column_name BETWEEN value1 AND value2 选择alexa1到10的所有记录 SELECT * FROM websites WHERE alexa BETWEEN 1 AND 10 CREATE DATABASE语法：CREATE DATABASE database_name 创建IIII数据库 CREATE DATABASE IIII DROP DATABASE语法：DROP DATABASE database_name 删除IIII数据库 DROP DATABASE IIII CREATE TABLE语法： CREATE TABLE table_name ( column_name data_type, column_name data_type, ... ) 创建一个名为 sds 的表，且有字段int CREATE TABLE sds (id int) DROP TABLE语法：DROP TABLE IF EXISTS tabale_name 如果表sds存在就删除 DROP TABLE IF EXISTS sds CREATE INDEX创建索引 语法： CREATE INDEX index_name ON tabale_name (column_name) OR CREATE UNIQUE INDEX index_name ON tabale_name (column_name) CREATE VIEW创建视图 视图是基于 SQL 语句的结果集的可视化的表。 语法： CREATE VIEW view_name AS SELECT column_name(s) FROM tabale_name DELETEDELETE FROM tabale_name WHERE some_column = some_value OR DELETE FROM tabale_name // 删除整个表 DELETE * FROM tabale_name DROP DATABASE删除数据库 DROP DATABASE data_name DROP INDEX删除索引 DROP INDEX index_name DROP TABLE删除表 DROP TABLE table_name GROUP BY合计函数 (比如 SUM) 常常需要添加 GROUP BY 语句。 SELECT column_name, aggregate_function(column_name) FROM table_name WHERE column_name operator value1 GROUP BY column_name HAVING在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用。 SELECT column_name, aggregate_function(column_name) FROM tabale_name WHERE column_name operator value GROUP BY column_name HAVING aggregate_function(column_name) operator value ININ 操作符允许您在 WHERE 子句中规定多个值。 SELECT column_name(s) FROM tabale_name WHERE column_name IN(value1, value2) INSERT INTO插入数据 INSERT INTO tabale_name VALUES(value1, value2, ...value3) OR INSERT INTO tabale_name (column1, column2, ...column3) VALUES(value1, value2, ...value3) INNER JOIN在表中存在至少一个匹配时，INNER JOIN 关键字返回行。 SELECT column_name(s) FROM tabale_name1 INNER JOIN tabale_name2 ON tabale_name1.column_name = tabale_name2.column_name LEFT JOIN返回左表 SELECT column_name(s) FROM tabale_name1 LEFT JOIN tabale_name2 ON tabale_name1.column_name = tabale_name2.column_name RIGHT JOIN返回左表 SELECT column_name(s) FROM tabale_name1 RIGHT JOIN tabale_name2 ON tabale_name1.column_name = tabale_name2.column_name FULL JOIN只要其中某个表存在匹配，FULL JOIN 关键字就会返回行。 SELECT column_name(s) FROM tabale_name1 FULL JOIN tabale_name2 ON tabale_name1.column_name = tabale_name2.column_name LIKELIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。 SELECT column_name(s) FROM tabale_name WHERE column_name LIKE pattern ORDER BYORDER BY 语句用于对结果集进行排序。 SELECT column_name FROM table_name ORDER BY column_name[ASC|DESC] SELECT查询 SELECT column_name(s) FROM tabale_name SELECT *SELECT * FROM tabale_name SELECT DISTINCT关键词 DISTINCT 用于返回唯一不同的值。 SELECT DISTINCT column_name(s) FROM tabale_name SELECT INTOSELECT * INTO new_table_name [IN externaldatabase] FROM old_table_name OR SELECT column_name(s) INTO new_table_name [IN externaldatabase] FROM old_table_name SELECT TOPSELECT column_name(s) FROM table_name LIMIT number TRUNCATE TABLETRUNCATE TABLE table_name UNIONSQL UNION 操作符合并两个或多个 SELECT 语句的结果。 SELECT column_name(s) FROM tabale_name1 UNION SELECT column_name(s) FROM tabale_name2 UNION ALLSELECT column_name(s) FROM tabale_name1 UNION ALL SELECT column_name(s) FROM tabale_name2 UPDATE更新 UPDATE tabale_name SET column1=value, column2=value WHERE some_column=some_value WHERE条件 SELECT column_name(s) FROM tabale_name WHERE column_name operator value 参考文档 SQL文档]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql函数学习]]></title>
    <url>%2F2017%2Fsql%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[SQL 函数SQL 拥有很多可用于计数和计算的内建函数。 SQL Aggregate 函数SQL Aggregate 函数计算从列中取得的值，返回一个单一的值。 AVG() - 返回平均值 COUNT() - 返回行数 FIRST() - 返回第一个记录的值 LAST() - 返回最后一个记录的值 MAX() - 返回最大值 MIN() - 返回最小值 SUM() - 返回总和 SQL Scalar 函数SQL Scalar 函数基于输入值，返回一个单一的值。 UCASE() - 将某个字段转换为大写 LCASE() - 将某个字段转换为小写 MID() - 从某个文本字段提取字符，MySql 中使用 SubString(字段，1，end) - 从某个文本字段提取字符 LEN() - 返回某个文本字段的长度 ROUND() - 对某个数值字段进行指定小数位数的四舍五入 NOW() - 返回当前的系统日期和时间 FORMAT() - 格式化某个字段的显示方式 AVG()一下实例中均使用数据库sql，表名为access_log AVG() 函数返回数值列的平均值。 语法：SELECT AVG(column_name) FROM table_name; 1.返回count的平均值 SELECT AVG(count) FROM access_log 2.返回大于count平均数的元组 SELECT site_id, count FROM access_log WHERE count &gt; (SELECT AVG(count) FROM access_log); COUNT()COUNT() 函数返回匹配指定条件的行数（NULL 不计入）。 语法：SELECT COUNT(column_name) FROM table_name; // COUNT(column_name) 函数返回指定列的值的数目（NULL 不计入） SELECT COUNT(DISTINCT column_name) FROM table_name; // COUNT(DISTINCT column_name) 函数返回指定列的不同值的数目 1.返回表中记录数 SELECT COUNT(*) FROM access_log 2.返回site_id = 3的记录拥有count的数量，并改名为nums SELECT COUNT(count) AS nums FROM access_log WHERE site_id = 3 3.计算 &quot;access_log&quot; 表中不同 site_id 的记录数 SELECT COUNT(DISTINCT site_id) AS nums FROM access_log SQL FIRST() 函数FIRST() 函数返回指定的列中第一个记录的值。 注释：只有 MS Access 支持 FIRST() 函数。 语法：SELECT FIRST(column_name) FROM table_name; MySQL 语法： SELECT column_name FROM table_name ORDER BY column_name ASC LIMIT 1; 1.mysql中获取第一条记录 SELECT count FROM access_log ORDER BY count ASC LIMIT 1; SQL LAST() 函数LAST() 函数返回指定的列中最后一个记录的值。 注释：只有 MS Access 支持 LAST() 函数。 语法：SELECT LAST(column_name) FROM table_name; MySQL 语法： SELECT * FROM table_name ORDER BY column_name ASC LIMIT 1; 1.mysql中获取最后一条记录 SELECT * FROM access_log ORDER BY count DESC LIMIT 1; SQL MAX() 函数MAX() 函数返回指定列的最大值。 语法：SELECT MAX(column_name) FROM table_name; 1.返回count最大的一条记录 SELECT * FROM access_log WHERE count = (SELECT MAX(count) FROM access_log) SQL MIN() 函数MIN() 函数返回指定列的最小值。 语法：SELECT column_name FROM table_name; 1.返回count最小的一条记录中的aid 和 count字段 SELECT aid, count FROM access_log WHERE count = (SELECT MIN(count) FROM access_log) SQL SUM() 函数SUM() 函数返回数值列的总数。 语法：SELECT column_name FROM table_name; 1.返回count 的总和 SELECT SUM(count) FROM access_log SQL GROUP BY 语句GROUP BY 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。 语法： SELECT column_name, aggregate_function(column_name) FROM table_name WHERE column_name operator value GROUP BY column_name; 1.返回通过site_id分组对count求和 SELECT site_id, SUM(access_log.count) AS nums FROM access_log GROUP BY site_id 2.统计所有网站的访问的记录数（LEFT JOIN 关键字从左表（table1）返回所有的行，即使右表（table2）中没有匹配。） SELECT websites.name, COUNT(access_log.aid) AS nums FROM access_log LEFT JOIN websites ON access_log.site_id = websites.id GROUP BY websites.name SQL HAVING 子句在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与聚合函数一起使用。 HAVING 子句可以让我们筛选分组后的各组数据。 1.现在我们想要查找总访问量大于 200 的网站 SELECT Websites.name, Websites.url, SUM(access_log.count) AS nums FROM (access_log INNER JOIN Websites ON access_log.site_id=Websites.id) GROUP BY Websites.name HAVING SUM(access_log.count) &gt; 200; SQL UCASE() 函数UCASE() 函数把字段的值转换为大写。 语法：SELECT UCASE(column_name) FROM table_name; 1.将某个列转化为大写 SELECT UCASE(websites.url) AS url3 FROM websites SQL LCASE() 函数LCASE() 函数把字段的值转换为大写。 语法：SELECT LCASE(column_name) FROM table_name; 1.将某个列转化为小写 SELECT LCASE(country) FROM websites SQL MID() 函数MID() 函数用于从文本字段中提取字符。 语法：SELECT MID(column_name, start [,length]) FROM table_name; 1.获取网站地址 SELECT MID(websites.url, 4) FROM websites SQL LEN() 函数LEN() 函数返回文本字段中值的长度。 语法：SELECT LEN(column_name) FROM table_name; MySQL中函数为 LENGTH() SELECT LENGTH(column_name) FROM table_name; 1.获取网址长度 SELECT LENGTH(websites.url) FROM websites; SQL ROUND() 函数ROUND() 函数用于把数值字段舍入为指定的小数位数。 语法：SELECT ROUND(column_name, decimals) FROM table_name; 1.对url四舍五入处理 SELECT ROUND(url) FROM websites WHERE id=7; SQL NOW() 函数NOW() 函数返回当前系统的日期和时间。 语法：SELECT NOW() FROM websites SQL FORMAT() 函数FORMAT() 函数用于对字段的显示进行格式化。 语法：SELECT FORMAT(column_name, format) FROM table_name; 1.格式化日期 SELECT name, url, DATE_FORMAT(Now(), &apos;%Y-%m-%d&apos;) AS date FROM websites 参考手册[SQL参考手册](http://www.runoob.com/sql/sql-quickref.html) 参考文档 SQL]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql学习（下部分）]]></title>
    <url>%2F2017%2Fmysql%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[MySQL 事务MySQL 事务主要用于处理操作量大，复杂度高的数据。 在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息。 事务用来管理 insert,update,delete 语句。 事务是必须满足4个条件（ACID）： Atomicity（原子性）、Consistency（稳定性）、Isolation（隔离性）、Durability（可靠性）。 事物控制语句BEGIN或START TRANSACTION；显式地开启一个事务； COMMIT；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改称为永久性的； ROLLBACK；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改； SAVEPOINT identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT； RELEASE SAVEPOINT identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常； ROLLBACK TO identifier；把事务回滚到标记点； SET TRANSACTION；用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。 MYSQL 事务处理主要有两种方法1、用 BEGIN, ROLLBACK, COMMIT来实现 BEGIN 开始一个事务 ROLLBACK 事务回滚 COMMIT 事务确认 2、直接用 SET 来改变 MySQL 的自动提交模式: SET AUTOCOMMIT=0 禁止自动提交 SET AUTOCOMMIT=1 开启自动提交 事务测试CREATE TABLE runoob_transaction_test( id int(5)) engine=innodb; # 创建数据表 mysql&gt; select * from runoob_transaction_test; mysql&gt; begin; # 开始事务 mysql&gt; insert into runoob_transaction_test value(5); mysql&gt; insert into runoob_transaction_test value(6); mysql&gt; commit; # 提交事务 mysql&gt; select * from runoob_transaction_test; +------+ | id | +------+ | 5 | | 6 | +------+ mysql&gt; begin; # 开始事务 mysql&gt; insert into runoob_transaction_test values(7); mysql&gt; rollback; # 回滚 mysql&gt; select * from runoob_transaction_test; # 因为回滚所以数据没有插入 MySQL ALTER命令当我们需要修改数据表名或者修改数据表字段时，就需要使用到MySQL ALTER命令。 删除，添加或修改表字段// 删除一列（不能是最后一列） ALTER TABLE table_name DROP column_name; // 添加一列 ALTER TABLE table_name ADD column_name INT; // 查看列数据类型 SHOW COLUMNS FROM table_name; // MySQL提供的关键字 FIRST (设定位第一列) ALTER TABLE table_name ADD column_name INT FIRST; // AFTER 字段名（设定位于某个字段之后） ALTER TABLE table_name ADD column_name INT AFTER c; 修改字段类型及名称如果需要修改字段类型及名称, 你可以在ALTER命令中使用 MODIFY 或 CHANGE 子句 。 // 更改列的类型 ALTER TABLE table_name MODIFY column_name CHAR(10); ALTER TABLE table_name CHANGE i j INT; ALTER TABLE 对 Null 值和默认值的影响// 指定字段 column_name 为 NOT NULL 且默认值为100 。 ALTER TABLE table_name MODIFY column_name BIGINT NOT NULL DEFAULT 100; 修改字段默认值// ALTER 来修改字段的默认值 ALTER TABLE table_name ALTER column_name SET DEFAULT 1000; // ALTER 命令及 DROP子句来删除字段的默认值 ALTER TABLE table_name ALTER column_name DROP DEFAULT; 修改表名ALTER TABLE table_name RENAME TO table_name1; MySQL 索引MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。 索引分单列索引和组合索引。 单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。 组合索引，即一个索引包含多个列。 实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。 普通索引创建索引CREATE INDEX indexName ON mytable(username(length)); // 如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。 修改表结构(添加索引)ALTER table tableName ADD INDEX indexName(columnName) 创建表的时候直接指定CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, INDEX [indexName] (username(length)) ); 删除索引的语法DROP INDEX [indexName] ON mytable; 唯一索引它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。 创建索引CREATE UNIQUE INDEX indexName ON mytable(username(length)) 修改表结构ALTER table mytable ADD UNIQUE [indexName] (username(length)) 创建表的时候直接指定CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, UNIQUE [indexName] (username(length)) ); 使用ALTER 命令添加和删除索引ALTER TABLE tbl_name ADD PRIMARY KEY (column_list): 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。 ALTER TABLE tbl_name ADD UNIQUE index_name (column_list): 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。 ALTER TABLE tbl_name ADD INDEX index_name (column_list): 添加普通索引，索引值可出现多次。 ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):该语句指定了索引为 FULLTEXT ，用于全文索引。 // 为在表中添加索引。 ALTER TABLE testalter_tbl ADD INDEX (c); // 可以在 ALTER 命令中使用 DROP 子句来删除索引。 ALTER TABLE testalter_tbl DROP INDEX c; 使用 ALTER 命令添加和删除主键// 主键只能作用于一个列上，添加主键索引时，你需要确保该主键默认不为空（NOT NULL）。 ALTER TABLE testalter_tbl MODIFY i INT NOT NULL; ALTER TABLE testalter_tbl ADD PRIMARY KEY (i); // 使用 ALTER 命令删除主键，删除主键时只需指定PRIMARY KEY，但在删除索引时，你必须知道索引名。 ALTER TABLE testalter_tbl DROP PRIMARY KEY; 显示索引信息// 使用 SHOW INDEX 命令来列出表中的相关的索引信息。可以通过添加 \G 来格式化输出信息。 SHOW INDEX FROM table_name; \G MySQL 临时表MySQL 临时表在我们需要保存一些临时数据时是非常有用的。临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间。 // 创建临时表 CREATE TEMPORARY TABLE SalesSummary ( product_name VARCHAR(50) NOT NULL, total_sales DECIMAL(12,2) NOT NULL DEFAULT 0.00, avg_unit_price DECIMAL(7,2) NOT NULL DEFAULT 0.00, total_units_sold INT UNSIGNED NOT NULL DEFAULT 0 ); // 临时表插入数据 INSERT INTO SalesSummary (product_name, total_sales, avg_unit_price, total_units_sold) VALUES (&apos;cucumber&apos;, 100.25, 90, 2); 删除MySQL 临时表DROP TABLE SalesSummary; MySQL 复制表使用 SHOW CREATE TABLE 命令获取创建数据表(CREATE TABLE) 语句，该语句包含了原数据表的结构，索引等。 复制以下命令显示的SQL语句，修改数据表名，并执行SQL语句，通过以上命令 将完全的复制数据表结构。 如果你想复制表的内容，你就可以使用 INSERT INTO ... SELECT 语句来实现。 MySQL 元数据查询结果信息： SELECT, UPDATE 或 DELETE语句影响的记录数。 数据库和数据表的信息： 包含了数据库及数据表的结构信息。 MySQL服务器信息： 包含了数据库服务器的当前状态，版本号等。 获取服务器元数据SELECT VERSION( ) 服务器版本信息 SELECT DATABASE( ) 当前数据库名 (或者返回空) SELECT USER( ) 当前用户名 SHOW STATUS 服务器状态 SHOW VARIABLES 服务器配置变量 MySQL 序列使用MySQL序列是一组整数：1, 2, 3, ...，由于一张数据表只能有一个字段自增主键， 如果你想实现其他字段也实现自动增加，就可以使用MySQL序列来实现。 使用AUTO_INCREMENTCREATE TABLE insect ( id INT UNSIGNED NOT NULL AUTO_INCREMENT, PRIMARY KEY (id), name VARCHAR(30) NOT NULL, # type of insect date DATE NOT NULL, # date collected origin VARCHAR(30) NOT NULL # where collected ); INSERT INTO insect (id,name,date,origin) VALUES (NULL,&apos;housefly&apos;,&apos;2001-09-10&apos;,&apos;kitchen&apos;), (NULL,&apos;millipede&apos;,&apos;2001-09-10&apos;,&apos;driveway&apos;), (NULL,&apos;grasshopper&apos;,&apos;2001-09-10&apos;,&apos;front yard&apos;); 获取AUTO_INCREMENT值在MySQL的客户端中你可以使用 SQL中的LAST_INSERT_ID( ) 函数来获取最后的插入表中的自增列的值。 重置序列如果你删除了数据表中的多条记录，并希望对剩下数据的AUTO_INCREMENT列进行重新排列，那么你可以通过删除自增的列，然后重新添加来实现。 ALTER TABLE insect DROP id; ALTER TABLE insect ADD id INT UNSIGNED NOT NULL AUTO_INCREMENT FIRST, ADD PRIMARY KEY (id); 设置序列的开始值一般情况下序列的开始值为1，但如果你需要指定一个开始值100，那我们可以通过以下语句来实现 CREATE TABLE insect ( id INT UNSIGNED NOT NULL AUTO_INCREMENT, PRIMARY KEY (id), name VARCHAR(30) NOT NULL, date DATE NOT NULL, origin VARCHAR(30) NOT NULL )engine=innodb auto_increment=100 charset=utf8; MySQL 处理重复数据防止表中出现重复数据你可以在MySQL数据表中设置指定的字段为 PRIMARY KEY（主键） 或者 UNIQUE（唯一） 索引来保证数据的唯一性。 1.如果你想设置表中字段first_name，last_name数据不能重复，你可以设置双主键模式来设置数据的唯一性。 1234567CREATE TABLE person_tbl( first_name CHAR(20) NOT NULL, last_name CHAR(20) NOT NULL, sex CHAR(10), PRIMARY KEY (last_name, first_name)); 2.INSERT IGNORE INTO会忽略数据库中已经存在的数据，如果数据库没有数据，就插入新的数据，如果有数据的话就跳过这条数据。 12INSERT IGNORE INTO person_tbl (last_name, first_name) VALUES( &apos;Jay&apos;, &apos;Thomas&apos;); 3.另一种设置数据的唯一性方法是添加一个UNIQUE索引。 1234567CREATE TABLE person_tbl( first_name CHAR(20) NOT NULL, last_name CHAR(20) NOT NULL, sex CHAR(10) UNIQUE (last_name, first_name)); 统计重复数据以下我们将统计表中 first_name 和 last_name的重复记录数 SELECT COUNT(*) as repetitions, last_name, first_name FROM person_tbl GROUP BY last_name, first_name HAVING repetitions &gt; 1; 确定哪一列包含的值可能会重复。 在列选择列表使用COUNT(*)列出的那些列。 在GROUP BY子句中列出的列。 HAVING子句设置重复数大于1。 过滤重复数据1.你需要读取不重复的数据可以在 SELECT 语句中使用 DISTINCT 关键字来过滤重复数据。 SELECT DISTINCT last_name, first_name FROM person_tbl; 2.使用 GROUP BY 来读取数据表中不重复的数据。 SELECT last_name, first_name FROM person_tbl GROUP BY (last_name, first_name); 删除重复数据1.删除person_tbl表中的重复数据 CREATE TABLE tmp SELECT last_name, first_name, sex FROM person_tbl; GROUP BY (last_name, first_name, sex); DROP TABLE person_tbl; ALTER TABLE tmp RENAME TO person_tbl; 2.可以在数据表中添加 INDEX（索引） 和 PRIMAY KEY（主键）这种简单的方法来删除表中的重复记录。 ALTER IGNORE TABLE person_tbl ADD PRIMARY KEY (last_name, first_name); MySQL 及 SQL 注入如果您通过网页获取用户输入的数据并将其插入一个MySQL数据库，那么就有可能发生SQL注入安全的问题。 我们永远不要信任用户的输入，我们必须认定用户输入的数据都是不安全的，我们都需要对用户输入的数据进行过滤处理。 // 过滤用户的输入 123456789if (preg_match(&quot;/^\w&#123;8,20&#125;$/&quot;, $_GET[&apos;username&apos;], $matches))&#123; $result = mysqli_query($conn, &quot;SELECT * FROM users WHERE username=$matches[0]&quot;);&#125; else &#123; echo &quot;username 输入异常&quot;;&#125; 防止SQL注入，我们需要注意以下几个要点： 1.永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和 双&quot;-&quot;进行转换等。 2.永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。 3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。 4.不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。 5.应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装。 6.sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky，网站平台就有亿思网站安全平台检测工具。MDCSOFT SCAN等。采用MDCSOFT-IPS可以有效的防御SQL注入，XSS攻击等。 防止SQL注入在脚本语言，如Perl和PHP你可以对用户输入的数据进行转义从而来防止SQL注入。 如：mysqli_real_escape_string() 123456if (get_magic_quotes_gpc()) &#123; $name = stripslashes($name);&#125;$name = mysqli_real_escape_string($conn, $name); mysqli_query($conn, &quot;SELECT * FROM users WHERE name=&apos;&#123;$name&#125;&apos;&quot;); Like语句中的注入1234$sub = addcslashes(mysqli_real_escape_string($conn, &quot;%something_&quot;), &quot;%_&quot;);// $sub == \%something\_ mysqli_query($conn, &quot;SELECT * FROM messages WHERE subject LIKE &apos;&#123;$sub&#125;%&apos;&quot;);addcslashes() 函数在指定的字符前添加反斜杠。 MySQL 导出数据MySQL中你可以使用SELECT...INTO OUTFILE语句来简单的导出数据到文本文件上。 1.将数据表 runoob_tbl 数据导出到 /tmp/tutorials.txt 文件中 12SELECT * FROM runoob_tbl INTO OUTFILE &apos;/tmp/tutorials.txt&apos;; 2.可以通过命令选项来设置数据输出的指定格式，以下实例为导出 CSV 格式 123SELECT * FROM passwd INTO OUTFILE &apos;/tmp/tutorials.txt&apos; FIELDS TERMINATED BY &apos;,&apos; ENCLOSED BY &apos;&quot;&apos; LINES TERMINATED BY &apos;\r\n&apos;; 3.生成一个文件，各值用逗号隔开。 1234SELECT a,b,a+b INTO OUTFILE &apos;/tmp/result.text&apos;FIELDS TERMINATED BY &apos;,&apos; OPTIONALLY ENCLOSED BY &apos;&quot;&apos;LINES TERMINATED BY &apos;\n&apos;FROM test_table; 导出表作为原始数据mysqldump是mysql用于转存储数据库的实用程序。 使用mysqldump导出数据需要使用 --tab 选项来指定导出文件指定的目录，该目标必须是可写的。 以下实例将数据表 runoob_tbl 导出到 /tmp 目录中。 12mysqldump -u root -p --no-create-info \ --tab=/tmp database_name table_name 导出SQL格式的数据1.导出SQL格式的数据到指定文件 1mysqldump -u root -p database_name table_name &gt; dump.txt 2.导出整个数据库的数据 1mysqldump -u root -p database_name &gt; database_dump.txt 3.备份所有数据库 1mysqldump -u root -p --all-databases &gt; database_dump.txt 将数据表及数据库拷贝至其他主机将数据备份至 dump.txt 文件中 mysqldump -u root -p database_name table_name &gt; dump.txt 将备份的数据库导入到MySQL服务器中，可以使用以下命令，使用以下命令你需要确认数据库已经创建 mysql -u root -p database_name &lt; dump.txt 使用以下命令将导出的数据直接导入到远程的服务器上，但请确保两台服务器是相通的，是可以相互访问的 mysqldump -u root -p database_name \ | mysql -h other-host.com database_name MySQL 导入数据使用 LOAD DATA 导入数据将从当前目录中读取文件 dump.txt ，将该文件中的数据插入到当前数据库的 mytbl 表中。 LOAD DATA LOCAL INFILE &apos;dump.txt&apos; INTO TABLE mytbl; 如果指定LOCAL关键词，则表明从客户主机上按路径读取文件。如果没有指定，则文件在服务器上按路径读取文件。 使用 mysqlimport 导入数据从文件 dump.txt 中将数据导入到 mytbl 数据表中 mysqlimport -u root -p --local database_name dump.txt mysqlimport的常用选项介绍 参考文档 MYSQL]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql学习（上部分）]]></title>
    <url>%2F2017%2Fmusql%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[基础构架：database –&gt; table –&gt; row 和 col（数据块） RDBMS 术语 数据库: 数据库是一些关联表的集合。. 数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。 列: 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。 行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。 冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。 主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。 外键：外键用于关联两个表。 复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。 索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。 参照完整性: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。 MySQL 创建数据库使用 mysqladmin 创建数据库以下实例会创建一个 RUNOOB 数据库 12[root@host]# mysqladmin -u root -p create RUNOOBEnter password:****** SQL语句创建数据库 RUNOOB1&apos;CREATE DATABASE RUNOOB&apos; MySQL 删除数据库使用 mysqladmin 删除数据库12[root@host]# mysqladmin -u root -p drop RUNOOBEnter password:****** SQL语句删除数据库 RUNOOB1&apos;DROP DATABASE RUNOOB&apos; MySQL 选择数据库从命令提示窗口中选择MySQL数据库使用 RUNOOB 数据库 123[root@host]# mysql -u root -pEnter password:******mysql&gt; use RUNOOB; 使用 NODE.js 选择数据库1234567891011var mysql = require(&apos;mysql&apos;);var connection = mysql.createConnetion(&#123; host: &apos;localhost&apos;, prot: 3306, user: &apos;root&apos;, password: &apos;****&apos;, database: &apos;RUNOOB&apos;&#125;);connection.connect(); // 连接数据库connection.query(&apos;SQL命令&apos;, function (err, result) &#123; // 数据库相应的 CURD &#125;) connection.end(); // 断开连接 MySQL 数据类型MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。 数值类型 日期和时间类型每个时间类型有一个有效值范围和一个&quot;零&quot;值，当指定不合法的MySQL不能表示的值时使用&quot;零&quot;值。 字符串类型字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。 MySQL 创建数据表创建数据表需要：表名、表字段名、定义每个表字段 SQL命令语法： CREATE TABLE table_name (column_name column_type) CREATE TABLE IF NOT EXISTS table_name (column_name column_type) // 判断是否存在 实例： 12345678910CREATE TABLE IF NOT EXISTS `runoob_tbl`( `runoob_id` INT UNSIGNED AUTO_INCREMENT, `runoob_title` VARCHAR(100) NOT NULL, `runoob_author` VARCHAR(40) NOT NULL, `submission_date` DATE, PRIMARY KEY ( `runoob_id` ))ENGINE=InnoDB DEFAULT CHARSET=utf8;1.如果你不想字段为 NULL 可以设置字段的属性为 NOT NULL2.AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。3.PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。 在命令提示窗口中创建数据表12345678910root@host# mysql -u root -pEnter password:*******mysql&gt; use RUNOOB;mysql&gt; CREATE TABLE runoob_tbl( -&gt; runoob_id INT NOT NULL AUTO_INCREMENT, -&gt; runoob_title VARCHAR(100) NOT NULL, -&gt; runoob_author VARCHAR(40) NOT NULL, -&gt; submission_date DATE, -&gt; PRIMARY KEY ( runoob_id ) -&gt; )ENGINE=InnoDB DEFAULT CHARSET=utf8; node.js中创建表1234connection.query(&quot;CREATE TABLE person(id int,user varchar(255),password varchar(255))&quot;, function(err,result)&#123; if(err)&#123;throw err&#125; console.log(&quot;创建表成功&quot;)&#125;) MySQL 删除数据表语法： DROP TABLE table_name 在命令提示窗口中删除数据表1234root@host# mysql -u root -pEnter password:*******mysql&gt; use RUNOOB;mysql&gt; DROP TABLE runoob_tbl node.js中删除表1234connection.query(&apos;DROP TABLE runoob_tbl&apos;, function (err, result) &#123; if (err) throw err; console.log(result);&#125;) MySQL 插入数据语法： INSERT INTO table_name (field1, field2, ...filedN) VALUES (value1, value2, value3); 通过命令提示窗口插入数据1234567root@host# mysql -u root -p password;Enter password:*******mysql&gt; use RUNOOB;mysql&gt; INSERT INTO runoob_tbl -&gt; (runoob_title, runoob_author, submission_date) -&gt; VALUES -&gt; (&quot;学习 PHP&quot;, &quot;菜鸟教程&quot;, NOW()); 读取某张表 -- select * from runoob_tbl; node.js插入数据1234567connection.query(&apos;INSERT INTO websites(id, name, url, alexa, country) VALUES (0, &quot;fanerge&quot;, &quot;23213&quot;, &quot;234&quot;, &quot;成都&quot;)&apos;, function (err, result) &#123; console.log(result);&#125;);// 占位符的形式connection.query(&apos;INSERT INTO websites(id, name, url, alexa, country) VALUES (0, ?, ?, ?)&apos;, [&quot;fanerge12&quot;, &quot;23213&quot;, &quot;234&quot;, &quot;成都&quot;], function (err, result) &#123; console.log(&apos;DELETE affectedRows:&apos;, result);&#125;); MySQL 查询数据语法： SELECT column_name, column_name FROM table_name // 可以查询多张表以,分隔 [WHERE clause] // 查询条件 [OFFSET M][LIMIT N] // 偏移量 和 限制条数 通过命令提示符获取数据1select * from runoob_tbl node.js查询数据123connection.query(&apos;SELECT name, url FROM websites&apos;, function (err, result) &#123; console.log(result);&#125;); MySQL WHERE 子句可以用在：SELECT 和 DELETE 和 UPDATE 命令中。 默认where语句不区分大小写，使用BINARY开启区分大小写。 语法： SELECT field1, field2, ...filedN FROM table_name1, table_name2 [WHERE confition1 [AND [OR]]] condition2 从命令提示符中读取数据123 SELECT name, url FROM user WHERE name=&quot;fanerge&quot; AND url=&quot;fanerge&quot; ``` #### node.js读取数据 connection.query(&apos;SELECT name, url FROM user WHERE name=&quot;fanerge&quot; AND url=&quot;fanerge&quot;&apos;, function (err, result) { console.log(result); }); 12345### MySQL UPDATE 查询 语法： UPDATE table_name SET field1=new-value1, field1=new-value2 [WHERE clause]#### 通过命令提示符更新数据 UPDATE runoob_tbl SET runoob_title=&apos;学习 C++&apos; WHERE runoob_id=3; 1#### node.js更新数据 connection.query(&apos;UPDATE user SET url=&quot;zhongguo&quot; WHERE name=&quot;1name&quot;&apos;, function (err, result) { console.log(result); }); 12345 ### MySQL DELETE 语句 语法： DELETE FROM table_name [WHERE clause]#### 从命令行中删除数据 use RUNOOB; mysql&gt; DELETE FROM runoob_tbl WHERE runoob_id=3; 1#### node.js删除数据 connection.query(&apos;DELETE FROM user WHERE name=&quot;1name&quot;&apos;, function (err, result) { console.log(result); }); 12345678910 ### MySQL LIKE 子句 我们需要获取 runoob_author 字段含有 &quot;COM&quot; 字符的所有记录，这时我们就需要在 WHERE 子句中使用 SQL LIKE 子句。 如果没有使用百分号 %, LIKE 子句与等号 = 的效果是一样的。 语法： SELECT field1, field2, ...filedN FROM table_name WHERE field1 LIKE confition1 [AND [OR]] field2 = &apos;somevalue&apos;#### 在命令提示符中使用 LIKE 子句 以下是我们将 runoob_tbl 表中获取 runoob_author 字段中以 COM 为结尾的的所有记录： use RUNOOB SELECT * from runoob_tl WHERE runoob_author LIKE &apos;%COM&apos; 1#### node.js中使用 LIKE 子句 connection.query(&apos;SELECT * FROM websites WHERE BINARY name LIKE &quot;f%&quot;&apos;, function (err, result) { console.log(result); }); 1234567891011121314 ### MySQL UNION 操作符 MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。 多个 SELECT 语句会删除重复的数据。 UNION [ALL | DISTINCT] // DISTINCT: 可选，删除结果集中重复的数据。ALL: 可选，返回所有结果集，包含重复数据。 语法： SELECT column1, column2, ... columnN FROM tables [WHERE conditions] UNION [ALL | DISTINCT] SELECT column1, column2, ... columnN FROM tables [WHERE conditions];#### node.js 中使用 UNION connection.query(&apos;SELECT country FROM websites UNION ALL SELECT country FROM apps ORDER BY country&apos;, function (err, result) { console.log(result); }); 1#### 带有 WHERE 的 SQL UNION ALL connection.query(&apos;SELECT country, name FROM websites WHERE country LIKE &quot;C%&quot; UNION ALL SELECT country, app_name FROM apps WHERE country=&quot;CN&quot; ORDER BY country&apos;, function (err, result) { console.log(result); }); 123456 ### MySQL 排序 语法： SELECT field1, field2, ...filedN table_name1, table_name2 ORDER BY field1, [field2] [ASC [DESC]] #### 在命令提示符中使用 ORDER BY 子句 use RUNOOB; mysql&gt; SELECT * from runoob_tbl ORDER BY submission_date ASC; 1#### node.js 中 ORDER BY [ASC DESC] connection.query(&apos;SELECT * FROM websites ORDER BY id DESC&apos;, function (err, result) { console.log(result); }); 12345678 ### MySQL GROUP BY 语句 语法： SELECT column_name, function(column_name) FROM table_name WHERE column_name operator value GROUP BY column_name;#### 我们使用 GROUP BY 语句 将数据表按名字进行分组，并统计每个人有多少条记录 SELECT name, COUNT(*) FROM employee_tbl GROUP BY name; 123#### 使用 WITH ROLLUP WITH ROLLUP 可以实现在分组统计数据基础上再进行相同的统计（SUM,AVG,COUNT…）。 coalesce函数说明：name !== null ? name : &apos;总数&apos;。 SELECT coalesce(name, &quot;总数&quot;), SUM(singin) as singin_count FROM employee_tbl GROUP BY name WITH ROLLUP 123456789### Mysql 连接的使用 从多个数据表中读取数据。 你可以在 SELECT, UPDATE 和 DELETE 语句中使用 Mysql 的 JOIN 来联合多表查询。 JOIN 按照功能大致分为如下三类： 1. INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。(类似于交集) 2. LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。 3. RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。 #### 在命令提示符中使用 INNER JOIN(相当于交集) SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a INNER JOIN tcount_tbl b ON a.runoob_author = b.runoob_author; SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a, tcount_tbl b WHERE a.runoob_author = b.runoob_author; 12#### MySQL LEFT JOIN MySQL left join 与 join 有所不同。 MySQL LEFT JOIN 会读取左边数据表的全部数据，即便右边表无对应数据。 SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a LEFT JOIN tcount_tbl b ON a.runoob_author = b.runoob_author; 12#### MySQL RIGHT JOIN MySQL RIGHT JOIN 会读取右边数据表的全部数据，即便左边边表无对应数据。 SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a RIGHT JOIN tcount_tbl b ON a.runoob_author = b.runoob_author; 1234567891011### MySQL NULL 值处理 IS NULL: 当列的值是 NULL,此运算符返回 true。 IS NOT NULL: 当列的值不为 NULL, 运算符返回 true。 &lt;=&gt;: 比较操作符（不同于=运算符），当比较的的两个值为 NULL 时返回 true。#### 在命令提示符中使用 NULL 值 SELECT * FROM runoob_test_tbl WHERE runoob_count IS NULL; SELECT * FROM runoob_test_tbl WHERE runoob_count IS NOT NULL;### MySQL 正则表达式![mysql_regexp](/images/mysql_regexp1.png) SELECT name FROM websites WHERE BINARY name REGEXP &apos;^F&apos; SELECT name FROM person_tbl WHERE name REGEXP &apos;ok$&apos;; ``` 参考文档 MYSQL]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js 和 mysql 结合使用]]></title>
    <url>%2F2017%2Fnode-mysql.html</url>
    <content type="text"><![CDATA[可视化工具：navicat for MySQL node和mysql的配合mysql和node.js的连接1234567891011121314151617181920212223var mysql = require(&apos;mysql&apos;);var connection = mysql.createConnection(&#123; host : &apos;localhost&apos;, // 数据库的ip port : 3306, // 数据库起服务的端口 user : &apos;root&apos;, password : &apos;123456&apos;, database : &apos;test&apos; // 数据库名称&#125;);// 链接数据库 connection.connect();// 推荐使用下面的链接方式connection.connect(function(err) &#123; if (err) &#123; console.error(&apos;error connecting: &apos; + err.stack); return; &#125; console.log(&apos;connected as id &apos; + connection.threadId); // 线程id&#125;);// 测试数据库是否连接成功 connection.query(&apos;SELECT 1 + 1 AS solution&apos;, function (error, results, fields) &#123; if (error) throw error; console.log(&apos;The solution is: &apos;, results[0].solution);&#125;); 创建表1234connection.query(&quot;CREATE TABLE person(id int,user varchar(255),password varchar(255))&quot;, function(err,result)&#123; if(err)&#123;throw err&#125; console.log(&quot;创建表成功&quot;)&#125;) 连接池连接池连接1234567891011121314151617181920var pool = mysql.createPool(&#123; connectionLimit : 10, host : &apos;example.org&apos;, user : &apos;bob&apos;, password : &apos;secret&apos;, database : &apos;my_db&apos; &#125;); // 测试数据库是否连接成功 pool.query(&apos;SELECT 1 + 1 AS solution&apos;, function (error, results, fields) &#123; if (error) throw error; console.log(&apos;The solution is: &apos;, results[0].solution);&#125;);// 使用连接池连接可以更容易地共享某个连接，也可以管理多个连接。pool.getConnection(function(err, connection) &#123; // 使用连接 connection.query( &apos;SELECT something FROM sometable&apos;, function(err, rows) &#123; // 使用连接执行查询 connection.release(); //连接不再使用，返回到连接池 connection.destroy(); // 如果你想关闭连接并从连接池中删除它，在下次需要时连接池会再创建一个新的连接。 &#125;); &#125;); 连接池的事件连接123pool.on(&apos;connection&apos;, function (connection) &#123; connection.query(&apos;SET SESSION auto_increment_increment=1&apos;) &#125;); 入列123pool.on(&apos;enqueue&apos;, function () &#123; console.log(&apos;Waiting for available connection slot&apos;); &#125;); 在连接池中关闭所有连接如不再需要连接池时，你必须关闭所有连接。 123pool.end(function (err) &#123; // all connections in the pool have ended &#125;); 集群连接池集群连接池提供多主机连接.(分组&amp;重试&amp;选择器) 1234567891011121314151617181920212223242526272829// create var poolCluster = mysql.createPoolCluster(); // add configurations (the config is a pool config object) poolCluster.add(config); // add configuration with automatic name poolCluster.add(&apos;MASTER&apos;, masterConfig); // add a named configuration poolCluster.add(&apos;SLAVE1&apos;, slave1Config); poolCluster.add(&apos;SLAVE2&apos;, slave2Config); // remove configurations poolCluster.remove(&apos;SLAVE2&apos;); // By nodeId poolCluster.remove(&apos;SLAVE*&apos;); // By target group : SLAVE1-2 // Target Group : ALL(anonymous, MASTER, SLAVE1-2), Selector : round-robin(default) poolCluster.getConnection(function (err, connection) &#123;&#125;); // Target Group : MASTER, Selector : round-robin poolCluster.getConnection(&apos;MASTER&apos;, function (err, connection) &#123;&#125;); // Target Group : SLAVE1-2, Selector : order // If can&apos;t connect to SLAVE1, return SLAVE2. (remove SLAVE1 in the cluster) poolCluster.on(&apos;remove&apos;, function (nodeId) &#123; console.log(&apos;REMOVED NODE : &apos; + nodeId); // nodeId = SLAVE1 &#125;); poolCluster.getConnection(&apos;SLAVE*&apos;, &apos;ORDER&apos;, function (err, connection) &#123;&#125;); // of namespace : of(pattern, selector) poolCluster.of(&apos;*&apos;).getConnection(function (err, connection) &#123;&#125;); var pool = poolCluster.of(&apos;SLAVE*&apos;, &apos;RANDOM&apos;); pool.getConnection(function (err, connection) &#123;&#125;); pool.getConnection(function (err, connection) &#123;&#125;); // close all connections poolCluster.end(function (err) &#123; // all connections in the pool cluster have ended &#125;); 更换用户并且改变连接状态该命令允许你在不关闭下列socket的情况下，改变当前用户和连接的其余部分. 123connection.changeUser(&#123;user : &apos;john&apos;&#125;, function(err) &#123; if (err) throw err; &#125;); 数据库操作（CURD）代表创建（Create）、更新（Update）、读取（Retrieve）和删除（Delete）操作。 查询数据（Retrieve）query(sqlString, callback)第一个参数是一条SQL字符串，第二个参数是回调 123456connection.query(&apos;SELECT * FROM `books` WHERE `author` = &quot;David&quot;&apos;, function (error, results, fields) &#123; if (error) &#123; console.log(error.message); &#125; // 查询之后的操作&#125;); query(sqlString, values, callback)带有值的占位符 (查看转义查询值) 1234567connection.query(&apos;SELECT * FROM `books` WHERE `author` = ?&apos;, [&apos;David&apos;], function (error, results, fields) &#123; if (error) &#123; console.log(error.message); &#125; // 查询之后的操作&#125;);connection.end(); // 断开数据库连接 query(options, callback)在查询时带有大量的高级可选项 12345678910connection.query(&#123; sql: &apos;SELECT * FROM `books` WHERE `author` = ?&apos;, timeout: 40000, values: [&apos;David&apos;] &#125;, function (error, results, fields) &#123; if (error) &#123; console.log(error.message); &#125; // 查询之后的操作&#125;); 查询值转义为了防止SQL注入，每当需要在SQL查询中使用用户数据时，你都应当提前对这些值进行转义。 12345678910// 第一种，转义可以通过 mysql.escape(), connection.escape() 或 pool.escape() 方法实现。var userId = &apos;some user provided value&apos;; var sql = &apos;SELECT * FROM users WHERE id = &apos; + connection.escape(userId); connection.query(sql, function(err, results) &#123; // ... &#125;);// 第二种，使用 ? 作为查询字符串中的占位符，替代你想要转义的值。connection.query(&apos;SELECT * FROM users WHERE id = ?&apos;, [userId], function(err, results) &#123; // ... &#125;); 查询标识符转义如果用户提供了不可信的查询标识符（数据库名、表名、列名）， 你应该用 mysql.escapeId(identifier), connection.escapeId(identifier) 或 pool.escapeId(identifier) 方法对它进行转义。 12345678910var sorter = &apos;date&apos;; var sql = &apos;SELECT * FROM posts ORDER BY &apos; + connection.escapeId(sorter); connection.query(sql, function(err, results) &#123; // ... &#125;);var userId = 1; var columns = [&apos;username&apos;, &apos;email&apos;]; var query = connection.query(&apos;SELECT ?? FROM ?? WHERE id = ?&apos;, [columns, &apos;users&apos;, userId], function(err, results) &#123; // SELECT `username`, `email` FROM `users` WHERE id = 1&#125;); 预查询你可以使用 mysql.format 来创建一个多插入点的查询语句，对id和值可以使用适当的转义处理 。 这样你就获得了一个有效并且安全的查询语句，然后可以把它发送给 数据库。 123var sql = &quot;SELECT * FROM ?? WHERE ?? = ?&quot;; var inserts = [&apos;users&apos;, &apos;id&apos;, userId]; sql = mysql.format(sql, inserts); 插入数据（Insert）1234567891011var addSql = &apos;INSERT INTO websites(Id, name, url, alexa, country) VALUES(0, ?, ?, ?, ?)&apos;;var addSqlParams = [&quot;fanerge&apos;s Blogs&quot;, &apos;fanerge.githut.io&apos;, &apos;333325&apos;, &apos;CN&apos;];connection.query(addSql, addSqlParams, function (err, result) &#123; if (err) &#123; console.log(&apos;[SELECT ERROR] - &apos;, err.message); &#125; console.log(&apos;-------INSERT--------&apos;); console.log(&apos;INSERT ID:&apos;, result); console.log(&apos;-------END--------&apos;);&#125;);connection.end(); 更新数据（Update）1234567891011var modSql = &apos;UPDATE websites SET name = ?, url = ?, alexa = ? WHERE Id = ?&apos;;var modSqlParams = [&quot;fanerge&apos;s Blogs&quot;, &apos;https://fanerge.github.io&apos;, 23, 6]connection.query(modSql, modSqlParams, function (err, result) &#123; if (err) &#123; console.log(&apos;[UPDATE ERROR] - &apos;, err.message); &#125; console.log(&apos;-------UPDATE--------&apos;); console.log(&apos;UPDATE affectedRows:&apos;, result.affectedRows); console.log(&apos;-------END--------&apos;);&#125;);connection.end(); 删除数据（Delete）12345678910var delSql = &apos;DELETE FROM websites WHERE name = &quot;fanerge&apos;s Blogs&quot;&apos;;connection.query(delSql, function (err, result) &#123; if (err) &#123; console.log(&apos;[DELETE ERROR] - &apos;, err.message); &#125; console.log(&apos;-------DELETE--------&apos;); console.log(&apos;DELETE affectedRows:&apos;, result.affectedRows); console.log(&apos;-------END--------&apos;);&#125;);connection.end(); 常用技巧获取插入行的id如果你把一行插入到一个有自增主键的表中，可以这样获得插入的ID 123connection.query(&apos;INSERT INTO posts SET ?&apos;, &#123;title: &apos;test&apos;&#125;, function(err, result) &#123; if (err) throw err; console.log(result.insertId); &#125;); 取得受影响的行数你可以从 insert，update 或者 delete 子句中取得受影响的行数。 1234connection.query(&apos;DELETE FROM posts WHERE title = &quot;wrong&quot;&apos;, function (err, result) &#123; if (err) throw err; console.log(&apos;deleted &apos; + result.affectedRows + &apos; rows&apos;); &#125;) 取得被改变的行数你可以从 update 子句取得被改变的行数。 1234connection.query(&apos;UPDATE posts SET ...&apos;, function (err, result) &#123; if (err) throw err; console.log(&apos;changed &apos; + result.changedRows + &apos; rows&apos;); &#125;) 获取连接ID你可以取得MySQL的连接ID（“线程ID”），这是一个给定的连接，使用的是线程ID属性。 1234connection.connect(function(err) &#123; if (err) throw err; console.log(&apos;connected as id &apos; + connection.threadId); &#125;); 并行执行查询MySQL协议是顺序的，这意味着你需要多次连接执行并行查询。 你可以使用池来管理连接，一个简单的办法是每传入一个http请求，就创建一个连接。 流式查询行有的时候可能需要查询大量的数据行，然后在接收到这些数据行的时候一行行的处理它们。 1234567891011121314151617var query = connection.query(&apos;SELECT * FROM posts&apos;); query.on(&apos;error&apos;, function(err) &#123; // 处理错误，这之后会触发 &apos;end&apos; 事件 &#125;) .on(&apos;fields&apos;, function(fields) &#123; // 字段信息 &#125;).on(&apos;result&apos;, function(row) &#123; // 暂停连接。如果你的处理过程涉及到 I/O 操作，这会很有用。 connection.pause(); processRow(row, function() &#123; connection.resume(); &#125;); &#125;).on(&apos;end&apos;, function() &#123; // 所有数据行都已经接收完毕 &#125;); 通过 Streams2 管道输出通过管道将查询结果输出到另一个流（最大缓冲 5 个对象） 123connection.query(&apos;SELECT * FROM posts&apos;) .stream(&#123;highWaterMark: 5&#125;) .pipe(...); 多语句查询123456// 开启多语句查询var connection = mysql.createConnection(&#123;multipleStatements: true&#125;);connection.query(&apos;SELECT 1; SELECT 2&apos;, function(err, results) &#123; if (err) throw err; // `results` is an array with one element for every statement in the query: &#125;); 总结： 先使用var connection = mysql.createConnection方法一个数据库连接的配置项 使用connection.connect方法连接数据库 使用sql语句对数据库进行CURD操作 操作完成后需使用connection.end方法断开数据库连接connection.end(function (err) { … }); // 支持回调connection.destroy(); // 该方法会立即终止底层套接字（underlying socket）。另外，destroy()不会触发更多的事件和回调函数。 参考文档：Node.js 连接 MySQL如何在node.js里连接和使用mysqlmysqljsmysql]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grid布局]]></title>
    <url>%2F2017%2Fgrid%E5%B8%83%E5%B1%80.html</url>
    <content type="text"><![CDATA[设置在网格容器上的属性display: grid | inline-grid | subgrid; grid-template-columns grid-template-rows grid-template-areas grid-column-gap grid-row-gap grid-gap justify-items align-items align-content grid-auto-columns grid-auto-rows grid-auto-flow grid 设置在网格项上的属性grid-column-start grid-column-end grid-row-start grid-row-end grid-column grid-row grid-area justify-self align-self 显式的网格html123456789&lt;section class=&quot;grid&quot;&gt; &lt;div class=&quot;item&quot;&gt;item1&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;item1&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;item1&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;item1&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;item1&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;item1&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;item1&lt;/div&gt;&lt;/section&gt; css123456.grid &#123; display: grid; grid-template-columns: 1fr 2fr 3fr; // 指定3个列，分别指定每个列的宽度（1/6, 2/6, 3/6）。 grid-template-rows: 100px 100px; // 指定2行，分别指定每个行的宽度 grid-gap: 20px 10px; // 指定行间距和列间距（若只有一个参数是行和类间距取相同值）&#125; 重复轨道css123456.grid &#123; display: grid; grid-template-columns: repeat(3, 1fr 2fr); // 第一个参数指定的是重复次数，第二个参数是每次重复的轨道列表（共3*2=6列）。 grid-template-rows: 100px 100px; grid-gap: 20px 1px;&#125; 自动重复轨道css123456789101112.grid &#123; display: grid; grid-template-columns: repeat(auto-fill, 100px); // auto-fill关键词创建了许多与网格容器相匹配的轨道，而不会导致网格溢出。 grid-template-rows: 100px 100px; grid-gap: 20px 10px;&#125;.grid &#123; display: grid; grid-template-columns: repeat(auto-fit, 100px); // auto-fit关键词与auto-fill有点类似，只是在网格项放置之后，它只会在需要时创建尽可能多的轨道，而重复的空轨道会堆叠在一起（合并）。 grid-template-rows: 100px 100px; grid-gap: 20px 10px;&#125; 隐式网格如果网格中有更多的网格项，或者网格项被放置在显式网格之外，网格容器就会通过向网格中添加网格线来自动生成网格轨道。 显式网格和这些额外的隐式轨道和网格线构成了所谓的隐式网格。 css对于子项目 123456.item:first-child &#123; grid-column-start: -1;&#125;.item:nth-child(2) &#123; grid-row-start: 4;&#125; 隐式轨道尺寸css12345678910.grid &#123; display: grid; grid-template-columns: repeat(4, 1fr); grid-template-rows: 100px 100px; grid-gap: 20px; grid-auto-columns: 200px; grid-auto-rows: 60px; grid-auto-columns: minmax(200px, auto); // 隐藏轨道现在最小宽度是200px grid-auto-rows: minmax(auto, 300px); // 隐藏轨道现在最大高度度是300px&#125; 将网格扩展到开始css12345678.item:first-child &#123; grid-row-end: 1; grid-row-start: span 3; // 开始跨越3个单元格&#125;.item:nth-child(2) &#123; grid-column-end: 2; grid-column-start: span 2; // 开始跨越2个单元格&#125; 自动放置css我们可以通过使用grid-auto-flow属性来指定如何把网格项目自动放置到网格容器。 123.grid2 &#123; grid-auto-flow: column;&#125; 未定义显式网格使用grid-auto-rows和grid-auto-columns可以自动地调整单元格大小，因此不需要定义显式网格。 参考文档 显式网格和隐式网格的区别 Grid布局指南]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node-学习（七天学会NodeJs）]]></title>
    <url>%2F2017%2Fnode-%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[NodeJs基础模块在编写每个模块时，都有require、exports、module三个预先定义好的变量可供使用。 requirerequire函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。模块名可使用相对路径（以./开头），或者是绝对路径（以/或C:之类的盘符开头）。另外，模块名中的.js扩展名可以省略。 12345var foo1 = require(&apos;./foo&apos;);var foo2 = require(&apos;./foo.js&apos;);var foo3 = require(&apos;/home/user/foo&apos;);var foo4 = require(&apos;/home/user/foo.js&apos;);// foo1至foo4中保存的是同一个模块的导出对象。 还可以加载使用JSON文件 1var data = require(&apos;./data.json&apos;); exportsexports对象是当前模块的导出对象，用于导出模块公有方法和属性。别的模块通过require函数使用当前模块时得到的就是当前模块的exports对象。 以下例子中导出了一个公有方法。 123exports.hello = function () &#123; console.log(&apos;fanerge&apos;);&#125;; module通过module对象可以访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。 例如模块导出对象默认是一个普通对象，如果想改成一个函数的话，可以使用以下方式。 123module.exports = function () &#123; console.log(&apos;fanerge&apos;);&#125;; 代码的组织和部署模块路径的解析规则（先后顺序） 内置模块如果传递给require函数的是NodeJS内置模块名称，不做路径解析，直接返回内部模块的导出对象，例如require(‘fs’)。 node_modules目录（第三方包）NodeJS定义了一个特殊的node_modules目录用于存放模块。例如某个模块的绝对路径是/home/user/hello.js，在该模块中使用require(‘foo/bar’)方式加载模块时，则NodeJS依次尝试使用以下路径。 123/home/user/node_modules/foo/bar/home/node_modules/foo/bar/node_modules/foo/bar NODE_PATH环境变量与PATH环境变量类似，NodeJS允许通过NODE_PATH环境变量来指定额外的模块搜索路径。NODE_PATH环境变量中包含一到多个目录路径，路径之间在Linux下使用:分隔，在Windows下使用;分隔。例如定义了以下NODE_PATH环境变量： 1NODE_PATH=/home/user/lib:/home/lib 当使用require(‘foo/bar’)的方式加载模块时，则NodeJS依次尝试以下路径。 12/home/user/lib/foo/bar/home/lib/foo/bar 包（package）我们已经知道了JS模块的基本单位是单个JS文件，但复杂些的模块往往由多个子模块组成。为了便于管理和使用，我们可以把由多个子模块组成的大模块称做包，并把所有子模块放在同一个目录里。在组成一个包的所有子模块中，需要有一个入口模块，入口模块的导出对象被作为包的导出对象。 示例一个标准包： -cat: doc -- 包说明文档 -lib -- 包具体代码 head.js body.js index.js -- 入口文件 tests -- 测试用例 package.json -- 包的说明及依赖关系 123456789101112131415// index.js具体代码var head = require(&apos;./head&apos;);var body = require(&apos;./body&apos;);exports.create = function (name) &#123; return &#123; name: name, head: head.create(), body: body.create() &#125;;&#125;;// package.json具体代码&#123; &quot;name&quot;: &quot;cat&quot;, &quot;main&quot;: &quot;./lib/index.js&quot; // 入口模块位置&#125; 工程目录一个标准的工程目录 /home/user/workspace/node-echo/ # 工程目录 -bin/ # 存放命令行相关代码 node-echo +doc/ # 存放文档 -lib/ # 存放API相关代码 echo.js -node_modules/ # 存放第三方包 babel +tests/ # 存放测试用例 package.json # 元数据文件 README.md # 说明文件 npm安装第三方包 1npm install argv 安装第三方包（特定版本） 1npm install argv@0.0.1 批量安装 还可以在package.json中dependencies字段中写入所有依赖包 123456&quot;dependencies&quot;: &#123; &quot;argv&quot;: &quot;0.0.2&quot;, ... &#125;// 在使用指令批量安装npm install 更新包 1npm update &lt;package&gt; 清除NPM本地缓存 1npm cache clear（用于对付使用相同版本号发布新版本代码的人） 文件操作文件拷贝练手// copy.js 12345678910var fs = require(&apos;fs&apos;);function copy(src, dst) &#123; fs.writeFileSync(dst, fs.readFileSync(src));&#125;function main(argv) &#123; copy(argv[0], argv[1]);&#125;main(process.argv.slice(0, 2));// 进行拷贝node copy.js 以上程序使用fs.readFileSync从源路径读取文件内容，并使用fs.writeFileSync将文件内容写入目标路径。 process是一个全局变量，可通过process.argv获得命令行参数。由于argv[0]固定等于NodeJS执行程序的绝对路径，argv[1]固定等于主模块的绝对路径 文件操作有关的APIBuffer（数据块）NodeJS提供了一个与String对等的全局构造函数Buffer来提供对二进制数据的操作。 12345678910// 构造一个Buffer实例var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);// Buffer实例具有length属性和bin[index]bin[0]; // =&gt; 0x68;// Buffer实例转化指定编码的字符串var str = bin.toString(&apos;utf-8&apos;); // =&gt; &quot;hello&quot;// 将字符串转化为指定编码的二进制数据var bin = new Buffer(&apos;hello&apos;, &apos;utf-8&apos;); // =&gt; &lt;Buffer 68 65 6c 6c 6f&gt;// Buffer与字符串有一个重要区别。字符串是只读的，并且对字符串的任何修改得到的都是一个新字符串，原字符串保持不变。// 至于Buffer，更像是可以做指针操作的C语言数组。例如，可以用[index]方式直接修改某个位置的字节。 Buffer拷贝的例子 1234567// 如果想要拷贝一份Buffer，得首先创建一个新的Buffer，并通过.copy方法把原Buffer中的数据复制过去。// 这个类似于申请一块新的内存，并把已有内存中的数据复制过去。var bin = new Buffer([0x68, 0x65, 0x6c, 0x6c, 0x6f]);var dup = new Buffer(bin.length);bin.copy(dup);dup[0] =0x46;console.log(bin, dup); Stream（数据流）Stream的使用场景： 当内存中无法一次装下需要处理的数据时。 一边读取一边处理更加高效时，我们就需要用到数据流。实例–将a.js拷贝到b.js123456789101112131415161718var fs = require(&apos;fs&apos;);var rs = fs.createReadStream(process.argv[1].slice(0, -7) + &apos;a.js&apos;);var ws = fs.createWriteStream(process.argv[1].slice(0, -7) + &apos;b.js&apos;);rs.on(&apos;data&apos;, function (chunk) &#123; // 传入的数据是否写入目标 if (ws.write(chunk) === false) &#123; rs.pause(); &#125;&#125;);rs.on(&apos;end&apos;, function () &#123; ws.end();&#125;);// 判断什么时候只写数据流已经将缓存中的数据写入目标，可以传入下一个待写数据了ws.on(&apos;drain&apos;, function () &#123; rs.resume();&#125;); File System（文件系统）NodeJS通过fs内置模块提供对文件的操作。fs模块提供的API基本上可以分为以下三类： 文件属性读写。其中常用的有fs.stat、fs.chmod、fs.chown等等。 文件内容读写。其中常用的有fs.readFile、fs.readdir、fs.writeFile、fs.mkdir等等。 底层文件操作。其中常用的有fs.open、fs.read、fs.write、fs.close等等同步API除了方法名的末尾多了一个Sync之外，异常对象与执行结果的传递方式也有相应变化。// 异步处理文件及异常处理 12345678var fs = require(&apos;fs&apos;);fs.readFile(process.argv[1].slice(0, -7) + &apos;a.js&apos;, function (error, data) &#123; if (error) &#123; console.error(error); &#125; else &#123; console.log(data); &#125;&#125;); // 同步处理文件及异常处理 1234567var fs = require(&apos;fs&apos;);try&#123; var data = fs.readFileSync(process.argv[1].slice(0, -7) + &apos;a.js&apos;); console.log(data);&#125;catch(err)&#123; console.error(err)&#125; Path（路径）NodeJS提供了path内置模块来简化路径相关操作，并提升代码可读性。 path.normalize(str) 将传入的路径转换为标准路径，除了解析路径中的.与..外，还能去掉多余的斜杠。 12345678910var fs = require(&apos;fs&apos;);var path = require(&apos;path&apos;);var cache = &#123;&#125;;function store (key, value) &#123; cache[path.normalize(key)] = value; console.dir(cache);&#125;store(&apos;/home&apos;, 1);store(&apos;/home/user&apos;, 44);// 标准化之后的路径里的斜杠在Windows系统下是\，而在Linux系统下是/。如果想保证任何系统下都使用/作为路径分隔符的话，需要用.replace(/\\/g, &apos;/&apos;)再替换一下标准路径。 path.join() 将传入的多个路径拼接为标准路径。该方法可避免手工拼接路径字符串的繁琐，并且能在不同系统下正确使用相应的路径分隔符。 1path.join(&apos;foo/&apos;, &apos;baz/&apos;, &apos;../bar&apos;); // =&gt; &quot;foo/bar&quot; path.extname() 当我们需要根据不同文件扩展名做不同操作时，该方法就显得很好用。 1path.extname(&apos;foo/bar.js&apos;); // =&gt; &quot;.js&quot; 遍历目录遍历目录是操作文件时的一个常见需求。比如写一个程序，需要找到并处理指定目录下的所有JS文件时，就需要遍历整个目录。 递归算法计算N的阶乘 12345678function factorial (n) &#123; if (n === 1) &#123; return 1; &#125; else &#123; return n * factorial(n-1); &#125;&#125;// 使用递归算法编写的代码虽然简洁，但由于每递归一次就产生一次函数调用，在需要优先考虑性能时，需要把递归算法转换为循环算法，以减少函数调用次数。 遍历算法目录是一个树状结构，在遍历时一般使用深度优先+先序遍历算法。 同步遍历 1234567891011121314function travel (dir, callback) &#123; try &#123; fs.readdirSync(dir).forEach(function (file) &#123; var pathname = path.join(dir, file); if (fs.statSync(pathname).isDirectory()) &#123; travel(pathname, callback); &#125; else &#123; callback(pathname); &#125; &#125;); &#125;catch(e)&#123; console.error(e); &#125;&#125; 异步遍历（有点复杂） 1234567891011121314151617181920212223function travel(dir, callback, finish) &#123; fs.readdir(dir, function (err, files) &#123; (function next(i) &#123; if (i &lt; files.length) &#123; var pathname = path.join(dir, files[i]); fs.stat(pathname, function (err, stats) &#123; if (stats.isDirectory()) &#123; travel(pathname, callback, function () &#123; next(i + 1); &#125;); &#125; else &#123; callback(pathname, function () &#123; next(i + 1); &#125;); &#125; &#125;); &#125; else &#123; finish &amp;&amp; finish(); &#125; &#125;(0)); &#125;);&#125; 文本编码我们常用的文本编码有UTF8和GBK两种，并且UTF8文件还可能带有BOM。在读取不同编码的文本文件时，需要将文件内容转换为JS使用的UTF8编码字符串后才能正常处理。 BOM的移除1234567function readText (pathname) &#123; var bin = fs.readFileAync(pathname); if (bin[0] === 0xFF &amp;&amp; bin[1] === oxBB &amp;&amp; bin[2] === 0xBF) &#123; bin = bin.slice(3); &#125; return bin.toString(&apos;utf-8&apos;);&#125; GBK转UTF8123456// 第三方包转换编码var iconv = require(&apos;iconv-lite&apos;); function readGBKText(pathname) &#123; var bin = fs.readFileSync(pathname); return iconv.decode(bin, &apos;gbk&apos;);&#125; 单字节编码不管大于0xEF的单个字节在单字节编码下被解析成什么乱码字符，使用同样的单字节编码保存这些乱码字符时，背后对应的字节保持不变。 12345function replace(pathname) &#123; var str = fs.readFileSync(pathname, &apos;binary&apos;); str = str.replace(&apos;foo&apos;, &apos;bar&apos;); fs.writeFileSync(pathname, str, &apos;binary&apos;);&#125; 网络操作例子开启一个服务12345http.createServer(function (request, response) &#123; response.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text-plain&apos;&#125;); response.end(&apos;Hello world\n&apos;);&#125;).listen(8734);// 以上程序创建了一个HTTP服务器并监听8734端口，打开浏览器访问该端口http://127.0.0.1:8124/就能够看到效果。 网络相关的APIHTTP&apos;http&apos;模块提供两种使用方式： 作为服务端使用时，创建一个HTTP服务器，监听HTTP客户端请求并返回响应。 作为客户端使用时，发起一个HTTP客户端请求，获取服务端响应。在回调函数中，除了可以使用request对象访问请求头数据外，还能把request对象当作一个只读数据流来访问请求体数据。除了可以使用response对象来写入响应头数据外，还能把response对象当作一个只写数据流来写入响应体数据。123456789101112http.createServer(function (request, response) &#123; var body = []; console.log(request.method); console.log(request.headers); request.on(&apos;data&apos;, function (chunk) &#123; body.push(chunk); &#125;); request.on(&apos;end&apos;, function () &#123; body = Buffer.concat(body); console.log(body.toString()); &#125;);&#125;).listen(8734); HTTPShttps模块与http模块极为类似，区别在于https模块需要额外处理SSL证书。 创建一个HTTPS服务器 12345678var options = &#123; key: fs.readFileSync(&apos;./ssl/default.key&apos;), cert: fs.readFileSync(&apos;./ssl/default.cer&apos;) &#125;;var server = https.createServer(options, function (request, response) &#123; // ...&#125;);// 与创建HTTP服务器相比，多了一个options对象，通过key和cert字段指定了HTTPS服务器使用的私钥和公钥。 另外，NodeJS支持SNI技术，可以根据HTTPS客户端请求使用的域名动态使用不同的证书，因此同一个HTTPS服务器可以使用多个域名提供服务。 1234server.addContext(&apos;foo.com&apos;, &#123; key: fs.readFileSync(&apos;./ssl/foo.com.key&apos;), cert: fs.readFileSync(&apos;./ssl/foo.com.cer&apos;)&#125;); URL处理HTTP请求时url模块使用率超高，因为该模块允许解析URL、生成URL，以及拼接URL。 url.parse()将一个URL字符串转换为URL对象 1234var url = require(&apos;url&apos;, [boolean], [boolean]);console.log(url.parse(&apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos;));第二个参数等于true时，该方法返回的URL对象中，query字段不再是一个字符串，而是一个经过querystring模块转换后的参数对象。第三个参数等于true时，该方法可以正确解析不带协议头的URL，例如//www.example.com/foo/bar。 url.format()允许将一个URL对象转换为URL字符串 url.resolve()可以用于拼接URL12var dd = url.resolve(&apos;http://www.baidu.com/yzf/age/sex&apos;, &apos;../va&apos;);// http://www.baidu.com/yzf/va Query Stringquerystring模块用于实现URL参数字符串与参数对象的互相转换. querystring.parse() 将字符串参数转化为对象URL参数 querystring.stringify() 将参数对象转化为URL参数字符串 Zlibzlib模块提供了数据压缩和解压的功能。当我们处理HTTP请求和响应时，可能需要用到这个模块。 例子：使用zlib模块压缩HTTP响应体数据。 这个例子中，判断了客户端是否支持gzip，并在支持的情况下使用zlib模块返回gzip之后的响应体数据。 zlib.gzip() 数据压缩 zlib.gunzip() 数据解压 123456789101112131415161718192021http.createServer(function (request, response) &#123; let i = 1024, data = &apos;&apos;; while (i--) &#123; data += &apos;x&apos;; &#125; if (request.headers[&apos;accept-encoding&apos;].includes(&apos;gzip&apos;)) &#123; zlib.gzip(data, function (err, data) &#123; response.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/plain&apos;, &apos;Content-Encoding&apos;: &apos;gzip&apos; &#125;); response.end(data); &#125;) &#125; else &#123; response.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/plain&apos; &#125;); response.end(data); &#125;&#125;).listen(8888); Netnet模块可用于创建Socket服务器或Socket客户端。 使用Socket搭建一个HTTP服务器的例子。 1234567891011net.createServer(function (conn) &#123; conn.on(&apos;data&apos;, function (data) &#123; conn.write([ &apos;HTTP/1.1 200 OK&apos;, &apos;Content-Type: text/plain&apos;, &apos;Content-Length: 12&apos;, &apos;&apos;, &apos;Hello World&apos; ].join(&apos;\n&apos;)); &#125;);&#125;).listen(8888); 进程管理NodeJS可以感知和控制自身进程的运行环境和状态，也可以创建子进程并与其协同工作，这使得NodeJS可以把多个程序组合在一起共同完成某项工作，并在其中充当胶水和调度器的作用。 node.js调用终端简化目录拷贝 123456789101112var child_process = require(&apos;child_process&apos;);var util = require(&apos;util&apos;);function copy(source, target, callback) &#123; child_process.exec( util.format(&apos;cp -r %s/* %s&apos;, source, target), callback);&#125;copy(process.argv[1].slice(0, -7) + &apos;copy1&apos;, process.argv[1].slice(0, -7) + &apos;copy2&apos;, function (err, data) &#123; if (err) &#123; console.log(err) &#125; console.log(data)&#125;); Process任何一个进程都有启动进程时使用的命令行参数，有标准输入标准输出，有运行权限，有运行环境和运行状态。 另外需要注意的是，process不是内置模块，而是一个全局对象，因此在任何地方都可以直接使用。 Child Process使用child_process模块可以创建和控制子进程。该模块提供的API中最核心的是.spawn，其余API都是针对特定使用场景对它的进一步封装，算是一种语法糖。 Clustercluster模块是对child_process模块的进一步封装，专用于解决单进程NodeJS Web服务器无法充分利用多核CPU的问题。使用该模块可以简化多进程服务器程序的开发，让每个核上运行一个工作进程，并统一通过主进程监听端口和分发请求。 应用场景 如何获取命令行参数 在NodeJS中可以通过process.argv获取命令行参数。 但是比较意外的是，node执行程序路径和主模块文件路径固定占据了argv[0]和argv[1]两个位置，而第一个命令行参数从argv[2]开始。 一般这样获取：process.argv.slice(2) 如何退出程序 123456try &#123; // ...&#125; catch (err) &#123; // ... process.exit(1); // 返回特定的状态码&#125; 如何控制输入输出NodeJS程序的标准输入流（stdin）、一个标准输出流（stdout）、一个标准错误流（stderr）分别对应process.stdin、process.stdout和process.stderr，第一个是只读数据流，后边两个是只写数据流，对它们的操作按照对数据流的操作方式即可。 如何降权在Linux系统下，我们知道需要使用root权限才能监听1024以下端口。但是一旦完成端口监听后，继续让程序运行在root权限下存在安全隐患，因此最好能把权限降下来。 1234567http.createServer(callback).listen(80, function () &#123; var env = process.env, uid = parseInt(env[&apos;SUDO_UID&apos;] || process.getuid(), 10), gid = parseInt(env[&apos;SUDO_GID&apos;] || process.getgid(), 10); process.setgid(gid); process.setuid(uid);&#125;); 如何创建子进程创建NodeJS子进程 12345678910var child = child_process.spawn(&apos;node&apos;, [ &apos;a.js&apos; ]);child.stdout.on(&apos;data&apos;, function (data) &#123; console.log(&apos;stdout: &apos; + data);&#125;);child.stderr.on(&apos;data&apos;, function (data) &#123; console.log(&apos;stderr: &apos; + data);&#125;);child.on(&apos;close&apos;, function (code) &#123; console.log(&apos;child process exited with code &apos; + code);&#125;); 进程间如何通讯 12345678910/* parent.js */var child = child_process.spawn(&apos;node&apos;, [ &apos;child.js&apos; ]);child.kill(&apos;SIGTERM&apos;);/* child.js */process.on(&apos;SIGTERM&apos;, function () &#123; cleanUp(); process.exit(0);&#125;); 进程间如何通讯如果父子进程都是NodeJS进程，就可以通过IPC（进程间通讯）双向传递数据。 12345678910111213141516/* parent.js */var child = child_process.spawn(&apos;node&apos;, [ &apos;child.js&apos; ], &#123; stdio: [ 0, 1, 2, &apos;ipc&apos; ] &#125;);child.on(&apos;message&apos;, function (msg) &#123; console.log(msg);&#125;);child.send(&#123; hello: &apos;hello&apos; &#125;);/* child.js */process.on(&apos;message&apos;, function (msg) &#123; msg.hello = msg.hello.toUpperCase(); process.send(msg);&#125;); 如何守护子进程守护进程一般用于监控工作进程的运行状态，在工作进程不正常退出时重启工作进程，保障工作进程不间断运行。 123456789function spawn(mainModule) &#123; var worker = child_process.spawn(&apos;node&apos;, [ mainModule ]); worker.on(&apos;exit&apos;, function (code) &#123; if (code !== 0) &#123; spawn(mainModule); &#125; &#125;);&#125;spawn(&apos;worker.js&apos;); 异步编程NodeJS最大的卖点——事件机制和异步IO。 回调在代码中，异步编程的直接体现就是回调。异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。 1234setTimeout(function () &#123; console.log(&apos;我是setTimeout&apos;)&#125;, 1000);console.log(&apos;hello&apos;); 理解js中如何实现异步 JS本身是单线程的，无法异步执行，因此我们可以认为setTimeout这类JS规范之外的由运行环境提供的特殊函数做的 事情是创建一个平行线程后立即返回，让JS主进程可以接着执行后续代码，并在收到平行进程的通知后再执行回调函数。 我们仍然回到JS是单线程运行的这个事实上，这决定了JS在执行完一段代码之前无法执行包括回调函数在内的别的代码。 也就是说，即使平行线程完成工作了，通知JS主线程执行回调函数了，回调函数也要等到JS主线程空闲时才能开始执行。 代码设计模式函数返回值使用一个函数的输出作为另一个函数的输入是很常见的需求。 同步方式编写代码： 1var output = fn1(fn2(&apos;input&apos;)); 异步方式编写代码： 由于函数执行结果不是通过返回值，而是通过回调函数传递。 12345fn2(&apos;input&apos;, function (output2) &#123; fn1(output2, function (output1) &#123; // do something &#125;);&#125;); 遍历数组在遍历数组时，使用某个函数依次对数据成员做一些处理也是常见的需求。 同步方式编写代码： 12345var len = arr.length;for (let i = 0; i &lt; len; i++) &#123; arr[i] = sync(arr[i]);&#125;// 所有的数组项处理完，打算做的事 异步方式编写代码(异步串行遍历)： 123456789101112((function next (i, len, callback) &#123; if (i &lt; len) &#123; async(arr[i], function (value) &#123; arr[i] = value; next(i + 1, len, callback); &#125;); &#125; else &#123; callback(); &#125;&#125;)(0, arr.length, function () &#123; // 所有的数组项处理完，打算做的事&#125;)); 异步方式编写代码(异步并行遍历)： 1234567891011121314((function (i, len, count, callback) &#123; for (; i &lt; len; i++) &#123; (function (i) &#123; async(arr[i], function (value) &#123; arr[i] = value; if (++count === len) &#123; callback(); &#125; &#125;) &#125;)(i); &#125;&#125;)(0, arr.length, 0, function () &#123; // 所有的数组项处理完，打算做的事&#125;)) 异常处理JS自身提供的异常捕获和处理机制——try..catch..，只能用于同步执行的代码。 同步异常处理： 因为代码执行路径被打断了，我们就需要在异常冒泡到断点之前用try语句把异常捕获住，并通过回调函数传递被捕获的异常。 12345678910function sync(fn) &#123; return fn();&#125;try &#123; sync(null); // Do something.&#125; catch (err) &#123; console.log(&apos;Error: %s&apos;, err.message);&#125; 异步异常处理： 但由于异步函数会打断代码执行路径，异步函数执行过程中以及执行之后产生的异常冒泡到执行路径被打断的位置时，如果一直没有遇到try语句，就作为一个全局异常抛出。 因为代码执行路径被打断了，我们就需要在异常冒泡到断点之前用try语句把异常捕获住，并通过回调函数传递被捕获的异常。 域（Domain）NodeJS提供了domain模块，可以简化异步代码的异常处理。 一个域就是一个JS运行环境，在一个运行环境中，如果一个异常没有被捕获，将作为一个全局异常被抛出。NodeJS通过process对象提供了捕获全局异常的方法。 1234567process.on(&apos;uncaughtException&apos;, function (err) &#123; console.log(&apos;Error: %s&apos;, err.message);&#125;);setTimeout(function (fn) &#123; fn();&#125;); 使用domain模块创建一个子域（JS子运行环境）。 在子域内运行的代码可以随意抛出异常，而这些异常可以通过子域对象的error事件统一捕获。 我们使用.create方法创建了一个子域对象，并通过.run方法进入需要在子域中运行的代码的入口点。 12345678910111213141516171819202122232425262728function async(request, callback) &#123; // Do something. asyncA(request, function (data) &#123; // Do something asyncB(request, function (data) &#123; // Do something asyncC(request, function (data) &#123; // Do something callback(data); &#125;); &#125;); &#125;);&#125;http.createServer(function (request, response) &#123; var d = domain.create(); // 创建子域 d.on(&apos;error&apos;, function () &#123; response.writeHead(500); response.end(); &#125;); d.run(function () &#123; // 子域运行入口 async(request, function (data) &#123; response.writeHead(200); response.end(data); &#125;); &#125;);&#125;); 陷阱无论是通过process对象的uncaughtException事件捕获到全局异常，还是通过子域对象的error事件捕获到了子域异常，在NodeJS官方文档里都强烈建议处理完异常后立即重启程序，而不是让程序继续运行。 参考书籍： 七天学会NodeJs node中文代码仓库：node学习源代码]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>服务端</tag>
        <tag>web开发</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css加强（多形状图像和心跳灯和竖着排的文字和面包屑导航）]]></title>
    <url>%2F2017%2Fcss%E5%8A%A0%E5%BC%BA-5.html</url>
    <content type="text"><![CDATA[在接下来的一段时间学习看云上购买的一本Web开发实战书籍，来提升自己的软实力。本部分为css实战部分。 多形状图像可以实现多形状图像 border-radius: top right bottom left; 心跳灯1234567891011121314151617.heartbeat &#123; width: 100px; height: 100px; background: red; animation: heartbeat .83s ease-in-out infinite;&#125;@keyframes heartbeat &#123; from &#123; opacity:0.1; &#125; 50% &#123; opacity:1; &#125; to &#123; opacity:0.1; &#125;&#125; 竖着排的文字writing-mode: horizontal-tb | vertical-lr | vertical-rl; horizontal-tb表示水平方向自上而下的书写方式。 vertical-rl表示垂直方向自右向左的书写方式 vertical-lr表示垂直方向自左向右的书写方式 IE writing-mode: lr-tb | tb-rl; lr-tb水平方向自左向右的书写方式 tb-rl垂直方向自上而下的书写方式。 首字母下沉::first-letter伪元素选择器用于选取指定选择器的首字母。 123456p::first-letter &#123; color:#c69c6d; float:left; font-size:5em; margin:0 .2em 0 0;&#125; 参考文档 web开发实战 linear-gradient代码仓库]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>web开发</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css加强（表单和文本样式和动态边框和上传组件美化）]]></title>
    <url>%2F2017%2Fcss%E5%8A%A0%E5%BC%BA-4.html</url>
    <content type="text"><![CDATA[在接下来的一段时间学习看云上购买的一本Web开发实战书籍，来提升自己的软实力。本部分为css实战部分。 表单input主要添加了过渡下border和验证提示 创建模版1234567891011&lt;div class=&quot;input-field&quot;&gt; &lt;input id=&quot;last-name&quot; type=&quot;text&quot; placeholder=&quot;name&quot;&gt;&lt;/input&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;!--带验证的--&gt;&lt;div class=&quot;input-field error input-field-icon&quot;&gt; &lt;input id=&quot;last_name&quot; type=&quot;text&quot; placeholder=&quot;账号&quot;&gt; &lt;span class=&quot;gradient&quot;&gt;&lt;/span&gt; &lt;i class=&quot;ion-android-close&quot;&gt; &lt;/i&gt;&lt;/div&gt; 解释： .input-field成为容器层，input和span并列排列。 让span来充当input的下border，然后在通过为类选择器:focus和兄弟选择器和伪类元素span:after来完成 设置样式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 *&#123; box-sizing:border-box;&#125;.input-field &#123; position: relative; width: 200px; margin: 20px 50px;&#125;.input-field input &#123; background-color: transparent; border: none; border-radius: 0; height: 35px; width: 100%; padding: 0; box-shadow: none; outline: none; transition: all 0.3s;&#125;.input-field input+span &#123; position: absolute; top: 100%; left: 0; display: inline-block; max-width: 100%; z-index: 0; width: 100%; height: 1px; border-bottom: 1px solid #d9d9d9;&#125;.input-field span:after &#123; content: &quot;&quot;; position: absolute; bottom: 0; left: 0; width: 100%; height: 2px; background: #2196f3; transform: scale(0); transition: all .2s ease-out;&#125;.input-field input:focus+span:after &#123; transform: scale(1);&#125;.input-field.input-field-icon i&#123; position:absolute; right:0; top:50%; padding:0 5px; font-size:1.5em; -webkit-transform: translate(0, -50%); transform: translate(0, -50%);&#125;.input-field.input-field-icon input&#123; padding-right:30px;&#125; 这里有个小技巧：要是验证图标垂直居中，达到居中效果。 top: 50%; 相对于父元素的高度 transform: translate(0, -50%); 相对于自身元素的高度。 自定义选择文本样式使用::selection伪类选择器，我们可以实现与众不同的选择文本样式。 注意：只能设置背景色和文字颜色，同时不支持渐变色。 1234567891011121314::selection &#123; background: #009a61; color: #fff;&#125;::-moz-selection &#123; background: #009a61; color: #fff;&#125;::-webkit-selection &#123; background: #009a61; color: #fff;&#125; 动态的边框创建模版12345&lt;div class=&quot;dynamic-border dynamic-border-2&quot;&gt; &lt;span&gt; &lt;/span&gt; &lt;img src=&quot;images/girl.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt; 整体思路： 创建一个容器，容器自身两个伪类元素，span又包含两个伪类元素，可以动态生成容器的4个边框（相对+绝对定位）。 在加上过渡效果就OK了。第二个动态边框只要按不同时间延迟组合就好了。 设置样式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 *&#123; box-sizing:border-box;&#125;.dynamic-border &#123; position:relative; width:200px; height:200px; background:gray;&#125;.dynamic-border:before,.dynamic-border:after,.dynamic-border span:first-child:before,.dynamic-border span:first-child:after &#123; content:&quot;&quot;; position:absolute; background:red; -webkit-transition:all .2s ease; transition:all .2s ease;&#125;/*上边边框*/.dynamic-border:before &#123; width:0; top:-2px; right:0; height:2px;&#125;/*右边边框*/.dynamic-border:after &#123; width:2px; height:0; right:-2px; bottom:0;&#125;/*下边边框*/.dynamic-border span:first-child:before &#123; width:0; height:2px; bottom:-2px; left:0;&#125;/*左边边框*/.dynamic-border span:first-child:after &#123; width:2px; height:0; top:0; left:-2px;&#125;/*鼠标移动上去时*/.dynamic-border:hover:before,.dynamic-border:hover span:first-child:before &#123; width:calc(100% + 2px);&#125;.dynamic-border:hover:after,.dynamic-border:hover span:first-child:after &#123; height:calc(100% + 2px);&#125;/*添加过渡延迟时间*/.dynamic-border-1:hover:before,.dynamic-border-1:hover span:first-child:before &#123; -webkit-transition-delay:.2s; transition-delay:.2s;&#125;.dynamic-border-2:hover span:first-child:before &#123; -webkit-transition-delay:.2s; transition-delay:.2s;&#125;.dynamic-border-2:hover:after &#123; -webkit-transition-delay:.4s; transition-delay:.4s;&#125;.dynamic-border-2:hover:before &#123; -webkit-transition-delay:.6s; transition-delay:.6s;&#125; 上传组件美化创建模版1234567891011&lt;div class=&quot;file file-input&quot;&gt; &lt;div class=&quot;file-inner&quot;&gt; 选择文件 &lt;button class=&quot;btn btn-primary file-inner-btn&quot;&gt; 文件上传 &lt;i class=&quot;ion-ios-cloud-upload-outline&quot;&gt; &lt;/i&gt; &lt;/button&gt; &lt;/div&gt; &lt;input type=&quot;file&quot; /&gt;&lt;/div&gt; 设置CSS样式123456789101112131415161718192021222324252627.file &#123; position:relative;&#125;.file input &#123; position:absolute; top:0; left:0; opacity:0; width:100%; height:100%;&#125;.file-inner &#123; position:relative; width:250px; height:35px; border:1px solid #d9d9d9; border-radius:5px; padding-left:10px; line-height:35px;&#125;.file-inner .file-inner-btn &#123; position:absolute; right:0; top:0; height:100%; box-shadow:none;&#125; 解释； 这里就用了一个技巧，把input设置为opacity: 0;然后在绝对定位并设置宽高100%，这样就会是整个区域都触发file的input默认事件。 参考文档 web开发实战 linear-gradient代码仓库]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>web开发</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css加强（进度条和遮罩条和切角）]]></title>
    <url>%2F2017%2Fcss%E5%8A%A0%E5%BC%BA-3.html</url>
    <content type="text"><![CDATA[在接下来的一段时间学习看云上购买的一本Web开发实战书籍，来提升自己的软实力。本部分为css实战部分。进度条 进度条创建进度条12345678910 &lt;div class=&quot;fan-progress fan-striped fan-active&quot;&gt; &lt;div class=&quot;fan-progress-bar&quot; style=&quot;width: 40%;&quot;&gt;40%&lt;/div&gt; &lt;/div&gt; ``` 解释： 1. fan-progress为定义进度条的整体样式（背景） 2. fan-striped为定义斑纹样式（背景） 3. fan-active为定义动态进度条样式（背景） 4. fan-progress-bar为定义当前行进到样式##### 设置样式 * { box-sizing: border-box; } fan-progress { box-sizing: border-box; height: 20px; line-height: 20px; background: #f7f7f7; overflow: hidden; box-shadow: inset 0 0 0 1px rgba(0, 0, 0, .08), inset 0 2px 2px rgba(0, 0, 0, .08); border-radius: 4px; } fan-progress-bar { width: 0; height: 100%; background: #009dd8; float: left; transition: width .6s ease; font-size: 12px; color: #fff; text-align: center; background-image: linear-gradient(to bottom, #oob4f5, #008dc5); box-shadow: inset 0 -1px 0 rgba(0, 0, 0, .3), inset 0 0 0 1px rgba(0, 0, 0, .1); text-shadow: 0 -1px 0 rgba(0,0,0,.2); } /*条纹*/ .fan-progress-striped .fan-progress-bar { background-image:linear-gradient(-45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent); background-size:30px 30px; } /*动态*/ .fan-progress-striped.fan-active .fan-progress-bar { animation: fan-progress-active 2s linear infinite; } @keyframes fan-progress-active { 0% { background-position: 0 0; } 100% { background-position: 30px 0; } } 1234567#### 遮罩条 设计思路：1. 用一个DOM容器包图片2. 遮罩条主要以容器的伪类来创建3. 通过hover效果和css3的transition和transform完成相应动画##### 创建DOM节点 &lt;div class=&quot;mask&quot; data-title=&quot;遮罩条&quot;&gt; &lt;img src=&quot;img/demo.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; 1##### 设置样式 .mask { position: relative; width: 150px; height: 150px; overflow: hidden; } .mask:before { content: attr(data-title); position: absolute; top: 100%; left: 0; padding: .7em 0; width: 100%; text-align: center; color: #fff; background: rgba(0,0,0,.5); transform: translate(0, 100%); transition: all .3s ease-in-out; opacity: 0; } .mask:hover:before { top: 80%; transform: translate(0, 0); opacity: 1; } 123#### 切角##### 创建DOM节点 &lt;div class=&quot;box corner&quot;&gt;单个切角&lt;/div&gt; &lt;div class=&quot;box corner1&quot;&gt;多个切角&lt;/div&gt; &lt;div class=&quot;box corner2&quot;&gt;多个园角&lt;/div&gt; 1##### 设置样式 .corner { background: linear-gradient(-45deg, transparent 15px, #58a 15px); } .corner1 { background: linear-gradient(135deg, transparent 15px, #58a 0) top left, linear-gradient(-135deg, transparent 15px, #58a 0) top right, linear-gradient(-45deg, transparent 15px, #58a 0) bottom right, linear-gradient(45deg, transparent 15px, #58a 0) bottom left; background-size: 50% 50%; background-repeat: no-repeat; } .corner2 { background: radial-gradient(circle at top left, transparent 15px, #58a 0) top left, radial-gradient(circle at top right, transparent 15px, #58a 0) top right, radial-gradient(circle at bottom right, transparent 15px, #58a 0) bottom right, radial-gradient(circle at bottom left, transparent 15px, #58a 0) bottom left; background-size: 50% 50%; background-repeat: no-repeat; } ``` 参考文档 web开发实战 linear-gradient代码仓库]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>web开发</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http缓存相关的知识]]></title>
    <url>%2F2017%2Fhttp%E7%BC%93%E5%AD%98%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[http缓存整理缓存过程当一个用户发送一个静态资源请求通过下面几步获取资源： 当第一次发送请求时，http返回200的状态码。 在没有关闭缓存请求的时候，则返回header中返回包含last-Modified以及Etag和Expires的字段，然后将文件保存在Cache目录下。 后续请求该文件时，先本地查找该资源。如果本地缓存存在该资源，但不知道是否过期，则发送一个http请求到服务器，然后服务器来判断。如果该文件没有改动，则返回304，继续使用本地资源。如果该文件发生改动，服务器返回该资源并返回200。如果服务器没有这个资源，则返回404。http头部缓存相关keyrequest header缓存相关cache-control： 其缓存指令对于前端常用的有如下no-cache、no-store、max-age这几个值；if-none-match： 该字段与响应中的eTag一起使用，表示检查实体是否有更新改变;客户端第一次发送请求时候响应报文会包含字段Etag，表示资源状态，当资源改变后该值也会改变（客户端不必关心该值怎么生成） 然后缓存保存下该字段，第二次已经有该缓存时候在浏览本地缓存时候会将该值赋给if-none-match字段发送给服务器，服务器将发送的值与当前的状态进行对比， 如果值一样的话则答复304去使用缓存数据，如果值改变了则发送最新数据给客户端替代现有缓存数据，并且返回状态200;if-modified-since: 该字段与last-modified配合使用，跟上述原理差不多，都是响应端先返回一个last-modified时间字段，再次请求时候 request头部会将缓存中的last-modified字段拿出来赋给if-modified-since， 发送给服务器，服务器去判断时间是否过期，如未过期则返回304，告诉客户使用缓存数据，如果过期则重新返回一个last-modified并且返回200；response header缓存相关：Etag： 刚才也说过 是跟if-none-match配合去使用，它根据实体内容生成的一段hash字符串（类似于MD5或者SHA1之后的结果），可以标识资源的状态。 当资源发送改变时，ETag也随之发生变化。 使用Etag主要是为了解决根据时间无法解决的问题：比如文件修改频繁（秒之内修改），导致根据时间无法判断是否更新；以及修改时间变了，但是内容没变（我们应该认为该文件是没变的）expires： 表示缓存过期时间例如:expires:Mon Dec 30 2011 11:01:19 GMT，跟cache-control中的max-age作用一样，不过在碰见max-age之后，该值会被覆盖从而被max-age替代;last-modified: 表示文件最后修改时间； 实现有关前端对于缓存的操作使用缓存方法一： 在服务器进行配置其max-age或者expires使其设置一个过期值为当前一年之后。这样每次进行检验时候都会使用缓存中文件。 例如在.htaccess中 &lt;IfModule mod_headers.c&gt; &lt;FilesMatch &quot;.(gif|jpg|jpeg|png|ico)$&quot;&gt; Header set Cache-Control &quot;max-age=604800&quot; &lt;/FilesMatch&gt; 方法二： 前端设置if-modified-since去设置一个上次修改时间大于当前日期， 方法三： 服务器端根据etag去判断是否匹配来根据实际业务来使用缓存； 后面两个方法属于弱缓存数据头，需要浪费http连接，所以建议使用第一种方式; 禁用缓存方法一： 可以在meta标签标明 &lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;&gt; &lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt; &lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&gt; 方法二： 也可以动态去setRequestHeader，强制不用缓存设置组合如下： cache-control=&apos;no-cache,no-store&apos; pragma=&apos;no-cache&apos; if-modified-since=0; 方法三： 请求端设置if-modified-since为已经过期的某个时间，可以是几年前或者几十年前。 方法四： 服务端设置Expires为过期某个时间，例如PHP中header(&quot;Expires: Mon, 26 Jul 1997 05:00:00 GMT&quot;); 实际开发中如果需要一致性检测则尽量去配合Etag以及last-Modified去进行比较然后返回使用缓存还是新数据;这个有点偏服务器端了，不再赘述 方法五： url后面加随机数或者时间戳url += “&amp;random=” + Math.random()这个方法js以及PHP经常用，原理就是每个请求的url都不一样这样一来缓存中找不到对应数据，就自动去服务器寻找最新资源;]]></content>
      <categories>
        <category>通信协议</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css加强（单选复选Switch、Loading）]]></title>
    <url>%2F2017%2Fcss%E5%8A%A0%E5%BC%BA-2.html</url>
    <content type="text"><![CDATA[在接下来的一段时间学习看云上购买的一本Web开发实战书籍，来提升自己的软实力。本部分为css实战部分。 单选复选Switchswitch组件是常用组件，默认的单选复选框都很丑，是这里使用CSS3美化switch。 本问重点将一下整体思路（以单选为例） 创建模版1234567891011121314&lt;label class=&quot;fan-check-radio fan-check-flat-radio&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked&gt; &lt;div class=&quot;fan-check-media&quot;&gt;&lt;/div&gt; &lt;div class=&quot;fan-check-inner&quot;&gt; &lt;div class=&quot;fan-check-title&quot;&gt;男&lt;/div&gt; &lt;/div&gt; &lt;/label&gt; &lt;label class=&quot;fan-check-radio fan-check-flat-radio&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt; &lt;div class=&quot;fan-check-media&quot;&gt;&lt;/div&gt; &lt;div class=&quot;fan-check-inner&quot;&gt; &lt;div class=&quot;fan-check-title&quot;&gt;女&lt;/div&gt; &lt;/div&gt; &lt;/label&gt; 这里讲解一下DOM结构用义： label包含整个组件，并且是label绑定与input的关系。 主要前端效果通过节点及其伪类完成 通过input:checked 和 兄弟选择器 + 控制类fan-check-media元素的样式 设置样式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364*&#123; box-sizing: border-box;&#125;.fan-check-radio&#123; display: flex; padding: 5px 0; cursor: pointer; justify-content: center; align-items: center;&#125;.fan-check-radio&gt;input&#123; display: none;&#125;.fan-check-radio:hover .fan-check-media &#123; border-color: red!important;&#125;.fan-check-inner,.fan-check-media&#123; position: relative;&#125; .fan-check-radio .fan-check-media &#123; line-height: 20px; width: 22px; height: 22px; margin-right: 5px; text-align: center; color: #fff; border: 1px solid #d9d9d9; border-radius: 11px;&#125; .fan-check-checkbox .fan-check-media &#123; line-height: 20px; width: 22px; height: 22px; margin-right: 5px; text-align: center; color: #fff; border: 1px solid #d9d9d9; border-radius: 2px;&#125;.fan-check-radio&gt;input:checked + .fan-check-media &#123; border: 1px solid #1aa500;&#125;.fan-check-radio&gt;input:checked + .fan-check-media:after &#123; content: &apos;&apos;; position: absolute; animation: radiozoom .1s linear forwards; border-radius: 6px; background: #1aa500; &#125;@keyframes radiozoom &#123; from &#123; top: 8px; left:8px; width: 2px; height: 2px; &#125; to &#123; top: 4px; left:4px; width: 12px; height: 12px; &#125;&#125; 解释：我们需要隐藏radio默认的样式，来做我们自己的UI：.fan-check-radio&gt;input{ display: none; }然后在就只这个节点及其伪类上下功夫了。.fan-check-media这个节点需要使用相对定位，其伪类上使用绝对定位。先设定input未选中时的样式，也是通过.fan-check-media及其伪类来控制。在设置input选中时的样式，通过属性选择其[type=’radio’]:checked来控制radio被选中的样式。具体操作请参考，下面的代码库 loading先来看下效果 讲解一下大体思路： 构建外层包裹div（相对定位），内部8个span分别占据一周（使它们绕中心一周）通过绝对定位。 创建一个动画，并为每个span添加动画及动画延迟。（需要满足动画周期 === 8* animation-delay ） 创建模版我们创意个正方形的div，里面放置8个子元素。 12345678910&lt;div class=&quot;loader circle-line small&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt; 设置样式通过定位和css的转换来移动每一个span的位置。 设置容器的基本样式和span的基本样式 1234567891011121314151617.loader &#123; position: relative; width: 5rem; height: 5rem;&#125;.loader.circle-line span &#123; position: absolute; display: inline-block; width: 1.5rem; height: .5rem; border-top-left-radius: .25rem; border-bottom-left-radius: .25rem; background: #1aa500; opacity: .05; -webkit-animation: circle-line 1s ease infinite; animation: circle-line 1s ease infinite;&#125; 通过css3-transform得到loading图案 当然这哥定位还是很复杂，我直接参考[web开始实战](https://www.kancloud.cn/dennis/javascriptmethod/261478)的源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364.loader.circle-line span:nth-child(1) &#123; top: 50%; left: 0; margin-top: -.25rem; animation-delay: .13s;&#125;.loader.circle-line span:nth-child(2) &#123; top: 1rem; left: .5rem; -webkit-transform: rotate(45deg); transform: rotate(45deg); animation-delay: .26s;&#125;.loader.circle-line span:nth-child(3) &#123; left: 50%; top: .5rem; margin-left: -.75rem; -webkit-transform: rotate(90deg); transform: rotate(90deg); animation-delay: .39s;&#125;.loader.circle-line span:nth-child(4) &#123; right: .5rem; top: 1rem; -webkit-transform: rotate(145deg); transform: rotate(145deg); animation-delay: .52s;&#125;.loader.circle-line span:nth-child(5) &#123; left: 3.5rem; top: 50%; margin-top: -.25rem; -webkit-transform: rotate(180deg); transform: rotate(180deg); animation-delay: .65s;&#125;.loader.circle-line span:nth-child(6) &#123; bottom: 1rem; right: .5rem; -webkit-transform: rotate(-145deg); transform: rotate(-145deg); animation-delay: .78s;&#125;.loader.circle-line span:nth-child(7) &#123; left: 50%; bottom: .5rem; margin-left: -15px; -webkit-transform: rotate(-90deg); transform: rotate(-90deg); animation-delay: 0.91s;&#125;.loader.circle-line span:nth-child(8) &#123; bottom: 1rem; left: .5rem; -webkit-transform: rotate(-45deg); transform: rotate(-45deg); animation-delay: 1.04s;&#125; 注意：上面动画的周期必须要无限接近于最后一个span元素的动画延迟（动画延迟是平均分配的哦）。 动画，这是使用Opcity动画。 12345678@keyframes circle-line &#123; 0% &#123; opacity: .05; &#125; 100% &#123; opacity: .7; &#125;&#125; 参考文档 web开发实战 linear-gradient代码仓库]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>web开发</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css加强（水中倒影、工具提示tooltip）]]></title>
    <url>%2F2017%2Fcss%E5%8A%A0%E5%BC%BA-1.html</url>
    <content type="text"><![CDATA[在接下来的一段时间学习看云上购买的一本Web开发实战书籍，来提升自己的软实力。本部分为css实战部分。 水中倒影要实现倒影，有两种方式：box-reflect方式和transform方式。 box-reflect效果 box-reflect方式（存在兼容性）属性介绍box-reflect: &lt;direction&gt; &lt;offset&gt;? &lt;mask-box-image&gt;? 参数说明： 表示倒影的方向，可能值：above、below、left、right（上下左右）； 表示倒影与元素之间的间隔； 表示遮罩图像，可为url地址、渐变创建模版1&lt;img src=&quot;./img/demo.png&quot; alt=&quot;&quot; /&gt; 设置样式123img &#123; -webkit-box-reflect: below 0 -webkit-linear-gradient(top, rgba(250, 250, 250, 0), rgba(250, 250, 250, .1) 20%, rgba(250, 250, 250, .3)); &#125; transform方式这种方式其实就是复制图片，然后翻转，最后同样是使用渐变来充当遮罩层，覆盖在翻转的图片之上。 transform效果 创建模版123&lt;div class=&quot;box-reflect&quot;&gt; &lt;img src=&quot;img/demo.png&quot; alt=&quot;&quot; /&gt; &lt;/div&gt; 设置样式使用伪类元素将我们需要将图片克隆一份，然后翻转过来，before存放背景图片，after达到渐变效果，这样after的z-index在before大，就达到了我们想要的效果。 123456789101112131415161718192021222324252627282930.box-reflect &#123; position: relative; width: 150px; float: left; margin-right: 40px; &#125; .box-reflect img &#123; width: 100%; height: 100%; &#125; .box-reflect:before &#123; background: url(img/demo.png) no-repeat; background-size: 100% 100%; transform: scaleY(-1); /*添加半透明是为了更真实*/ opacity: 0.5; filter: alpha(opacity=&apos;50&apos;); &#125; .box-reflect:before, .box-reflect:after &#123; position: absolute; width: 100%; height: 100%; top: 100%; left: 0; content: &quot;&quot;; &#125; .box-reflect:after &#123; background-image: -webkit-linear-gradient(bottom,rgb(0,0,0) 20%,rgba(0,0,0,0) 90%); filter: progid:DXImageTransform.Microsoft.Gradient(gradientType=0,startColor=0, EndColorStr=#000000); &#125; 工具提示（tooltip）css3设计的tooltip工具 创建模版1234567891011121314&lt;div class=&quot;toop-group&quot;&gt; &lt;button class=&quot;btn btn-primary tooltip&quot; data-tooltip=&quot;在上方&quot; data-direction=&quot;up&quot;&gt; 在上方 &lt;/button&gt; &lt;button class=&quot;btn btn-primary tooltip&quot; data-tooltip=&quot;在右方&quot; data-direction=&quot;right&quot;&gt; 在右方 &lt;/button&gt; &lt;button class=&quot;btn btn-primary tooltip&quot; data-tooltip=&quot;在下方&quot; data-direction=&quot;down&quot;&gt; 在下方 &lt;/button&gt; &lt;button class=&quot;btn btn-primary tooltip&quot; data-tooltip=&quot;在左方&quot; data-direction=&quot;left&quot;&gt; 在左方 &lt;/button&gt; &lt;/div&gt; 设置样式总体思路： 利用伪类before生成提示工具的三角形border来形成。 利用伪类after生成提示内容（长方形）以及获取提示文本content(attr(data-tooltip)),来获取自身的自定义属性data-tooltip。 利用hover效果让其展现，在加入一些css3动画将表现的更好。 使用了calc用于动态计算长度值，使我们的组件更通用。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125.tooltip&#123; position: relative;&#125;.tooltip:before&#123; position: absolute; content: &apos;&apos;; border: 5px solid transparent;&#125;.tooltip:after&#123; font-size: 14px; line-height: normal; position: absolute; padding: 5px 10px; content: attr(data-tooltip); white-space: nowrap; color: #fff; border-radius: 3px; background: #383838;&#125;.tooltip:before,.tooltip:after&#123; z-index: 1000000; visibility: hidden; -webkit-transition: .3s ease; -moz-transition: .3s ease; transition: .3s ease; -webkit-transition-delay: 0ms; -moz-transition-delay: 0ms; transition-delay: 0ms; pointer-events: none; opacity: 0;&#125;.tooltip:hover:before,.tooltip:hover:after&#123; visibility: visible; opacity: 1;&#125;[data-direction=&apos;down&apos;]:before&#123; top: -webkit-calc(100% - 5px); top: -moz-calc(100% - 5px); top: calc(100% - 5px); border-bottom-color: #383838;&#125;[data-direction=&apos;down&apos;]:after&#123; top: -webkit-calc(100% + 5px); top: -moz-calc(100% + 5px); top: calc(100% + 5px);&#125;[data-direction=&apos;down&apos;]:before,[data-direction=&apos;down&apos;]:after,[data-direction=&apos;up&apos;]:before,[data-direction=&apos;up&apos;]:after&#123; left: 50%; -webkit-transform: translate3d(-50%,0,0); -moz-transform: translate3d(-50%,0,0); transform: translate3d(-50%,0,0);&#125;[data-direction=&apos;up&apos;]:before&#123; bottom: -webkit-calc(100% - 5px); bottom: -moz-calc(100% - 5px); bottom: calc(100% - 5px); border-top-color: #383838;&#125;[data-direction=&apos;up&apos;]:after&#123; bottom: -webkit-calc(100% + 5px); bottom: -moz-calc(100% + 5px); bottom: calc(100% + 5px);&#125;[data-direction=&apos;left&apos;]:before,[data-direction=&apos;left&apos;]:after,[data-direction=&apos;right&apos;]:before,[data-direction=&apos;right&apos;]:after&#123; top: 50%; -webkit-transform: translate3d(0,-50%,0); -moz-transform: translate3d(0,-50%,0); transform: translate3d(0,-50%,0);&#125;[data-direction=&apos;left&apos;]:before&#123; left: -5px; border-left-color: #383838;&#125;[data-direction=&apos;left&apos;]:after&#123; right: -webkit-calc(100% + 5px); right: -moz-calc(100% + 5px); right: calc(100% + 5px);&#125;[data-direction=&apos;right&apos;]:before&#123; left: -webkit-calc(100% - 5px); left: -moz-calc(100% - 5px); left: calc(100% - 5px); border-right-color: #383838;&#125;[data-direction=&apos;right&apos;]:after&#123; left: -webkit-calc(100% + 5px); left: -moz-calc(100% + 5px); left: calc(100% + 5px);&#125;.toop-group &#123; padding-top: 100px;&#125; 参考文档： web开发实战 MDN box-reflect代码仓库]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>web开发</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-加强（白光划过效果、3D立方体）]]></title>
    <url>%2F2017%2Fcss%E5%8A%A0%E5%BC%BA.html</url>
    <content type="text"><![CDATA[在接下来的一段时间学习看云上购买的一本Web开发实战书籍，来提升自己的软实力。本部分为css实战部分。 白光划过效果创建模板我们要放置一张图片，用一个div包裹起来： 123&lt;div class=&quot;highlight-box&quot;&gt; &lt;img src=&quot;./img/demo.png&quot; width=&quot;296&quot; height=&quot;374&quot; alt=&quot;s&quot;&gt;&lt;/div&gt; 设置CSS样式定义初始样式: 1234567.highlight-box &#123; /**这里用于before、after伪类定位**/ position: relative; width: 296px; height: 374px; overflow: hidden; &#125; 接着让我们来制作白光，我们不需多余的元素，只需使用:before选择器.position为伪类定位： 12345678910111213141516.highlight-box:before &#123; position: absolute; /* 注意这里top和left，让白光移动到图片左上角，后续的划过动画也是依靠这两个属性 */ top: -200%; left: -100%; z-index: 2; display: block; content: &apos;&apos;; /* 定义白光的高宽，hight为300%是为了防止在移动过程中白光不够用 */ width: 50%; height: 300%; /* 使用线性渐变来实现白光 */ background: linear-gradient(to left top, rgba(255, 255, 255, .05) 20%, rgba(255, 255, 255, .6) 65% , rgba(255, 255, 255, .05) 100%); /* background: rgba(255, 255, 255, .5); */ transform: rotate(45deg); &#125; 我们使用渐变（linear-gradient）来实现白光效果，同时为了斜向划过，使用transform: rotate(45deg)将其旋转45度。上面的height、width、top和left，你也可以使用具体的像素值，不过建议采用百分比，这样可以重复使用，而不需手动改变太多值。触发白光(hover伪类和css3动画)： 1234567891011121314.highlight-box:hover:before &#123; /* 这里省略了私有前缀代码 */ animation: crossed .5s linear; &#125; @keyframes crossed &#123; 0% &#123; top: -200%; left: -100%; &#125; 100% &#123; top: -50px; left: 100%; &#125; &#125; 截图效果(鼠标划入时的效果) 3D立方体随着CSS3的出现，实现3D效果已经不是难事，这一节就来看看3D立方体是如何实现的。 创建模板首先来放置一个父div.cude，然后在其里面放置6个div，分别表示立方体的6个面。 1234567891011121314151617181920&lt;div class=&quot;cude&quot;&gt; &lt;div class=&quot;front surface&quot;&gt; 正面 &lt;/div&gt; &lt;div class=&quot;surface left&quot;&gt; 左面 &lt;/div&gt; &lt;div class=&quot;surface right&quot;&gt; 右面 &lt;/div&gt; &lt;div class=&quot;surface bottom&quot;&gt; 底面 &lt;/div&gt; &lt;div class=&quot;surface top&quot;&gt; 顶面 &lt;/div&gt; &lt;div class=&quot;surface back&quot;&gt; 背面 &lt;/div&gt;&lt;/div&gt; 设置CSS样式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354.cude &#123; width:300px; height:300px; position:relative; margin:100px auto; transform-style:preserve-3d; -webkit-transform-style:preserve-3d;&#125;.surface &#123; position:absolute; top:0; left:0; width:300px; height:300px; background:#666; opacity:0.8; font-size:60px; text-align:center; line-height:300px; font-weight:bold; color:#fff; border:1px solid #fff; -webkit-transition:all .3s; transition:all .3s;&#125;.surface img &#123; width:100%;&#125;.front &#123; transform:rotateY(0) translateZ(150px);&#125;.back &#123; transform:translateZ(-150px) rotateY(180deg);&#125;.left &#123; transform:rotateY(-90deg) translateZ(150px);&#125;.right &#123; transform:rotateY(90deg) translateZ(150px);&#125;.top &#123; transform:rotateX(90deg) translateZ(150px);&#125;.bottom &#123; transform:rotateX(90deg) translateZ(-150px);&#125;@-webkit-keyframes rotate &#123; from &#123; transform: rotateX(0deg) rotateY(0deg); &#125; to &#123; transform: rotateX(360deg) rotateY(360deg); &#125;&#125; 总结： 使用了before和after伪类 linear-gradient-api的使用 animation transform(分为2D转换和3D转换) 2d转换：translate(x,y)、translateX(x)、translateY(y)、scale(x,y)、scaleX(x)、scaleY(y)、rotate(angle)、skew(x-angle,y-angle)、skewX(angle) 3d转换：translate3d(x,y,z)、translateZ(z)、scale3d(x,y,z)、scaleZ(z)、rotate3d(x,y,z,angle)、rotateX(angle)、rotateY(angle)、rotateZ(angle) 参考文档 web开发实战 linear-gradient transform代码仓库]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>web开发</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue end]]></title>
    <url>%2F2017%2Fvue-end.html</url>
    <content type="text"><![CDATA[今天完成后台界面中引入iconfont图标和添加全屏功能screenfull如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。 引入iconfont图标，这是阿里的开源产品，个人感觉不错，其中symbol方式应该会成为未来的主流方式（不支持ie8） 进入iconfont后，创建项目，把自己喜欢的图标都放到项目中去，点击下载这里我们只需要iconfont.js文件 在main.js中引入 1import &apos;@/assets/icon-font/iconfont&apos; // 引入iconfont图库 这里我把它单独封装一个组件，以便其他地方使用(直接贴上源码了，都能看懂) 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;svg class=&quot;icon&quot; :style=&quot;&#123;width: width + &apos;em&apos;, height: height + &apos;em&apos;, verticalAlign: verticalAlign + &apos;em&apos;&#125;&quot; aria-hidden=&quot;true&quot;&gt; &lt;use :xlink:href=&quot;iconName&quot;&gt;&lt;/use&gt; &lt;/svg&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &apos;iconfont&apos;, props: &#123; icon: &#123; type: String, required: true &#125;, width: &#123; type: Number, default: 1 &#125;, height: &#123; type: Number, default: 1 &#125;, verticalAlign: &#123; type: Number, default: -0.15 &#125; &#125;, data () &#123; return &#123; &#125; &#125;, computed: &#123; iconName () &#123; return `#$&#123;this.icon&#125;` &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .icon &#123; fill: currentColor; overflow: hidden; &#125;&lt;/style&gt; 使用的时候 1&lt;iconfont icon=&quot;icon-daxiang&quot; :width=&quot;2&quot; :height=&quot;2&quot; :verticalAlign=&quot;-0.5&quot;&gt;&lt;/iconfont&gt; 添加全屏功能 安装依赖 npm i screenfull -S 我还是封装成组件，一遍其他项目使用(贴原代码) 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;iconfont @click.native=&quot;toggleFullScreen&quot; :icon=&quot;iconType&quot;&gt;&lt;/iconfont&gt;&lt;/template&gt;&lt;script&gt;import screenfull from &apos;screenfull&apos;import iconfont from &apos;@/components/iconfont&apos; export default &#123; name: &apos;screenfull&apos;, data () &#123; return &#123; isFullscreen: false, iconType: &apos;icon-quanping&apos; &#125; &#125;, methods: &#123; toggleFullScreen () &#123; if (!screenfull.enabled) &#123; this.$message(&#123; message: &apos;you browser can not work&apos;, type: &apos;warning&apos; &#125;); return false; &#125; this.iconType = this.isFullscreen ? &apos;icon-quanping&apos; : &apos;icon-tuichuquanping&apos; screenfull.toggle() this.isFullscreen = !this.isFullscreen &#125; &#125;, components: &#123; iconfont &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 后台系统，先做的这里，以后在添加。打算接着撸一段事件的函数式编程]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>element-ui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ramda运用--官方文档解读]]></title>
    <url>%2F2017%2Framda%E8%BF%90%E7%94%A8-5.html</url>
    <content type="text"><![CDATA[从8月25到8月29共5个晚上和小部分周末时间撸完了Ramda官方文档，继续在事件中继续学习。Rmda中共分为List、Relation、Object、Function、Math、Type、Logic、String共8大类。 Stringtest定义：检测字符串是否匹配给定的正则表达式。 ``` R.test(/^x/, &apos;xyz&apos;); // true ``` match定义：正则匹配字符串。注意，如果没有匹配项，则返回空数组。和 String.prototype.match 不同，后者在没有匹配项时会返回 null。 ``` R.match(/([a-z]a)/g, &apos;bananas&apos;); //=&gt; [&apos;ba&apos;, &apos;na&apos;, &apos;na&apos;] ``` replace定义：替换字符串的子串或正则匹配到的值。 ``` R.replace(&apos;foo&apos;, &apos;bar&apos;, &apos;foo foo foo&apos;); // bar foo foo ``` split定义：根据指定的分隔符将字符串拆分为字符串类型的数组。 ``` R.split(&apos;.&apos;, &apos;a.b.c.xyz.d&apos;); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;xyz&apos;, &apos;d&apos;] ``` toLower定义：将字符串转换成小写。 ``` R.toLower(&apos;XYZ&apos;); // xyz ``` toUpper定义：将字符串转换为大写。 ``` R.toUpper(&apos;abc&apos;); // ABC ``` toString定义：返回代表输入元素的字符串。求得的输出结果应该等价于输入的值。许多内建的 toString 方法都不满足这一条件。 如果输入值是 [object Object] 对象，且自身含有 toString 方法（不是 Object.prototype.toString 方法），那么直接调用这个方法求返回值。 这意味着，通过用户自定义的构造函数可以提供合适的 toString 方法。 ``` R.toString(42); // 42 ``` trim定义：删除字符串首、尾两端的空白字符。 ``` R.trim(&apos; xyz &apos;); //=&gt; &apos;xyz&apos; ``` List(Array)adjust定义：将数组中指定索引处的值替换为经函数变换的值。 ``` R.adjust(R.add(10))(1)([1, 2, 3]); // [1, 12, 3] ``` all定义：如果列表中的所有元素都满足 predicate，则返回 true；否则，返回 false。 ``` var equals3 = R.equals(3); R.all(equals3)([3, 3, 3]); // true R.all(equals3)([1, 3, 3]); // false ``` any定义：只要列表中有一个元素满足 predicate，就返回 true，否则返回 false。 ``` var lessThan0 = R.flip(R.lt)(0); var lessThan2 = R.flip(R.lt)(2); R.any(lessThan0)([1, 2]); // false R.any(lessThan2)([1, 2]); // true ``` aperture定义：返回一个新列表，列表中的元素为由原列表相邻元素组成的 n 元组。如果 n 大于列表的长度，则返回空列表。 ``` R.aperture(2, [1, 2, 3, 4, 5]); // [[1, 2], [2, 3], [3, 4], [4, 5]] ``` append定义：在列表末尾拼接一个元素。 ``` R.append(5)([1, 2, 3]); // [1, 2, 3, 5] ``` chain定义：chain 将函数映射到列表中每个元素，并将结果连接起来。 chain 在一些库中也称为 flatMap（先 map 再 flatten ）。 ``` var duplicate = n =&gt; [n, n]; R.chain(duplicate, [1, 2, 3]); // [1, 1, 2, 2, 3, 3] ``` concat定义：连接列表或字符串。 ``` R.concat(&apos;ABC&apos;, &apos;DEF&apos;); // ABCDEF R.concat([1, 2, 3])([4, 5, 6]); // [1, 2, 3, 4, 5, 6] ``` contains定义：只要列表中有一个元素等于指定值，则返回 true；否则返回 false。通过 R.equals 函数进行相等性判断。 ``` R.contains(2, [1, 2, 3]); // true ``` drop定义：删除给定 list，string 或者 transducer/transformer（或者具有 drop 方法的对象）的前 n 个元素。 ``` R.drop(2, [&apos;fan&apos;, &apos;yu&apos;, &apos;zhen&apos;]); // [&apos;zhen&apos;] R.drop(2, &apos;fanerge&apos;); // nerge ``` dropLast定义：删除 &quot;list&quot; 末尾的 n 个元素。 ``` R.dropLast(2, [&apos;fan&apos;, &apos;yu&apos;, &apos;zhen&apos;]); // [&apos;fan&apos;] R.dropLast(2, &apos;fanerge&apos;); // faner ``` dropLastWhile定义：对 list 从后向前一直删除满足 predicate 的尾部元素，直到遇到第一个 falsy 值，此时停止删除操作。 predicate 需要作为第一个参数传入。 ``` var lteThree = x =&gt; x &lt;= 3; R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); // [1, 2, 3, 4] ``` dropRepeats定义：返回一个没有连续重复元素的 list。通过 R.equals 函数进行相等性判断。 ``` R.dropRepeats([1, 1, 2, 2, 3, 3, 2, 2]); // [1, 2, 3, 2] ``` dropRepeatsWith定义：返回一个没有连续重复元素的 list。首个参数提供的 predicate 用于检测 list 中相邻的两个元素是否相等。 一系列相等元素中的首个元素会被保留。 ``` var list = [1, -1, 1, 3, 4, -4]; R.dropRepeatsWith(R.eqBy(Math.abs), list); // [1, 3, 4] ``` dropWhile定义：对 list 从前向后删除满足 predicate 的头部元素，直到遇到第一个 falsy 值。 predicate 需要作为第一个参数传入。 ``` var lteTwo = x =&gt; x &lt;= 2; R.dropWile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); // [3, 4, 3, 2, 1] ``` endsWith定义：检查列表或字符串是否以给定的值结尾。 ``` R.endsWith(&apos;c&apos;, &apos;abc&apos;); // true R.endsWith([&apos;c&apos;], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]); // true ``` filter定义：使用 predicate 遍历传入的 Filterable，返回满足 predicate 的所有元素的新的 Filterable。新 Filterable 与原先的类型相同。Filterable 类型包括 plain object 或者任何带有 filter 方法的类型，如 Array 。 ``` var isEven = n =&gt; n % 2 === 0; R.filter(isEven, [1, 2, 3, 4]); // [2, 4] ``` find定义：查找并返回 list 中首个满足 predicate 的元素；如果未找到满足条件的元素，则返回 undefined 。 ``` var xs = [{a: 1}, {a: 2}, {a: 3}]; R.find(R.propEq(&apos;a&apos;, 2))(xs); // {a: 2} ``` findIndex定义：查找并返回 list 中首个满足 predicate 的元素的索引；如果未找到满足条件的元素，则返回 -1 。 ``` var xs = [{a: 1}, {a: 2}, {a: 3}]; R.findIndex(R.propEq(&apos;a&apos;, 2))(xs); // 1 ``` findLast定义：查找并返回 list 中最后一个满足 predicate 的元素；如果未找到满足条件的元素，则返回 undefined 。 ``` var xs = [{a: 1, b: 0}, {a:1, b: 1}]; R.findLast(R.propEq(&apos;a&apos;, 1))(xs); // {a: 1, b: 1} ``` findLastIndex定义：查找并返回 list 中最后一个满足 predicate 的元素的索引；如果未找到满足条件的元素，则返回 -1 。 ``` var xs = [{a: 1, b: 0}, {a:1, b: 1}]; R.findLastIndex(R.propEq(&apos;a&apos;, 1))(xs); // 1 ``` flatten定义：获取 list 的所有元素（包含所有子数组中的元素），然后由这些元素组成一个新的数组。深度优先。 ``` R.flatten([1, [2, [3]]]); // [1, 2, 3] ``` forEach定义：遍历 list，对 list 中的每个元素执行方法 fn。 Ramda 的 forEach 会将原数组返回。 ``` var printPlusFive = x =&gt; console.log(x + 5); R.forEach(printPlusFive, [1, 2, 3]); // [1, 2, 3] ``` fromPairs定义：由一系列 “键值对” 创建一个 object。如果某个键出现多次，选取最右侧的键值对。 ``` var R.fromPairs([[&apos;a&apos;, 1], [&apos;b&apos;, 2], [&apos;c&apos;, 3]]); // {a: 1, b: 2, c: 3} ``` groupBy定义：将列表根据一定规则拆分成多组子列表，并存储在一个对象中。 对列表中的每个元素调用函数，根据函数返回结果进行分组。 函数返回字符串作为相等性判断，返回的字符串作为存储对象的键，具有相同返回字符串的元素聚合为数组，作为该键的值。 ``` var byGrade = R.groupBy(function(student) { var score = student.score; return score &lt; 65 ? &apos;F&apos; : score &lt; 70 ? &apos;D&apos; : score &lt; 80 ? &apos;C&apos; : score &lt; 90 ? &apos;B&apos; : &apos;A&apos;; }); var students = [{name: &apos;Abby&apos;, score: 84}, {name: &apos;Eddy&apos;, score: 58}, // ... {name: &apos;Jack&apos;, score: 69}]; byGrade(students); // { // &apos;A&apos;: [{name: &apos;Dianne&apos;, score: 99}], // &apos;B&apos;: [{name: &apos;Abby&apos;, score: 84}] // // ..., // &apos;F&apos;: [{name: &apos;Eddy&apos;, score: 58}] // } ``` groupWith定义：通过给定的对比函数，将列表按顺序分割成多组子列表。 对比函数只比较相邻元素。 ``` var R.groupWith(R.equals, [0, 1, 1, 2, 3, 5, 13, 21]); // [[0], [1, 1], [2], [3], [5], [13], [21]] ``` head定义：求列表或字符串的首个元素。在某些库中，该函数也被称作 first。 ``` R.head([1, 2, 3]); // 1 R.head(&apos;fan&apos;); // f ``` indexBy定义：通过生成键的函数，将元素为对象的 list 转换为以生成的键为索引的新对象。注意，如果 list 中多个对象元素生成相同的键，以最后一个对象元素作为该键的值。 ``` var list = [{id: &apos;xyz&apos;, title: &apos;A&apos;}, {id: &apos;abc&apos;, title: &apos;B&apos;}]; R.indexBy(R.prop(&apos;id&apos;), list); //=&gt; {abc: {id: &apos;abc&apos;, title: &apos;B&apos;}, xyz: {id: &apos;xyz&apos;, title: &apos;A&apos;}} ``` indexOf定义：返回给定元素在数组中首次出现时的索引值，如果数组中没有该元素，则返回 -1。通过 R.equals 函数进行相等性判断。 ``` R.indexOf(3, [1, 2, 3, 4]); // 2 ``` init定义：返回 list 或 string 删除最后一个元素后的部分。 ``` R.init([1, 2, 3]); //=&gt; [1, 2] R.init(&apos;abc&apos;); //=&gt; &apos;ab&apos; ``` insert定义：将元素插入到 list 指定索引处。注意，该函数是破坏性的：返回处理后列表的拷贝。函数运行过程中不会破坏任何列表。 ``` R.insert(2, &apos;x&apos;, [1, 2, 3, 4]); // [1,2,&apos;x&apos;,3,4] ``` insertAll定义：将子 list 插入到 list 指定索引处。注意，该函数是破坏性的：返回处理后列表的拷贝。函数运行过程中不会破坏任何列表。 ``` R.insertAll(2, [&apos;x&apos;, &apos;y&apos;], [1, 2, 3, 4]); // [1, 2, &apos;x&apos;, &apos;y&apos;, 3, 4] ``` intersperse定义：在列表的元素之间插入分割元素。 ``` R.intersperse(&apos;n&apos;, [&apos;ba&apos;, &apos;a&apos;, &apos;a&apos;]); //=&gt; [&apos;ba&apos;, &apos;n&apos;, &apos;a&apos;, &apos;n&apos;, &apos;a&apos;] ``` into定义：使用 transducer 对 list 中的元素进行转换，然后使用基于 accumulator 的类型的迭代器函数将转换后的元素依次添加到 accumulator 上。 ``` var numbers = [1, 2, 3, 4]; var transducer = R.compose(R.map(R.add(1)), R.take(2)); R.into([], transducer, numbers); //=&gt; [2, 3] ``` join定义：将列表中所有元素通过 分隔符 串连为一个字符串。 ``` var spacer = R.join(&apos;#&apos;); spacer([1, 2, 3]); // 1#2#3 ``` last定义：返回列表或字符串的最后一个元素。 ``` R.last([&apos;fan&apos;, &apos;zhen&apos;, &apos;yu&apos;]); // yu R.last(&apos;abc&apos;); // c ``` lastIndexOf定义：返回数组中某元素最后一次出现的位置，如果数组中不包含该项则返回 -1 。通过 R.equals 函数进行相等性判断。 ``` R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); // 6 ``` length定义：通过 list.length，返回数组的大小（数组中元素的数量）。 ``` R.length([]); // 0 ``` map定义：接收一个函数和一个 functor, 将该函数应用到 functor 的每个值上，返回一个具有相同形态的 functor。 Ramda 为 Array 和 Object 提供了合适的 map 实现，因此 R.map 适用于 [1, 2, 3] 或 {x: 1, y: 2, z: 3}。 若第二个参数自身存在 map 方法，则调用自身的 map 方法。 ``` var double = x =&gt; x * 2; R.map(double, [1, 2, 3]); // [2, 4, 6] ``` mapAccum定义：mapAccum 的行为类似于 map 和 reduce 的组合； 它将迭代函数作用于列表中的每个元素，从左往右传递经迭代函数计算的累积值，并将最后的累积值和由所有中间的累积值组成的列表一起返回。 迭代函数接收两个参数，acc 和 value， 返回一个元组 [acc, value]。 ``` var digits = [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;]; var appender = (a, b) =&gt; [a + b, a + b]; R.mapAccum(appender, 0, digits); // [&apos;01234&apos;, [&apos;01&apos;, &apos;012&apos;, &apos;0123&apos;, &apos;01234&apos;]] ``` mapAccumRight定义：mapAccumRight 的行为类似于 map 和 reduce 的组合； 它将迭代函数作用于列表中的每个元素，从右往左传递经迭代函数计算的累积值，并将最后的累积值和由所有中间的累积值组成的列表一起返回。 和 mapAccum 类似，除了列表遍历顺序是从右往左的。 迭代函数接收两个参数，value 和 acc ，返回一个元组 [value, acc]。 ``` var digits = [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;]; var append = (a, b) =&gt; [a + b, a + b]; R.mapAccumRight(append, 5, digits); // [[&apos;12345&apos;, &apos;2345&apos;, &apos;345&apos;, &apos;45&apos;], &apos;12345&apos;] ``` mapObjIndexed定义：Object 版本的 map。mapping function 接受三个参数： (value, key, obj) 。如果仅用到参数 value，则用 map 即可。 ``` var values = {x: 1, y: 2, z: 3}; var prependKeyAndDouble = (val, key, obj) =&gt; key + (val * 2); R.mapIndexed(prependKeyAndDouble, values); // { x: &apos;x2&apos;, y: &apos;y4&apos;, z: &apos;z6&apos; } ``` mergaAll定义：将对象类型列表合并为一个对象。 ``` R.mergeAll([{foo: 1}, {bar: 2}, {baz: 3}]); // {foo: 1, bar: 2, baz: 3} ``` none定义：如果列表中的元素都不满足 predicate，返回 true；否则返回 false。 ``` var isEven = n =&gt; n % 2 === 0; R.none(isEven, [1, 2, 3]); // true ``` nth定义：返回列表或字符串的第 n 个元素。如果 n 为负数，则返回索引为 length + n 的元素。 ``` var list = [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;, &apos;quux&apos;]; R.nth(1, list); // &apos;bar&apos; ``` pair定义：接收两个参数，fst 和 snd，返回数组 [fst, snd]。 ``` R.pair(&apos;foo&apos;, &apos;bar&apos;); // [&apos;foo&apos;, &apos;bar&apos;] ``` partition定义：接收两个参数，fst 和 snd，返回数组 [fst, snd]。 ``` R.partition(R.contains(&apos;s&apos;), [&apos;sss&apos;, &apos;ttt&apos;, &apos;foo&apos;, &apos;bars&apos;]); // [ [ &apos;sss&apos;, &apos;bars&apos; ], [ &apos;ttt&apos;, &apos;foo&apos; ] ] ``` pluck定义：从列表内的每个对象元素中取出特定名称的属性，组成一个新的列表。 pluck 可以作用于任何 functor ，包括 Array，因为它等价于 R.map(R.prop(k), f)。 ``` R.pluck(&apos;a&apos;)([{a: 1}, {a: 2}]); // [1, 2] ``` prepend定义：在列表头部之前拼接一个元素。 ``` R.prepend(&apos;fee&apos;, [&apos;fi&apos;, &apos;fo&apos;, &apos;fum&apos;]); // [&apos;fee&apos;, &apos;fi&apos;, &apos;fo&apos;, &apos;fum&apos;] ``` range定义：返回从 from 到 to 之间的所有数的升序列表。左闭右开（包含 from，不包含 to）。 ``` R.range(1, 5); // [1, 2, 3, 4] ``` reduce定义：左折叠操作。 遍历列表，相继调用二元迭代函数（参数为累积值和从数组中取出的当前元素），将本次迭代结果作为下次迭代的累积值。返回最终累积值。 可以用 R.reduced 提前终止遍历操作。 ``` R.reduce(R.subtract, 0, [1, 2, 3, 4]) // =&gt; ((((0 - 1) - 2) - 3) - 4) = -10 ``` reduceBy定义：首先对列表中的每个元素调用函数 keyFn ，根据 keyFn 返回的字符串对列表元素进行分组。 然后调用 reducer 函数 valueFn，对组内的元素进行折叠操作。 该函数相当于更通用的 groupBy 函数。 ``` var reduceToNamesBy = R.reduceBy((acc, student) =&gt; acc.concat(student.name), []); var namesByGrade = reduceToNamesBy(function(student) { var score = student.score; return score &lt; 65 ? &apos;F&apos; : score &lt; 70 ? &apos;D&apos; : score &lt; 80 ? &apos;C&apos; : score &lt; 90 ? &apos;B&apos; : &apos;A&apos;; }); var students = [{name: &apos;Lucy&apos;, score: 92}, {name: &apos;Drew&apos;, score: 85}, {name: &apos;Bart&apos;, score: 62}]; namesByGrade(students); // { // &apos;A&apos;: [&apos;Lucy&apos;], // &apos;B&apos;: [&apos;Drew&apos;] // &apos;F&apos;: [&apos;Bart&apos;] // } ``` reduced定义：返回一个封装的值，该值代表 reduce 或 transduce 操作的最终结果。 返回值是一个黑盒：不保证其内部结构的稳定性。 ``` R.reduce( (acc, item) =&gt; item &gt; 3 ? R.reduced(acc) : acc.concat(item), [], [1, 2, 3, 4, 5] ); // [1, 2, 3] ``` reduceRight定义：右折叠操作。 遍历列表，相继调用二元迭代函数（参数为累积值和从数组中取出的当前元素），将本次迭代结果作为下次迭代的累积值。返回最终累积值。 类似于 reduce，除了遍历列表的顺序是从右向左的。 ``` R.reduceRight(R.subtract, 0, [1, 2, 3, 4]); // (1 - (2 - (3 - (4 - 0)))) = -2 ``` reduceWhile定义：与 reduce 类似， reduceWhile 会遍历列表，相继调用二元迭代函数，并返回最终累积值。 reduceWhile 在每次调用迭代函数前，先使用 predicate 进行判断，如果 predicate 返回 false ，则提前终止遍历操作，并返回当前累积值。 ``` var isOdd = (acc, x) =&gt; x % 2 === 1; var xs = [1, 3, 5, 60, 777, 800]; R.reduceWhile(isOdd, R.add, 0, xs); // 9 ``` reject定义：filter 的补操作。返回结果为 R.filter 操作结果的补集。 ``` var isOdd = (acc, x) =&gt; x % 2 === 1; R.reject(isOdd, [1, 2, 3, 4]); // [2, 4] ``` remove定义：删除列表中从 start 开始的 count 个元素。_ 注意，该操作是非破坏性的：不改变原列表，返回处理后列表的拷贝。 ``` R.remove(2, 3, [1, 2, 3, 4, 5, 6, 7, 8]); // [1, 2, 6, 7, 8] ``` repeat定义：生成包含 n 个同一元素的数组。 ``` R.repeat(&apos;h&apos;, 5); // [&apos;h&apos;, &apos;h&apos;, &apos;h&apos;, &apos;h&apos;, &apos;h&apos;] ``` reverse定义：对列表或字符串的排列顺序取反。 ``` R.reverse([1, 2, 3]); // [3, 2, 1] ``` scan定义：Scan 与 reduce 类似，但会将每次迭代计算的累积值记录下来，组成一个列表返回。 ``` var numbers = [1, 2, 3, 4]; var factorials = R.scan(R.multiply, 1, numbers); // [1, 1, 2, 6, 24] ``` sequence定义：将一个 Applicative 的 Traversable 转换成一个 Traversable 类型的 Applicative。 ``` R.sequence(Maybe.of, [Just(1), Just(2), Just(3)]); //=&gt; Just([1, 2, 3]) ``` slice定义：取出给定的列表或字符串（或带有 slice 方法的对象）中，从 fromIndex（包括）到 toIndex（不包括）的元素。 ``` R.slice(1, 3, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]); // [&apos;b&apos;, &apos;c&apos;] ``` sort定义：使用比较函数对列表进行排序。比较函数每次接受两个参数，如果第一个值较小，则返回负数；如果第一个值较大，则返回正数；如果两值相等，返回零。注意，返回的是列表的 拷贝 ，不会修改原列表。 ``` var diff = function (a, b) { return a - b }; R.sort(diff, [4, 2, 7, 5]); // [2, 4, 5, 7] ``` splitAt定义：在指定的索引处拆分列表或者字符串。 ``` R.splitAt(1, [1, 2, 3]); // [[1], [2, 3]] R.splitAt(5, &apos;hello world&apos;); // [&apos;hello&apos;, &apos;world&apos;] ``` splitEvery定义：将列表拆分成指定长度的子列表集。 ``` R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); // [[1, 2, 3], [4, 5, 6], 7] R.splitEvery(3, &apos;foobarbaz&apos;); //=&gt; [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;] ``` splitWhen定义：查找列表中首个满足 predicate 的元素，在该处将列表拆分为两部分。首个满足 predicate 的元素包含在后一部分。 ``` R.splitWhen(R.equals(2), [1, 2, 3, 1, 2, 3]); //=&gt; [[1], [2, 3, 1, 2, 3]] ``` startsWith定义：检查列表是否以给定的值开头。 ``` R.startsWith(&apos;a&apos;, &apos;abc&apos;); // true R.startsWith([&apos;a&apos;], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]); // true ``` tail定义：删除列表中的首个元素（或者调用对象的 tail 方法）。 ``` R.tail([1, 2, 3]); // [2, 3] ``` take定义：返回列表的前 n 个元素、字符串的前n个字符或者用作 transducer/transform（或者调用对象的 take 方法）。 ``` R.take(1, [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]); //=&gt; [&apos;foo&apos;] ``` takeLast定义：返回列表的后 n 个元素。如果 n &gt; list.length，则返回 list.length 个元素。 ``` R.takeLast(1, [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]); //=&gt; [&apos;baz&apos;] ``` takeLastWhile定义：从后往前取出列表元素，直到遇到首个不满足 predicate 的元素为止。取出的元素中不包含首个不满足 predicate 的元素。 ``` var isNotOne = x =&gt; x !== 1; R.takeLastWhile(isNotOne, [1, 2, 3, 4]); // [2, 3, 4] ``` takeWhile定义：从前往后取出列表元素，直到遇到首个不满足 predicate 的元素为止。取出的元素中不包含首个不满足 predicate 的元素。 ``` var isNotFour = x =&gt; x !== 4; R.takeLastWhile(isNotFour, [1, 2, 3, 4, 3, 2, 1]); // [1, 2, 3] ``` times定义：执行输入的函数 n 次，返回由函数执行结果组成的数组。 fn 为一元函数，n 次调用接收的参数为：从 0 递增到 n-1 。 ``` R.times(R.identity, 5); // [0, 1, 2, 3, 4] ``` transduce定义：用 iterator function 初始化 transducer ，生成一个 transformed iterator function。 然后顺次遍历列表，对每个列表元素先进行转换，然后与累积值进行归约，返回值作为下一轮迭代的累积值。最终返回与初始累积值类型相同的一个累积值。 ``` var numbers = [1, 2, 3, 4]; var transducer = R.compose(R.map(R.add(1)), R.take(2)); R.transduce(transducer, R.flip(R.append), [], numbers); //=&gt; [2, 3] ``` transpose定义：二维数组行列转置。输入 n 个长度为 x 的数组，输出 x 个长度为 n 的数组。 ``` R.transpose([[1, &apos;a&apos;], [2, &apos;b&apos;], [3, &apos;c&apos;]]); // [[1, 2, 3], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]] ``` traverse定义：将返回值为 Applicative 类型的函数映射到一个 Traversable 上。 然后使用 sequence 将结果由 Traversable of Applicative 转换为 Applicative of Traversable。 ``` var safeDiv = n =&gt; d =&gt; d === 0 ? Nothing() : Just(n / d); R.traverse(Maybe.of, safeDiv(10), [2, 4, 5]); //=&gt; Just([5, 2.5, 2]) ``` unfold定义：通过一个种子值（ seed ）创建一个列表。unfold 接受一个迭代函数： 该函数或者返回 false 停止迭代，或者返回一个长度为 2 的数组：数组首个元素添加到结果列表，第二个元素作为种子值传给下一轮迭代使用。 ``` var f = n =&gt; n &gt; 50 ? false : [-n, n + 10]; R.unfold(f, 10); //=&gt; [-10, -20, -30, -40, -50] ``` uniq定义：列表去重操作。返回无重复元素的列表。通过 R.equals 函数进行相等性判断。 ``` R.uniq([1, 1, 2, 1]); // [1, 2] ``` uniqBy定义：返回无重复元素的列表。元素通过给定的函数的返回值以及 R.equals 进行相同性判断。如果给定的函数返回值相同，保留第一个元素。 ``` R.uniqBy(Math.abs, [1, -1, 2, 1]); // [1, 2] ``` uniqWith定义：返回无重复元素的列表。元素通过 predicate 进行相同性判断。如果通过 predicate 判断两元素相同，保留第一个元素。 ``` var strEq = R.eqBy(String); R.uniqWith(strEq)([1, &apos;1&apos;, 2, 1]); //=&gt; [1, 2] ``` unnest定义：R.chain(R.identity) 的简写, 对 Chain 类型的数据消除一层嵌套。 ``` R.unnest([1, [2], [[3]]]); //=&gt; [1, 2, [3]] ``` update定义：替换数组中指定索引处的值。 ``` R.update(1, 11, [0, 1, 2]); // [0, 11, 2] ``` without定义：求第二个列表中，未包含在第一个列表中的任一元素的集合。通过 R.equals 函数进行相等性判断。 ``` R.without([1, 2], [1, 2, 1, 3, 4]); // [3, 4] ``` xprod定义：将两个列表的元素两两组合，生成一个新的元素对列表。 ``` R.xprod([1, 2], [&apos;a&apos;, &apos;b&apos;]); // [[1, &apos;a&apos;], [1, &apos;b&apos;], [2, &apos;a&apos;], [2, &apos;b&apos;]] ``` zip定义：将两个列表对应位置的元素组合，生成一个新的元素对列表。生成的列表长度取决于较短的输入列表的长度。 注意，zip 等价于 zipWith(function(a, b) { return [a, b] }) 。 ``` R.zip([1, 2, 3], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]); // [[1, &apos;a&apos;], [2, &apos;b&apos;], [3, &apos;c&apos;]] ``` zipObj定义：将两个列表对应位置的元素作为键值对组合，生成一个新的键值对的列表。生成的列表长度取决于较短的输入列表的长度。 注意，zip 等价于 pipe(zipWith(pair), fromPairs) 。 ``` R.zipObj([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], [1, 2, 3]); // {a: 1, b: 2, c: 3} ``` zipWith定义：将两个列表对应位置的元素通过一个函数处理，生成一个新的元素的列表。生成的列表长度取决于较短的输入列表的长度。 ``` var f = (x, y) =&gt; { // ... }; R.zipWith(f, [1, 2, 3], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]); //=&gt; [f(1, &apos;a&apos;), f(2, &apos;b&apos;), f(3, &apos;c&apos;)] ``` Objectassoc定义：浅复制对象，然后设置或覆盖对象的指定属性。 ``` R.assoc(&apos;c&apos;, 3, {a: 1, b: 2}); {a: 1, b: 2, c: 3} ``` assocPath定义：浅复制对象，设置或覆盖即将创建的给定路径所需的节点，并将特定值放在该路径的末端。 ``` R.assocPath([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 42, {a: {b: {c: 0}}}); // {a: {b: {c: 42}}} ``` clone定义：深复制。其值可能（嵌套）包含 Array、Object、Number、String、Boolean、Date 类型的数据。Function 通过引用复制。 ``` var objects = [{}, {}, {}]; var objectsClone = R.clone(objects); objects === objectsClone; // true ``` dissoc定义：删除对象中指定 prop 属性。 ``` R.dissoc(&apos;b&apos;, {a: 1, b: 2, c: 3}); // {a: 1, c: 3} ``` dissocPath定义：浅复制对象，删除返回对象中指定路径上的属性。 ``` R.dissocPath([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], {a: {b: {c: 42}}}); // {a: {b: {}}} ``` eqProps定义：判断两个对象指定的属性值是否相等。通过 R.equals 函数进行相等性判断。可用作柯里化的 predicate 。 ``` var o1 = {a: 1, b: 2, c: 3, d: 4}; var o2 = {a: 10, b: 20, c: 3, d: 40}; R.eqProps(&apos;a&apos;, o1, o2); // false ``` evolve定义：递归地对 object 的属性进行变换，变换方式由 transformation 函数定义。所有非原始类型属性都通过引用来复制。 如果某个 transformation 函数对应的键在被变换的 object 中不存在，那么该方法将不会执行。 ``` var tomato = {firstName: &apos; Tomato &apos;, data: {elapsed: 100, remaining: 1400}, id:123}; var transformations = { firstName: R.trim, lastName: R.trim, // Will not get invoked data: {elapsed: R.add(1), remaining: R.add(-1)} }; R.evolve(transformations, tomato); // {firstName: &apos;Tomato&apos;, data: {elapsed: 101, remaining: 1399}, id:123} ``` forEachObjIndexed定义：遍历 object，对 object 中的每对 key 和 value 执行方法 fn。 fn 接收三个参数: (value, key, obj). ``` var printKeyConcatValue = (value, key) =&gt; console.log(key + &apos;:&apos; + value); R.forEachObjIndexed(printKeyConcatValue, {x: 1, y: 2}); //=&gt; {x: 1, y: 2} ``` has定义：如果对象自身含有指定的属性，则返回 true；否则返回 false。 ``` R.has(&apos;name&apos;)({name: &apos;fanerge&apos;}); // true ``` hasIn定义：如果对象自身或原型链上含有指定的属性，则返回 true；否则返回 false。 ``` var Rect = function (w, h) { this.width = w; this.height = h; }; Rect.prototype.area = function (){ return this.width * this.heigth; }; var rect1 = new Rect(100, 200); R.hasIn(&apos;area&apos;)(rect1); // true ``` invert定义：与 R.invertObj 类似，但会将值放入数组中，来处理一个键对应多个值的情况。 ``` var raceResultsByFirstName = { first: &apos;alice&apos;, second: &apos;jake&apos;, third: &apos;alice&apos;, }; R.invert(raceResultsByFirstName); //=&gt; { &apos;alice&apos;: [&apos;first&apos;, &apos;third&apos;], &apos;jake&apos;:[&apos;second&apos;] } ``` invertObj定义：将对象的键、值交换位置：值作为键，对应的键作为值。交换后的键会被强制转换为字符串。注意，如果原对象同一值对应多个键，采用最后遍历到的键。 ``` var raceResults = { first: &apos;alice&apos;, second: &apos;jake&apos; }; R.invertObj(raceResults); //=&gt; { &apos;alice&apos;: &apos;first&apos;, &apos;jake&apos;:&apos;second&apos; } ``` keys定义：返回给定对象所有可枚举的、自身属性的属性名组成的列表。注意，不同 JS 运行环境输出数组的顺序可能不一致。 ``` R.keys({a: 1, b: 2, c: 3}); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] ``` keysIn定义：返回给定对象所有属性（包括 prototype 属性）的属性名组成的列表。注意，不同 JS 运行环境输出数组的顺序可能不一致。 ``` var F = function () { this.x = &apos;X&apos; }; F.prototype.y = &apos;Y&apos;; var f = new F(); R.keysIn(f); // [&apos;x&apos;, &apos;y&apos;] ``` lens定义：返回封装了给定 getter 和 setter 方法的 lens 。 getter 和 setter 分别用于 “获取” 和 “设置” 焦点（lens 聚焦的值）。 setter 不会改变原数据。 ``` var xLens = R.lens(R.prop(&apos;x&apos;), R.assoc(&apos;x&apos;)); R.view(xLens, {x: 1, y: 2}); // 1 R.set(xLens, 4, {x: 1, y: 2}); // {x: 4, y: 2} R.over(xLens, R.negate, {x: 1, y: 2}); // {x: -1, y: 2} ``` lensIndex定义：返回聚焦到指定索引的 lens。 ``` var headLens = R.lensIndex(0); R.view(headLens, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]); // a R.set(headLens, &apos;x&apos;, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]); // [&apos;x&apos;, &apos;b&apos;, &apos;c&apos;] R.over(headLens, R.toUpper, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]); // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;] ``` lensPath定义：返回聚焦到指定路径的 lens。 ``` var xHeadYLens = R.lensPath([&apos;x&apos;, 0, &apos;y&apos;]); R.view(xHeadYLens, {x: [{y: 2, z: 3}, {y: 4, z: 5}]}); // 2 R.set(xHeadYLens, 1, {x: [{y: 2, z: 3}, {y: 4, z: 5}]}); // {x: [{y: 1, z: 3}, {y: 4, z: 5}]} R.over(xHeadYLens, R.negate, {x: [{y: 2, z: 3}, {y: 4, z: 5}]}); // {x: [{y: -2, z: 3}, {y: 4, z: 5}]} ``` lensProp定义：返回聚焦到指定属性的 lens。 ``` var xLens = R.lensProp(&apos;x&apos;); R.view(xLens, {x: 1, y: 2}); //=&gt; 1 R.set(xLens, 4, {x: 1, y: 2}); //=&gt; {x: 4, y: 2} R.over(xLens, R.negate, {x: 1, y: 2}); //=&gt; {x: -1, y: 2} ``` merge定义：合并两个对象的自身属性（不包括 prototype 属性）。如果某个 key 在两个对象中都存在，使用后一个对象对应的属性值。 ``` R.merge({&apos;name&apos;: &apos;fanerge&apos;, &apos;age&apos;: 10}, {age: 30}); // {&apos;name&apos;: &apos;fanerge&apos;, age: 30} ``` mergaDeepLeft定义：合并两个对象的自身属性（不包括 prototype 属性）。如果某个 key 在两个对象中都存在： 并且两个值都是对象，则继续递归合并这两个值。 否则，采用第一个对象的值。 ``` R.mergeDeepLeft({ name: &apos;fred&apos;, age: 10, contact: { email: &apos;moo@example.com&apos; }}, { age: 40, contact: { email: &apos;baa@example.com&apos; }}); // { name: &apos;fred&apos;, age: 10, contact: { email: &apos;moo@example.com&apos; }} ``` mergaDeepRight定义：合并两个对象的自身属性（不包括 prototype 属性）。如果某个 key 在两个对象中都存在： 并且两个值都是对象，则继续递归合并这两个值。 否则，采用第二个对象的值。 ``` R.mergeDeepRight({ name: &apos;fred&apos;, age: 10, contact: { email: &apos;moo@example.com&apos; }}, { age: 40, contact: { email: &apos;baa@example.com&apos; }}); // { name: &apos;fred&apos;, age: 40, contact: { email: &apos;baa@example.com&apos; }} ``` mergaDeepWith定义：合并两个对象的自身属性（不包括 prototype 属性）。如果某个 key 在两个对象中都存在： 并且两个关联的值都是对象，则继续递归合并这两个值。 否则，使用给定函数对两个值进行处理，并将返回值作为该 key 的新值。 如果某 key 只存在于一个对象中，该键值对将作为结果对象的键值对。 ``` R.mergeDeepWith(R.concat, { a: true, c: { values: [10, 20] }}, { b: true, c: { values: [15, 35] }}); // { a: true, b: true, c: { values: [10, 20, 15, 35] }} ``` mergeDeepWithKey定义：合并两个对象的自身属性（不包括 prototype 属性）。如果某个 key 在两个对象中都存在： 并且两个关联的值都是对象，则继续递归合并这两个值。 否则，使用给定函数对该 key 和对应的两个值进行处理，并将返回值作为该 key 的新值。 如果某 key 只存在于一个对象中，该键值对将作为结果对象的键值对。 ``` let concatValues = (k, l, r) =&gt; k == &apos;values&apos; ? R.concat(l, r) : r R.mergeDeepWithKey(concatValues, { a: true, c: { thing: &apos;foo&apos;, values: [10, 20] }}, { b: true, c: { thing: &apos;bar&apos;, values: [15, 35] }}); // { a: true, b: true, c: { thing: &apos;bar&apos;, values: [10, 20, 15, 35] }} ``` mergeWith定义：使用给定的两个对象自身属性（不包括 prototype 属性）来创建一个新对象。 如果某个 key 在两个对象中都存在，则使用给定的函数对每个对象该 key 对应的 value 进行处理，处理结果作为新对象该 key 对应的值。 ``` R.mergeWith(R.concat, {a: true, values: [10, 20]}, {b: true, values: [15, 35]}); // {a: true, b: true, values: [10, 20, 15, 35]} ``` mergeWithKey定义：使用给定的两个对象自身属性（不包括 prototype 属性）来创建一个新对象。 如果某个 key 在两个对象中都存在，则使用给定的函数对该 key 和每个对象该 key 对应的 value 进行处理，处理结果作为新对象该 key 对应的值。 ``` let concatValues = (k, l, r) =&gt; k == &apos;values&apos; ? R.concat(l, r) : r R.mergeWithKey(concatValues, { a: true, thing: &apos;foo&apos;, values: [10, 20] }, { b: true, thing: &apos;bar&apos;, values: [15, 35] }); // { a: true, b: true, thing: &apos;bar&apos;, values: [10, 20, 15, 35] } ``` objOf定义：创建一个包含单个键值对的对象。 ``` var matchPhrases = R.compose( R.objOf(&apos;must&apos;), R.map(R.objOf(&apos;match_phrase&apos;)) ); matchPhrases([&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]); //=&gt; {must: [{match_phrase: &apos;foo&apos;}, {match_phrase: &apos;bar&apos;}, {match_phrase: &apos;baz&apos;}]} ``` omit定义：删除对象中给定的 keys 对应的属性。 ``` R.omit([&apos;a&apos;, &apos;d&apos;], {a: 1, b: 2, c: 3, d: 4}); // {b: 2, c: 3} ``` over定义：对数据结构中被 lens 聚焦的部分进行函数变换。 ``` var headLens = R.lensIndex(0); R.over(headLens, R.toUpper, [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]); // [&apos;FOO&apos;, &apos;bar&apos;, &apos;baz&apos;] ``` path定义：取出给定路径上的值。 ``` R.path([&apos;a&apos;, &apos;b&apos;], {a: {b: 2}}); // 2 ``` pathOr定义：如果非空对象在给定路径上存在值，则将该值返回；否则返回给定的默认值。 ``` R.pathOr(&apos;N/A&apos;, [&apos;a&apos;, &apos;b&apos;], {a: {b: 2}}); // 2 ``` pick定义：返回对象的部分拷贝，其中仅包含指定键对应的属性。如果某个键不存在，则忽略该属性。 ``` R.pick([&apos;a&apos;, &apos;d&apos;], {a: 1, b: 2, c: 3, d: 4}); // {a: 1, d: 4} ``` pickAll定义：与 pick 类似，但 pickAll 会将不存在的属性以 key: undefined 键值对的形式返回。 ``` R.pickAll([&apos;a&apos;, &apos;d&apos;, &apos;e&apos;], {a: 1, b: 2, c: 3, d: 4}); // {a: 1, d: 4, e: undefined} ``` pickBy定义：返回对象的部分拷贝，其中仅包含 key 满足 predicate 的属性。 ``` var isUpperCase = (val, key) =&gt; key.toUpperCase() === key; R.pickBy(isUpperCase, {a: 1,b: 2, A: 3, B: 4}); // {A: 3, B: 4} ``` project定义：模拟 SQL 中的 select 语句。 ``` var abby = {name: &apos;Abby&apos;, age: 7, hair: &apos;blond&apos;, grade: 2}; var fred = {name: &apos;Fred&apos;, age: 12, hair: &apos;brown&apos;, grade: 7}; var kids = [abby, fred]; R.project([&apos;name&apos;, &apos;grade&apos;], kids); // [{name: &apos;Abby&apos;, grade: 2}, {name: &apos;Fred&apos;, grade: 7}] ``` prop定义：取出对象中指定属性的值。如果不存在，则返回 undefined。 ``` R.prop(&apos;x&apos;, {x: 100}); // 100 ``` propOr定义：对于给定的非空对象，如果指定属性存在，则返回该属性值；否则返回给定的默认值。 ``` var alice = { name: &apos;ALICE&apos;, age: 101 }; var favorite = R.prop(&apos;favoriteLibrary&apos;); var favoriteWithDefault = R.propOr(&apos;Ramda&apos;, &apos;favoriteLibrary&apos;); favorite(alice); // undefined favoriteWithDefault(alice); // &apos;Ramda&apos; ``` props定义：返回 prop 的数组：输入为 keys 数组，输出为对应的 values 数组。values 数组的顺序与 keys 的相同。 ``` R.props([&apos;x&apos;, &apos;y&apos;], {x: 1, y: 2}); // [1, 2] ``` set定义：通过 lens 对数据结构聚焦的部分进行设置。 ``` var xLens = R.lensProp(&apos;x&apos;); R.set(xLens, 4, {x: 1, y: 2}); // {x: 4, y: 2} ``` toPairs定义：将一个对象的属性转换成键、值二元组类型的数组，只处理对象自身的属性。注意：不同 JS 运行环境输出数组的顺序可能不一致。 ``` R.toPairs({a: 1, b: 2, c: 3}); // [[&apos;a&apos;, 1], [&apos;b&apos;, 2], [&apos;c&apos;, 3]] ``` toPairsIn定义：将一个对象的属性转换成键、值二元组类型的数组，包括原型链上的属性。注意，不同 JS 运行环境输出数组的顺序可能不一致。 ``` var F = function () { this.x = &apos;X&apos;; }; F.prototype.y = &apos;Y&apos;; var f = new F(); R.toPairsIn(f); // [[&apos;x&apos;,&apos;X&apos;], [&apos;y&apos;,&apos;Y&apos;]] ``` values定义：返回对象所有自身可枚举的属性的值。注意：不同 JS 运行环境输出数组的顺序可能不一致。 ``` R.values({a: 1, b: 2, c: 3}); //=&gt; [1, 2, 3] ``` valuesIn定义：返回对象所有属性的值，包括原型链上的属性。注意：不同 JS 运行环境输出数组的顺序可能不一致。 ``` var F = function() { this.x = &apos;X&apos;; }; F.prototype.y = &apos;Y&apos;; var f = new F(); R.valuesIn(f); //=&gt; [&apos;X&apos;, &apos;Y&apos;] ``` view定义：返回数据结构中，lens 聚焦的部分。lens 的焦点决定了数据结构中的哪部分是可见的。 ``` var xLens = R.lensProp(&apos;x&apos;); R.view(xLens, {x: 1, y: 2}); //=&gt; 1 ``` where定义：接受一个测试规范对象和一个待检测对象，如果测试满足规范，则返回 true，否则返回 false。测试规范对象的每个属性值都必须是 predicate 。 每个 predicate 作用于待检测对象对应的属性值，如果所有 predicate 都返回 true，则 where 返回 true，否则返回 false 。 where 非常适合于需要声明式表示约束的函数，比如 filter 和 find 。 ``` var pred = R.where({ a: R.equals(&apos;foo&apos;), b: R.complement(R.equals(&apos;bar&apos;)), x: R.gt(R.__, 10), y: R.lt(R.__, 20) }); pred({a: &apos;foo&apos;, b: &apos;xxx&apos;, x: 11, y: 19}); //=&gt; true pred({a: &apos;xxx&apos;, b: &apos;xxx&apos;, x: 11, y: 19}); //=&gt; false ``` whereEq定义：接受一个测试规范对象和一个待检测对象，如果测试满足规范，则返回 true，否则返回 false。 如果对于每一个测试规范对象的属性值，待检测对象中都有一个对应的相同属性值，则 where 返回 true，否则返回 false 。 whereEq 是 where 的一种特殊形式。 ``` var pred = R.whereEq({a: 1, b: 2}); pred({a: 1}); //=&gt; false pred({a: 1, b: 2}); //=&gt; true ``` LogicallPass定义：传入包含多个 predicate 的列表，返回一个 predicate：如果给定的参数满足列表中的所有 predicate ，则返回 true。 该函数返回一个柯里化的函数，参数个数由列表中参数最多的 predicate 决定。 ``` var isQueen = R.propEq(&apos;rank&apos;, &apos;Q&apos;); var isSpade = R.propEq(&apos;suit&apos;, &apos;??&apos;); var isQueenOfSpades = R.allPass([isQueen, isSpade]); isQueenOfSpades({rank: &apos;Q&apos;, suit: &apos;??&apos;}); // true ``` anyPass定义：传入包含多个 predicate 的列表，返回一个 predicate：只要给定的参数满足列表中的一个 predicate ，就返回 true。 该函数返回一个柯里化的函数，参数个数由列表中参数最多的 predicate 决定。 ``` var isQueen = R.propEq(&apos;rank&apos;, &apos;Q&apos;); var isSpade = R.propEq(&apos;suit&apos;, &apos;??&apos;); var isQueenOfSpades = R.anyPass([isQueen, isSpade]); isQueenOfSpades({rank: &apos;K&apos;, suit: &apos;??&apos;}); // true ``` and（针对于值）定义：如果两个参数都是 true，则返回 true；否则返回 false。相当于且（&amp;&amp;） ``` R.and(true, true); // true ``` or（针对于值）定义：逻辑或运算，只要有一个参数为 truth-y，就返回 true；否则返回 false。 ``` R.or(true, true); // true ``` not（针对于值）定义：逻辑非运算。 当传入参数为 false-y 值时，返回 true；truth-y 值时，返回 false。 ``` R.not(true); // false ``` both（针对于函数）定义：该函数调用两个函数，并对两函数返回值进行与操作。若第一个函数结果为 false-y 值 (false, null, 0 等)，则返回该结果，否则返回第二个函数的结果。注意，both 为短路操作，即如果第一个函数返回 false-y 值，则不会调用第二个函数。 ``` var gt10 = R.gt(R.__, 10); var lt20 = R.lt(R.__, 20); var f = R.both(gt10, lt20); f(15); // true ``` either（针对于函数）定义：返回由 || 运算符连接的两个函数的包装函数。如果两个函数中任一函数的执行结果为 truth-y，则返回其执行结果。 注意，这个是短路表达式，意味着如果第一个函数返回 truth-y 值的话，第二个函数将不会执行。 ``` var gt10 = x =&gt; x &gt; 10; var even = x =&gt; x % 2 === 0; var f = R.either(gt10, even); f(101); // true ``` complement（针对于函数）定义：对函数的返回值取反。接受一个函数 f，返回一个新函数 g：在输入参数相同的情况下，若 f 返回 &apos;true-y&apos; ，则 g 返回 false-y ，反之亦然。 ``` var isNotNil = R.complement(R.isNil); isNotNil(null); // true ``` cond定义：返回一个封装了 if / else，if / else if/ else逻辑的函数 fn。 R.cond 接受列表元素为 [predicate，transformer] 的列表。 fn 的所有参数顺次作用于每个 predicate，直到有一个返回 &quot;truthy&quot; 值，此时相应 transformer 对参数处理，并作为 fn 的结果返回。 如果没有 predicate 匹配，则 fn 返回 undefined。 ``` var fn = R.cond([ [R.equals(0), R.always(&apos;water freezes at 0&apos;)], [R.equals(100), R.always(&apos;water freezes at 100&apos;)], [R.T, temp =&gt; `nothing special happens at ${temp}`], ]); fn(3); // nothing special happens at 3 ``` defaultTo定义：如果第二个参数不是 null、undefined 或 NaN，则返回第二个参数，否则返回第一个参数（默认值）。 ``` var defaultTo42 = R.defaultTo(42); defaultTo42(undefined); // 42 defaultTo42(13); // 13 ``` ifElse定义：根据 condition predicate 的返回值调用 onTrue 或 onFalse 函数。 ``` var inCount = R.ifElse( R.has(&apos;count&apos;), R.over(R.lensProp(&apos;count&apos;), R.inc), R.assoc(&apos;count&apos;, 1) ); incCount({}); //=&gt; { count: 1 } incCount({ count: 1 }); //=&gt; { count: 2 } ``` isEmpty定义：检测给定值是否为其所属类型的空值，若是则返回 true ；否则返回 false 。 ``` R.isEmpty([1, 2, 3]); // false R.isEmpty(&apos;&apos;); // true ``` pathSatisfies定义：如果对象的给定路径上的属性满足 predicate，返回 ture；否则返回 false。 ``` R.pathSatisfies(y =&gt; y &gt; 0, [&apos;x&apos;, &apos;y&apos;], {x: {y: 2}}); // true ``` propSatisfies定义：如果指定的对象属性满足 predicate，返回 true；否则返回 false。 ``` R.propSatisfies(x =&gt; x &gt; 0, &apos;x&apos;, {x: 1, y: 2}); // true ``` unless定义：判断输入值是否满足 predicate，若不符合，则将输入值传给 whenFalseFn 处理，并将处理结果作为返回；若符合，则将输入值原样返回。 ``` let safeInc = R.unless(R.isNil, R.inc); safeInc(null); //=&gt; null safeInc(1); //=&gt; 2 ``` until定义：接受一个 predicate ，transform function 和 初始值，返回一个与初始值相同类型的值。 对输入值进行 transform ，直到 transform 的结果满足 predicate，此时返回这个满足 predicate 的值。 ``` R.until(R.gt(R.__, 100), R.multiply(2))(1); // 128 ``` when定义：判断输入值是否满足 predicate，若符合，则将输入值传给 whenTrueFn 处理，并将处理结果作为返回；若不符合，则将输入值原样返回。 ``` var truncate = R.when( R.propSatisfies(R.gt(R.__, 10), &apos;length&apos;), R.pipe(R.take(10), R.append(&apos;…&apos;), R.join(&apos;&apos;)) ); truncate(&apos;12345&apos;); // &apos;12345&apos; truncate(&apos;0123456789ABC&apos;); // &apos;0123456789…&apos; ``` Function__定义：柯里化函数的参数占位符。允许部分应用于任何位置的参数。 ``` 假设 g 代表柯里化的三元函数 g(1, 2, 3) g(R.__, 2, 3)(1) g(R.__, R__, 3)(1)(2) g(R.__, 2, R.__)(1)(3) g(R.__, 2)(R.__, 3)(1) // 这些函数都是等价的。 var greet = R.replace(&apos;{name}&apos;, R.__, &apos;Hello, {name}!&apos;); greet(&apos;Fanerge&apos;); // Hello, Fanerge ``` addIndex定义：通过向列表迭代函数的回调函数添加两个新的参数：当前索引、整个列表，创建新的列表迭代函数。 ``` var mapIndexed = R.addIndex(R.map); mapIndexed((val, idx) =&gt; {idx + &apos;-&apos; + val}, [&apos;f&apos;, &apos;a&apos;, &apos;n&apos;]); // [&apos;0-f&apos;, &apos;1-a&apos;, &apos;2-n&apos;] ``` always定义：返回一个返回恒定值的函数。注意，对于非原始值，返回的值是对原始值的引用。 ``` var t = R.always(&apos;Tee&apos;); t(); // Tee ``` ap定义：将函数列表作用于值列表上。 ``` R.ap([R.multiply(2), R.add(3)], [1, 2, 3]); // [2, 4, 6, 4, 5, 6] ``` apply定义：将函数 fn 作用于参数列表 args。apply 可以将变参函数转换为为定参函数。如果上下文很重要，则 fn 应该绑定其上下文。 ``` var nums = [1, 2, 3, -99, 42, 6, 7]; R.apply(Math.max, nums); // 42 ``` applySpec定义：接受一个属性值为函数的对象，返回一个能生成相同结构对象的函数。返回的函数使用传入的参数调用对象的每个属性位对应的函数，来生成相应属性的值。 ``` var getMetrics = R.applySpec({ sum: R.add, nested: { mul: R.multiply } }); getMetrics(2, 4); // {sum: 6, nested: { mul: 8 }} ``` ascend定义：由返回值可与 &lt; 和 &gt; 比较的函数，创建一个升序比较函数。 ``` var byAge = R.ascend(R.prop(&apos;age&apos;)); var people = [{name: &apos;yzf&apos;, age: 11}, {name: &apos;wkm&apos;, age: 10}]; var peopleByYoungestFirst = R.sort(byAge, people); // [{&quot;name&quot;:&quot;wkm&quot;,&quot;age&quot;:10},{&quot;name&quot;:&quot;yzf&quot;,&quot;age&quot;:11}] ``` binary定义：将任意元函数封装为二元函数（只接受2个参数）中。任何额外的参数都不会传递给被封装的函数。 ``` var takesThreeArgs = function (a, b, c){ return [a, b, c]; }; vat takeTwoArgs = R.binary(takesThreeArgs); // takeTwoArgs.length; // 2 takeTwoArgs(1, 2, 3); // [1, 2, undefined] ``` bind定义：创建一个绑定了上下文的函数。 注意：与 Function.prototype.bind 不同，R.bind 不会绑定额外参数。 ``` var log = R.bind(console.log, console); log(1); // 1 ``` call定义：提取第一个参数作为函数，其余参数作为刚提取的函数的参数，调用该函数并将结果返回。 ``` R.call(R.add, 1, 2); // 3 ``` comparator定义：由首个参数是否小于第二个参数的判断函数，生成一个比较函数。 ``` var byAge = R.comparator((a, b) =&gt; a.age &lt; b.age); var people = [{name: &apos;yzf&apos;, age: 11}, {name: &apos;wkm&apos;, age: 10}]; var peopleByIncreasingAge = R.sort(byAge, people); // [{&quot;name&quot;:&quot;wkm&quot;,&quot;age&quot;:10},{&quot;name&quot;:&quot;yzf&quot;,&quot;age&quot;:11}] ``` compose定义：从右往左执行函数组合（右侧函数的输出作为左侧函数的输入）。最右侧函数可以是任意元函数（参数个数不限），其余函数必须是一元函数。 ``` R.compose(R.add(1), R.multiply(2))(3); // 7 ``` composeK定义：接受一系列函数，返回从右向左的 Kleisli 组合，每个函数必须返回支持 chain 操作的值。 ``` R.composeK(h, g, f) 等同于 R.compose(R.chain(h)，R.chain(g)，R.chain(f))。 ``` composeP定义： 从右向左执行返回 Promise 的函数的组合。最右边的函数可以是任意元函数（参数个数不限）; 其余函数必须是一元函数。 ``` var db = { users: { JOE: { name: &apos;Joe&apos;, followers: [&apos;STEVE&apos;, &apos;SUZY&apos;] } } }; var lookupUser = (userId) =&gt; Promise.resolve(db.users[userId]); var lookupFollowers = (user) =&gt; Promise.resolve(user.followers); lookupUser(&apos;JOE&apos;).then(lookupFollowers); var followersForUser = R.composeP(lookupFollowers, lookupUser); followersForUser(&apos;JOE&apos;).then(followers =&gt; console.log(&apos;Followers:&apos;, followers)) // [&quot;STEVE&quot;,&quot;SUZY&quot;] ``` construct定义：将构造函数封装进柯里化函数，新函数与原构造函数的传入参数类型及返回值类型相同。 ``` // constructor function function Animal (kind) { this.kind = kind; } Animal.prototype.sighting = function () { return `it&apos;s a ${this.kind}!`; }; var AnimalConstructor = R.construct(Animal); console.log(AnimalConstructor(&apos;PIG&apos;)); // {&quot;kind&quot;:&quot;PIG&quot;} ``` constructN定义：将构造函数封装进柯里化函数，新函数与原构造函数的传入参数类型及返回值类型相同。为了能够使用变参的构造函数，返回函数的元数需要明确指定。 ``` function Salad() { this.ingredients = arguments; }; Salad.prototype.recipe = function() { var instructions = R.map((ingredient) =&gt; ( &apos;Add a whollop of &apos; + ingredient, this.ingredients) ) return R.join(&apos;\n&apos;, instructions) } var ThreeLayerSalad = R.constructN(3, Salad) // Notice we no longer need the &apos;new&apos; keyword, and the constructor is curried for 3 arguments. var salad = ThreeLayerSalad(&apos;Mayonnaise&apos;)(&apos;Potato Chips&apos;)(&apos;Ketchup&apos;) console.log(salad.recipe()); // Add a whollop of Mayonnaise // Add a whollop of Potato Chips // Add a whollop of Potato Ketchup ``` converge定义：接受一个 converging 函数和一个分支函数列表，返回一个新函数。 当被调用时，新函数接受参数，并将这些参数转发给每个分支函数；然后将每个分支函数的计算结果作为参数传递给 converging 函数，converging 函数的计算结果即新函数的返回值。 ``` var average = R.converge(R.divide, [R.sum, R.length]); average([1, 2, 3, 4, 5, 6, 7]); // 4 ``` curry定义：对函数进行柯里化。柯里化函数与其他语言中的柯里化函数相比，有两个非常好的特性： 1.参数不需要一次只传入一个。 g(1)(2)(3) === g(1, 2, 3) 2.占位符值 R.__ 可用于标记暂未传入参数的位置。允许部分应用于任何参数组合，而无需关心它们的位置和顺序。 F(1, 2, 3) === F(R.__, 2, 3)(1) === F(R.__, 3)(1)(2) ``` var addFourNumbers = (a, b, c, d) =&gt; a + b + c + d; var curriedAddFourNumbers = R.curry(addFourNumbers); var f = curriedAddFourNumbers(1); // 返回剩余三个参数的函数 f(2, 3, 4); // 10(当参数全部传入，才返回结果) ``` curryN定义：对函数进行柯里化，并限制柯里化函数的元数。 ``` var sumArgs = (...args) =&gt; R.sum(args); var curriedFourNumbers = R.curryN(5, sumArgs); var f = curriedAddFourNumbers(1, 2); var g = f(3, 4, 5); // 15 ``` descend定义：由返回值可与 &lt; 和 &gt; 比较的函数，创建一个降序比较函数。 ``` var byAge = R.descend(R.prop(&apos;age&apos;)); var people = [ ]; var peopleByOldFirst = R.sort(byAge, people); ``` empty定义：根据传入参数的类型返回其对应的空值。 Ramda 定义了各类型的空值如下：Array ([])，Object ({})，String (&apos;&apos;)，和 Arguments。empty 还支持其它定义了 &lt;Type&gt;.empty 和/或 &lt;Type&gt;.prototype.empty 的类型。 ``` R.empty(Just(42)); // Noting() R.empty([1, 2]); // [] ``` F定义：恒定返回 false 的函数。忽略所有的输入参数。 ``` R.F(); // false ``` flip定义：交换函数前两个参数的位置。 ``` var mergeThree = (a, b, c) =&gt; [].concat(a, b, c); mergeThree(1, 2, 3); // [1, 2, 3] R.flip(mergeThree)(1, 2, 3); // [2, 1, 3] ``` identity定义：将输入值原样返回。适合用作默认或占位函数。 ``` R.identity(1); // 1 var obj = {}; R.identity(obj) === obj; // true ``` invoker定义：将具有指定元数（参数个数）的具名方法，转换为可以被给定参数和目标对象直接调用的函数。 返回的函数是柯里化的，它接收 arity + 1 个参数，其中最后一个参数是目标对象。 ``` var sliceFrom = R.invoker(1, &apos;slice&apos;); sliceFrom(6, &apos;abcdefghijklm&apos;); //=&gt; &apos;ghijklm&apos; ``` juxt定义：juxt 将函数列表作用于值列表。 ``` var getRange = R.juxt([Math.min, Math.max]); getRange(3, 4, 9, -3); // [-3, 9] ``` lift定义：提升一个多元函数，使之能映射到列表、函数或其他符合 FantasyLand Apply spec 规范的对象上。 ``` var madd3 = R.lift((a, b, c) =&gt; a + b + c); madd3([1,2,3], [1,2,3], [1]); //=&gt; [3, 4, 5, 4, 5, 6, 5, 6, 7] ``` liftN定义：将一个函数提升为指定元数的函数，使之能映射到多个列表、函数或其他符合 FantasyLand Apply spec 规范的对象上。 ``` var madd3 = R.liftN(3, (...args) =&gt; R.sum(args)); madd3([1,2,3], [1,2,3], [1]); //=&gt; [3, 4, 5, 4, 5, 6, 5, 6, 7] ``` memoize定义：memoize 方法可以缓存函数的计算结果。 创建一个新函数，被调用时，缓存特定参数对应的经 fn 计算的结果，并将结果返回。 此后如果用相同的参数调用缓存的 fn 时，直接返回该参数对应的缓存结果，不必再调用 fn。 ``` var count = 0; const factorial = R.memoize(n =&gt; { count += 1; return R.product(R.range(1, n + 1)); }); factorial(5); // 120 factorial(5); // 120 count; // 1(只进行了一次运算) ``` memoizeWith定义：R.memoize 的可定制版本。memoizeWith 需要一个额外的函数，该函数接受一个参数集，用于创建缓存的键值，在该缓存中会存储被缓存函数的结果。 注意，生成缓存键值时，要避免可能会错误地覆盖之前已缓存键值对的冲突。 ``` var count = 0; const factorial = R.memoizeWith(R.identity, n =&gt; { count += 1; return R.product(R.range(1, n + 1)); }); factorial(5); // 120 factorial(5); // 120 count; // 1(只进行了一次运算) ``` nAry定义：将一个任意元（包括零元）的函数，封装成一个确定元数（参数个数）的函数。任何多余的参数都不会传入被封装的函数。 ``` var takesTwoArgs = (a, b) =&gt; [a, b]; takesTwoArgs.length; // 2 takesTwoArgs(1, 2); // [1, 2] var takesOneArg = R.nAry(1, takeTwoArgs); takesOneArg.length; // 1 takesOneArg(1, 2); // [1, undefined] ``` nthArg定义：返回一个函数，该函数返回它的第 n 个参数。 ``` R.nthArg(1)(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;); // b ``` o定义：o 是一个柯里化组合函数，返回一元函数。 类似于 compose，o 从右到左执行函数组合。但与 compose 不同的是，传递给 o 的最右边的函数为一元函数。 ``` R.o(R.multiply(10), R.add(10))(-4); // 60 ``` of定义：将给定值作为元素，封装成单元素数组。 ``` R.of(42); // [42] ``` once定义：创建一个只能调用一次的函数。 将给定函数 fn 封装到新函数fn&apos;中，fn&apos; 确保 fn 只能调用一次。重复调用fn&apos; ，只会返回第一次执行时的结果。 ``` var addOneOnce = R.once(x =&gt; x + 1); addOneOnce(10); // 11 addOneOnce(51); // 11 ``` partial定义：部分应用。 接收两个参数：函数 f 和 参数列表，返回函数 g。当调用 g 时，将初始参数和 g 的参数顺次传给 f，并返回 f 的执行结果。 ``` var multiply2 = (a, b) =&gt; a * b; var double = R.partial(multiply2, [2]); double(3); // 2*3=6 ``` partialRight定义：部分应用。 接收两个参数：函数 f 和 参数列表，返回函数 g。当调用 g 时，将 g 的参数和初始参数顺序传给 f，并返回 f 的执行结果。 ``` var multiply2 = (a, b) =&gt; a * b; var double = R.partial(multiply2, [2]); double(3); // 3*2=6 ``` pipe定义：从左往右执行函数组合。最左边的函数可以是任意元函数（参数个数不限），其余函数必须是一元函数。 ``` var f = R.pipe(Math.pow, R.negate, R.inc); f(3, 4); // -(3^4) + 1 ``` pipeK定义：将一系列函数，转换成从左到右的 Kleisli 组合，每个函数必须返回支持chain操作的值。 R.pipeK(f, g, h) 等价于 R.pipe(R.chain(f), R.chain(g), R.chain(h))。 ``` var getStateCode = R.pipeK( parseJson, get(&apos;user&apos;), get(&apos;address&apos;), get(&apos;state&apos;), R.compose(Maybe.of, R.toUpper) ); getStateCode(&apos;{&quot;user&quot;:{&quot;address&quot;:{&quot;state&quot;:&quot;ny&quot;}}}&apos;); // Just(&apos;NY&apos;) ``` pipeP定义：从左往右执行返回 Promise 的函数的组合。最左边的函数可以是任意元函数（参数个数不限）；其余函数必须是一元函数。 ``` var followersForUser = R.pipeP(db.getUserById, db.getFollowers); ``` T定义：恒定返回 true 的函数。忽略所有的输入参数。 ``` R.T(); // true ``` tap定义：对输入的值执行给定的函数，然后返回输入的值。 ``` var sayX = x =&gt; console.log(&apos;x is &apos; + x); R.tap(sayX, 100); // 100 ``` tryCatch定义：tryCatch 接受两个函数：tryer 和 catcher，生成的函数执行 tryer，若未抛出异常，则返回执行结果。 若抛出异常，则执行 catcher，返回 catcher 的执行结果。注意，为了有效的组合该函数，tryer 和 catcher 应返回相同类型的值。 ``` R.tryCatch(R.prop(&apos;x&apos;), R.f)({x: true}); // true ``` unapply定义：输入一个只接收单个数组作为参数的函数，返回一个新函数： 接收任意个参数； 将参数组成数组传递给 fn ； 返回执行结果。 换言之，R.unapply 将一个使用数组作为参数的函数，变为一个不定参函数。 R.unapply 是 R.apply 的逆函数 ``` R.unapply(JSON.stringify, 1, 2, 3); // &apos;[1, 2, 3]&apos; ``` unary定义：将任意元（包括零元）函数封装成一元函数。任何额外的参数都不会传递给被封装的函数。 ``` var takesTwoArgs = function(a, b) { return [a, b]; }; takesTwoArgs.length; //=&gt; 2 takesTwoArgs(1, 2); //=&gt; [1, 2] var takesOneArg = R.unary(takesTwoArgs); takesOneArg.length; //=&gt; 1 // 只有一个参数能被传递到函数当中 takesOneArg(1, 2); //=&gt; [1, undefined] ``` uncurryN定义：将一个柯里化的函数转换为一个 n 元函数。 ``` var addFour = a =&gt; b =&gt; c =&gt; d =&gt; a + b + c + d; var uncurriedAddFour = R.uncurryN(4, addFour); uncurriedAddFour(1, 2, 3, 4); // 10 ``` useWith定义：接受一个函数 fn 和一个 transformer 函数的列表，返回一个柯里化的新函数。 当被调用时，新函数将每个参数转发给对应位置的 transformer 函数，然后将每个 transformer 函数的计算结果作为参数传递给 fn，fn 的计算结果即新函数的返回值。 如果新函数传传入参数的数量比 transformer 函数的数量多，多出的参数会作为附加参数直接传给 fn 。 如果不需要处理多出的那部分参数，除了忽略之外，也可以用 identity 函数来作为 transformer ，以保证新函数的参数数量是确定的。 ``` R.useWith(Math.pow, [R.identity, R.identity])(3, 4); //=&gt; 81 ``` Mathadd定义：两数相加。 ``` R.add(2)(3); // 5 ``` divide定义：两数相除。等价于a / b。 ``` R.divide(71, 100); // 0.71 ``` dec（相当于自减）定义：减一。与i--的区别为会生产一个新数据（不改变原有值）。 ``` R.dec(42); // 41 ``` inc（相当于自加）定义：加1。 ``` R.inc(42); // 43 ``` mathMod定义：mathMod 和算术取模操作类似，而不像 % 操作符 （或 R.modulo）。所以 -17 % 5 等于 -2，而 mathMod(-17, 5) 等于 3 。 mathMod 要求参数为整型，并且当模数等于 0 或者负数时返回 NaN 。 ``` R.mathMod(-17, 5); // 3 R.mathMod(17, 5); // 2 ``` mean定义：返回给定数字列表的平均值。 ``` R.mean([2, 7, 9]); // 6 ``` median定义：返回给定数字列表的中位数。 ``` R.median([2, 9, 7]); // 7 ``` modulo定义：用第一个参数除以第二个参数，并返回余数。注意，该函数是 JavaScript-style 的求模操作。数学求模另见 mathMod。 ``` R.modulo(17, 3); // 2 R.modulo(-17, 3); // -2 ``` multiply定义：两数相乘，等价于柯里化的 a * b 。 ``` R.multiply(2, 3); // 6 ``` negate定义：取反操作。 ``` R.negate(42); // -42 ``` product定义：列表中的所有元素相乘。 ``` R.product([2, 3, 4]); // 24 ``` subtract定义：首个参数减去第二个参数。 ``` R.subtract(1, 2); // -1 ``` sum定义：对数组中所有元素求和。 ``` R.sum([1, 2, 3]); // 6 ``` Relationclamp定义：将数字限制在指定的范围内。 clamp 也可用于其他有序类型，如字符串和日期。 ``` R.clamp(1, 10, -5); // 1 R.clamp(1, 10, 4); // 4 ``` countBy定义：根据给定函数提供的统计规则对列表中的元素进行分类计数。 返回一个对象，其键值对为：fn 根据列表元素生成键，列表中通过 fn 映射为对应键的元素的个数作为值。 注意，由于 JavaScript 对象的实现方式，所有键都被强制转换为字符串。 ``` var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2]; R.countBy(Math.floor, numbers); // {&apos;1&apos;: 3, &apos;2&apos;: 2, &apos;3&apos;: 1 } ``` difference定义：求差集。求第一个列表中，未包含在第二个列表中的任一元素的集合。对象和数组比较数值相等，而非引用相等。 ``` R.difference([1, 2, 3, 4], [7, 6, 5, 4, 3]); // [1, 2] ``` differenceWith定义：求第一个列表中未包含在第二个列表中的所有元素的集合（集合中没有重复元素）。 两列表中的元素通过 predicate 判断相应元素是否同时 “包含在” 两列表中。 ``` var cmp = (x, y) =&gt; x.a === y.a; var l1 = [{a: 1}, {a: 2}, {a: 3}]; var l2 = [{a: 3}, {a: 4}]; R.differenceWith(cmp, l1, l2); // [{a: 1}, {a: 2}] ``` eqBy定义：接受一个函数和两个值，通过传入函数对两个值进行相等性判断。如果两个值的计算结果相等，则返回 true ；否则返回 false 。 ``` R.eqBy(Math.abs, 5, -5); // true ``` equals定义：如果传入的参数相等，返回 true；否则返回 false。可以处理几乎所有 JavaScript 支持的数据结构。 ``` R.equals(1, 1); // true R.equals([&apos;1&apos;], [&apos;1&apos;]); // true ``` gt定义：如果首个参数大于第二个参数，返回 true；否则返回 false。 ``` R.gt(2, 1); // true ``` gte定义：如果首个参数大于等于第二个参数，返回 true；否则返回 false。 ``` R.gte(2, 1); // true ``` identical定义：如果两个参数是完全相同，则返回 true，否则返回 false。 如果它们引用相同的内存，也认为是完全相同的。NaN 和 NaN 是完全相同的；0 和 -0 不是完全相同的。 ``` var o = {}; R.identical(o, o); //=&gt; true R.identical(1, 1); //=&gt; true ``` innerJoin定义：接受一个 predicate pred 、列表 xs 和 ys ，返回列表 xs&apos;。 依次取出 xs 中的元素，若通过 pred 判断等于 ys 中的一个或多个元素，则放入 xs&apos; 。 pred 必须为二元函数，两个参数分别来自于对应两个列表中的元素。 ``` R.innerJoin( (record, id) =&gt; record.id === id, [{id: 824, name: &apos;Richie Furay&apos;}, {id: 956, name: &apos;Dewey Martin&apos;}, {id: 313, name: &apos;Bruce Palmer&apos;}, {id: 456, name: &apos;Stephen Stills&apos;}, {id: 177, name: &apos;Neil Young&apos;}], [177, 456, 999] ); // [{id: 456, name: &apos;Stephen Stills&apos;}, {id: 177, name: &apos;Neil Young&apos;}] ``` intersection定义：取出两个 list 中相同的元素组成的 set （集合：没有重复元素）。 ``` R.intersection([1, 2, 3, 4], [7, 6, 5, 4, 3]); // [4, 3] ``` intersectionWith定义：取出两个 list 中相同的元素组成的 set （集合：没有重复元素）。由给定的 predicate 进行相同性判断。 ``` var buffaloSpringfield = [ {id: 824, name: &apos;Richie Furay&apos;}, {id: 956, name: &apos;Dewey Martin&apos;}, {id: 313, name: &apos;Bruce Palmer&apos;}, {id: 456, name: &apos;Stephen Stills&apos;}, {id: 177, name: &apos;Neil Young&apos;} ]; var csny = [ {id: 204, name: &apos;David Crosby&apos;}, {id: 456, name: &apos;Stephen Stills&apos;}, {id: 539, name: &apos;Graham Nash&apos;}, {id: 177, name: &apos;Neil Young&apos;} ]; var list = R.intersectionWith(R.eqBy(R.prop(&apos;id&apos;)), buffaloSpringfield, csny); //=&gt; [{id: 456, name: &apos;Stephen Stills&apos;}, {id: 177, name: &apos;Neil Young&apos;}] ``` lt定义：如果首个参数小于第二个参数，返回 true；否则返回 false。 ``` R.lt(2, 1); // false R.lt(&apos;a&apos;, &apos;b&apos;); // true ``` lte定义：如果首个参数小于或等于第二个参数，返回 true；否则返回 false。 ``` R.lt(2, 2); // false R.lt(&apos;a&apos;, &apos;b&apos;); // true ``` max定义：返回两个参数中的较大值。 ``` R.max(789, 123); // 789 ``` maxBy定义：接收一个函数和两个值，返回使给定函数执行结果较大的值。 ``` var square = n =&gt; n * n; R.maxBy(square, -3, 2); // -3 R.reduce(R.maxBy(square), 0, [3, -5, 4, 1, -2]); // -5 ``` min定义：返回两个参数中的较小值。 ``` R.min(789, 123); // 123 R.min(&apos;a&apos;, &apos;c&apos;); // a ``` minBy定义：接收一个函数和两个值，返回使给定函数执行结果较小的值。 ``` var square = n =&gt; n * n; R.minBy(square, -3, 2); // 2 ``` pathEq定义：判断对象的嵌套路径上是否为给定的值，通过 R.equals 函数进行相等性判断。常用于列表过滤。 ``` var user1 = { address: { zipCode: 90210 } }; var user2 = { address: { zipCode: 55555 } }; var user3 = { name: &apos;Bob&apos; }; var users = [ user1, user2, user3 ]; var isFamous = R.pathEq([&apos;address&apos;, &apos;zipCode&apos;], 90210); var list = R.filter(isFamous, users); // [{&quot;address&quot;:{&quot;zipCode&quot;:90210}}] ``` propEq定义：如果指定对象属性与给定的值相等，则返回 true ；否则返回 false 。通过 R.equals 函数进行相等性判断。 ``` var abby = {name: &apos;Abby&apos;, age: 7, hair: &apos;blond&apos;}; var fred = {name: &apos;Fred&apos;, age: 12, hair: &apos;brown&apos;}; var rusty = {name: &apos;Rusty&apos;, age: 10, hair: &apos;brown&apos;}; var alois = {name: &apos;Alois&apos;, age: 15, disposition: &apos;surly&apos;}; var kids = [abby, fred, rusty, alois]; var hasBrownHair = R.propEq(&apos;hair&apos;, &apos;brown&apos;); R.filter(hasBrownHair, kids); // [fred, rusty] ``` sortBy定义：根据给定的函数对列表进行排序。 ``` var sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop(&apos;name&apos;))); var alice = { name: &apos;ALICE&apos;, age: 101 }; var bob = { name: &apos;Bob&apos;, age: -10 }; var clara = { name: &apos;clara&apos;, age: 314.159 }; var people = [clara, bob, alice]; sortByNameCaseInsensitive(people); //=&gt; [alice, bob, clara] ``` sortWith定义：依据比较函数列表对输入列表进行排序。 ``` var alice = { name: &apos;alice&apos;, age: 40 }; var bob = { name: &apos;bob&apos;, age: 30 }; var clara = { name: &apos;clara&apos;, age: 40 }; var people = [clara, bob, alice]; var ageNameSort = R.sortWith([ R.descend(R.prop(&apos;age&apos;)), R.ascend(R.prop(&apos;name&apos;)) ]); ageNameSort(people); //=&gt; [alice, clara, bob] ``` symmetricDifference定义：求对称差集。所有不属于两列表交集元素的集合，其元素在且仅在给定列表中的一个里面出现。 ``` R.symmetricDifference([1,2,3,4], [7,6,5,4,3]); //=&gt; [1,2,7,6,5] ``` symmetricDifferenceWith定义：求对称差集。所有不属于两列表交集元素的集合。交集的元素由条件函数的返回值决定。 ``` var eqA = R.eqBy(R.prop(&apos;a&apos;)); var l1 = [{a: 1}, {a: 2}, {a: 3}, {a: 4}]; var l2 = [{a: 3}, {a: 4}, {a: 5}, {a: 6}]; R.symmetricDifferenceWith(eqA, l1, l2); //=&gt; [{a: 1}, {a: 2}, {a: 5}, {a: 6}] ``` union定义：集合并运算，合并两个列表为新列表（新列表中无重复元素）。 ``` R.union([1, 2, 3], [2, 3, 4]); //=&gt; [1, 2, 3, 4] ``` unionWith定义：集合并运算，合并两个列表为新列表（新列表中无重复元素）。由 predicate 的返回值决定两元素是否重复。 ``` var l1 = [{a: 1}, {a: 2}]; var l2 = [{a: 1}, {a: 4}]; R.unionWith(R.eqBy(R.prop(&apos;a&apos;)), l1, l2); //=&gt; [{a: 1}, {a: 2}, {a: 4}] ``` Typeis定义：检测一个对象（val）是否是给定构造函数的实例。该函数会依次检测其原型链，如果存在的话。 ``` R.is(Object, {}); // true ``` isNil定义：检测输入值是否为 null 或 undefined 。 ``` R.isNil(null); // true ``` propIs定义：判断指定对象的属性是否为给定的数据类型，是则返回 true ；否则返回 false 。 ``` R.propIs(Number, &apos;x&apos;, {x: 1, y: 2}); // true ``` type定义：用一个单词来描述输入值的（原生）类型，返回诸如 &apos;Object&apos;、&apos;Number&apos;、&apos;Array&apos;、&apos;Null&apos; 之类的结果。不区分用户自定义的类型，统一返回 &apos;Object&apos;。 ``` R.type([]); // Array ```]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>函数式编程</tag>
        <tag>ramda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ramda运用概述]]></title>
    <url>%2F2017%2Framda%E8%BF%90%E7%94%A8-4.html</url>
    <content type="text"><![CDATA[继续函数式编程的学习。 它提供了一系列以函数式、声明式和数据不变性方式工作的函数。在这个系列中，我们了解了蕴含在 Ramda API 背后的一些指导原则： 数据最后：几乎所有的函数都将数据参数作为最后一个参数。 柯里化：Ramda 几乎所有的函数都是自动柯里化的。也即，可以使用函数必需参数的子集来调用函数，这会返回一个接受剩余参数的新函数。当所有参数都传入后，原始函数才被调用。 章节总结入门：介绍了函数、纯函数和数据不变性思想。作为入门，展示了一些集合迭代函数，如：map、filter 和 reduce 等。函数组合：演示了可以使用工具（如 both、either、pipe 和 compose）以多种方式组合函数。部分应用(Partial Application)：演示了一种非常有用的函数延时调用方式：可以先向函数传入部分参数，以后根据需要将其余参数传入。借助 partial 和 curry 可以实现部分应用。我们还学习了 flip 和占位符（__）。声明式编程：介绍了命令式和函数式编程之间的区别。学习了如何使用 Ramda 的声明式函数代替算术、比较、逻辑和条件运算符。无参数风格编程(Pointfree Style)：介绍了 pointfree 风格的思想，也被称为 “tatic” 式编程。在 pointfree 式编程时，实际上不会看到正在操作的数据参数，数据被隐含在函数中了。程序是由许多较小的、简单的构建模块组合而成。只有在最后才将组合后的函数应用于实际的数据上。数据不变性和对象：该节让我们回到了声明式编程的思想，展示了读取、更新、删除和转换对象属性所需的工具。数据不变性和数组：继续上一节的主题，展示了数据不变性在数组中的应用。透镜(Lenses)：引入了透镜的概念，该结构允许我们把重点聚焦在较大的数据结构的一小部分上。借助 view、set 和 over 函数，可以对较大数据结构的小部分被关注数据进行读取、更新和变换操作。 参考文献： JavaScript函数编程-Ramdajs Thinking in Ramda系列文章]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>函数式编程</tag>
        <tag>ramda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ramda数组的操作和透镜]]></title>
    <url>%2F2017%2Framda%E8%BF%90%E7%94%A8-3.html</url>
    <content type="text"><![CDATA[继续函数式编程的学习。 数据不变性和数组读取数组元素nth -- 类型于对象prop slice -- 类似于对象pick contains -- 类似于对象的has 12345const numbers = [10, 20, 30, 40, 50, 60]R.nth(3, numbers) // =&gt; 40 (0-based indexing)R.nth(-2, numbers) // =&gt; 50 (negative numbers start from the right)R.slice(2, 5, numbers) // =&gt; [30, 40, 50] (see below)R.contains(20, numbers) // =&gt; true nth(0) === head nth(length-1) === last tail -- 访问除首个元素之外的所有元素的函数 init -- 除最后一个元素之外的所有元素的方法 take(N) -- 前 N 个元素 takeLast(N) -- 后 N 个元素 1234567const numbers = [10, 20, 30, 40, 50, 60]R.head(numbers) // =&gt; 10R.tail(numbers) // =&gt; [20, 30, 40, 50, 60]R.last(numbers) // =&gt; 60R.init(numbers) // =&gt; [10, 20, 30, 40, 50]R.take(3, numbers) // =&gt; [10, 20, 30]R.takeLast(3, numbers) // =&gt; [40, 50, 60] 增、删、改数组元素1234567891011121314151617181920insert：将元素插入到 list 指定索引处。R.insert(2, &apos;x&apos;, [1,2,3,4]); //=&gt; [1,2,&apos;x&apos;,3,4]update：替换数组中指定索引处的值。R.update(1, 11, [0, 1, 2]); //=&gt; [0, 11, 2]append：在列表末尾拼接一个元素。R.append(&apos;tests&apos;, [&apos;write&apos;, &apos;more&apos;]); //=&gt; [&apos;write&apos;, &apos;more&apos;, &apos;tests&apos;]prepend：在列表头部之前拼接一个元素。R.prepend(&apos;fee&apos;, [&apos;fi&apos;, &apos;fo&apos;, &apos;fum&apos;]); //=&gt; [&apos;fee&apos;, &apos;fi&apos;, &apos;fo&apos;, &apos;fum&apos;]concat：连接列表或字符串。R.concat([4, 5, 6], [1, 2, 3]); //=&gt; [4, 5, 6, 1, 2, 3]// 反转数组拼接const concatAfter = R.flip(R.concat)remove：删除列表中从 start 开始的 count 个元素。R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=&gt; [1,2,6,7,8]without：求第二个列表中，未包含在第一个列表中的任一元素的集合。R.without([1, 2], [1, 2, 1, 3, 4]); //=&gt; [3, 4]drop：删除给定 list，string 或者 transducer/transformer（或者具有 drop 方法的对象）的前 n 个元素。R.drop(1, [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]); //=&gt; [&apos;bar&apos;, &apos;baz&apos;]dropLast：删除 &quot;list&quot; 末尾的 n 个元素。R.dropLast(1, [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]); //=&gt; [&apos;foo&apos;, &apos;bar&apos;] 变换元素12adjust：将数组中指定索引处的值替换为经函数变换的值。R.adjust(R.add(10), 1, [1, 2, 3]); //=&gt; [1, 12, 3] 透镜（Lenses）什么是透镜？透镜将 &quot;getter&quot; 和 &quot;setter&quot; 函数组合为一个单一模块。Ramda 提供了一系列配合透镜一起工作的函数。 可以将透镜视为对某些较大数据结构的特定部分的聚焦、关注。 如何创建透镜lens：返回封装了给定 getter 和 setter 方法的 lens 。 getter 和 setter 分别用于 “获取” 和 “设置” 焦点（lens 聚焦的值）。 1234567var xLens = R.lens(R.prop(&apos;x&apos;), R.assoc(&apos;x&apos;));R.view(xLens, &#123;x: 1, y: 2&#125;); //=&gt; 1R.set(xLens, 4, &#123;x: 1, y: 2&#125;); //=&gt; &#123;x: 4, y: 2&#125;// 还有三个便捷函数LensProp：创建关注对象某一属性的透镜。lensPath: 创建关注对象某一嵌套属性的透镜。lensIndex: 创建关注数组某一索引的透镜。 我能用它做什么呢？Ramda 提供了三个配合透镜一起使用的的函数： view：读取透镜的值。 set：更新透镜的值。 over：将变换函数作用于透镜。 123456var xLens = R.lens(R.prop(&apos;x&apos;), R.assoc(&apos;x&apos;));R.view(xLens, &#123;x: 1, y: 2&#125;); //=&gt; 1R.set(xLens, 4, &#123;x: 1, y: 2&#125;); //=&gt; &#123;x: 4, y: 2&#125;R.over(xLens, R.negate, &#123;x: 1, y: 2&#125;); //=&gt; &#123;x: -1, y: 2&#125;// 区别:// set 和 over 会按指定的方式对被透镜关注的属性进行修改，并返回整个新的对象。 总结本节学习了：某些较大数据结构的处理 -- 透镜。 数组：读取(nth、slice、contains、head、last、tail、init、take、takeLast) 增、删、改(insert、update、append、prepend、concat、remove、without、drop、dropLast) 变换(adjust) 参考文献： JavaScript函数编程-Ramdajs Thinking in Ramda系列文章]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>函数式编程</tag>
        <tag>ramda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ramda无参数风格和对象的相关操作]]></title>
    <url>%2F2017%2Framda%E8%BF%90%E7%94%A8-2.html</url>
    <content type="text"><![CDATA[继续函数式编程的学习。 Pointfree 风格（无参数风格）1234567var forever21 = age =&gt; R.ifElse(R.gte(R.__, 21), R.always(21), R.inc)(age);// console.log(forever21(23)); // 21// pointfree风格的var forever21 = R.ifElse(R.gte(R.__, 21), R.always(21), R.inc);// console.log(forever21(21));// 我们刚刚让 age 消失了。这就是 Pointfree 风格。注意，这两个版本所做的事情完全一样。我们仍然返回一个接受年龄的函数，但并未显示的指定 age 参数。 多元函数（多参数函数）123456789101112131415var titlesForYear = R.curry((year, books) =&gt; &#123; R.pipe( R.filter(publishedInYear(year)), R.map(book =&gt; book.title) )(books);&#125;);// console.log(titlesForYear(2012)(books));var titlesForYear = year =&gt; &#123; R.pipe( R.filter(publishedInYear(year)), R.map(book =&gt; book.title) )&#125;;console.log(titlesForYear(2012)); 重构为 pointfree 风格的代码12345678910// 改写18岁投票系统const wasBornInCountry = person =&gt; person.birthCountry === OUR_COUNTRYconst wasNaturalized = person =&gt; Boolean(person.naturalizationDate)const isOver18 = person =&gt; person.age &gt;= 18const isCitizen = person =&gt; wasBornInCountry(person) || wasNaturalized(person)const isEligibleToVote = person =&gt; isOver18(person) &amp;&amp; isCitizen(person)const isEligibleToVote = person =&gt; both(isOver18, isCitizen)(person)const isCitizen = either(wasBornInCountry, wasNaturalized)const isEligibleToVote = both(isOver18, isCitizen) 读取对象属性12345678910const wasBornInCountry = person =&gt; person.birthCountry === OUR_COUNTRYconst wasNaturalized = person =&gt; Boolean(person.naturalizationDate)const isOver18 = person =&gt; person.age &gt;= 18const isCitizen = either(wasBornInCountry, wasNaturalized)const isEligibleToVote = both(isOver18, isCitizen)// 改写为const wasBornInCountry = person =&gt; equals(person.birthCountry, OUR_COUNTRY)const wasNaturalized = person =&gt; Boolean(person.naturalizationDate)const isOver18 = person =&gt; gte(person.age, 18) prop定义：取出对象中指定属性的值。如果不存在，则返回 undefined。 R.prop(&apos;x&apos;, {x: 100}); //=&gt; 100 1234var wasBornInCountry = R.compose(R.equals(&apos;CHINA&apos;), R.prop(&apos;birthCountry&apos;))var wasNaturalized = R.compose(Boolean, R.prop(&apos;naturalizationDate&apos;))var isOver18 = R.compose(R.gte(R.__, 18), R.prop(&apos;age&apos;))console.log(R.both(wasBornInCountry, isOver18)(person1)); // true pick定义：返回对象的部分拷贝，其中仅包含指定键对应的属性。如果某个键不存在，则忽略该属性。 R.pick([&apos;a&apos;, &apos;d&apos;], {a: 1, b: 2, c: 3, d: 4}); //=&gt; {a: 1, d: 4} has/hasInhas定义：如果对象自身含有指定的属性，则返回 true；否则返回 false。 R.has(&apos;name&apos;)({name: &apos;alice&apos;}); hasIn定义：如果对象自身或其原型链上含有指定的属性，则返回 true；否则返回 false。 path定义：取出给定路径上的值。 R.path([&apos;a&apos;, &apos;b&apos;], {a: {b: 2}}); //=&gt; 2 propOr / pathOrpropOr定义：propOr 和 pathOr 像是 prop/path 与 defaultTo 的组合。如果在目标对象中找不到属性或路径的值，它们允许你提供默认值 propOr(&apos;&lt;Unnamed&gt;&apos;, &apos;name&apos;, person); keys / valueskeys 返回一个包含对象中所有属性名称的数组，values 返回这些属性的值组成的数组。 对属性增、删、改、查··· assoc/assocPath assoc：浅复制对象，然后设置或覆盖对象的指定属性。 R.assoc(&apos;c&apos;, 3, {a: 1, b: 2}); //=&gt; {a: 1, b: 2, c: 3} assocPath：浅复制对象，设置或覆盖即将创建的给定路径所需的节点，并将特定值放在该路径的末端。 R.assocPath([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 42, {a: {b: {c: 0}}}); //=&gt; {a: {b: {c: 42}}} dissoc/dissocPath/omit dissoc：删除对象中指定 prop 属性。 R.dissoc(&apos;b&apos;, {a: 1, b: 2, c: 3}); //=&gt; {a: 1, c: 3} dissocPath：浅复制对象，删除返回对象中指定路径上的属性。 R.dissocPath([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], {a: {b: {c: 42}}}); //=&gt; {a: {b: {}}} omit：删除对象中给定的 keys 对应的属性。 R.omit([&apos;a&apos;, &apos;d&apos;], {a: 1, b: 2, c: 3, d: 4}); //=&gt; {b: 2, c: 3} 123 #### 属性转换 evolve：递归地对 object 的属性进行变换，变换方式由 transformation 函数定义。 var tomato = {firstName: &apos; Tomato &apos;, data: {elapsed: 100, remaining: 1400}, id:123}; var transformations = { firstName: R.trim, lastName: R.trim, // Will not get invoked. data: {elapsed: R.add(1), remaining: R.add(-1)} }; R.evolve(transformations, tomato); //=&gt; {firstName: &apos;Tomato&apos;, data: {elapsed: 101, remaining: 1399}, id:123} 123#### 合并对象 merge：合并两个对象的自身属性（不包括 prototype 属性）。如果某个 key 在两个对象中都存在，使用后一个对象对应的属性值。 R.merge({ &apos;name&apos;: &apos;fred&apos;, &apos;age&apos;: 10 }, { &apos;age&apos;: 40 }); //=&gt; { &apos;name&apos;: &apos;fred&apos;, &apos;age&apos;: 40 } // 定义一个反转合并的函数(用前面的同名属性覆盖后面的同名属性) reverseMerge：const reverseMerge = R.flip(merge) ``` 总结本节学习了：pointfree(无参数风格编程) 对象属性：读取(prop、pick、has、path、propOr、pathOr、keys、values、) 增删改查(assoc、assocPath、dissoc、dissocPath、omit) 属性转换(evolve) 合并对象(merge) 参考文献： JavaScript函数编程-Ramdajs Thinking in Ramda系列文章]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>函数式编程</tag>
        <tag>ramda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ramda无参数风格编程 (Pointfree Style)和声明式编程]]></title>
    <url>%2F2017%2Framda%E8%BF%90%E7%94%A8-1.html</url>
    <content type="text"><![CDATA[继续函数式编程的学习。 部分应用（Partial Application）在上篇文章中，简单的函数链式调用（&quot;pipeline&quot;）时，其中的被调用函数都是一元的（除了首个函数）。但如果要使用多元函数呢？ 例如，假设有一个书籍对象的集合，我们想要找到特定年份出版的所有图书的标题。 1234567891011var books = [ &#123;year: 1991, title: &apos;11111&apos;&#125;, &#123;year: 1991, title: &apos;22222&apos;&#125;, &#123;year: 1992, title: &apos;33333&apos;&#125;];const publishedInYear = (book, year) =&gt; book.year === year;const titlesForYear = (books, year) =&gt; &#123; const selected = R.filter(book =&gt; publishedInYear(book, year), books); return R.map(book =&gt; book.title, selected);&#125;;var book1 = titlesForYear(books, 1991); // [&apos;11111&apos;, &apos;22222&apos;] 高阶函数获取或返回其他函数的函数称为 &quot;高阶函数&quot;。 12345678910111213// 高阶函数var publishedInYear = function (year) &#123; return function (book) &#123; return book.year === year; &#125;;&#125;;// 箭头函数// var publishedInYear = year =&gt; book =&gt; book.year === year;var titlesForYear = (books, year) =&gt; &#123; const selected = R.filter(publishedInYear(year), books); return R.map(book =&gt; book.title, selected);&#125;; console.log(titlesForYear(books, 1992)); // &apos;33333&apos; 部分应用函数partial/partialRight（部分应用） 定义：这两个函数可以让我们不必一次传递所有需要的参数，也可以调用函数。它们都返回一个接受剩余参数的新函数，当所有参数都传入后，才会真正调用被包裹的原函数。 1234567// 例子，只是想检查一本书是否是在指定年份出版的。var publishedInYear = (book, year) =&gt; book.year === year;var titleForYear = (books, year) =&gt; &#123; const selected = R.filter(R.partialRight(publishedInYear, [year]), books); return R.map(book =&gt; book.title, selected);&#125;;// console.log(titleForYear(books, 1992)); // [&apos;33333&apos;] 柯里化(Curry)定义：一个柯里化了的函数是一系列高阶一元函数，将多参数函数转化为单参数函数。 一般来说，我只有需要在多个地方对同一个函数使用 partial 的时候，才会对函数进行柯里化。 1234567var publishedInYear = R.curry((year, book) =&gt; book.year === year);var titlesForYear = (books, year) =&gt; &#123; const selected = R.filter(publishedInYear(year), books); return R.map(book =&gt; book.title, selected);&#125;;console.log(titlesForYear(books, 1992)); // [&apos;33333&apos;]var book2 = publishedInYear(1992, &#123;year: 1992, title: &apos;33333&apos;&#125;); // true 顺序错误的参数filp：交换函数前两个参数的位置。 12var mergeThree = (a, b, c) =&gt; [].concat(a, b, c);console.log(R.flip(mergeThree)(1, 2, 3)); // [2, 1, 3] __或placeholder (占位符) 定义：柯里化函数的参数占位符。允许部分应用于任何位置的参数。 更通用的选择是使用 &quot;placeholder&quot; 参数（__） 假设有一个三元柯里化的函数，并且我们想传入第一个和最后一个参数，中间参数后续再传，应该怎么办呢？我们可以使用 &quot;占位符&quot; 作为中间参数： 1234567891011const threeArgs = curry((a, b, c) =&gt; &#123; /* ... */ &#125;);const middleArgumentLater = threeArgs(&apos;value for a&apos;, R.__, &apos;value for c&apos;);var publishedInYear = R.curry((year, book) =&gt; book.year === year)var titlesForYear = R.curry((year, books) =&gt; R.pipe( R.filter(publishedInYear(year)), R.map(book =&gt; book.title) )(books))// console.log(titlesForYear(1991, books)); // [&quot;11111&quot;, &quot;22222&quot;] 声明式编程命令式 vs 声明式命令式编程中，程序员需要告诉计算机怎么做来完成任务。 声明式编程，程序员只需告诉计算机我想要什么，然后计算机自己理清如何产生结果。 123456789101112var square = x =&gt; R.multiply(x, x);var operate = R.pipe( R.multiply, R.add(1), square );var operate3 = operate(3, 4); // 169// add(1) 与增量运算符（++）非常相似，但 ++ 修改了被操作的值，因此它是 &quot;mutation&quot; 的。// 所以使用R.add(1),R.subtract(1)代替++ 和 --// Ramda提供了R.inc和R.decR.dec(42); //=&gt; 41R.negate(42); //=&gt; -42 取反 比较(Comparison)使用R.gt()、R.gte()、R.lt()、R.lte()、R.equals()代替&gt;、&gt;=、&lt;、&lt;=、=== identical：如果两个参数是完全相同，则返回 true，否则返回 false。如果它们引用相同的内存，也认为是完全相同的。 isEmpty：检测给定值是否为其所属类型的空值，若是则返回 true ；否则返回 false 。 isNil：检测输入值是否为 null 或 undefined 。 1234567891011// 改写投票的例子var wasBornInCountry = person =&gt; R.equals(person.birthCountry, &apos;CHINA&apos;);var wasNaturalized = person =&gt; Boolean(person.naturalizationDate);var isOver18 = person =&gt; R.gte(person.age, 18);var isCitizen = R.either(wasBornInCountry, wasBornInCountry);var isEligibleToVote = R.both(isOver18, isCitizen);console.log(isEligibleToVote(&#123; birthCountry: &apos;CHINA&apos;, naturalizationDate: false, age: 22&#125;)); // true 逻辑(Logic)both 和 either 来代替 &amp;&amp; 和 || 运算符。使用 complement 代替 !。 我以下列方式进行分类：and、or 和 not 用于处理数值；both、either 和 complement 用于处理函数。 1234var setting = &#123;&#125;;var lineWith = setting.lineWith || 80;var lineWith = R.defaultTo(80, setting.lineWith);console.log(lineWith); //使用后者代替前者 条件(Conditionals)R.ifElse 代替 if-else 1234var forever21 = age =&gt; age &gt;= 21 ? 21 : age + 1// console.log(forever21(19)); // 20var forever21 = age =&gt; R.ifElse(R.gte(R.__, 21), () =&gt; 21, R.inc)(age)// console.log(forever21(19)); // 20 constants (常量)1234R.always(42) 代替 42R.T() === true 忽略所有参数console.log(R.T(false)); // trueR.F() === false 忽略所有参数 identity (恒等)输出恒等于输入。如，a =&gt; a 123identity：将输入值原样返回。适合用作默认或占位函数。nthArg；返回一个函数，该函数返回它的第 n 个参数。const alwaysDrivingAge = age =&gt; ifElse(lt(__, 16), always(16), a =&gt; a)(age) when 和 unless12var alwaysDrivingAge = age =&gt; R.unless(R.gte(R.__, 16), R.always(16))(age)console.log(alwaysDrivingAge(15)); // 16 cond作用：来代替 switch 语句或链式的 if...then...else 语句 123456const water = temperature =&gt; R.cond([ [R.equals(0), R.always(&apos;water freezes at 0°C&apos;)], [R.equals(100), R.always(&apos;water boils at 100°C&apos;)], [R.T, temp =&gt; `nothing special happens at $&#123;temp&#125;°C`]])(temperature)console.log(water(23)); // nothing special happens at 23°C 总结本节学习了：高阶函数、部分应用函数、柯里化（Curry）、改变参数顺序的方法（flip、plachhokder__、pipeline） 常用的声明式编程替换命令式编程：add、subtract、multiply、divide等等 参考文献： JavaScript函数编程-Ramdajs Thinking in Ramda系列文章 参考文献： JavaScript函数编程-Ramdajs Thinking in Ramda系列文章]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>函数式编程</tag>
        <tag>ramda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ramda入门和函数组合]]></title>
    <url>%2F2017%2Framda%E8%BF%90%E7%94%A8.html</url>
    <content type="text"><![CDATA[继续函数式编程的学习。 总结Ramda与Lodash和Underscore的优势自动柯里化1234567891011121314// 一map函数为例，解释Ramda的自动柯里化 // map函数解释：param1为对集合每一项进行处理并返回同类型的数据，param2需要处理的集合（Array或Object）// 第一种，为使用柯里化var map3 = R.map(function (item) &#123; return item * item;&#125;, [1, 2, 3, 4]); // console.log(map3); // [1, 4, 9, 16]// 第一种curry化（转化成单参数函数）var map1 = R.map(function (item) &#123; return item * item;&#125;);var map2 = map1([1, 2, 3, 4]);// console.log(map2); // [1, 4, 9, 16] 函数参数优先于数据12345// 函数优先于数据var map4 = R.map(R.multiply(2), [1, 2, 3, 4]);// console.log(map4); // [2, 4, 6, 8]var map5 = R.map(R.multiply(2))([1, 2, 3, 4]);// console.log(map5); // [2, 4, 6, 8] Ramdajs的组合123456789101112131415161718192021222324252627// ramdajs的compose组合var users = [ &#123; &apos;user&apos;: &apos;user1&apos;, &apos;age&apos;: 36 &#125;, &#123; &apos;user&apos;: &apos;user2&apos;, &apos;age&apos;: 40 &#125;, &#123; &apos;user&apos;: &apos;user3&apos;, &apos;age&apos;: 18 &#125;];// R.pluck(k)[array] === R.map(R.prop(k), array)var pluck1 = R.pluck(&apos;user&apos;)(users);var pluck2 = R.map(R.prop(&apos;user&apos;))(users);// compose为函数组合（从右到左）var pluck3 = R.compose(R.join(&apos;,&apos;), R.pluck(&apos;user&apos;))(users);// console.log(pluck3); // user1,user2,user3// pipe为函数组合（从左到右）var pipe1 = R.pipe(R.pluck(&apos;user&apos;), R.join(&apos;*&apos;))(users);// console.log(pipe1); // user1*user2*user3// 依次获得用户的出生年var compose1 = R.compose(R.join(&apos;,&apos;), R.map(R.subtract(new Date().getFullYear())), R.pluck(&apos;age&apos;))(users);console.log(compose1); // 1981,1977,1999// 获得最年轻的用户信息var userMin = R.compose(R.head, R.sortBy(R.prop(&apos;age&apos;)))(users);var userMax = R.compose(R.last, R.sortBy(R.prop(&apos;age&apos;)))(users);var userMax1 = R.compose(R.head, R.reverse, R.sortBy(R.prop(&apos;age&apos;)))(users);console.log(userMin, userMax); // &#123;user: &quot;user3&quot;, age: 18&#125; &#123;user: &quot;user2&quot;, age: 40&#125;console.log(userMax1); // &#123;user: &quot;user2&quot;, age: 40&#125; **纯函数**纯函数是没有副作用的函数。它不会给任何外部变量赋值，不会获取输入，不会产生 &quot;输出&quot;，不会对数据库进行读写，不会修改输入参数等。 纯函数的基本思想是：相同的输入，永远会得到相同的输出。 **数据不变性**函数式编程的另一个重要概念是 &quot;Immutability&quot;，&quot;Immutability&quot; 是指 &quot;数据不变性&quot;。 当以 immutable 方式工作时，一旦定义了某个值或对象，以后就再也不会改变它了。这意味着不能更改已有数组中的元素或对象中的属性。 开始以函数式思维思考最简单的方式是，使用集合迭代函数代替循环。 1234567891011121314151617181920foreachfor (const value of Array) &#123; console.log(value);&#125;forEach(value =&gt; console.log(value), Array);mapmap(x =&gt; x*2, [1, 2, 3]); // [2, 4, 6]filter/reject(互补)const isEven = x =&gt; x % 2 === 0;filter(isEven, [1, 2, 3]); // [2]reject(isEven, [1, 2, 3]); // [1, 3]findfind(isEven, [1, 2, 3, 4]); // 2reduceconst add = (accum, value) =&gt; accum + value; reduce(add, 5, [1, 2, 3, 4]); // 15 函数组合ComplementComplement：对函数的返回值取反。接受一个函数 f，返回一个新函数 g。 123const isEven = x =&gt; x % 2 === 0;var complement1 = R.find(isEven, [1, 1, 2, 4]); // 2var complement2 = R.find(R.complement(isEven), [1, 2, 2, 4]); // 1 Both/Eitherboth：该函数调用两个函数，并对两函数返回值进行与（&amp;&amp;）操作。 either：该函数调用两个函数，并对两函数返回值进行或（||）操作。 投票系统（投票资格的条件：在本国出生，或者后来加入该国国籍，且年满18岁。） 123456789101112// 判断是否有投票的权利let person1 = &#123; birthCountry: &apos;CHINA&apos;, naturalizationDate: false, age: 20&#125;;const wasBornInCountry = person =&gt; person.birthCountry === &apos;CHINA&apos;;const wasNaturalized = person =&gt; Boolean(person.naturalizationDate);const isOver18 = person =&gt; person.age &gt;= 18;var isCitizen = R.either(wasBornInCountry, wasNaturalized); // 在本国出生，或者后来加入该国国籍。var isEligibleToVote = R.both(isCitizen, isOver18);var vote1 = isEligibleToVote(person1); // true Pipelines(管道)pipe：从左往右执行函数组合。最左边的函数可以是任意元函数（参数个数不限），其余函数必须是一元函数。 1234var multiply = (num1, num2) =&gt; num1 * num2;var addOne = num =&gt; num + 1;var square = num =&gt; num * num;var operate1 = R.pipe(multiply, addOne, square)(1, 2); // ((1*2)+1)^2 = 9 compose：从右往左执行函数组合（右侧函数的输出作为左侧函数的输入）。最右侧函数可以是任意元函数（参数个数不限），其余函数必须是一元函数。 1var operate2 =R.compose(square, addOne, multiply)(1, 2); // 9 总结本节学习了：函数、纯函数、IMMUTABILITY、foreach（递归替代循环）、map、filter、reject、find、reduce、 函数组合的方法：complement、either、both、pipe、compose、 参考文献： JavaScript函数编程-Ramdajs Thinking in Ramda系列文章]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>函数式编程</tag>
        <tag>ramda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ramda库的使用]]></title>
    <url>%2F2017%2Framda%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[学习源代码地址 了解Pointfree的概念概念：fn = R.pipe(f1, f2, f3); 可以把数据处理的过程，定义成一种与参数无关的合成运算。 **不使用所要处理的值，只合成运算过程。** 一些小例子1234567891011121314151617181920212223242526// pointfree例子var addOne = x =&gt; x + 1;var square = x =&gt; x * x;var addOneThenSquare = R.pipe(square, addOne);var pointfree1 = addOneThenSquare(3);console.log(pointfree1); // 10// addOneThenSquare是一个合成函数。定义它的时候，根本不需要提到要处理的值，这就是 Pointfree。var prop = (p, obj) =&gt; obj[p]; // 封装了读取操作，它需要两个参数p（属性名）和obj（对象）。var propRole = R.curry(prop)(&apos;role&apos;); // 将函数柯里化var demo1 = propRole(&#123;role: &apos;fan&apos;&#125;);console.log(demo1); // fanvar data = [ &#123;name: &apos;张三&apos;, role: &apos;worker&apos;&#125;, &#123;name: &apos;李四&apos;, role: &apos;worker&apos;&#125;, &#123;name: &apos;王五&apos;, role: &apos;manager&apos;&#125;,];var isWorker = r =&gt; r === &apos;worker&apos;;var getWorkers = R.filter(R.pipe(R.prop(&apos;role&apos;), isWorker));var demo2 = getWorkers(data);// console.log(demo2); // [// &#123;&quot;name&quot;: &quot;张三&quot;, &quot;role&quot;: &quot;worker&quot;&#125;,// &#123;&quot;name&quot;: &quot;李四&quot;, &quot;role&quot;: &quot;worker&quot;&#125;// ] Pointfree示例一**求下面字符串，请问其中最长的单词有多少个字符？** 12345678910111213141516171819202122232425262728var str = &apos;Lorem ipsum dolor sit amet consectetur adipiscing elit&apos;;// 以空格分割单词var splitBySpace = s =&gt; s.split(&apos; &apos;);// 获得每个单词的长度var getLength = w =&gt; w.length;// 单词数组转化为单词长度的数组var getLengArr = arr =&gt; R.map(getLength, arr);// 返回较大的数字var getBiggerNumber = (a, b) =&gt; a &gt; b ? a : b;// 返回最大的一个数字var findBiggestNumber = arr =&gt; R.reduce(getBiggerNumber, 0, arr);var getLongestWordLength = R.pipe( splitBySpace, getLengArr, findBiggestNumber );var demo3 = getLongestWordLength(str);console.log(demo3); // 11// 使用ramda库var getLongestWordLength = R.pipe( R.split(&apos; &apos;), R.map(R.length), R.reduce(R.max, 0) );var demo3 = getLongestWordLength(str);// console.log(demo3); // 11 Pointfree 示例二12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// 下面是一段服务器返回的 JSON 数据。var data = &#123; result: &quot;SUCCESS&quot;, interfaceVersion: &quot;1.0.3&quot;, requested: &quot;10/17/2013 15:31:20&quot;, lastUpdated: &quot;10/16/2013 10:52:39&quot;, tasks: [ &#123;id: 104, complete: false, priority: &quot;high&quot;, dueDate: &quot;2013-11-29&quot;, username: &quot;Scott&quot;, title: &quot;Do something&quot;, created: &quot;9/22/2013&quot;&#125;, &#123;id: 105, complete: false, priority: &quot;medium&quot;, dueDate: &quot;2013-11-22&quot;, username: &quot;Lena&quot;, title: &quot;Do something else&quot;, created: &quot;9/22/2013&quot;&#125;, &#123;id: 107, complete: true, priority: &quot;high&quot;, dueDate: &quot;2013-11-22&quot;, username: &quot;Mike&quot;, title: &quot;Fix the foo&quot;, created: &quot;9/22/2013&quot;&#125;, &#123;id: 108, complete: false, priority: &quot;low&quot;, dueDate: &quot;2013-11-15&quot;, username: &quot;Punam&quot;, title: &quot;Adjust the bar&quot;, created: &quot;9/25/2013&quot;&#125;, &#123;id: 110, complete: false, priority: &quot;medium&quot;, dueDate: &quot;2013-11-15&quot;, username: &quot;Scott&quot;, title: &quot;Rename everything&quot;, created: &quot;10/2/2013&quot;&#125;, &#123;id: 112, complete: true, priority: &quot;high&quot;, dueDate: &quot;2013-11-27&quot;, username: &quot;Lena&quot;, title: &quot;Alter all quuxes&quot;, created: &quot;10/5/2013&quot;&#125; ]&#125;;var fetchData = function (data) &#123; return Promise.resolve(data);&#125;;// 提取 tasks 属性var SelectTasks = R.prop(&apos;tasks&apos;);// 过滤出指定的用户var filterMember = member =&gt; R.filter( R.propEq(&apos;username&apos;, member) );// 排除已经完成的任务var excludeCompletedTasks = R.reject(R.propEq(&apos;complete&apos;, true));// 选取指定属性var selectFields = R.map( R.pick([&apos;id&apos;, &apos;dueDate&apos;, &apos;title&apos;, &apos;priority&apos;]) );// 按照到期日期排序var sortByDueDate = R.sortBy(R.prop(&apos;dueDate&apos;));// 合成函数var getIncompleteTaskSummaries = function (membername) &#123; return fetchData(data) .then(R.prop(&apos;tasks&apos;)) .then(R.filter(R.propEq(&apos;username&apos;, membername))) .then(R.reject(R.propEq(&apos;complete&apos;, true))) .then(R.map(R.pick([&apos;id&apos;, &apos;dueData&apos;, &apos;title&apos;, &apos;priority&apos;]))) .then(R.sortBy(R.prop(&apos;dueData&apos;)));&#125;;var scottList = getIncompleteTaskSummaries(&apos;Scott&apos;);console.log(scottList); [[object Object] &#123; dueDate: &quot;2013-11-15&quot;, id: 110, priority: &quot;medium&quot;, title: &quot;Rename everything&quot;&#125;, [object Object] &#123; dueDate: &quot;2013-11-29&quot;, id: 104, priority: &quot;high&quot;, title: &quot;Do something&quot;&#125;] 参考文档：阮老师–Pointfree 编程风格指南Ramda 中文]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>函数式编程</tag>
        <tag>ramda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ramda库学习]]></title>
    <url>%2F2017%2FRamda%E5%BA%93%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[学习源代码经过4个晚上的学习，了解了ramda库120多个api的用法，下一步继续深入学习函数式编程。继续学习js函数式编程，这里贴出阮老师总结的Ramda的优点： 1. Ramda 的数据一律放在最后一个参数，理念是&quot;function first，data last&quot;。 2. 所有方法都支持柯里化。 一、比较运算（gt、gte、lt、lte、eauals、eqBy）gt：判断第一个参数是否大于第二个参数。 1234let gt1 = R.gt(2)(1);// console.log(gt1); truelet gt2 = R.gt(&apos;a&apos;)(&apos;c&apos;);// console.log(gt2); false gte：判断第一个参数是否大于等于第二个参数。 1234let gte1 = R.gte(2)(2);// console.log(gte1); truelet gte2 = R.gte(&apos;a&apos;)(&apos;c&apos;);// console.log(gte2); false lt：判断第一个参数是否小于第二个参数。 1234let lt1 = R.lt(2)(1);// console.log(lt1); falselet lt2 = R.lt(&apos;a&apos;)(&apos;z&apos;);// console.log(lt2); true lte：判断第一个参数是否小于等于第二个参数。 1234let lte1 = R.lte(1)(2);// console.log(lte1); truelet lte2 = R.lte(&apos;a&apos;)(&apos;v&apos;);// console.log(lte2); true eauals：比较两个值是否相等（支持对象的比较）。 12345678let equals1 = R.equals(1)(1);// console.log(equals1); truelet equals2 = R.equals(1)(&apos;1&apos;);// console.log(equals2); falselet equals3 = R.equals([1, 2])([1,2]);// console.log(equals3); // truelet equals4 = R.equals(&#123;a:1&#125;)(&#123;a:2&#125;);// console.log(equals4); // false eqBy：比较两个值传入指定函数的运算结果是否相等。 12let eqBy1 = R.eqBy(Math.abs, 5, -5);console.log(eqBy1); 二、数学运算（add、subtract、multiply、divide）add：返回两个值的和。 12let add1 = R.add(1)(10);// console.log(add1); // 11 subtract：返回第一个参数减去第二个参数的差。 12let subtract1 = R.subtract(10)(2);//console.log(subtract1); // 8 multiply：返回两个值的积。 12let multiply1 = R.multiply(5)(6);// console.log(multiply1); // 30 divide：返回第一个参数除以第二个参数的商。 12let divide1 = R.divide(5)(10);// console.log(divide1); // 0.5 三、逻辑运算（either、both、allPass）either：接收两个参数，相当于 || 运算（或）。 1234567let gt10 = x =&gt; x &gt; 10;let even = x =&gt; x % 2 === 0;let either1 = R.either(gt10)(even);let either2 = either1(18);let either3 = either1(3);// console.log(either2); // true//console.log(either3); // false both：接收两个参数，相当于 &amp;&amp; 运算（且）。 1234567var gt10 = x =&gt; x &gt; 10;var even = x =&gt; x % 2 === 0;let both1 = R.both(gt10)(even);let both2 = both1(18);let both3 = both1(4);// console.log(both2); // true// console.log(both3); // false allPass：接受一个函数数组作为参数，只有它们都返回true，才返回true，否则返回false。 12345678var gt10 = x =&gt; x &gt; 10;var lt20 = x =&gt; x &lt; 20;var even = x =&gt; x % 2 === 0;let allPass1 = R.allPass([gt10, even, lt20]);let allPass2 = allPass1(16);let allPass3 = both1(13);console.log(allPass2); // trueconsole.log(allPass3); // false 四、字符串（split、test、match）split：按照指定分隔符将字符串拆成一个数组。 12let split1 = R.split(&apos;.&apos;)(&apos;a.b.c.fanerge&apos;);// console.log(split1); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;fanerge&quot;] test：判断一个字符串是否匹配给定的正则表达式。 12let test1 = R.test(/^f/)(&apos;fanerge&apos;);// console.log(test1); // true match：返回一个字符串的匹配结果。 1234let match1 = R.match(/([a-z]a)/g)(&apos;bananas&apos;)// console.log(match1); // [&quot;ba&quot;, &quot;na&quot;, &quot;na&quot;]let match2 = R.match(/a/)(&apos;n&apos;);// console.log(match2); // [] 五、函数5.1 函数的合成（compose、pipe、converge）compose：将多个函数合并成一个函数，从右到左执行 12let compose1 = R.compose(Math.abs, R.add(1), R.multiply(2))(4)console.log(compose1); // 9 pipe：将多个函数合并成一个函数，从左到右执行。 12let pipe1 = R.pipe(Math.abs, R.add(1), R.multiply(2))(4);console.log(pipe1); // 10 converge：接受两个参数，第一个参数是函数，第二个参数是函数数组。传入的值先使用第二个参数包含的函数分别处理以后，再用第一个参数处理前一步生成的结果。 123456789var sumOfArr = arr =&gt; &#123; let sum = 0; arr.forEach(i =&gt; sum += i); return sum;&#125;;var lengthArr = arr =&gt; arr.length;var converge1 = R.converge(R.divide, [sumOfArr, lengthArr]);var converge2 = converge1([1, 2, 3, 4, 5]);// console.log(converge2); // 3 5.2 柯里化（curry、partial、partialRight、useWith、memoize、complement）curry：将多个参数的函数，转化成单参数的形式。 1234var addFourNumbers = (a, b, c, d) =&gt; a + b + c + d;var curriedAddFourNumbers = R.curry(addFourNumbers);var f = curriedAddFourNumbers(1)(2)(3)(4);// console.log(f); // 10 partial：允许多参数的函数接受一个数组，指定最左边的部分参数。 123var multiply2 = (a, b) =&gt; a * b;var double = R.partial(multiply2, [3]);// console.log(double(2)); // 6 partialRight：与partial类似，但数组指定的参数为最右边的参数。 12345var greet = (salutation, title, firstName, lastName) =&gt; salutation + &apos;, &apos; + title + &apos; &apos; + firstName + &apos; &apos; + lastName + &apos;!&apos;;var greetMsJaneJones = R.partialRight(greet, [&apos;Ms.&apos;, &apos;Jane&apos;, &apos;Jones&apos;]);var dd = greetMsJaneJones(&apos;Hello&apos;); console.log(dd); // &apos;Hello, Ms. Jane Jones!&apos; useWith：接受一个函数fn和一个函数数组fnList作为参数，返回fn的柯里化版本。该新函数的参数，先分别经过对应的fnList成员处理，再传入fn执行。 1234var decreaseOne = x =&gt; x - 1;var increaseOne = x =&gt; x + 1;var useWith1 = R.useWith(Math.pow, [decreaseOne, increaseOne])(3)(4);console.log(useWith1) // 2^5 32 memoize：返回一个函数，会缓存每一次的运行结果。 123456789101112var productOfArr = arr =&gt; &#123; var product = 1; arr.forEach(i =&gt; product *= i); return product;&#125;;var count = 0;var factorial = R.memoize(n =&gt; &#123; count += 1; return productOfArr(R.range(1, n + 1));&#125;);var memoize1 = factorial(5);console.log(memoize1, count); // 120, 1 complement：返回一个新函数，如果原函数返回true，该函数返回false；如果原函数返回false，该函数返回true。 1234var gt10 = x =&gt; x &gt; 10;var lte10 = R.complement(gt10);var complement1 = lte10(11);// console.log(complement1); // false 5.3 函数的执行（binary、tap、zipWith、apply、applySpec、ascend、descend）binary：参数函数执行时，只传入最前面两个参数。 123456var takesThreeArgs = function (a, b, c) &#123; return [a, b, c];&#125;;var takesTwoArgs = R.binary(takesThreeArgs);var binary1 = takesTwoArgs(1, 2, 3);// console.log(binary1); // [1, 2, undefined] tap：将一个值传入指定函数，并返回该值。 123var sayX = x =&gt; console.log(&apos;x is&apos; + x);var tap1 = R.tap(sayX)(100);// console.log(tap1); // x is100 100 zipWith：将两个数组对应位置的值，一起作为参数传入某个函数。 12345var f = (x, y) =&gt; &#123; return x + y;&#125;;var zipWith1 = R.zipWith(f)([1, 2, 3])([4, 5, 6]);// console.log(zipWith1); // [5, 7, 9] apply：将数组转成参数序列，传入指定函数。 123var nums = [1, 2, 3, -99, 42, 6, 7];var apply1 = R.apply(Math.max)(nums);// console.log(apply1); // 42 applySpec：返回一个模板函数，该函数会将参数传入模板内的函数执行，然后将执行结果填充到模板。 123456var getMetrics = R.applySpec(&#123; sum: R.add, nested: &#123;mul: R.multiply&#125;&#125;);var applySpec1 = getMetrics(2, 4);//console.log(applySpec1); // &#123; sum: 6, nested: &#123; mul: 8 &#125; &#125; ascend：返回一个升序排列的比较函数，主要用于排序。 12345678var byAge = R.ascend(R.prop(&apos;age&apos;));var people = [ &#123;name: &apos;fan&apos;, age: 11&#125;, &#123;name: &apos;yu&apos;, age: 8&#125;, &#123;name: &apos;zhen&apos;, age: 9&#125;];var ascend1 = R.sort(byAge)(people);// console.log(ascend1); // [ &#123;name: &apos;yu&apos;, age: 8&#125;, &#123;name: &apos;zhen&apos;, age: 9&#125;, name: &apos;fan&apos;, age: 11&#125;]; ascend：返回一个升序排列的比较函数，主要用于排序。 12345678var byAge = R.descend(R.prop(&apos;age&apos;));var people = [ &#123;name: &apos;fan&apos;, age: 11&#125;, &#123;name: &apos;yu&apos;, age: 8&#125;, &#123;name: &apos;zhen&apos;, age: 9&#125;];var descend1 = R.sort(byAge)(people);// console.log(descend1); // [ &#123;name: &apos;fan&apos;, age: 11&#125;, &#123;name: &apos;zhen&apos;, age: 9&#125;, &#123;name: &apos;yu&apos;, age: 8&#125;]; 六、数组6.1 数组的特性判断（contains、all、any、none）contains：如果包含某个成员，返回true。 12var contains1 = R.contains(3)([1,2]);// console.log(contains1); // false contains：如果包含某个成员，返回true。 1234var contains1 = R.contains(3)([1,2]);var contains2 = R.contains(&#123;name: &apos;fan&apos;&#125;)([&#123;name: &apos;fan&apos;&#125;,2]);// console.log(contains1); // false// console.log(contains2); // true all：所有成员都满足指定函数时，返回true，否则返回false 123var equals3 = R.equals(3);var all1 = R.all(equals3)([3, 3]);// console.log(all1); // true any：只要有一个成员满足条件，就返回true。 123456var lessThan0 = R.flip(R.lt)(0);var lessThan2 = R.flip(R.lt)(2);var any1 = R.any(lessThan0)([1, 2]);// console.log(any1); // falsevar any2 = R.any(lessThan2)([1, 2]);// console.log(any2); // true none：没有成员满足条件时，返回true。 1234var isEven = n =&gt; n % 2 === 0;var none1 = R.none(isEven)([1, 3, 5, 7, 9, 11]) // truevar none2 = R.none(isEven)([1, 3, 5, 7, 8, 11]) // falseconsole.log(none2); // true 6.2 数值的截取和添加（head、last、tail、init、nth、take、slice、remove、insert、insertAll、prepend、append、intersperse、join）head：返回数组的第一个成员。 12var head1 = R.head([1, 2, 3]);// console.log(head1); // 1 last：返回数组的最后一个成员。 12var last1 = R.last(&apos;fan&apos;);console.log(last1); // n tail：返回第一个成员以外的所有成员组成的新数组。 12var tail1 = R.tail([1, 2, 3]);// console.log(tail1); // [2, 3] init：返回最后一个成员以外的所有成员组成的新数组。 12var init1 = R.init([1, 2, 3]);// console.log(init1); // [1, 2] nth：取出指定位置的成员。 123var list = [1, 2, 3, 4];var nth1 = R.nth(0)(list);// console.log(nth1); // 1 take：取出前 n 个成员。 12var take1 = R.take(3)([1, 2, 3, 4]);// console.log(take1); // [1, 2, 3] takeLast：取出后 n 个成员。 12var takeLast1 = R.takeLast(3)([1, 2, 3, 4]);// console.log(takeLast1); // [2, 3, 4] slice：从起始位置（包括）开始，到结束位置（不包括）为止，从原数组截取出一个新数组。 12var slice1 = R.slice(1, 3)([1, 2, 3, 4]);// console.log(slice1); // [2, 3] remove：移除开始位置后的n个成员。 12var remove1 = R.remove(2, 3)([1, 2, 3, 4, 5, 6, 7, 8]);// console.log(remove1); // [1, 2, 6, 7, 8] insert：在指定位置插入给定值。 12var insert1 = R.insert(2, &apos;x&apos;)([1, 2, 3]);// console.log(insert1); // [1, 2, &quot;x&quot;, 3] insertAll：在指定位置，插入另一个数组的所有成员。 12var insertAll1 = R.insertAll(2, [&apos;x&apos;, &apos;y&apos;, &apos;z&apos;])([1, 2, 3, 4]);// console.log(insertAll1); // [1, 2, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, 3, 4] prepend：在数组头部插入一个成员。 12var prepend1 = R.prepend(&apos;fee&apos;)([&apos;ss&apos;, &apos;ee&apos;]);// console.log(prepend1); // [&quot;fee&quot;, &quot;ss&quot;, &quot;ee&quot;] append：在数组尾部追加新的成员。 12var append1 = R.append(&apos;test&apos;)([&apos;ss&apos;]);// console.log(append1); // [&quot;ss&quot;, &quot;test&quot;] intersperse：在数组成员之间插入表示分隔的成员。 12var intersperse1 = R.intersperse(&apos;/&apos;)([&apos;aa&apos;, &apos;bb&apos;, &apos;cc&apos;]);// console.log(intersperse1); // [&quot;aa&quot;, &quot;/&quot;, &quot;bb&quot;, &quot;/&quot;, &quot;cc&quot;] join：将数组合并成一个字符串，并在成员之间插入分隔符。 12var join1 = R.join(&apos;|&apos;)([1, 2, 3]);// console.log(join1); // 1|2|3 6.3 数组的过滤（filter、reject、takeWhile、dropWhile、without）filter：过滤出符合条件的成员。 123var isEven = n =&gt; n % 2 === 0;var filter1 = R.filter(isEven)([1, 2, 3]);// console.log(filter1); // [2] reject：过滤出所有不满足条件的成员。 123var isEven = n =&gt; n % 2 === 0;var reject1 = R.reject(isEven)([1, 2, 3]);// console.log(reject1); // [1, 3] takeWhile：一旦满足条件，取出前面的所有成员。 123var isNotFour = x =&gt; x !== 4;var takeWhile1 = R.takeWhile(isNotFour)([1, 2, 3, 4, 3])// console.log(takeWhile1); // [1, 2, 3] dropWhile：一旦满足条件，取出剩余的所有成员。 123var lteTwo = x =&gt; x &lt;= 2;var dropWhile1 = R.dropWhile(lteTwo)([1, 2, 3, 4, 3, 2, 1]);// console.log(dropWhile1); // [3, 4, 3, 2, 1] without：返回指定值以外的成员。 12var without1 = R.without([1, 2])([1, 2, 1, 3, 4]);// console.log(without1); // [3, 4] 6.4 单数组运算（countBy、splitAt、splitEvery、splitWhen、aperture、partition、indexOf、lastIndexOf、map、mapIndexed、forEach、reduce、reduceRight、reduceWhile、sort、sortWith、adjust、ap、flatten、groupWith）countBy：对每个成员执行指定函数以后，返回一个对象，表示各种执行结果分别包含多少成员。 123var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];var countBy1 = R.countBy(Math.floor)(numbers);// console.log(countBy1); // &#123;1: 3, 2: 2, 3: 1&#125; splitAt：在给定位置，将原数组分成两个部分。 12var splitAt1 = R.splitAt(1)([1, 2, 3]);// console.log(splitAt1); // [[1],[2, 3]] splitEvery：按照指定的个数，将原数组分成多个部分。 12var splitEvery1 = R.splitEvery(3)([1, 2, 3, 4, 5, 6, 7]);// console.log(splitEvery1); // [[1, 2, 3], [4, 5, 6], [7]] splitWhen：以第一个满足指定函数的成员为界，将数组分成两个部分。 12var splitEvery1 = R.splitEvery(3)([1, 2, 3, 4, 5, 6, 7]);// console.log(splitEvery1); // [[1, 2, 3], [4, 5, 6], [7]] aperture：每个成员与其后给定数量的成员分成一组，这些组构成一个新的数组。 12var aperture1 = R.aperture(3)([1, 2, 3, 4, 5, 6, 7]);// console.log(aperture1); // [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7]] partition：根据是否满足指定函数，将成员分区。 12var partition1 = R.partition(R.contains(&apos;s&apos;))([&apos;aaa&apos;, &apos;bbb&apos;, &apos;sss&apos;]);// console.log(partition1); // [[&apos;sss&apos;], [&quot;aaa&quot;, &quot;bbb&quot;]] indexOf：某个值在数组中第一次出现的位置。 12var indexOf1 = R.indexOf(3)([1, 2, 3, 4]);// console.log(indexOf1); // 2 lastIndexOf：某个值在数组中最后一次出现的位置。 12var lastIndexOf1 = R.lastIndexOf(3)([-1, 3, 3, 0, 1, 2, 3, 4]);// console.log(lastIndexOf1); // 6 map：数组的每个成员依次执行某个函数。 123var double = x =&gt; x * 2;var map1 = R.map(double)([1, 2, 3]);// console.log(map1); // [2, 4, 6] mapIndexed：与map类似，区别是遍历函数可以额外获得两个参数：索引位置和原数组。 123var mapIndexed = R.addIndex(R.map);var mapIndex1 = mapIndexed((val, idx) =&gt; idx + &apos;-&apos; + val, [&apos;f&apos;, &apos;o&apos;, &apos;o&apos;, &apos;b&apos;, &apos;a&apos;, &apos;r&apos;]);// console.log(mapIndex1); // [&quot;0-f&quot;, &quot;1-o&quot;, &quot;2-o&quot;, &quot;3-b&quot;, &quot;4-a&quot;, &quot;5-r&quot;] forEach：数组的每个成员依次执行某个函数，总是返回原数组。 123var printXPlusFive = x =&gt; console.log(x + 5);var forEach1 = R.forEach(printXPlusFive, [1, 2, 3]); // console.log(forEach1); // [1, 2, 3] reduce：数组成员依次执行指定函数，每一次的运算结果都会进入一个累积变量。 12345var mySubtract = function (a, b) &#123; return a - b;&#125;;var reduce1 = R.reduce(mySubtract, 0)([1, 2, 3, 4]);// console.log(reduce1); // -10 reduceRight：与reduce类似，区别是数组成员从左到右执行。 12var reduceRight1 = R.reduceRight(R.subtract, 0)([1, 2, 3, 4]);// console.log(reduceRight1); // -2 reduceWhile：与reduce类似，区别是有一个判断函数，一旦数组成员不符合条件，就停止累积。 1234var isOdd = (acc, x) =&gt; x % 2 === 1;var ys = [2, 4, 6];var reduceWhile1 = R.reduceWhile(isOdd, R.add, 111)(ys);// console.log(reduceWhile1); // 111 sort：按照给定函数，对数组进行排序。 123var diff = function (a, b) &#123; return a -b; &#125;;var sort1 = R.sort(diff)([4, 2, 7, 5]);// console.log(sort1); // [2, 4, 5, 7] sortWith：按照给定的一组函数，进行多重排序。 12345678910111213141516171819var alice = &#123; name: &apos;alice&apos;, age: 40&#125;;var bob = &#123; name: &apos;bob&apos;, age: 30&#125;;var clara = &#123; name: &apos;clara&apos;, age: 40&#125;;var people = [clara, bob, alice];var ageNameSort = R.sortWith([ // R.descend(R.prop(&apos;age&apos;)), R.ascend(R.prop(&apos;name&apos;)) ]);var sortWith1 = ageNameSort(people);console.log(sortWith1); // [&#123;name: &quot;alice&quot;, age: 40&#125;, &#123;name: &quot;bob&quot;, age: 30&#125;, &#123;name: &quot;clara&quot;, age: 40&#125;] adjust：对指定位置的成员执行给定的函数。 12var adjust1 = R.adjust(R.add(10) ,1)([1, 2, 3]);// console.log(adjust1); // [1, 12, 3] ap：数组成员分别执行一组函数，将结果合成为一个新数组。 12var ap1 = R.ap([R.multiply(2), R.add(3)])([1, 2, 3]);// console.log(ap1); // [2, 4, 6, 4, 5, 6] flatten：将嵌套数组铺平。 12var flatten1 = R.flatten([1, 2, [ 3, 4, 5, [6]]]);// console.log(flatten1); // [1, 2, 3, 4, 5, 6] groupWith：将数组成员依次按照指定条件两两比较，并按照结果将所有成员放入子数组。 12var groupWith1 = R.groupWith(R.equals)([0, 1, 1, 2, 3, 5, 8, 13, 21]);// console.log(groupWith1); // [[0], [1, 1], [2], [3], [5], [8], [13], [21]] 6.5 双数组运算（concat、zip、zipObj、xprod、intersection、intersectionWith、diffrence、diffrenceWith、symmetricDifference、symmetricDifferenceWith）concat：将两个数组合并成一个数组。 12var concat1 = R.concat([1, 2])([&apos;a&apos;, &apos;b&apos;]);console.log(concat1); // [1, 2, &quot;a&quot;, &quot;b&quot;] zip：将两个数组指定位置的成员放在一起，生成一个新数组。 12var zip1 = R.zip([1, 2, 3])([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]);// console.log(zip1); // [[1, &quot;a&quot;], [2, &quot;b&quot;], [3, &quot;c&quot;]] zipObj：将两个数组指定位置的成员分别作为键名和键值，生成一个新对象。 12var zip1 = R.zip([1, 2, 3])([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]);// console.log(zip1); // [[1, &quot;a&quot;], [2, &quot;b&quot;], [3, &quot;c&quot;]] xprod：将两个数组的成员两两混合，生成一个新数组。 12var xprod1 = R.xprod([1, 2])([&apos;a&apos;, &apos;b&apos;]);// console.log(xprod1); // [[1, &quot;a&quot;], [1, &quot;b&quot;], [2, &quot;a&quot;], [2, &quot;b&quot;]] intersection：返回两个数组相同的成员组成的新数组。 12var intersection1 = R.intersection([1, 2, 3, 4])([4, 3, 8]);// console.log(intersection1); // [4, 3] intersectionWith：返回经过某种运算，有相同结果的两个成员。 12345678910var buffaloSpringfield = [ &#123;id: 824, name: &apos;Richie Furay&apos;&#125;, &#123;id: 177, name: &apos;Neil Young&apos;&#125;];var csny = [ &#123;id: 204, name: &apos;David Crosby&apos;&#125;, &#123;id: 177, name: &apos;Neil Young&apos;&#125;];var intersectionWith1 = R.intersectionWith(R.eqBy(R.prop(&apos;id&apos;)), buffaloSpringfield)(csny);// console.log(intersectionWith1); // [&#123;id: 177, name: &quot;Neil Young&quot;&#125;] difference：返回第一个数组不包含在第二个数组里面的成员。 12var difference1 = R.difference([1, 2, 3, 4])([7, 6, 5, 4, 3]);// console.log(difference1); // [1, 2] differenceWith：返回执行指定函数后，第一个数组里面不符合条件的所有成员。 12345var cmp = (x, y) =&gt; x.a === y.a;var l1 = [&#123;a: 1&#125;, &#123;a: 2&#125;, &#123;a: 3&#125;];var l2 = [&#123;a: 3&#125;, &#123;a: 4&#125;];var differenceWith1 = R.differenceWith(cmp, l1)(l2);console.log(differenceWith1); // [&#123;a: 1&#125;, &#123;a: 2&#125;] symmetricDifference：返回两个数组的非共有成员所组成的一个新数组。 12var symmetricDifference1 = R.symmetricDifference([1, 2, 3, 4])([7, 6, 5, 4, 3]);// console.log(symmetricDifference1); // [1, 2, 7, 6, 5] symmetricDifferenceWith：根据指定条件，返回两个数组所有运算结果不相等的成员所组成的新数组。 12345var eqA = R.eqBy(R.prop(&apos;a&apos;));var l1 = [&#123;a: 1&#125;, &#123;a: 2&#125;, &#123;a: 3&#125;, &#123;a: 4&#125;];var l2 = [&#123;a: 3&#125;, &#123;a: 4&#125;, &#123;a: 5&#125;, &#123;a: 6&#125;];var symmetricDifferenceWith1 = R.symmetricDifferenceWith(eqA, l1, l2);// console.log(symmetricDifferenceWith1); // [&#123;a: 1&#125;, &#123;a: 2&#125;, &#123;a: 5&#125;, &#123;a: 6&#125;] 6.6 复合数组（find、dindIndex、findLast、findLastIndex、pluck、project、transpose、mergeAll、fromPairs、groupBy、sortBy）find：返回符合指定条件的成员。 123var xs = [&#123;a: 1&#125;, &#123;a: 2&#125;, &#123;a: 3&#125;];var find1 = R.find(R.propEq(&apos;a&apos;, 2))(xs);// console.log(find1); // [&#123;a: 2&#125;] findIndex：返回符合指定条件的成员的位置。 123var xs = [&#123;a: 1&#125;, &#123;a: 2&#125;, &#123;a: 3&#125;];var findIndex1 = R.findIndex(R.propEq(&apos;a&apos;, 2))(xs);// console.log(findIndex1); // 1 findLast：返回最后一个符合指定条件的成员。 123var xs = [&#123;a: 1, b: 0&#125;, &#123;a:1, b: 1&#125;];var findLast1 = R.findLast(R.propEq(&apos;a&apos;, 1))(xs);// console.log(findLast1); // &#123;a: 1, b: 1&#125; findLastIndex：返回最后一个符合指定条件的成员的位置。 123var xs = [&#123;a: 1, b: 0&#125;, &#123;a:1, b: 1&#125;];var findLastIndex1 = R.findLastIndex(R.propEq(&apos;a&apos;, 1))(xs);// console.log(findLastIndex1); // 1 pluck：取出数组成员的某个属性，组成一个新数组。 12var pluck1 = R.pluck(&apos;a&apos;)([&#123;a: 1&#125;, &#123;a: 2&#125;]);// console.log(pluck1); // [1, 2] project：取出数组成员的多个属性，组成一个新数组。 12345var abby = &#123;name: &apos;Abby&apos;, age: 7, hair: &apos;blond&apos;, grade: 2&#125;;var fred = &#123;name: &apos;Fred&apos;, age: 12, hair: &apos;brown&apos;, grade: 7&#125;;var kids = [abby, fred];var project1 = R.project([&apos;name&apos;, &apos;grade&apos;])(kids);// console.log(project1); // [&#123;name: &apos;Abby&apos;, grade: 2&#125;, &#123;name: &apos;Fred&apos;, grade: 7&#125;] transpose：将每个成员相同位置的值，组成一个新数组。 12var transpose1 = R.transpose([[1, &apos;a&apos;], [2, &apos;b&apos;], [3, &apos;c&apos;]]);// console.log(transpose1); // [[1, 2, 3], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]] mergeAll：将数组的成员合并成一个对象。 12var mergeAll1 = R.mergeAll([&#123;foo: 1&#125;, &#123;bar: 2&#125;, &#123;baz: 3&#125;]);// console.log(mergeAll1); // &#123;foo:1,bar:2,baz:3&#125; fromPairs：将嵌套数组转为一个对象。 12var fromPairs1 = R.fromPairs([[&apos;a&apos;, 1], [&apos;b&apos;, 2], [&apos;c&apos;, 3]])// console.log(fromPairs1); // &#123;a: 1, b: 2, c: 3&#125; groupBy：将数组成员按照指定条件分组。 1234567891011121314151617var byGrade = R.groupBy(function (student) &#123; let score = student.score; return score &lt; 60 ? &apos;F&apos; : score &lt; 70 ? &apos;D&apos; : score &lt; 80 ? &apos;C&apos; : score &lt; 90 ? &apos;B&apos; : &apos;A&apos;;&#125;);var students = [&#123;name: &apos;Abby&apos;, score: 84&#125;, &#123;name: &apos;Eddy&apos;, score: 58&#125;, &#123;name: &apos;Jack&apos;, score: 90&#125;];var groupBy1 = byGrade(students);// console.log(groupBy1); // &#123;// &apos;A&apos;: [&#123;name: &apos;Jack&apos;, score: 90&#125;],// &apos;B&apos;: [&#123;name: &apos;Abby&apos;, score: 84&#125;]// &apos;F&apos;: [&#123;name: &apos;Eddy&apos;, score: 58&#125;]// &#125; sortBy：根据成员的某个属性排序。 123var sortByFirstItem = R.sortBy(R.prop(0));var sortBy1 = sortByFirstItem([[-1, 1], [-2, 2], [-3, 3]])// console.log(sortBy1); // // [[-3, 3], [-2, 2], [-1, 1]] 七、对象7.1 对象的特征判断（has、hasIn、propEq、whereEq、where）has: 返回一个布尔值，表示对象自身是否具有该属性。 123var hasName = R.has(&apos;name&apos;);var has1 = hasName(&#123;name: &apos;fan&apos;&#125;);// console.log(has1); // true hasIn：返回一个布尔值，表示对象自身或原型链上是否具有某个属性。 1234567891011function Rectangle (width, height) &#123; this.width = width; this.height = height;&#125;Rectangle.prototype.area = function () &#123; return this.width * this.height;&#125;;var square = new Rectangle(2, 2);var hasIn1 = R.hasIn(&apos;width&apos;)(square); // 自身的var hasIn2 = R.hasIn(&apos;area&apos;)(square); // 原型的// console.log(hasIn1, hasIn2); // true true propEq：如果单个属性等于给定值，返回true。 12345678var abby = &#123;name: &apos;Abby&apos;, age: 7, hair: &apos;blond&apos;&#125;;var fred = &#123;name: &apos;Fred&apos;, age: 12, hair: &apos;brown&apos;&#125;;var rusty = &#123;name: &apos;Rusty&apos;, age: 10, hair: &apos;brown&apos;&#125;;var alois = &#123;name: &apos;Alois&apos;, age: 15, disposition: &apos;surly&apos;&#125;;var kids = [abby, fred, rusty, alois];var hasBrownHair = R.propEq(&apos;hair&apos;, &apos;brown&apos;);var propEq1 = R.filter(hasBrownHair)(kids) // [fred, rusty]// console.log(propEq1); // // [fred, rusty] whereEq：如果多个属性等于给定值，返回true。 123var pred = R.whereEq(&#123;a: 1, b: 2&#125;);var whereEq1 = pred(&#123;a: 1, b: 2&#125;);// console.log(whereEq1); // true where：如果各个属性都符合指定条件，返回true。 12345678var pred = R.where(&#123; a: R.equals(&apos;foo&apos;), b: R.equals(&apos;bzr&apos;), x: R.gt(10), y: R.lt(20)&#125;);var where1 = pred(&#123;a: &apos;foo&apos;, b: &apos;bzr&apos;, x: 12, y: 15&#125;);console.log(where1); // true 7.2 对象的过滤（omit、filter、reject）omit：过滤指定属性。 12var omit1 = R.omit([&apos;a&apos;, &apos;b&apos;])(&#123;a: 1, b: 2, c: 3, d: 4&#125;);// console.log(omit1); // &#123;b: 2, c: 3&#125; filter：返回所有满足条件的属性。 123var isEven = n =&gt; n % 2 === 0;var filter1 = R.filter(isEven)(&#123;a: 1, b: 2, c: 3, d: 4&#125;);// console.log(filter1); // &#123;b: 2, d: 4&#125; reject：返回所有不满足条件的属性。 123var isOdd = n =&gt; n % 2 === 1;var reject1 = R.reject(isOdd)(&#123;a: 1, b: 2, c: 3, d: 4&#125;);// console.log(reject1); // &#123;b: 2, d: 4&#125; reject：返回所有不满足条件的属性。 7.3 对象的截取（dissoc、assoc、partition、pick、pickAll、pickBy、keys、keysIn、values、valuesIn、invertObj、invert）dissoc：过滤指定属性。 12var dissoc1 = R.dissoc(&apos;b&apos;)(&#123;a: 1, b: 2, c: 3&#125;);// console.log(dissoc1); // &#123;a: 1, c: 3&#125; assoc：添加或改写某个属性。 12var assoc1 = R.assoc(&apos;c&apos;, 3)(&#123;a: 1, b: 2&#125;);// console.log(assoc1); // &#123;a: 1, b: 2, c: 3&#125; partition：根据属性值是否满足给定条件，将属性分区。 12var partition1 = R.partition(R.contains(&apos;s&apos;))(&#123;a: &apos;ssss&apos;, b: &apos;ttt&apos;, foo: &apos;bars&apos;&#125;);// console.log(partition1); // [ &#123; a: &apos;sss&apos;, foo: &apos;bars&apos; &#125;, &#123; b: &apos;ttt&apos; &#125; ] pick：返回指定属性组成的新对象。 12var pick1 = R.pick([&apos;a&apos;, &apos;d&apos;])(&#123;a: 1, b: 2, c: 3, d: 4&#125;);// console.log(pick1); // &#123;a: 1, d: 4&#125; pickAll：与pick类似，但会包括不存在的属性。 12var pickAll1 = R.pickAll([&apos;a&apos;, &apos;d&apos;, &apos;f&apos;])(&#123;a: 1, b: 2, c: 3, d: 4&#125;);// console.log(pickAll1); // &#123;a: 1, d: 4, f: undefined&#125; pickBy：返回符合条件的属性。 123var isUpperCase = (val, key) =&gt; key.toUpperCase() === key;var pickBy1 = R.pickBy(isUpperCase)(&#123;a: 1, b: 2, A: 3, B: 4&#125;);// console.log(pickBy1); // &#123;A: 3, B: 4&#125; keys：返回对象自身属性的属性名组成的新数组。 12var keys1 = R.keys(&#123;a: 1, b: 2&#125;);// console.log(keys1); // [&apos;a&apos;, &apos;b&apos;] keysIn：返回对象自身的和继承的属性的属性名组成的新数组。 12345var F = function () &#123;this.x = &apos;X&apos;&#125;;F.prototype.y = &apos;Y&apos;;var f = new F();var keysIn1 = R.keysIn(f);// console.log(keysIn1); // [&apos;x&apos;, &apos;y&apos;] values：返回对象自身的属性的属性值组成的数组。 12var values1 = R.values(&#123;a: 1, b: 2, c: 3&#125;);// console.log(values1); // [1, 2, 3] valuesIn：返回对象自身的和继承的属性的属性值组成的数组。 12345var F = function() &#123; this.x = &apos;X&apos;; &#125;;F.prototype.y = &apos;Y&apos;;var f = new F();var valuesIn1 = R.valuesIn(f);// console.log(valuesIn1); // [&quot;X&quot;, &quot;Y&quot;] invertObj：将属性值和属性名互换。如果多个属性的属性值相同，只返回最后一个属性。 1234567var raceResultsByFirstName = &#123; first: &apos;alice&apos;, second: &apos;jake&apos;, third: &apos;alice&apos;,&#125;;var invertObj1 = R.invertObj(raceResultsByFirstName);// console.log(invertObj1); // &#123;alice: &quot;third&quot;, jake: &quot;second&quot;&#125; invert：将属性值和属性名互换，每个属性值对应一个数组。 1234567var raceResultsByFirstName = &#123; first: &apos;alice&apos;, second: &apos;jake&apos;, third: &apos;alice&apos;,&#125;;var invert1 = R.invert(raceResultsByFirstName);console.log(invert1); // // &#123; &apos;alice&apos;: [&apos;first&apos;, &apos;third&apos;], &apos;jake&apos;:[&apos;second&apos;] &#125; 7.4 对象的运算（prop、map、mapObjIndexed、forEachObjIndexed、merge、mergeWith、eqProps、evolve）prop：返回对象的指定属性。 12var prop1 = R.prop(&apos;x&apos;)(&#123;x: 100&#125;);// console.log(prop1); // 100 map：对象的所有属性依次执行某个函数。 123var double = x =&gt; x * 2;var map1 = R.map(double)(&#123;x: 1, y: 2, z: 3&#125;);// console.log(map1); // &#123;x: 2, y: 4, z: 6&#125; mapObjIndexed：与map类似，但是会额外传入属性名和整个对象。 1234var values = &#123;x: 1, y: 2, z: 3&#125;;var prependkeyAndDouble = (num, key, obj) =&gt; key + (num * 2);var mapObjIndexed1 = R.mapObjIndexed(prependkeyAndDouble)(values);// console.log(mapObjIndexed1); // &#123;x: &quot;x2&quot;, y: &quot;y4&quot;, z: &quot;z6&quot;&#125; forEachObjIndexed：每个属性依次执行给定函数，给定函数的参数分别是属性值和属性名，返回原对象。 123var printkeyConcatValue = (value, key) =&gt; console.log(key + &apos;:&apos; + value);var forEachObjIndexed1 = R.forEachObjIndexed(printkeyConcatValue)(&#123;x: 1,y: 2&#125;);// console.log(forEachObjIndexed1); // &#123;x: 1,y: 2&#125; merge：合并两个对象，如果有同名属性，后面的值会覆盖掉前面的值。 12var merge1 = R.merge(&#123;&apos;name&apos;: &apos;fred&apos;, &apos;age&apos;: 10&#125;)(&#123;&apos;age&apos;: 40&#125;);// console.log(merge1); // &#123;name: &quot;fred&quot;, age: 40&#125; mergeWith：合并两个对象，如果有同名属性，会使用指定的函数处理。 123456var mergeWith1 = R.mergeWith( R.concat, &#123;a: true, values: [10, 20]&#125;, &#123;b: true, values: [15, 35]&#125; );// console.log(mergeWith1); // &#123; a: true, b: true, values: [10, 20, 15, 35] &#125; eqProps：比较两个对象的指定属性是否相等。 1234var o1 = &#123;a: 1, b: 2, c: 3, d: 4&#125;;var o2 = &#123;a: 10, b: 20, c: 3, d: 40&#125;;var eqProps1 = R.eqProps(&apos;c&apos;, o1)(o2);// console.log(eqProps1); //true evolve：对象的属性分别经过一组函数的处理，返回一个新对象。 1234567891011121314151617var tomato = &#123; firstName: &apos;Tomato&apos;, data: &#123;elapsed: 100, remaining: 1400&#125;, id: 123&#125;;var transformations = &#123; firstName: R.trim, lastName: R.trim, data: &#123;elapsed: R.add(1), remaining: R.add(-1)&#125;&#125;;var evolve1 = R.evolve(transformations)(tomato);// console.log(evolve1);// &#123;// firstName: &apos;Tomato&apos;,// data: &#123;elapsed: 101, remaining: 1399&#125;,// id: 123// &#125; 7.5 复合对象（path、pathEq、assocPath）path：取出数组中指定路径的值。 12var path1 = R.path([&apos;a&apos;, &apos;b&apos;], &#123;a: &#123;b: 2&#125;&#125;);// console.log(path1); // 2 pathEq：返回指定路径的值符合条件的成员。 1234567var user1 = &#123;address: &#123;zipCode: 11111&#125;&#125;;var user2 = &#123;address: &#123;zipCode: 22222&#125;&#125;;var user3 = &#123;address: &#123;zipCode: 33333&#125;&#125;;var users = [user1, user2, user3];var isFamous = R.pathEq([&apos;address&apos;, &apos;zipCode&apos;], 11111);var pathEq1 = R.filter(isFamous)(users);// console.log(pathEq1); // [user1] assocPath：添加或改写指定路径的属性的值。 12var assocPath1 = R.assocPath([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 42)(&#123;a: &#123;b: &#123;c: 0&#125;&#125;&#125;);// console.log(assocPath1); // &#123;a: &#123;b: &#123;c: 42&#125;&#125;&#125; 参考文档：阮老师–Ramda 函数库参考教程Ramda 中文]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>函数式编程</tag>
        <tag>ramda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js面向对象编程-非构造函数的继承]]></title>
    <url>%2F2017%2Fjs%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-2.html</url>
    <content type="text"><![CDATA[重新复习 – js面向对象编程知识，本文介绍-对象之间的非构造函数实现”继承”。 先来两个对象（父类和子类）1234567let Chinese = &#123; nation: &apos;中国&apos;&#125;;let Doctor = &#123; career: &apos;医生&apos;&#125;; 一、object()方法12345678910111213let Chinese = &#123; nation: &apos;中国&apos;&#125;;function object (o) &#123; function F () &#123;&#125;; F.prototype = o; return new F();&#125;let Doctor = object(Chinese);Doctor.career = &apos;医生&apos;;console.log(Doctor.nation) // 中国 这个object()函数，其实只做一件事，就是把子对象的prototype属性，指向父对象，从而使得子对象与父对象连在一起。 浅拷贝把父对象的属性，全部拷贝给子对象，也能实现继承。 1234567891011121314let Chinese = &#123; nation: &apos;中国&apos;&#125;;function extendCopy (p) &#123; let c = &#123;&#125;; for (let i in p) &#123; c[i] = p[i]; &#125; return c;&#125;let Doctor = extendCopy(Chinese);Doctor.career = &apos;医生&apos;;console.log(Doctor.nation) // 中国 存在问题：只拷贝基本类型，对于引用类型拷贝内存地址，存在父对象别篡改的可能。 深拷贝所谓&quot;深拷贝&quot;，就是能够实现真正意义上的数组和对象的拷贝。它的实现并不难，只要递归调用&quot;浅拷贝&quot;就行了。 12345678910111213141516171819let Chinese = &#123; nation: &apos;中国&apos;, cities: [&apos;成都&apos;, &apos;北京&apos;]&#125;;function deepCopy(p, c) &#123; var c = c || &#123;&#125;; for (let i in p) &#123; if (typeof p[i] === &apos;object&apos;) &#123; c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;; deepCopy(p[i], c[i]); &#125; else &#123; c[i] = p[i]; &#125; &#125; return c;&#125; let Doctor = deepCopy(Chinese);Doctor.career = &apos;医生&apos;;console.log(Doctor.cities) // [&quot;成都&quot;, &quot;北京&quot;] 参考： 阮老师-Javascript面向对象编程（三）：非构造函数的继承]]></content>
      <categories>
        <category>面向对象编程</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>面向对象编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js面向对象编程-构造函数的继承]]></title>
    <url>%2F2017%2Fjs%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-1.html</url>
    <content type="text"><![CDATA[重新复习 – js面向对象编程知识，本文介绍-对象之间的”继承”的五种方法。 先来两个构造函数（父类和子类）现有一个&quot;动物&quot;对象的构造函数 123function Animal () &#123; this.species = &quot;动物&quot;;&#125; 再来一只&quot;猫&quot;对象的构造函数 1234function Cat (name, color) &#123; this.name = name; this.color = color;&#125; 一、构造函数绑定使用call或apply方法，将父对象的构造函数绑定在子对象上。 12345678function Cat (name, color) &#123; Animal.call(this, arguments); // 构造函数绑定-继承 this.name = name; this.color = color;&#125;var cat1 = new Cat(&apos;小白&apos;, &apos;红色&apos;);console.log(cat1); // &#123;species: &quot;动物&quot;, name: &quot;小白&quot;, color: &quot;红色&quot;&#125; 二、prototype模式12345678910111213function Animal () &#123; this.species = &quot;动物&quot;;&#125;function Cat (name, color) &#123; this.name = name; this.color = color;&#125;Cat.prototype = new Animal(); // prototype模式-继承Cat.prototype.constructor = Cat; // 重新将constructor指向Catvar cat1 = new Cat(&apos;小白&apos;, &apos;红色&apos;);console.log(cat1.species); // 动物 三、直接继承prototype第三种方法是对第二种方法的改进。由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。 12345678910111213function Animal () &#123; &#125;Animal.prototype.species = &apos;动物&apos;;function Cat (name, color) &#123; this.name = name; this.color = color;&#125; Cat.prototype = Animal.prototype; // 直接继承prototypeCat.prototype.constructor = Cat;var cat1 = new Cat(&apos;小白&apos;, &apos;红色&apos;);console.log(cat1.species); // 动物 与前一种方法相比，这样做的优点是效率比较高（不用执行和建立Animal的实例了），比较省内存。缺点是 Cat.prototype和Animal.prototype现在指向了同一个对象，那么任何对Cat.prototype的修改，都会反映到Animal.prototype。 console.log(Animal.prototype.constructor); // Cat 四、利用空对象作为中介1234567891011121314151617function Animal () &#123; &#125;Animal.prototype.species = &apos;动物&apos;;function Cat (name, color) &#123; this.name = name; this.color = color;&#125;// 空对象作为中介let F = function () &#123;&#125;;F.prototype = Animal.prototype;Cat.prototype = new F(); Cat.prototype.constructor = Cat;var cat1 = new Cat(&apos;小白&apos;, &apos;红色&apos;);console.log(cat1.species); // 动物 还可以单独封装成方法 123456789let extend = function (child, parent) &#123; let F = function () &#123;&#125;; F.prototype = parent.prototype; child.prototype = new F(); child.prototype.constructor = child;&#125;;extend(Cat, Animal);let cat1 = new Cat(&apos;小白&apos;, &apos;红色&apos;);console.log(cat1.species); // 动物 五、拷贝继承简单说，如果把父对象的所有属性和方法，拷贝进子对象。 12345678910111213141516171819function Animal () &#123; &#125;Animal.prototype.species = &apos;动物&apos;;function Cat (name, color) &#123; this.name = name; this.color = color;&#125;// 拷贝继承function extend2 (child, parent) &#123; let p = parent.prototype; let c = child.prototype; for (let i in p) &#123; c[i] = p[i]; &#125;&#125;extend2(Cat, Animal);let cat1 = new Cat(&apos;小白&apos;, &apos;红色&apos;);console.log(cat1.species) // 动物 参考： 阮老师-Javascript面向对象编程（二）：构造函数的继承]]></content>
      <categories>
        <category>面向对象编程</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>面向对象编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js面向对象编程-"封装"（Encapsulation）]]></title>
    <url>%2F2017%2Fjs%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B.html</url>
    <content type="text"><![CDATA[重新复习 – js面向对象编程知识 封装1234567891011function Cat (name, color) &#123; this.name = name; // 使用动态作用域this this.color = color;&#125;Cat.prototype.type = &apos;猫科动物&apos;;Cat.prototype.eat = function () &#123; console.log(&apos;吃老鼠&apos;);&#125;;let cat1 =new Cat(&apos;大毛&apos;, &apos;黄色&apos;);let cat2 =new Cat(&apos;小毛&apos;, &apos;黑色&apos;); constructor — 每个实例都有一个constructor属性，指向它们的构造函数// console.log(cat1.constructor == Cat) true instanceof — 验证原型对象与实例之间的关系// console.log(cat1 instanceof Cat) true // console.log(cat1.type); 猫科动物 // console.log(cat1.type === cat2.type) true 都从原型中获得 // cat1.eat() 吃老鼠 isPrototypeOf() — 某个proptotype对象和某个实例之间的关系。// console.log(Cat.prototype.isPrototypeOf(cat1)) true hasOwnProperty() — 每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。// console.log(cat1.hasOwnProperty(&apos;name&apos;)); true // console.log(cat1.hasOwnProperty(&apos;eat&apos;)); false in运算符 — 某个实例是否含有某个属性，不管是不是本地属性// console.log(&apos;name&apos; in cat1); true // console.log(&apos;eat&apos; in cat1); true 总结对象属性的遍历1. in --- 遍历**可枚举的自身属性和继承属性** 2. Object.getOwnPropertyNames() --- 遍历所有的自身属性 3. Object.keys(obj) --- 遍历**可枚举的自身属性**，返回一个属性数组 参考： 阮老师-Javascript面向对象编程（一）：封装]]></content>
      <categories>
        <category>面向对象编程</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>面向对象编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js函数式编程-读书笔记]]></title>
    <url>%2F2017%2Fjs%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-7.html</url>
    <content type="text"><![CDATA[最近，工作不是很忙，赶紧为自己充电。准备很长一段事件撸函数式编程。如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。 基于流的编程 or 无类编程连接12345678910111213141516171819202122232425262728function createPerson () &#123; let firstName = &apos;&apos;; let lastName = &apos;&apos;; let age = 0; return &#123; setFirstName: function (fn) &#123; firstName = fn; return this; &#125;, setLastName: function (fn) &#123; lastName = fn; return this; &#125;, setAge: function (fn) &#123; age = fn; return this; &#125;, toString: function () &#123; return [firstName, lastName, age].join(&apos; &apos;); &#125; &#125;;&#125;let dd = createPerson() .setFirstName(&apos;yu&apos;) .setLastName(&apos;fan&apos;) .setAge(11) .toString();console.log(dd) // yu fan 11 管道pipeline(a, _.compact, _.initial, _.rest, rev) // 对数据a进行一系列的操作 数据流与控制流无类编程 数据导向Mixins123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475类层次结构function ContainerClass () &#123;&#125;function ObservedContainerClass () &#123;&#125;function HoleClass () &#123;&#125;function CASClass () &#123;&#125;function TableBaseClass () &#123;&#125;ObservedContainerClass.prototype = new ContainerClass();HoleClass.prototype = new ObservedContainerClass();CASClass.prototype = new HoleClass();TableBaseClass.prototype = new HoleClass();// 用Mixin扁平化层级结构function Container (val) &#123; this._value = val; this.init(val);&#125;Container.prototype.init = _.identity;let Hole = function (val) &#123; Container.call(this, val);&#125;let HoleMixin = &#123; setValue: function (newValue) &#123; let oldVal = this._value; this.validate(newValue); this._value = newValue; this.notify(oldVal, newValue); return this._value; &#125;,&#125;;let ObserverMixin = (function () &#123; let _watchers = []; return &#123; watch: function (fun) &#123; _watchers.push(fun); return _.size(_watchers); &#125;, notify: function (oldVal, newVal) &#123; _.each(_._watchers, function (watcher) &#123; watcher.call(this, oldVal, newVal); &#125;); return _.size(_watchers); &#125; &#125;;&#125;);let ValidateMixin = &#123; addValidator: function (fun) &#123; this._validator = fun; &#125;, init: function (val) &#123; this.validate(val); &#125;, validate: function (val) &#123; if (existy(this._validator) &amp;&amp; !this._validator(val)) &#123; fail(&apos;Attrmpted to set invalid value&apos; + polyToString(val)); &#125; &#125;&#125;;_.extend(Hole.prototype, HoleMixin, ValidateMixin, ObserverMixin); // 同级继承let h = new Hole(43);h.addValidator(always(false));console.log(h); // 43let SwapMixin = &#123; swap: function (fun) &#123; let args = _.rest(arguemnts); let newValue = fun.apply(this, _.identity); return this.setValue(newValue); &#125;,&#125;;let o = &#123;_value: 0, setValue: _.identity&#125;_.extend(o, SwapMixin);o.swap(construct, [1, 2, 3]); //[0, 1, 2, 3] 源代码仓库 函数式编程-读书笔记 ```]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js函数式编程-纯度、不变性和更改政策]]></title>
    <url>%2F2017%2Fjs%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-6.html</url>
    <content type="text"><![CDATA[最近，工作不是很忙，赶紧为自己充电。准备很长一段事件撸函数式编程。如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。 纯度、不变性和更改政策纯度纯函数 1.其结果只能从它的参数的值来计算 2.不能依赖于能被外部操作改变的数据 3.不能改变外部状态 不变性1234567891011121314151617181920212223242526272829303132333435363738394041// 不变性function summ (array) &#123; let result = 0; let sz = array.length; for (let i = 0; i &lt; sz; i++) &#123; result += array[i]; &#125; return result;&#125;let dd = summ(_.range(1, 11));console.log(dd); // 55// 递归function summRec (array, seed) &#123; if (_.isEmpty(array))&#123; return seed; &#125; else &#123; return summRec(_.rest(array), _.first(array) + seed) &#125;&#125;let dd = summRec(_.range(1, 11), 0);console.log(dd); // 55// 冻结和克隆Object.freeze(a) // 浅冻结// 深冻结function deepFreeze(obj) &#123; if (!Object.isFrozen(obj)) &#123; Object.freeze(obj); &#125; for (let key in obj) &#123; if (!obj.hasOwnProperty(key) || !_.isObject(obj[key])) &#123; continue; &#125; deepFreeze(obj[key]); &#125;&#125;let x = [&#123;a: [1, 2, 3], b: 42&#125;, &#123;c: &#123;d: []&#125;&#125;];deepFreeze(x);x[0] = null;console.dir(x); // [&#123;a: [1, 2, 3], b: 42&#125;, &#123;c: &#123;d: []&#125;&#125;] 控制变化的政策用容器封装数据，不能直接更改数据。 123456789101112131415function Container (init) &#123; this._value = init;&#125;Container.prototype = &#123; update: function (fun) &#123; let args = _.rest(arguments); let oldValue = this._value; this._value = fun.apply(this, constructor(oldValue, args)); return this._value; &#125;&#125;;let aNumber = new Container(42);let dd = aNumber.update(function (n) &#123; return n + 1; &#125;);console.log(dd) // 43 源代码仓库 函数式编程-读书笔记]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js函数式编程-递归]]></title>
    <url>%2F2017%2Fjs%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-5.html</url>
    <content type="text"><![CDATA[最近，工作不是很忙，赶紧为自己充电。准备很长一段事件撸函数式编程。如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。 递归自吸收函数（调用自己的函数）123456789101112131415161718192021222324252627282930function myLength (ary) &#123; if (_.isEmpty(ary)) &#123; return 0; &#125; else &#123; return 1 + myLength(_.rest(ary)); &#125;&#125;let dd = myLength([1, 2, 3]);console.log(dd); // 3function cycle(times, ary) &#123; if (times &lt;= 0) &#123; return []; &#125; else &#123; return cat(ary, cycle(times -1, ary)); &#125;&#125;let dd = cycle(2, [1, 2, 3]);console.log(dd); // [1, 2, 3, 1, 2, 3]*_.zip*function cycle(times, ary) &#123; if (times &lt;= 0) &#123; return []; &#125; else &#123; return cat(ary, cycle(times -1, ary)); &#125;&#125;let dd = _.zip([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], [1, 2, 3]);console.dir(dd); // [[&apos;a&apos;, 1],[&apos;b&apos;, 2], [&apos;c&apos;, 3]] // 深度优先自递归搜索 12345678910111213141516171819202122232425262728293031323334353637*andify 组合函数*function andify () &#123; let preds = _.toArray(arguments); return function () &#123; let args = _.toArray(arguments); let everything = function (ps, truth) &#123; if (_.isEmpty(ps)) &#123; return truth; &#125; else &#123; return _.every(args, _.first(ps)) &amp;&amp; everything(_.rest(ps), truth); &#125; &#125;; return everything(preds, true); &#125;;&#125;let evenNums = andify(_.isNumber, isEven);console.log(evenNums(4, 2)); // true*andify 组合函数*function orify () &#123; let preds = _.toArray(arguments); return function () &#123; let args = _.toArray(arguments); let something = function (ps, truth) &#123; if (_.isEmpty(ps)) &#123; return truth; &#125; else &#123; return _.some(args, _.first(ps)) || something(_.rest(ps), truth); &#125; &#125;; return something(preds, true); &#125;;&#125;let evenNums = orify(_.isNumber, isEven);console.log(evenNums(1, 2)); // true 相互关联函数（函数调用其他会再调用回他的函数）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162function evenSteven(n) &#123; if (n === 0) &#123; return true; &#125; else &#123; return oddJohn(Math.abs(n) - 1); &#125;&#125;function oddJohn(n) &#123; if (n === 0) &#123; return false; &#125; else &#123; return evenSteven(Math.abs(n) - 1); &#125;&#125;let dd = evenSteven(3);console.log(dd); // false*flat 展开嵌套数组*function flat(array) &#123; if (_.isArray(array)) &#123; return cat.apply(cat, _.map(array, flat)); &#125; else &#123; return [array]; &#125;&#125;let dd = flat([[1, 2], [3, 4]]);console.log(dd) // [1, 2, 3, 4]*clone 浅clone*let x = [&#123;a: [1, 2, 3], b: 42&#125;, &#123;c: &#123;d: []&#125;&#125;]let y = _.clone(x);console.log(y) // [&#123;a: [1, 2, 3], b: 42&#125;, &#123;c: &#123;d: []&#125;&#125;] *deepClone 深clone*function deepClone(obj) &#123; if (!existy(obj) || !_.isObject(obj)) &#123; return obj; &#125; let temp = new obj.constructor(); for (let key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; temp[key] = deepClone(obj[key]); &#125; &#125; return temp;&#125;let x = [&#123;a: [1, 2, 3], b: 42&#125;, &#123;c: &#123;d: []&#125;&#125;]let y = deepClone(x);x[1][&apos;c&apos;][&apos;d&apos;] = 100;console.log(_.isEqual(x, y)); // false// 遍历嵌套数组的数组function visit(mapFun, resultFun, array) &#123; if (_.isArray(array)) &#123; return resultFun(_.map(array, mapFun)); &#125; else &#123; return resultFun(array); &#125;&#125;let dd = visit(_.identity, _.isNumber, 42);console.log(dd); // true 太多递归了递归是一个底层操作 源代码仓库 函数式编程-读书笔记]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP学习-了解]]></title>
    <url>%2F2017%2F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[最近，由于最近项目需要集成到老项目中去，采用原始的前后端不分离开发，需要学习jsp语言。如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。 JSP简介1. JSP全称Java Server Pages，是一种动态网页开发技术。它使用JSP标签在HTML网页中插入Java代码。标签通常以&lt;%开头以%&gt;结束。 JSP 生命周期1. 编译阶段： 当浏览器请求JSP页面时，JSP引擎会首先去检查是否需要编译这个文件。如果这个文件没有被编译过，或者在上次编译后被更改过，则编译这个JSP文件。 编译的过程包括三个步骤： 解析JSP文件。 将JSP文件转为servlet。 编译servlet。 2. 初始化阶段： 容器载入JSP文件后，它会在为请求提供任何服务前调用jspInit()方法。如果您需要执行自定义的JSP初始化任务，复写jspInit()方法就行了，就像下面这样： 123public void jspInit()&#123; // 初始化代码&#125; 一般来讲程序只初始化一次，servlet也是如此。通常情况下您可以在jspInit()方法中初始化数据库连接、打开文件和创建查询表。 执行阶段： 这一阶段描述了JSP生命周期中一切与请求相关的交互行为，直到被销毁。 当JSP网页完成初始化后，JSP引擎将会调用_jspService()方法。 _jspService()方法需要一个HttpServletRequest对象和一个HttpServletResponse对象作为它的参数，就像下面这样： 12345void _jspService(HttpServletRequest request, HttpServletResponse response)&#123; // 服务端处理代码&#125; _jspService()方法在每个request中被调用一次并且负责产生与之相对应的response，并且它还负责产生所有7个HTTP方法的回应，比如GET、POST、DELETE等等。 销毁阶段： SP生命周期的销毁阶段描述了当一个JSP网页从容器中被移除时所发生的一切。 jspDestroy()方法在JSP中等价于servlet中的销毁方法。当您需要执行任何清理工作时复写jspDestroy()方法，比如释放数据库连接或者关闭文件夹等等。 12345jspDestroy()方法的格式如下：public void jspDestroy()&#123; // 清理代码&#125; JSP语法语法格式： &lt;% 代码片段 %&gt; &lt;jsp:scriptlet&gt; 代码片段 &lt;/jsp:scriptlet&gt; 中文编码问题： &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; JSP声明 &lt;%! declaration; [ declaration; ]+ ... %&gt; &lt;jsp:declaration&gt; 代码片段 &lt;/jsp:declaration&gt; 例子： &lt;%! int i = 0; %&gt; JSP表达式 &lt;%= 表达式 %&gt; &lt;jsp:expression&gt; 表达式 &lt;/jsp:expression&gt; JSP注释 &lt;%-- 注释 --%&gt; JSP指令 JSP指令用来设置与整个JSP页面相关的属性。 &lt;%@ directive attribute=&quot;value&quot; %&gt; 例子： &lt;%@ page ... %&gt; 定义页面的依赖属性，比如脚本语言、error页面、缓存需求等等 &lt;%@ include ... %&gt; 包含其他文件 &lt;%@ taglib ... %&gt; 引入标签库的定义，可以是自定义标签 JSP行为 JSP行为标签使用XML语法结构来控制servlet引擎。 &lt;jsp:action_name attribute=&quot;value&quot; /&gt; JSP隐含对象 JSP支持九个自动定义的变量，江湖人称隐含对象。 request HttpServletRequest类的实例 response HttpServletResponse类的实例 判断语句 if-else &lt;%! int day = %&gt; &lt;% if (day == 1 | day == 7) { %&gt; &lt;p&gt;今天是周末&lt;/p&gt; &lt;% } else { %&gt; &lt;p&gt;今天不是周末&lt;/p&gt; &lt;% } %&gt; switch-case &lt;% switch(day) { case 0: out.println(&quot;星期天&quot;); break; case 1: out.println(&quot;星期一&quot;); break; default: out.println(&quot;星期六&quot;); } %&gt; 循环语句 for &lt;%for ( fontSize = 1; fontSize &lt;= 3; fontSize++){ %&gt; &lt;font color=&quot;green&quot; size=&quot;&lt;%= fontSize %&gt;&quot;&gt; 菜鸟教程 &lt;/font&gt;&lt;br /&gt; &lt;%}%&gt; while &lt;%while ( fontSize &lt;= 3){ %&gt; &lt;font color=&quot;green&quot; size=&quot;&lt;%= fontSize %&gt;&quot;&gt; 菜鸟教程 &lt;/font&gt;&lt;br /&gt; &lt;%fontSize++;%&gt; &lt;%}%&gt; JSP 字面量 布尔值(boolean)：true 和 false; 整型(int)：与 Java 中的一样; 浮点型(float)：与 Java 中的一样; 字符串(string)：以单引号或双引号开始和结束; Null：null。 JSP指令JSP指令用来设置整个JSP页面相关的属性，如网页的编码方式和脚本语言。 &lt;%@ directive attribute=&quot;value&quot; %&gt; Page指令 Page指令为容器提供当前页面的使用说明。一个JSP页面可以包含多个page指令。 &lt;%@ page attribute=&quot;value&quot; %&gt; &lt;jsp:directive.page attribute=&quot;value&quot; /&gt; Include指令 JSP可以通过include指令来包含其他文件。被包含的文件可以是JSP文件、HTML文件或文本文件。 &lt;%@ include file=&quot;文件相对 url 地址&quot; %&gt; &lt;jsp:directive.include file=&quot;文件相对 url 地址&quot; /&gt; Taglib指令 JSP API允许用户自定义标签，一个自定义标签库就是自定义标签的集合。 &lt;%@ taglib uri=&quot;uri&quot; prefix=&quot;prefixOfTag&quot; %&gt; &lt;jsp:directive.taglib uri=&quot;uri&quot; prefix=&quot;prefixOfTag&quot; /&gt; JSP动作元素JSP动作元素在请求处理阶段起作用。JSP动作元素是用XML语法写成的。 &lt;jsp:action_name attribute=&quot;value&quot; /&gt; JSP隐式对象JSP隐式对象是JSP容器为每个页面提供的Java对象，开发者可以直接使用它们而不用显式声明。JSP隐式对象也被称为预定义变量。 JSP客户端请求当浏览器请求一个网页时，它会向网络服务器发送一系列不能被直接读取的信息，因为这些信息是作为HTTP信息头的一部分来传送的。您可以查阅HTTP协议来获得更多的信息。 JSP服务器响应Response响应对象主要将JSP容器处理后的结果传回到客户端。可以通过response变量设置HTTP的状态和向客户端发送数据，如Cookie、HTTP文件头信息等。 JSP HTTP状态码以状态行+CRLF（回车换行）开始 零行或多行头模块+CRLF 一个空行，比如CRLF 可选的消息体比如文件，查询数据，查询输出 JSP 表单处理JSP 读取表单数据 getParameter(): 使用 request.getParameter() 方法来获取表单参数的值。 getParameterValues(): 获得如checkbox类（名字相同，但值有多个）的数据。 接收数组变量 ，如checkbox类型 getParameterNames():该方法可以取得所有变量的名称，该方法返回一个Emumeration。 getInputStream():调用此方法来读取来自客户端的二进制数据流。 JSP过滤器JSP 和 Servlet 中的过滤器都是 Java 类。 过滤器可以动态地拦截请求和响应，以变换或使用包含在请求或响应中的信息。 可以将一个或多个过滤器附加到一个 Servlet 或一组 Servlet。过滤器也可以附加到 JavaServer Pages (JSP) 文件和 HTML 页面。 过滤器是可用于 Servlet 编程的 Java 类，可以实现以下目的： 在客户端的请求访问后端资源之前，拦截这些请求。 在服务器的响应发送回客户端之前，处理这些响应。 JSP Cookie 处理Cookie是存储在客户机的文本文件，它们保存了大量轨迹信息。在servlet技术基础上，JSP显然能够提供对HTTP cookie的支持。 JSP Session有三种方法来维持客户端与服务器的会话 Cookies 隐藏表单域 &lt;input type=&quot;hidden&quot; name=&quot;sessionid&quot; value=&quot;12345&quot;&gt; 重写URL http://w3cschool.cc/file.htm;sessionid=12345 session对象 JSP利用servlet提供的HttpSession接口来识别一个用户，存储这个用户的所有访问信息。 默认情况下，JSP允许会话跟踪，一个新的HttpSession对象将会自动地为新的客户端实例化。 JSP 文件上传JSP 日期处理使用JSP最重要的优势之一，就是可以使用所有Java API。本章将会详细地讲述Java中的Date类，它在java.util包下，封装了当前日期和时间。 JSP 页面重定向当需要将文档移动到一个新的位置时，就需要使用JSP重定向了。 JSP 点击量统计JSP 自动刷新想象一下，如果要直播比赛的比分，或股票市场的实时状态，或当前的外汇配给，该怎么实现呢？显然，要实现这种实时功能，您就不得不规律性地刷新页面。 JSP 发送邮件]]></content>
      <categories>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>jsp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js函数式编程-由函数构建函数]]></title>
    <url>%2F2017%2Fjs%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-4.html</url>
    <content type="text"><![CDATA[最近，工作不是很忙，赶紧为自己充电。准备很长一段事件撸函数式编程。如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。 由函数构建函数函数式组合的精华函数组合的精华：使用现有的零部件来建立新的行为，这些新行为同样也成为了已有的零部件。 123456789101112131415161718192021function dispatch() &#123; let funs = _.toArray(arguments); let size = funs.length; return function (target) &#123; let ret = undefined; let args = _.rest(arguments); for(let funIndex = 0; funIndex &lt; size; funIndex++)&#123; let fun = funs[funIndex]; ret = fun.apply(fun, construct(target, args)); if (existy(ret)) return ret; &#125; return ret; &#125;&#125;let str = dispatch(invoker(&apos;toString&apos;, Array.prototype.toString), invoker(&apos;toString&apos;, String.prototype.toString) )let dd = str(&apos;a&apos;);console.log(dd) // &apos;a&apos; 柯里化（Currying）12345678function rightAwayInvoker() &#123; let args = _.toArray(arguments); let method = args.shift(); let target = args.shift(); return method.apply(target, args);&#125;let dd = rightAwayInvoker(Array.prototype.reverse, [1, 2, 3]);console.log(dd) // [3, 2, 1] 柯里化的方向（默认向右） 123456789101112131415161718192021222324252627282930313233343536373839404142function rigthCurryDiv(d) &#123; return function (n) &#123; return n/d; &#125;;&#125;let divideBy10 = rigthCurryDiv(10); // 被除数let dd = divideBy10(2); // 除数var d1 = rigthCurryDiv(10)(2)console.log(d1); // 0.2// 柯里化一个参数function curry(fun) &#123; return function(arg) &#123; return fun(arg); &#125;;&#125;let dd = [&apos;11&apos;, &apos;11&apos;, &apos;11&apos; ,&apos;11&apos;].map(curry(parseInt))console.log(dd) // [&apos;11&apos;, &apos;11&apos;, &apos;11&apos; ,&apos;11&apos;]// 柯里化两个参数function curry2(fun) &#123; return function(secondArg) &#123; return function(firstArg) &#123; return fun(firstArg, secondArg); &#125; &#125;&#125;function div(n, d) &#123; return n / d;&#125;let dd = curry2(div)(10)(50);console.log(dd) // 5function toHex(n) &#123; let hex = n.toString(16); return (hex.length &lt; 2) ? [0, hex].join(&apos;&apos;) : hex;&#125;function rgbToHexString(r, g, b) &#123; return [&apos;#&apos;, toHex(r), toHex(g), toHex(b)].join(&apos;&apos;);&#125;let dd = rgbToHexString(255, 255, 255);console.log(dd) // #ffffff 部分应用123456789101112131415161718192021222324252627function partial (fun) &#123; let pargs = _.rest(arguments); return function () &#123; let args = cat(pargs, _.toArray(arguments)); return fun.apply(fun, args); &#125;;&#125;var div10by2by4by5000partial = partial(div, 10, 2, 4, 5000);console.log(div10by2by4by5000partial()) // 5// 局部应用实战：前置条件function condition1() &#123; let validators = _.toArray(arguments); return function (fun, arg) &#123; let errors = mapcat(function(isValid)&#123; return isValid(arg) ? [] : [isValid.message]; &#125;, validators); if (!_.isEmpty(errors)) &#123; throw new Error(error.join(&apos;,&apos;)); &#125; return fun(arg); &#125;;&#125;let sqrPre = condition1(validator(&apos;arg must not be zero&apos;, complement(zero)), validator(&apos;arg must be a number&apos;, _.isNumber));let dd = sqrPre(_.identity, 10);console.log(dd) 通过组合端至端的拼接函数123let isntString = _.compose(function (x) &#123; return !x; &#125;, _.isString);let dd = isntString([]);console.log(dd) // true 源代码仓库 函数式编程-读书笔记]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js函数式编程-高阶函数]]></title>
    <url>%2F2017%2Fjs%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-3.html</url>
    <content type="text"><![CDATA[最近，工作不是很忙，赶紧为自己充电。准备很长一段事件撸函数式编程。如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。 高阶函数以其他函数为参数的函数如：_.map、_.reduce、_.filter等函数 关于传递函数的思考：max、finder、best 123456789101112131415161718192021222324252627282930*max 集合中选择最大值的项*var dd = _.max([1, 2, 3, 4, 5])console.log(dd) // 5var people = [&#123;name: &apos;fed&apos;, age: 45&#125;, &#123;name: &apos;fan&apos;, age: 25&#125;];var dd = _.max(people, function (item) &#123; return item.age;&#125;);console.log(dd) // &#123;name: &quot;fed&quot;, age: 45&#125;*finder *function finder(valueFun, bestFun, coll) &#123; return _.reduce(coll, function (best, current) &#123; var bestValue = valueFun(best); var currentValue = valueFun(current); return (bestValue === bestFun(bestValue, currentValue)) ? best : current; &#125;);&#125;var dd = finder(_.identity, Math.max, [1, 2, 3, 4, 5]);console.log(dd) // 5*best *function best(fun, coll)&#123; return _.reduce(coll, function (x, y) &#123; return fun(x, y) ? x : y; &#125;); &#125;var dd = best(function (x, y) &#123; return x &gt; y;&#125;, [1, 2, 3, 4]);console.log(dd)// 4 关于传递函数的更多思考：重复、反复和条件迭代 1234567891011121314151617181920212223242526272829function repeat(times, VALUE) &#123; return _.map(_.range(times), function () &#123; return VALUE; &#125;)&#125;var dd = repeat(4, &apos;Major&apos;);console.log(dd) // [&apos;Major&apos;,&apos;Major&apos;,&apos;Major&apos;,&apos;Major&apos;]// 使用函数，而不是值function repeatedly(times, fun) &#123; return _.map(_.range(times), fun);&#125;var dd = repeatedly(4, function () &#123; return Math.floor((Math.random()*10) + 1)&#125;);console.log(dd)// 再次强调，&quot;使用函数，而不是值&quot;function iterateUntil(fun, check, init) &#123; let ret = []; let result = fun(init); while (check(result))&#123; ret.push(result); result = fun(result); &#125; return ret;&#125;let dd = iterateUntil(function (n)&#123; return n+n&#125;, function (n) &#123; return n &lt;= 1024&#125;, 1)console.log(dd) // [2, 4, 8, 16, ...] 返回其他函数的函数123456789101112131415161718192021222324252627282930313233function always(VALUE)&#123; return function ()&#123; return VALUE; &#125;&#125;var f = always(function () &#123;&#125;)var g = always(function () &#123;&#125;)console.log(f() === g()) // falsefunction invoker(NAME, METHOD)&#123; return function(target)&#123; if (!existy(target)) fail(&quot;Must provide a target&quot;); let targetMethod = target[NAME]; let args = _.rest(arguments); return doWhen((existy(targetMethod) &amp;&amp; METHOD === targetMethod), function () &#123; return targetMethod.apply(target, args); &#125;) &#125;&#125;let rev = invoker(&apos;reverse&apos;, Array.prototype.reverse);console.log(_.map([[1, 2, 3]], rev))// 捕获增量值function makeUniqueStringFunction(start) &#123; let COUNTER = start; return function(prefix) &#123; return [prefix, COUNTER++].join(&apos;&apos;); &#125;;&#125;let dd = makeUniqueStringFunction(0);let d1 = dd(&apos;fanerge&apos;)let d2 = dd(&apos;fanerge&apos;)console.log(d1, d2); // fanerge0 fanerge1 整合：对象校验器123456789101112131415function aMap(obj) &#123; return _.isObject(obj);&#125;function hasKeys() &#123; let KEYS = _.toArray(arguments); let fun = function(obj)&#123; return _.every(KEYS, function (k)&#123; return _.has(obj, k); &#125;) &#125;; fun.message = cat([&apos;Must have values for keys:&apos;], KEYS).join(&quot; &quot;); return fun;&#125;let checkCommand = checker(validator(&quot;Must be a map&quot;, aMap), hasKeys(&apos;msg&apos;, &apos;type&apos;));console.log(checkCommand(&#123;msg: &apos;blah&apos;, type: &apos;display&apos;&#125;)); //[] 源代码仓库 函数式编程-读书笔记]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js函数式编程基本概念]]></title>
    <url>%2F2017%2Fjs%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html</url>
    <content type="text"><![CDATA[高阶函数满足下列条件之一则为高阶函数： 接受一个或多个函数作为输入。 输出一个函数。 函数的合成（Compose）如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做”函数的合成”（compose）。通用 compose 函数123456789101112131415let compose = function(...args) &#123; let len = args.length, count = len - 1, result; return function f1(...args1) &#123; result = args[count].apply(this, args1); if (count &lt;= 0) &#123; count = len - 1; return result; &#125; else &#123; count--; return f1.call(null, result); &#125; &#125;&#125; PS：具有以下特点 第一函数接受参数, 其他函数接受的上一个函数的返回值 第一个函数的参数是多元的, 其他函数的一元的 自右向左执行 函数柯里化（curry）把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数的函数或者计算结果（参数足够的情况）。123456789101112let curry = function(fn) &#123; let limit = fn.length; return function judgeCurry (...args) &#123; if (args.length &gt;= limit) &#123; return fn.apply(null, args); &#125; else &#123; return function(...args2) &#123; return judgeCurry.apply(null, args.concat(args2)); &#125; &#125; &#125;&#125; PS：具有以下特点 当传入参数少于原本需要的参数个数就返回一个函数 当传入参数等于原本需要的参数个数就返回计算结果 总结纯函数输入输出数据流全是显式(函数与外界交换数据只有一个唯一渠道——参数和返回值)的。非纯函数的操作读取全局变量/修改全局变量 函数副作用函数副作用是指函数在正常工作任务之外对外部环境所施加的影响（修改外部全局变量）。 Compose函数组合，单一职责原则如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做”函数的合成”（compose）。 pointfree无参编程，函数无须提及将要操作的数据是什么样的，结合curry和compose。就是使用一些通用的函数，组合出各种复杂运算。var snakeCase = compose(replace(/\s+/ig, &#39;_&#39;), toLowerCase); Curry函数柯里化，只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。 偏函数所谓偏函数，就是固定一个函数的一个或者多个参数，返回一个新的函数，这个函数用于接受剩余的参数。 高阶函数一个函数的参数或者返回值里有函数。]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js函数式编程-变量的作用域和闭包]]></title>
    <url>%2F2017%2Fjs%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2.html</url>
    <content type="text"><![CDATA[最近，工作不是很忙，赶紧为自己充电。准备很长一段事件撸函数式编程。如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。 变量的作用域和闭包全局作用域动态作用域 -- this（函数调用时确定的） 静态作用域（词法作用域）-- 函数声明时确定的 词法作用域定义：所谓的词法作用域其实是指作用域在词法解析阶段既确定了,不会改变。 123456789var aVariable = &apos;outer&apos;;function afunc()&#123; let aVariable = &apos;middle&apos;; return _.map([1, 2, 3], function (e)&#123; let aVariable = &apos;in&apos;; // 使用最内层的aVariable return [aVariable,e].join(&apos; &apos;); &#125;);&#125;console.log(afunc()) // [&quot;in 1&quot;, &quot;in 2&quot;, &quot;in 3&quot;] 动态作用域1234567891011121314151617181920var globals = &#123;&#125;;function makeBindFun(resolver)&#123; return function(k, v)&#123; let stack = globals[k] || []; globals[k] = resolver(stack, v); return globals; &#125;&#125;var stackBinder = makeBindFun(function(stack, v)&#123; stack.push(v); return stack;&#125;);var stackUnBinder = makeBindFun(function(stack, v)&#123; stack.pop(v); return stack;&#125;);var dd = stackBinder(&apos;sd&apos;, &apos;dd&apos;)console.log(dd) //&#123;sd: [&apos;dd&apos;]&#125; javascript的动态作用域（对this引用的讨论） 12345678910111213141516*bind* 锁定this使其不被更改function globalThis() &#123; return this;&#125;var nopeThis = _.bind(globalThis, &apos;nope&apos;);nopeThis.call(&apos;wat&apos;) // &apos;nope&apos;;*bindAll* 锁定this引用到对应的命名函数var target = &#123; name: &apos;the right value&apos;, aux: function () &#123; return this.name; &#125;&#125;var dd = _.bindAll(target, &apos;aux&apos;)console.log(target.aux.call(&apos;wat&apos;)) // the right value 函数作用域12345678*clone* 克隆一个对象function f()&#123; this[&apos;a&apos;] = 200; return this[&apos;a&apos;] + this[&apos;b&apos;];&#125;var globals = &#123;&apos;b&apos;: 2&#125;;var dd = f.call(_.clone(globals))console.log(dd) // 202 闭包模拟闭包 12345678910111213141516171819202122function whatWasTheLocal() &#123; let CAPTURED = &quot;Oh hai&quot;; return function () &#123; return &quot;The local was:&quot; + CAPTURED; &#125;&#125;var dd = whatWasTheLocal();console.log(dd()) // The local was:Oh haifunction createWeirdScaleFunction(FACTOR) &#123; return function (v) &#123; this[&apos;FACTOR&apos;] = FACTOR; let captures = this; return _.map(v, _.bind(function (n) &#123; return (n * this[&apos;FACTOR&apos;]); &#125;, captures)); &#125;&#125;let scale10 = createWeirdScaleFunction(10);let dd = scale10.call(&#123;&#125;, [3, 4, 5])console.log(dd) 遮蔽 1234567var shadowed = 220;function argShadow(shadowed) &#123; return [&apos;value is&apos;, shadowed].join();&#125;var dd = argShadow()console.log(dd) 使用闭包 1234567891011121314let pingpong = (function () &#123; let PRIVATE = 0; return &#123; inc: function (n) &#123; return PRIVATE += n; &#125;, dec: function (n) &#123; return PRIVATE -= n; &#125; &#125;;&#125;)();let dd = pingpong.inc(10);console.log(dd) // 10 闭包的抽象 ``` function plucker (FIELD) { return function (obj) { return (obj &amp;&amp; obj[FIELD]) } } let best = {title: &apos;infinite jest&apos;, author: &apos;dfw&apos;} let getTitle = plucker(&apos;title&apos;) let dd = getTitle(best); console.log(dd) // infinite jest ``` 源代码仓库 函数式编程-读书笔记]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js函数式编程-一等函数与Applicative编程]]></title>
    <url>%2F2017%2Fjs%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-1.html</url>
    <content type="text"><![CDATA[最近，工作不是很忙，赶紧为自己充电。准备很长一段事件撸函数式编程。如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。 一等函数与Applicative编程函数式一等公民函数式编程语言应该是促进创造和使用函数的。 函数式一等公民：函数可以作为数组的成员、对象的方法、存储为变量等等。 12// 例如存储为数组的成员var fortytwos = [42, function () &#123; return 42 &#125;] 高阶函数的定义：以函数作为参数或者返回函数。 多种javascript编程方式 命令式编程 -- 通过详细描述行为的编程方式。 基于原型的面向对象编程 -- 基于原型对象及其实例的编程方式。 元编程 -- 对JavaScript执行模型数据进行编写和操作的编程方式。 Applicative编程定义：函数A作为参数提供给函数B。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596var nums = [1, 2, 3, 4, 5];*map* 遍历集合并对其每一个值调用一个函数，返回结果的集合。function doubleAll(array) &#123; return _.map(array, function (n) &#123; return n*2; &#125;);&#125;console.log(doubleAll(nums)) // [2, 4, 6, 8, 10]*reduce* 利用函数将值的集合合并成一个值，该函数接收一个累积值和本次处理的值function average (array) &#123; let sum = _.reduce(array, function (a, b)&#123; return a + b; &#125;) return sum / array.length;&#125;console.log(average(nums)) // 3*filter* 对集合每一个值调用函数，若返回为true并添加到新集合中去，并返回新集合function onlyEven(array) &#123; return _.filter(array, function (n)&#123; return n%2 === 0 &#125;)&#125;console.log(onlyEven(nums))集合中心编程var test = _.map(&#123;a: 1, b: 2&#125;, function (v, k) &#123; return [k, v];&#125;)console.dir(test) // [[&apos;a&apos;, 1], [&apos;b&apos;, 2]]Applicative编程的其他实例*reduceRight*（从右到左）var nums = [100, 2, 25];function div(x, y) &#123; return x/y;&#125;var test = _.reduceRight(nums, div);console.log(test) // 0.125*find* 它接收一个集合和一个谓词函数，并返回该谓词为true时的第一个元素。// 其中谓词函数为：_.isEqual、_.isEmpty、_.isElement...var dd = _.find([&apos;a&apos;, &apos;b&apos;, &apos;3&apos;, 4], _.isNumber);console.log(dd) // 4*reject* 本质为_.filter的逆命题var dd = _.reject([&apos;a&apos;, &apos;b&apos;, &apos;3&apos;, 4], _.isNumber);console.log(dd) // [&apos;a&apos;, &apos;b&apos;, &apos;3&apos;]// 另一种实现function complement(pred) &#123; return function () &#123; return !pred.apply(null, _.toArray(arguments)); &#125;;&#125;var d1 = _.filter([&apos;a&apos;, &apos;b&apos;, &apos;3&apos;, 4], complement(_.isNumber))console.log(d1) // [&apos;a&apos;, &apos;b&apos;, &apos;3&apos;]*all* 当对于集合中所有元素都满足谓词时返回true，否则返回falsevar dd = _.all([1, 2, 3, &apos;4&apos;], _.isNumber)console.log(dd) // false*any* 当对于集合中有满足谓词时返回true，否则返回falsevar dd = _.any([1, 2, 3, &apos;4&apos;], _.isNumber)console.log(dd) // true*sortBy* 接收一个集合和函数来对该集合排序var people = [&#123;name: &apos;Rick&apos;, age: 30&#125;,&#123;name: &apos;Jaka&apos;, age: 24&#125;];var list = _.sortBy(people, function (p) &#123; return p.name&#125;)console.log(list) // [&#123;name: &apos;Jaka&apos;, age: 24&#125;, &#123;name: &apos;Rick&apos;, age: 30&#125;]*groupBy* 接收一个集合和一个条件函数，并返回一个对象，k为传入的条件，v为对应的元素var albums = [ &#123;title: &apos;sabba&apos;, genre: &apos;metal&apos;&#125;, &#123;title: &apos;scientist&apos;, genre: &apos;dub&apos;&#125;, &#123;title: &apos;undertow&apos;, genre: &apos;metal&apos;&#125;,]var list = _.groupBy(albums, function (a) &#123; return a.genre;&#125;)console.dir(list)*countBy* 接收一个集合和一个条件函数，并返回一个对象，k为传入的条件，v为对应的元素的个数var albums = [ &#123;title: &apos;sabba&apos;, genre: &apos;metal&apos;&#125;, &#123;title: &apos;scientist&apos;, genre: &apos;dub&apos;&#125;, &#123;title: &apos;undertow&apos;, genre: &apos;metal&apos;&#125;,]var list = _.countBy(albums, function (a) &#123; return a.genre;&#125;)console.dir(list) // &#123;metal: 2, dub: 1&#125; 定义几个Applicative函数 12345678910111213141516*cat* 合并数组function cat() &#123; let head = _.first(arguments); if (existy(head)) &#123; return head.concat.apply(head, _.rest(arguments)); &#125; else &#123; return []; &#125;&#125;cat([1, 2, 3], [4, 5]) // [1, 2, 3, 4, 5]*construct* 将元素放置在数组前方function construct(head, tail) &#123; return cat([head], _.toArray(tail));&#125;construct(42, [1, 2, 3]) // [42, 1, 2, 3] 数据思考123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869*keys* 以数组的形式返回对象的keyvar zombie = &#123;name: &apos;bub&apos;, film: &apos;day&apos;&#125;console.log(_.keys(zombie)) // [&apos;name&apos;, &apos;film&apos;]*values* 以数组的形式返回对象的valueconsole.log(_.keys(zombie)) // [&apos;bub&apos;, &apos;day&apos;]*pluck* 接收一个对象数组和一个字符串，并返回在给定的键数组中对应对象的值var authorList = _.pluck([ &#123;title: &apos;chthon&apos;, author: &apos;anthony&apos;&#125;, &#123;title: &apos;grendel&apos;, author: &apos;grendel&apos;&#125;, &#123;title: &apos;after&apos;&#125;], &apos;author&apos;);*pairs* 接收一个对象，并把它变成这个嵌套数组var demo = _.pairs(&#123;title: &apos;chthon&apos;, author: &apos;anthony&apos;&#125;)console.log(demo) // [[&apos;title&apos;, &apos;chthon&apos;],[&apos;author&apos;, &apos;anthony&apos;]]*object* 将其重新组合成一个新的对象var zombie = &#123;name: &apos;bub&apos;, film: &apos;day&apos;&#125;var dd = _.object(_.map(_.pairs(zombie), function (pair) &#123; return [pair[0].toUpperCase(), pair[1]]&#125;))console.log(dd) // &#123;NAME: &quot;bub&quot;, FILM: &quot;day&quot;&#125;*invert* 翻转key和valuevar zombie = &#123;name: &apos;bub&apos;, film: &apos;day&apos;&#125;var dd = _.invert(zombie);console.log(dd) // &#123;bub: &quot;name&quot;, day: &quot;film&quot;&#125;*defaults* 用于扩充传入的对象，如为某个属性添加默认值var dd = _.pluck(_.map([ &#123;title: &apos;chthon&apos;, author: &apos;anthony&apos;&#125;, &#123;title: &apos;grendel&apos;, author: &apos;gardner&apos;&#125;, &#123;title: &apos;after&apos;&#125;, ], function (obj) &#123; return _.defaults(obj, &#123;author: &apos;Unknown&apos;&#125;) &#125;),&apos;author&apos;);console.log(dd) // [&quot;anthony&quot;, &quot;gardner&quot;, &quot;Unknown&quot;]*pick* 根据参数筛选对象*omit* 根据参数筛选对象var person = &#123; name: &apos;romy&apos;, token: &apos;j3900&apos;, password: &apos;3333&apos;&#125;;var info = _.pick(person, &apos;token&apos;, &apos;password&apos;)var other = _.omit(person, &apos;token&apos;, &apos;password&apos;)console.log(info) // &#123;token: &quot;j3900&quot;, password: &quot;3333&quot;&#125;console.log(other) // &#123;name: &apos;romy&apos;&#125;*findWhere* 接收一个对象数组，返回第一个与参数给出的条件匹配的对象var library = [ &#123;title: &apos;sicp&apos;, isbn: &apos;0234&apos;, ed: 1&#125;, &#123;title: &apos;sicp&apos;, isbn: &apos;0235&apos;, ed: 2&#125;, &#123;title: &apos;joy&apos;, isbn: &apos;0236&apos;, ed: 1&#125;,];var dd = _.findWhere(library, &#123;title: &apos;sicp&apos;, ed: 2&#125;)console.log(dd) // &#123;title: &quot;sicp&quot;, isbn: &quot;0235&quot;, ed: 2&#125; *where* 接收一个对象数组，返回所有条件匹配的对象var library = [ &#123;title: &apos;sicp&apos;, isbn: &apos;0234&apos;, ed: 1&#125;, &#123;title: &apos;sicp&apos;, isbn: &apos;0235&apos;, ed: 2&#125;, &#123;title: &apos;joy&apos;, isbn: &apos;0236&apos;, ed: 1&#125;,];var dd = _.where(library, &#123;title: &apos;sicp&apos;&#125;)console.log(dd) // &#123;&#123;title: &apos;sicp&apos;, isbn: &apos;0234&apos;, ed: 1&#125;, &#123;title: &apos;sicp&apos;, isbn: &apos;0235&apos;, ed: 2&#125;&#125; 表状（Tabel-Like）数据 ``` function project(table, keys){ return _.map(table, function (obj){ return _.pick.apply(null, construct(obj, keys)); }); } var editionResults = project(library, [&apos;title&apos;, &apos;isbn&apos;]) // [ {title: &apos;sicp&apos;, isbn: &apos;0234&apos;}, {title: &apos;sicp&apos;, isbn: &apos;0235&apos;}, {title: &apos;joy&apos;, isbn: &apos;0236&apos;}, ] *rename* 为对象属性设置别名 function rename(obj, newNames){ return _.reduce(newNames, function(o, nu, old){ if (_.has(obj, okd)) { o[nu] = obj[old]; return o; } else { return o; } }, _.omit.apply(null, construct(obj, _.keys(newNames)))); } var dd = {a: 1, b: 2} console.log(rename(dd, {&apos;a&apos;: &apos;A&apos;})) // {b: 2, A: 1} *as* 类似于SQL语句 SELECT ed as edition FROM library function as(table, newNames){ return _.map(table, function(obj){ return rename(obj, newNames); }); } var library = [ {title: &apos;sicp&apos;, isbn: &apos;0234&apos;, ed: 1}, {title: &apos;sicp&apos;, isbn: &apos;0235&apos;, ed: 2}, {title: &apos;joy&apos;, isbn: &apos;0236&apos;, ed: 1}, ]; var dd = as(library, {ed: &apos;edition&apos;}) console.log(dd) // [ {title: &apos;sicp&apos;, isbn: &apos;0234&apos;, edition: 1}, {title: &apos;sicp&apos;, isbn: &apos;0235&apos;, edition: 2}, {title: &apos;joy&apos;, isbn: &apos;0236&apos;, edition: 1}, ] *where* 类似于SQL的where语句 //接收一个函数，作为对表中的每个对象的谓词。每当谓词返回false是，该对象不会出现在新表中 function restrict(table, pred){ return _.reduce(table, function(newTable, obj){ if (truthy(pred(obj))) { return newTable; } else { return _.without(newTable, obj) } }, table) } var dd = restrict(library, function (book){ return book.ed &gt; 1; }) console.log(dd) // [{title: &apos;sicp&apos;, isbn: &apos;0235&apos;, ed: 2}] ``` 总结1. 一等函数 可以存储在变量中 可以存储在数组中的插槽中 可以存储在对象的字段中 ... 2. applicative编程 _.map _.reduce _.filter 源代码仓库 函数式编程-读书笔记]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PWA-1]]></title>
    <url>%2F2017%2FPWA-1.html</url>
    <content type="text"><![CDATA[Lavas – 基于 Vue 的 PWA 解决方案，帮助开发者快速搭建 PWA 应用，解决接入 PWA 的各种问题如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。 基础教程 Lavas 介绍Lavas 是什么？Lavas 是一个基于 Vue 的 PWA (Progressive Web Apps) 完整解决方案。 Lavas 做什么？站点 PWA 化需要做什么，Lavas 就做什么。 PWA (Progressive Web Apps) 是一种 Web App 新模型： 1.站点可添加至主屏幕 2.全屏方式运行 3.支持离线缓存 4.消息推送 ... 探索PWA什么是PWA？ PWA 工程的解决方案中借助了 service worker 的离线存储能力，消息推送能力以及系统的添加桌面能力，从而形成一个完善的 Web App 解决方案，帮助我们在 Web 端低成本的开发和维护一个逐步类 Native App 化的 Web App。什么站点适合改造成 PWA？ 除了对系统强依赖的 App, 以及游戏类的 App 等, 所有的 Native App 都可以改造成 PWA 应用。PWA 的效果？ 1.https 环境部署。 2.响应式设计，一次部署，可以在移动设备和 PC 设备上运行。 3.在不同浏览器下可正常访问。 4.浏览器离线和弱网环境可极速访问。 5.可以把 App Icon 入口添加到桌面。 6.点击 Icon 入口有类似 Native App 的动画效果。 7.灵活的热更新。离线缓存 HTML5 新的 service worker API，提供的离线缓存能力SPA (Single Page Apps)基于 Vue 架构的 PWA 工程App Shell App Shell 架构是构建 PWA 工程的一种方式，这种应用能可靠且即时地加载到您的用户屏幕上，与本地应用相似。 快速开始 PWA 工程依赖工具 $ npm install -g lavas初始化工程 $ lavas init运行 cd projectName npm install npm run dev 开发一个页面（以NotFound页面为例）添加路由 12345678910const NotFound = () =&gt; import(&apos;@/pages/NotFound.vue&apos;);routes: [ // 省略其他路由对象 &#123; path: &apos;*&apos;, name: &apos;notFound&apos;, component: NotFound &#125;] 页面组织结构 标准.vue单文件与app shell 的交互 vuex监听全局事件 1234567import EventBus from &apos;@/event-bus&apos;;// 在 activated 钩子中注册EventBus.$on(`app-header:click-action`, (&#123;actionIdx&#125;) =&gt; &#123; // 处理点击按钮事件 // ...&#125;); 组件开发 vuetify异步请求数据 axios 调试工程webpack dev-serverchrome 调试 构建部署工程生产环境构建部署到服务器 进阶教程 维护 service-worker.js 文件service-worker.js service-worker.js 文件作为缓存管理的重要文件如何配置缓存内容 通过 config/sw-precache.js 文件进行缓存配置，根据配置为用户缓存网站静态与动态资源，并截获用户的所有网络请求，决定是从缓存还是网络获取相应资源，限制缓存大小等。 Service Worker 与页面通信如何使用 postMessage 方法发送信息 在 sw.js 中向接管页面发信息，可以采用 client.postMessage() 方法 在主页面给 Service Worker 发消息，可以采用 navigator.serviceWorker.controller.postMessage() 方法如何接收 postMessage 发送的信息 在 sw.js 中接收主页面发来的信息，示例代码如下，通过 event.data 来读取数据 在页面中接收 sw.js 发来的信息，示例代码如下，通过 event.data 来读取数据 App Shell 调整及扩展App Shell 模型调整及扩展 App Shell 状态管理 与路由组件通信 扩展 Shell App Skeleton 介绍Lavas 的 Skeleton 支持默认 Skeleton 页面切换动画效果具体实现 修改项目主题配置文件 主题相关的配置文件在 config/theme.js 中 使用预定义的颜色变量 使用主题变量 在项目中使用图标字体文件自定义 SVG 使用 Material Design UI 开发muse-ui、vue-material、vuetify HTTPS 环境部署 服务器端渲染 参考： lavas-百度PWA解决方案]]></content>
      <categories>
        <category>PWA</category>
      </categories>
      <tags>
        <tag>有趣的</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js函数式编程-javascript函数式编程的简介]]></title>
    <url>%2F2017%2Fjs%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[最近，工作不是很忙，赶紧为自己充电。准备很长一段事件撸函数式编程。如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。 javascript函数式编程的简介javascript案列12345678910111213141516171819202122javascript函数式编程初试function splt (fn) &#123; return function (array) &#123; return fn.apply(null, array) &#125;&#125;// examplevar addArrayElements = splt(function (x, y) &#123; return x + y;&#125;)console.log(addArrayElements([1,2])) // 3function unsplat (fun) &#123; return function () &#123; return fun.call(null, _.toArray(arguments)) &#125;;&#125;let joinElments = unsplat(function (array) &#123; return array.join(&apos; &apos;)&#125;)// exampleconsole.log(joinElments(&apos;@&apos;, &apos;$&apos;, &apos;*&apos;)) // @ $ * 开始函数式编程直白的定义：函数式编程通过使用函数来将值转换成抽象单元，接着用于构建软件系统。 以函数为抽象单元 例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243function parseAge (age) &#123; if (!_.isString(age)) &#123; throw new Error(&apos;expecting a string&apos;); &#125; let a; console.log(&apos;attempting to parse an age&apos;) a = parseInt(age, 10); if (_.isNaN(a)) &#123; console.log([&quot;could not parse age:&quot;, age].join(&apos; &apos;)); a = 0; &#125; return a;&#125;// exampleconsole.log(parseAge(34)) // throw Error// 如果我们想修改输出错误、信息和警告呈现的方式，较好的方式是将错误、信息和警告的概念抽象成不同的函数function fail(thing) &#123; throw new Error(thing);&#125;function warn(thing) &#123; console.log([&apos;WARNING:&apos;, thing].join(&apos; &apos;));&#125;function note(thing) &#123; console.log([&apos;NOTE:&apos;, thing].join(&apos; &apos;));&#125;function parseAge (age) &#123; if (!_.isString(age)) &#123; fail(&apos;Expecting a string&apos;); &#125; let a; note(&apos;Attempting to parse an age&apos;) a = parseInt(age, 10); if (_.isNaN(a)) &#123; warn([&apos;Could not parse age:&apos;, age].join(&apos; &apos;)); a = 0; &#125; return a;&#125;// exampleconsole.log(parseAge(&apos;df&apos;)) // throw Error 封装和隐藏（闭包） 以函数为行为单位 1234567891011121314151617181920212223function nativeNth(a, index) &#123; return a[index];&#125;var letters = [&apos;a&apos;, &apos;b&apos;];// exampleconsole.log(nativeNth(letters, 0)) // a// function nth(a, index) &#123; if (!_.isNumber(index)) &#123; fail(&apos;Expected a number as the index&apos;); &#125; if (!isIndexed(a)) &#123; fail(&apos;Not supported on non-indexed type&apos;); &#125; if ((index &lt; 0) || (index &gt; a.length -1)) &#123; fail(&apos;Index value is out of bounds&apos;); &#125; return a[index];&#125;var letters = [&apos;1&apos;, &apos;2&apos;]console.log(nth(letters, 1)) 数据抽象 Javascript的对象原型模型是一个丰富且基础的数据方案。 函数式javascript初试 1234567891011// existy 定义事物的存在（js中null和undefined表示不存在）function existy(x) &#123; return x != null &#125;// exampleexisty(null) // falsetruthy 用来判断一个对象是否应该被认为是true的同义词// js的原始真类型function truthy(x) &#123; return (x !== false) &amp;&amp; existy(x)&#125;console.log(truthy(&apos;&apos;)) // true Underscore示例总结一种用于构建Javascript应用程序的技术称为“函数式编程” 1.确定抽象，并为其构建函数。 2.利用已有的函数来构建更为复杂的抽象。 3.通过将现有的函数传给其他的函数来构建更加复杂的抽象。 书籍【javascript函数式编程】]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js函数式编程-6]]></title>
    <url>%2F2017%2Fjs%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-6.html</url>
    <content type="text"><![CDATA[Applicative Functor如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。 应用 applicative functor123Container.of(2).chain(function(two) &#123; return Container.of(3).map(add(two));&#125;); 瓶中之船12345678// ap 就是这样一种函数，能够把一个 functor 的函数值应用到另一个 functor 的值上。Container.prototype.ap = function(other_container) &#123; return other_container.map(this.__value);&#125;Container.of(add(2)).ap(Container.of(3)); // Container(5)// all together nowContainer.of(2).map(add).ap(Container.of(3)); // Container(5 协调与激励123456789101112131415// 帮助函数：// $ :: String -&gt; IO DOMvar $ = function(selector) &#123; return new IO(function()&#123; return document.querySelector(selector) &#125;);&#125;// getVal :: String -&gt; IO Stringvar getVal = compose(map(_.prop(&apos;value&apos;)), $);// Example:// signIn :: String -&gt; String -&gt; Bool -&gt; Uservar signIn = curry(function(username, password, remember_me)&#123; /* signing in */ &#125;)IO.of(signIn).ap(getVal(&apos;#email&apos;)).ap(getVal(&apos;#password&apos;)).ap(IO.of(false));// IO(&#123;id: 3, email: &quot;gg@allin.com&quot;&#125;) 定律123456789101112131415161718同一律（identity） A.of(id).ap(v) == v var v = Identity.of(&quot;Pillow Pets&quot;); Identity.of(id).ap(v) == v同态（homomorphism） A.of(f).ap(A.of(x)) == A.of(f(x)) Either.of(_.toUpper).ap(Either.of(&quot;oreos&quot;)) == Either.of(_.toUpper(&quot;oreos&quot;))互换（interchange） v.ap(A.of(x)) == A.of(function(f) &#123; return f(x) &#125;).ap(v) var v = Task.of(_.reverse); var x = &apos;Sparklehorse&apos;; v.ap(Task.of(x)) == Task.of(function(f) &#123; return f(x) &#125;).ap(v)组合（composition） A.of(compose).ap(u).ap(v).ap(w) == u.ap(v.ap(w)); var u = IO.of(_.toUpper); var v = IO.of(_.concat(&quot;&amp; beyond&quot;)); var w = IO.of(&quot;blood bath &quot;); IO.of(_.compose).ap(u).ap(v).ap(w) == u.ap(v.ap(w)) js函数式编程]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js函数式编程-5]]></title>
    <url>%2F2017%2Fjs%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-5.html</url>
    <content type="text"><![CDATA[Monad如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。 pointed functorof 方法不是用来避免使用 new 关键字的，而是用来把值放到默认最小化上下文（default minimal context）中的。 pointed functor 是实现了 of 方法的 functor。 123这里的关键是把任意值丢到容器里然后开始到处使用 map 的能力。IO.of(&quot;tetris&quot;).map(concat(&quot; master&quot;)); // IO(&quot;tetris master&quot;)Maybe.of(1336).map(add(1)); // Maybe(1337) 混合比喻 例子 12345678910111213141516171819202122var fs = require(&apos;fs&apos;);// readFile :: String -&gt; IO Stringvar readFile = function(filename) &#123; return new IO(function() &#123; return fs.readFileSync(filename, &apos;utf-8&apos;); &#125;);&#125;;// print :: String -&gt; IO Stringvar print = function(x) &#123; return new IO(function() &#123; console.log(x); return x; &#125;);&#125;// cat :: IO (IO String)var cat = compose(map(print), readFile);cat(&quot;.git/config&quot;)// IO(IO(&quot;[core]\nrepositoryformatversion = 0\n&quot;)) 剥开洋葱 12345678910我说过 monad 像洋葱，可以使用一个叫作 join 的方法，来剥开。var mmo = Maybe.of(Maybe.of(&quot;nunchucks&quot;));// Maybe(Maybe(&quot;nunchucks&quot;))mmo.join();// Maybe(&quot;nunchucks&quot;)var ttt = Task.of(Task.of(Task.of(&quot;sewers&quot;)));// Task(Task(Task(&quot;sewers&quot;)));ttt.join()// Task(Task(&quot;sewers&quot;)) monad 是可以变扁（flatten）的 pointed functor。 一个 functor，只要它定义个了一个 join 方法和一个 of 方法，并遵守一些定律，那么它就是一个 monad。 为Maybe实现join方法 1234567891011121314151617Maybe.prototype.join = function () &#123; return this.isNothing() ? Maybe.of(null) : this.__value;&#125;;Example// join :: Monad m =&gt; m (m a) -&gt; m avar join = function(mma)&#123; return mma.join(); &#125;// firstAddressStreet :: User -&gt; Maybe Streetvar firstAddressStreet = compose( join, map(safeProp(&apos;street&apos;)), join, map(safeHead), safeProp(&apos;addresses&apos;));firstAddressStreet( &#123;addresses: [&#123;street: &#123;name: &apos;Mulburry&apos;, number: 8402&#125;, postcode: &quot;WC2N&quot; &#125;]&#125;);// Maybe(&#123;name: &apos;Mulburry&apos;, number: 8402&#125;) chain 函数123456789101112131415161718192021// 使用 chain封装（map的后面调用join）// chain :: Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m bvar chain = curry(function(f, m)&#123; return m.map(f).join(); // 或者 compose(join, map(f))(m)&#125;);// map/joinvar firstAddressStreet = compose( join, map(safeProp(&apos;street&apos;)), join, map(safeHead), safeProp(&apos;addresses&apos;));// chainvar firstAddressStreet = compose( chain(safeProp(&apos;street&apos;)), chain(safeHead), safeProp(&apos;addresses&apos;));ExampleMaybe.of(3).chain(function(three) &#123; return Maybe.of(2).map(add(three));&#125;);// Maybe(5); 理论12 // 结合律compose(join, map(join)) == compose(join, join) 总结：monad 能够借给我们从盒子中取出的值，而且知道我们会在结束使用后还给它。 monad 让我们深入到嵌套的运算当中，使我们能够在完全避免回调金字塔（pyramid of doom）情况下，为变量赋值，运行有序的作用，执行异步任务等等。]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js函数式编程-4]]></title>
    <url>%2F2017%2Fjs%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-4.html</url>
    <content type="text"><![CDATA[特百惠如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。 强大的容器函数式的程序：即通过管道把数据在一系列纯函数间传递的程序。 12345678910111. // 先创建一个容器（container），这个容器必须能够装载任意类型的值，一个存放宝贵的数据的特殊盒子。 var Container = function (x) &#123; this._value = x; &#125;; // 作用容器的构造器（constructor） Container.of = function (x) &#123; return new Container(x); &#125;; // 测试容器 var test = Container.of(Container.of(&#123;name: &apos;fanerge&apos;&#125;)) console.log(test) 第一个functor 123456789101112131415// 操作容器中的值// (a -&gt; b) -&gt; Container a -&gt; Container bContainer.prototype.map = function (f) &#123; return Container.of(f(this._value))&#125;; // 使用map方法Container.of(3).map(function (two) &#123; return two + 2;&#125;);// Container(5)Container.of(&apos;fanerge&apos;).map(function (str) &#123; return str.toUpperCase()&#125;);// Container(&apos;FANERGE&apos;)// 因为我们能够在不离开 Container 的情况下操作容器里面的值。这是非常了不起的一件事情。Container 里的值传递给 map 函数之后，就可以任我们操作；操作结束后，为了防止意外再把它放回它所属的 Container。这样做的结果是，我们能连续地调用 map，运行任何我们想运行的函数。 functor 是实现了 map 函数并遵守一些特定规则的容器类型。把值装进一个容器，而且只能使用 map 来处理它，让容器自己去运用函数能给我们带来什么好处？答案是抽象，对于函数运用的抽象。当 map 一个函数的时候，我们请求容器来运行这个函数。不夸张地讲，这是一种十分强大的理念。 薛定谔的Maybe 123456789101112131415161718192021222324252627var Maybe = function (x) &#123; this._value = x;&#125;;Maybe.of = function (x) &#123; return new Maybe(x);&#125;;Maybe.prototype.isNoting = function () &#123; return (this._value == null || this._value === undefined)&#125;;Maybe.prototype.map = function (f) &#123; return this.isNoting() ? Maybe.of(null) : Maybe.of(f(this._value));&#125;;Maybe.of(&apos;Malkovich Malkovich&apos;).map(_.match(/a/ig)) // Maybe([&apos;a&apos;, &apos;a&apos;]// map 完全有能力以 curry 函数的方式来“代理”任何 functorvar map = curry(function (f, any_functor_at_all) &#123; return any_functor_at_all.map(f);&#125;);// safeHead :: [a] -&gt; Maybe(a)var safeHead = function (xs) &#123; return Maybe.of(xs[0]);&#125;;var streetName = _.compose(map(_.prop(&apos;street&apos;)), safeHead, _.prop(&apos;address&apos;));streetName(&#123;addresses: [&#123;street: &quot;Shady Ln.&quot;, number: 4201&#125;]&#125;); // Maybe(&quot;Shady Ln.&quot;) 购物的例子 123456789101112// withdraw :: Number -&gt; Account -&gt; Maybe(Account)var withdraw = curry(function (amount, account) &#123; return account.balance &gt;= amount ? Maybe.of(&#123;balance: acount.balance - amount&#125;) : Maybe.of(null);&#125;)// finishTransaction :: Account -&gt; Stringvar finishTransaction = compose(remainingBalance, updateLedger); //// &lt;- 假定这两个函数已经在别处定义好了// getTwenty :: Account -&gt; Maybe(String)var getTwenty = compose(map(finishTransaction), withdraw(20));getTwenty(&#123;balance: 200.00&#125;); // Maybe(&quot;Your balance is $180.00&quot;)getTwenty(&#123; balance: 10.00&#125;); // Maybe(null) 12345678910// maybe :: b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b var may = curry(function (x, f, m) &#123; return m.isNoting() ? x : f(m._value);&#125;);// getTwenty :: Account -&gt; Stringvar getTwenty = compose( maybe(&quot;You&apos;re broke!&quot;, finishTransaction), withdraw(20)); getTwenty(&#123; balance: 200.00&#125;); // &quot;Your balance is $180.00&quot;getTwenty(&#123; balance: 10.00&#125;); // &quot;You&apos;re broke!&quot; “纯”错误处理123456789101112131415161718192021222324252627282930313233343536373839Left 和 Right 是我们称之为 Either 的抽象类型的两个子类。var Left = function(x) &#123; this.__value = x;&#125;Left.of = function(x) &#123; return new Left(x);&#125;Left.prototype.map = function(f) &#123; return this;&#125;var Right = function(x) &#123; this.__value = x;&#125;Right.of = function(x) &#123; return new Right(x);&#125;Right.prototype.map = function(f) &#123; return Right.of(f(this.__value));&#125;// 就像 Maybe 可以有个 maybe 一样，Either 也可以有一个 either。两者的用法类似，但 either 接受两个函数（而不是一个）和一个静态值为参数。// either :: (a -&gt; c) -&gt; (b -&gt; c) -&gt; Either a b -&gt; cvar either = curry(function(f, g, e) &#123; switch(e.constructor) &#123; case Left: return f(e.__value); case Right: return g(e.__value); &#125;&#125;);// zoltar :: User -&gt; _var zoltar = compose(console.log, either(id, fortune), getAge(moment()));zoltar(&#123;birthdate: &apos;2005-12-12&apos;&#125;);// &quot;If you survive, you will be 10&quot;// undefinedzoltar(&#123;birthdate: &apos;balloons!&apos;&#125;);// &quot;Birth date could not be parsed&quot;// undefined **取到容器里的东西** 1234567891011121314151617181920var IO = function (f) &#123; this.__value = f;&#125;;IO.of = function (x) &#123; return new IO(function () &#123; return x; &#125;);&#125;;IO.prototype.map = function (f) &#123; return new IO(_.compose(f, this.__value));&#125;;// io_window_ :: IO Windowvar io_window = new IO(function () &#123; return window;&#125;)io_window.map(function (win) &#123; return win.innerWidth &#125;) // IO(1430)io_window.map(_.prop(&apos;location&apos;)).map(_.prop(&apos;href&apos;)).map(split(&apos;/&apos;)); // IO([&quot;http:&quot;, &quot;&quot;, &quot;localhost:8000&quot;, &quot;blog&quot;, &quot;posts&quot;])// $ :: String -&gt; IO [DOM]var $ = function(selector) &#123; return new IO(function()&#123; return document.querySelectorAll(selector); &#125;);&#125;$(&apos;#myDiv&apos;).map(head).map(function(div)&#123; return div.innerHTML; &#125;); // IO(&apos;I am some inner html&apos;) **解析url参数** 12345678910111213纯代码库: lib/params.jsvar url = new IO(function () &#123; return window.location.href; &#125;);// toPairs = String -&gt; [[String]]var toPairs = compose(map(split(&apos;=&apos;), split(&apos;&amp;&apos;));// params :: String -&gt; [[String]]var params = conmpose(toPairs, last, split(&apos;?&apos;));// findParam = String -&gt; Io Maybe [String]var findParam = function (key) &#123; return map(compose(Maybe.of, filter(compose(eq(key), head)), params), url);&#125;;// 调用 __value() 来运行它！findParam(&apos;searchTerm&apos;).__value();// Maybe([&apos;searchTerm&apos;, &apos;wafflehouse&apos;]) 异步任务1234567891011121314151617181920// Postgres.connect :: Url -&gt; IO DbConnection// runQuery :: DbConnection -&gt; ResultSet// readFile :: String -&gt; Task Error String// Pure application//=====================// dbUrl :: Config -&gt; Either Error Urlvar dbUrl = function(c) &#123; return (c.uname &amp;&amp; c.pass &amp;&amp; c.host &amp;&amp; c.db) ? Right.of(&quot;db:pg://&quot;+c.uname+&quot;:&quot;+c.pass+&quot;@&quot;+c.host+&quot;5432/&quot;+c.db) : Left.of(Error(&quot;Invalid config!&quot;));&#125;// connectDb :: Config -&gt; Either Error (IO DbConnection)var connectDb = compose(map(Postgres.connect), dbUrl);// getConfig :: Filename -&gt; Task Error (Either Error (IO DbConnection))var getConfig = compose(map(compose(connectDB, JSON.parse)), readFile);// Impure calling code//=====================getConfig(&quot;db.json&quot;).fork( logErr(&quot;couldn&apos;t read file&quot;), either(console.log, map(runQuery))); 一些理论1234// identitymap(id) === id;// compositioncompose(map(f), map(g)) === map(compose(f, g)); 参考： js函数式编程 参考： js函数式编程]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js函数式编程-3]]></title>
    <url>%2F2017%2Fjs%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-3.html</url>
    <content type="text"><![CDATA[实例应用如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。 声明式代码 理解命令式与声明式 1234567891011// 命令式var makes = [];for (let i, len = cars.length; i++) &#123; makes.push(cars[i]make) &#125;// 声明式var makes = cars.map((car) =&gt; &#123; return car.make; &#125;)总结：命令式的循环要求你必须先实例化一个数组，而且执行完这个实例化语句之后，解释器才继续执行后面的代码。然后再直接迭代 cars 列表，手动增加计数器，把各种零零散散的东西都展示出来...实在是直白得有些露骨。何收集，都有很大的自由度。它指明的是做什么，不是怎么做。因此，它是正儿八经的声明式代码。 例子 1234567// 命令式 --- 硬编码了那种一步接一步的执行方式。var authenticate = function (form) &#123; var user = toUser(form); return logIn(user);&#125;// 声明式 --- 用户验证是 toUser 和 logIn 两个行为的组合。var authenticate = compose(logIn, toUser) 示例函数式编程demo 1.根据特定搜索关键字构造 url 2.向 flickr 发送 api 请求 （不纯） 3.把返回的 json 转为 html 图片 4.把图片放到屏幕上 （不纯） 有原则的重构 // map 的组合律 var law = compose(map(f), map(g)) === map(compose(f, g)) Hindley-Milner 类型签名 初始类型 类型签名作用：短短一行，就能暴露函数的行为和目的，可以用类型签名生成文档，也可以用注释来达到区分类型的目的。 Hindley-Milner 系统 12345678910111213141516// capitalize :: String -&gt; String （表示输入为string，输出也为string）var capitalize = function (s) &#123; return toUpperCase(head(s)) + toLowerCase(tail(s));&#125;// 使用capitalize(&apos;fanerge&apos;) // &apos;Fanerge&apos;// id :: a -&gt; a （同一类型的）var id = function(x)&#123; return x; &#125;// map :: (a -&gt; b) -&gt; [a] -&gt; [b]var map = curry(function(f, xs)&#123; return xs.map(f);&#125;);// 说明给定一个从 a 到 b 的函数和一个 a 类型的数组作为参数，它就能返回一个 b 类型的数组。 缩小可能性范围（parametricity） 12// head :: [a] -&gt; a它接受 [a] 返回 a,参数是个数组 自由定理（free theorems） 123// head :: [a] -&gt; acompose(f, head) == compose(head, map(f));等式左边说的是，先获取数组的头部（译者注：即第一个元素），然后对它调用函数 f；等式右边说的是，先对数组中的每一个元素调用 f，然后再取其返回结果的头部。这两个表达式的作用是相等的，但是前者要快得多。 参考： js函数式编程]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js函数式编程-2]]></title>
    <url>%2F2017%2Fjs%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-2.html</url>
    <content type="text"><![CDATA[代码组合（compose）如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。 先上手一个组合函数的例子1234567891011var compose = function (f, g) &#123; // 执行顺序为从右到左 return function (x) &#123; return f(g(x)); &#125;&#125;// f 和 g 都是函数，x 是在它们之间通过“管道”传输的值。var toUppercase = function (x) &#123; return x.toUpperCase() &#125;;var exclaim = function (x) &#123; return `$&#123;x&#125;!` &#125;;var shout = compose(exclaim, toUppercase);var test = shout(&apos;I am fanerge&apos;)console.log(test) // I AM FANERGE! 组合的特性1. 结合律（associativity） 12345678910var associative = compose(f, compose(g, h)) === compose(compose(f, g), h)// 必须满足相同的执行顺序及h-g-f（从右到左）var loudLastUpper = compose(exclaim, toUpperCase, head, reverse);// 或var last = compose(head, reverse);var loudLastUpper = compose(exclaim, toUpperCase, last);// 或var last = compose(head, reverse);var angry = compose(exclaim, toUpperCase);var loudLastUpper = compose(angry, last); **其实只要把握好（从右向左执行的顺序即可）** 2. pointfree模式 定义：永远不必说出你的数据，函数无须提及将要操作的数据是什么样的。 123456//非 pointfree，因为提到了数据：wordvar snakeCase = function (word) &#123; return word.toLowerCase().replace(/\s+/ig, &apos;_&apos;);&#125;// pointfreevar snakeCase = compose(replace(/\s+/ig, &apos;_&apos;), toLowerCase) debug123456789101112131415161718192021222324252627 // 正确做法：每个函数都接受一个实际的参数 var latin = compose(map(angry), reverse) // angry = compose(exclaim, toUpperCase) latin([&quot;frog&quot;, &quot;eyes&quot;]) // [&apos;EYES!&apos;,&apos;FROG!&apos;] // 不纯的 trace 函数来追踪代码的执行情况。 var trace = curry(function(tag, x)&#123; console.log(tag, x); return x; &#125;); // 使用 var dasherize = compose(join(&apos;-&apos;), toLower, trace(&quot;after split&quot;), split(&apos; &apos;), replace(/\s&#123;2,&#125;/ig, &apos; &apos;)); // after split [ &apos;The&apos;, &apos;world&apos;, &apos;is&apos;, &apos;a&apos;, &apos;vampire&apos; ]### 组合背后的理论 --- 范畴学（category theory） 作用：范畴学主要处理对象（object）、态射（morphism）和变化式（transformation） **对象的搜集** 对象就是数据类型，例如 String、Boolean、Number 和 Object 等等。 通常我们把数据类型视作所有可能的值的一个集合（set）。 **态射的搜集** 态射是标准的、普通的纯函数。 **态射的组合** var g = function(x)&#123; return x.length; &#125;; var f = function(x)&#123; return x === 4; &#125;; var isFourLetterWord = compose(f, g); var test = isFourLetterWord(&apos;fanerge&apos;) // false **identity 这个独特的态射** identity 这个独特的态射 // id 的实用函数 var id = function (x) { return x }; // 结论成立 compose(id, f) === compose(f, id) === f; 总结：组合像一系列管道那样把不同的函数联系在一起，数据就可以也必须在其中流动——毕竟纯函数就是输入对输出 ``` 参考： js函数式编程]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js函数式编程]]></title>
    <url>%2F2017%2Fjs%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-1.html</url>
    <content type="text"><![CDATA[刚下班回家，最近打算利用空余时间撸函数式编程如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。 一等公民的函数 与其他数据类型一样，可以把函数存在数组里，当作参数传递，赋值给变量…等等。 纯函数的理解 定义：纯函数的定义是因为对相同的输入它保证能返回相同的输出。 123456789101112var xs = [1,2,3,4,5];// 纯的xs.slice(0,3);//=&gt; [1,2,3]xs.slice(0,3);//=&gt; [1,2,3]// 不纯的xs.splice(0,3);//=&gt; [1,2,3]xs.splice(0,3);//=&gt; [4,5] 纯函数中的副作用 副作用的定义：只要是跟函数外部环境发生的交互就都是副作用（更改文件系统、往数据库插入记录） 纯函数的特点 可缓存性（Cacheable） 可移植性／自文档化（Portable / Self-Documenting） 可测试性（Testable） 合理性（Reasonable） 合理性（Reasonable） 柯里化（curry） 定义：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。 1234567var add = function (x) &#123; return function (y) &#123; return x + y; &#125;&#125;var addTen = add(10)console.log(addTen(1)) // 11 示例 123456789101112131415161718var curry = require(&apos;lodash&apos;).curry; // lodash.js是一个工具函数库var match = curry(function (what, str) &#123; return str.match(what)&#125;)// 使用**match(/\s+/g, &apos;hello world&apos;) // [&apos; &apos;]****match(/\s+/g)(&apos;hello world&apos;) // [&apos; &apos;]**var hasSpaces = match(/\s+/g) // function (x) &#123; return x.match(/\s+/g) &#125;hasSpaces(&apos;hello world&apos;) // [&apos; &apos;]// 再来一个列子var curry = require(&apos;lodash&apos;).curry; // lodash.js是一个工具函数库var replace = curry(function(what, replacement, str) &#123; return str.replace(what, replacement);&#125;)var noVowels = replace(/[aeiou]/ig) (传入第一个参数)// function (replacement, x) &#123; return x.replace(/[aeiou]/ig, replacement) &#125;var censored = noVowels(&apos;*&apos;) (传入第二个参数)// function (x) &#123; return x.replace(/[aeiou]/ig, &apos;*&apos;) &#125;var end = censored(&apos;Chocolate Rain&apos;) (传入第三个参数)// &apos;Ch*c*l*t* R**n&apos; 通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。 只传给函数一部分参数通常也叫做局部调用（partial application） 高阶函数：参数或返回值为函数的函数（higher order function） 当我们谈论纯函数的时候，我们说它们接受一个输入返回一个输出。 curry 函数所做的正是这样：每传递一个参数调用函数，就返回一个新函数处理剩余的参数。这就是一个输入对应一个输出啊。 记于2017-07-19 23:14 参考JS函数式编程指南]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue vuex]]></title>
    <url>%2F2017%2Fvue-vuex.html</url>
    <content type="text"><![CDATA[今天来总结下，在项目中使用vuex，项目采用easy-mock模拟数据如有不正确的地方，请大家联系我，谢谢。 首先在项目中添加vuex 在store文件夹下面建立index.js,内容如下 1234567891011121314151617181920212223242526272829303132333435363738 import Vue from &apos;vue&apos; import Vuex from &apos;vuex&apos; import &#123; login &#125; from &apos;@/api/http&apos; // 用于登录的 Vue.use(Vuex)const store = new Vuex.Store(&#123; state: &#123; // 保存全局state --- this.$store.state[key]-- 放在computed userInfo: null, token: &apos;&apos; &#125;, getters: &#123; // 对state进行不修改操作，相当于数据库的查操作 --- this.$store.getter[key]-- 放在computed &#125;, mutations: &#123; // 同步操作state --- this.$store.commit(&apos;func&apos;,payload)-- 放在methods login (state, payload) &#123; state.userInfo = payload &#125;, setToken (state, payload) &#123; state.token = payload &#125; &#125;, actions: &#123; // 异步操作state --- this.$store.dispatch(&apos;func&apos;,payload)-- 放在methods login (&#123; commit &#125;, userInfo) &#123; return new Promise((resolve, reject) =&gt; &#123; login(userInfo.username, userInfo.password) .then((res) =&gt; &#123; commit(&apos;login&apos;, res.userInfo) // 全局state中保存用户信息 commit(&apos;setToken&apos;, res.token) // 全局state中保存token resolve(res) // 这里很关键，必须要传递res参数，登录之后的其他操作 &#125;) .catch((err) =&gt; &#123; reject(err) &#125;) &#125;) &#125; &#125;&#125;)export default store 在main.js中添加 12345678import store from &apos;./store&apos;new Vue(&#123; el: &apos;#app&apos;, router, store, template: &apos;&lt;App/&gt;&apos;, components: &#123;App&#125;&#125;) 在api文件夹中http.js文件中 1234567import http from &apos;./axios&apos;export function login (username, password) &#123; return http.post(&apos;user/login&apos;, &#123; username, password &#125;)&#125; 在登录组件中login.vue 1234567891011methods: &#123; login (data) &#123; this.$store.dispatch(&apos;login&apos;, data) .then((res) =&gt; &#123; console.dir(res) &#125;) .catch((err) =&gt; &#123; console.error(err) &#125;) &#125; &#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>element-ui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue admin]]></title>
    <url>%2F2017%2Fvue-admin.html</url>
    <content type="text"><![CDATA[最近个人接触了一些后台管理系统的搭建，参考了很多资料，打算把自己的后台管理系统开发经验写成博客，可能会帮助到一些想做后台管理系统的朋友，更主要的记录整个开发思路，以及vue的一整套解决方案。如有不正确的地方，请大家提出来，我会更正，共同进步，谢谢。 后台管理系统主要功能(vue-cli搭建项目) element-ui 饿了么出品的vue2.0 pc端 UI框架 axios vue官方推荐的请求库 支持Promise html5的本地存储LocalStorage（用于记住密码等） 与 SessionStorage （用于存储个人信息和token等） 浏览器样式兼容库 normalize.css 格式化css 类似于YouTube的页面跳转精度条-nprogress 轻量的全局进度条控制 官方提供的状态管理库 vuex 官方提供路由 vue-router 集成icon-font图标(symbol方式) 添加全屏功能（后续会继续添加） 先在项目中引入 element-ui 安装 element-ui npm i element-ui -S 引入相关资源 import ElementUI from ‘element-ui’ import ‘element-ui/lib/theme-default/index.css’ Vue.use(ElementUI) 这样你就可以愉快的在你的项目中使用element的组件了。 例如使用 Message 消息提示 就可以在任何vue组件中 this.$message(‘这是一条消息提示’); // this指向vue实例 在项目中引入axios请求库axios 安装 axios npm i axios -S 在使用axios的时候我们经常要进行一些封装和全局配置等 我一般开发时会在src目录下新建一个api的文件夹，里面存放对axios的封装（axios.js）和项目所有请求（http.js） 这里重点讲一下axios.js这个文件夹，也就是对axios的封装以及拦截操作 这里是全局配置 12345var service = axios.create(&#123; baseURL:&quot;https://some-domain.com/api/&quot;, timeout:1000, headers: &#123;&apos;X-Custom-Header&apos;:&apos;foobar&apos;&#125;&#125;); 这里是request拦截操作 123456789// request拦截器service.interceptors.request.use(config =&gt; &#123; if (store.getters.token) &#123; // 判断全局状态中是否有token，也就是说判断你不是合法用户 config.headers[&apos;token&apos;] = store.getters.token; // 让每个请求携带自定义token，开心不用没个请求都带上token字段了 &#125; return config;&#125;, error =&gt; &#123; Promise.reject(error);&#125;) 这里是response拦截操作 123456789101112131415161718192021222324252627282930313233// respone拦截器service.interceptors.response.use( response =&gt; &#123; // code为非20000是抛错 可结合自己业务进行修改 const res = response.data; if (res.code !== 20000) &#123; // 在该页面使用element组件，别忘了需要引入哦！！ Message(&#123; message: res.data, type: &apos;error&apos;, duration: 5 * 1000 &#125;); // 50008:非法的token; 50012:其他客户端登录了; 50014:Token 过期了; if (res.code === 50008 || res.code === 50012 || res.code === 50014) &#123; // 这里需要你进行相应的操作处理 &#125; return Promise.reject(error); &#125; else &#123; return response.data; &#125; &#125;, error =&gt; &#123; Message(&#123; message: error.message, type: &apos;error&apos;, duration: 5 * 1000 &#125;); return Promise.reject(error); &#125;)// 最后被忘了，要export 这个实例export default service; 阻止http.js请求文件 里面的内容大致是这样的 123456789101112131415161718192021import service from &apos;./axios&apos;const ApiUrl = &#123; login: &apos;login/&apos;, // 存放api路径 ...&#125;export default &#123; login () &#123; // 这里后期我会发在vuex中的actions里面 service.post(ApiUrl.login, &#123; username: &apos;fanerge&apos;, password: &apos;XXXXXX&apos; &#125;) .then((res) =&gt; &#123; let resp = res.data console.log(resp) &#125;) .catch((err) =&gt; &#123; console.error(err) &#125;) &#125;&#125; 参考vueAdmin-template]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>element-ui</tag>
      </tags>
  </entry>
</search>
